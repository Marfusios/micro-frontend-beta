(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common/http'), require('@angular/platform-browser/animations'), require('@angular/platform-browser'), require('@angular/forms'), require('tslib'), require('@angular/common'), require('rxjs'), require('rxjs/operators'), require('@ngrx/store'), require('@angular/core')) :
  typeof define === 'function' && define.amd ? define('micro-frontend-beta', ['exports', '@angular/common/http', '@angular/platform-browser/animations', '@angular/platform-browser', '@angular/forms', 'tslib', '@angular/common', 'rxjs', 'rxjs/operators', '@ngrx/store', '@angular/core'], factory) :
  (factory((global['micro-frontend-beta'] = {}),global.ng.common.http,global.ng.platformBrowser.animations,global.ng.platformBrowser,global.ng.forms,global.tslib,global.ng.common,global.rxjs,global.rxjs.operators,global.store,global.ng.core));
}(this, (function (exports,http,animations,platformBrowser,forms,tslib_1,common,rxjs,operators,store,core) { 'use strict';

  /* ***** BEGIN LICENSE BLOCK *****
   * Distributed under the BSD license:
   *
   * Copyright (c) 2010, Ajax.org B.V.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *     * Redistributions of source code must retain the above copyright
   *       notice, this list of conditions and the following disclaimer.
   *     * Redistributions in binary form must reproduce the above copyright
   *       notice, this list of conditions and the following disclaimer in the
   *       documentation and/or other materials provided with the distribution.
   *     * Neither the name of Ajax.org B.V. nor the
   *       names of its contributors may be used to endorse or promote products
   *       derived from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
   * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
   * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
   * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
   * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *
   * ***** END LICENSE BLOCK ***** */
  /**
   * Define a module along with a payload
   * @param module a name for the payload
   * @param payload a function to call with (acequire, exports, module) params
   */
  (function () {
      var ACE_NAMESPACE = "ace";
      var global = (function () { return this; })();
      if (!global && typeof window != "undefined")
          global = window; // strict mode
      var define = function (module, deps, payload) {
          if (typeof module !== "string") {
              if (define.original)
                  define.original.apply(this, arguments);
              else {
                  console.error("dropping module because define wasn\'t a string.");
                  console.trace();
              }
              return;
          }
          if (arguments.length == 2)
              payload = deps;
          if (!define.modules[module]) {
              define.payloads[module] = payload;
              define.modules[module] = null;
          }
      };
      define.modules = {};
      define.payloads = {};
      /**
       * Get at functionality define()ed using the function above
       */
      var _acequire = function (parentId, module, callback) {
          if (typeof module === "string") {
              var payload = lookup(parentId, module);
              if (payload != undefined) {
                  callback && callback();
                  return payload;
              }
          }
          else if (Object.prototype.toString.call(module) === "[object Array]") {
              var params = [];
              for (var i = 0, l = module.length; i < l; ++i) {
                  var dep = lookup(parentId, module[i]);
                  if (dep == undefined && acequire.original)
                      return;
                  params.push(dep);
              }
              return callback && callback.apply(null, params) || true;
          }
      };
      var acequire = function (module, callback) {
          var packagedModule = _acequire("", module, callback);
          if (packagedModule == undefined && acequire.original)
              return acequire.original.apply(this, arguments);
          return packagedModule;
      };
      var normalizeModule = function (parentId, moduleName) {
          // normalize plugin acequires
          if (moduleName.indexOf("!") !== -1) {
              var chunks = moduleName.split("!");
              return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
          }
          // normalize relative acequires
          if (moduleName.charAt(0) == ".") {
              var base = parentId.split("/").slice(0, -1).join("/");
              moduleName = base + "/" + moduleName;
              while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
                  var previous = moduleName;
                  moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
              }
          }
          return moduleName;
      };
      /**
       * Internal function to lookup moduleNames and resolve them by calling the
       * definition function if needed.
       */
      var lookup = function (parentId, moduleName) {
          moduleName = normalizeModule(parentId, moduleName);
          var module = define.modules[moduleName];
          if (!module) {
              module = define.payloads[moduleName];
              if (typeof module === 'function') {
                  var exports = {};
                  var mod = {
                      id: moduleName,
                      uri: '',
                      exports: exports,
                      packaged: true
                  };
                  var req = function (module, callback) {
                      return _acequire(moduleName, module, callback);
                  };
                  var returnValue = module(req, exports, mod);
                  exports = returnValue || mod.exports;
                  define.modules[moduleName] = exports;
                  delete define.payloads[moduleName];
              }
              module = define.modules[moduleName] = exports || module;
          }
          return module;
      };
      function exportAce(ns) {
          var root = global;
          if (ns) {
              if (!global[ns])
                  global[ns] = {};
              root = global[ns];
          }
          if (!root.define || !root.define.packaged) {
              define.original = root.define;
              root.define = define;
              root.define.packaged = true;
          }
          if (!root.acequire || !root.acequire.packaged) {
              acequire.original = root.acequire;
              root.acequire = acequire;
              root.acequire.packaged = true;
          }
      }
      exportAce(ACE_NAMESPACE);
  })();
  ace.define("ace/lib/regexp", ["require", "exports", "module"], function (acequire, exports, module) {
      var real = {
          exec: RegExp.prototype.exec,
          test: RegExp.prototype.test,
          match: String.prototype.match,
          replace: String.prototype.replace,
          split: String.prototype.split
      }, compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined, // check `exec` handling of nonparticipating capturing groups
      compliantLastIndexIncrement = function () {
          var x = /^/g;
          real.test.call(x, "");
          return !x.lastIndex;
      }();
      if (compliantLastIndexIncrement && compliantExecNpcg)
          return;
      RegExp.prototype.exec = function (str) {
          var match = real.exec.apply(this, arguments), name, r2;
          if (typeof (str) == 'string' && match) {
              if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
                  r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
                  real.replace.call(str.slice(match.index), r2, function () {
                      for (var i = 1; i < arguments.length - 2; i++) {
                          if (arguments[i] === undefined)
                              match[i] = undefined;
                      }
                  });
              }
              if (this._xregexp && this._xregexp.captureNames) {
                  for (var i = 1; i < match.length; i++) {
                      name = this._xregexp.captureNames[i - 1];
                      if (name)
                          match[name] = match[i];
                  }
              }
              if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))
                  this.lastIndex--;
          }
          return match;
      };
      if (!compliantLastIndexIncrement) {
          RegExp.prototype.test = function (str) {
              var match = real.exec.call(this, str);
              if (match && this.global && !match[0].length && (this.lastIndex > match.index))
                  this.lastIndex--;
              return !!match;
          };
      }
      function getNativeFlags(regex) {
          return (regex.global ? "g" : "") +
              (regex.ignoreCase ? "i" : "") +
              (regex.multiline ? "m" : "") +
              (regex.extended ? "x" : "") + // Proposed for ES4; included in AS3
              (regex.sticky ? "y" : "");
      }
      function indexOf(array, item, from) {
          if (Array.prototype.indexOf) // Use the native array method if available
              return array.indexOf(item, from);
          for (var i = from || 0; i < array.length; i++) {
              if (array[i] === item)
                  return i;
          }
          return -1;
      }
  });
  ace.define("ace/lib/es5-shim", ["require", "exports", "module"], function (acequire, exports, module) {
      function Empty() { }
      if (!Function.prototype.bind) {
          Function.prototype.bind = function bind(that) {
              var target = this;
              if (typeof target != "function") {
                  throw new TypeError("Function.prototype.bind called on incompatible " + target);
              }
              var args = slice.call(arguments, 1); // for normal call
              var bound = function () {
                  if (this instanceof bound) {
                      var result = target.apply(this, args.concat(slice.call(arguments)));
                      if (Object(result) === result) {
                          return result;
                      }
                      return this;
                  }
                  else {
                      return target.apply(that, args.concat(slice.call(arguments)));
                  }
              };
              if (target.prototype) {
                  Empty.prototype = target.prototype;
                  bound.prototype = new Empty();
                  Empty.prototype = null;
              }
              return bound;
          };
      }
      var call = Function.prototype.call;
      var prototypeOfArray = Array.prototype;
      var prototypeOfObject = Object.prototype;
      var slice = prototypeOfArray.slice;
      var _toString = call.bind(prototypeOfObject.toString);
      var owns = call.bind(prototypeOfObject.hasOwnProperty);
      var defineGetter;
      var defineSetter;
      var lookupGetter;
      var lookupSetter;
      var supportsAccessors;
      if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
          defineGetter = call.bind(prototypeOfObject.__defineGetter__);
          defineSetter = call.bind(prototypeOfObject.__defineSetter__);
          lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
          lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
      }
      if ([1, 2].splice(0).length != 2) {
          if (function () {
              function makeArray(l) {
                  var a = new Array(l + 2);
                  a[0] = a[1] = 0;
                  return a;
              }
              var array = [], lengthBefore;
              array.splice.apply(array, makeArray(20));
              array.splice.apply(array, makeArray(26));
              lengthBefore = array.length; //46
              array.splice(5, 0, "XXX"); // add one element
              if (lengthBefore + 1 == array.length) {
                  return true; // has right splice implementation without bugs
              }
          }()) { //IE 6/7
              var array_splice = Array.prototype.splice;
              Array.prototype.splice = function (start, deleteCount) {
                  if (!arguments.length) {
                      return [];
                  }
                  else {
                      return array_splice.apply(this, [
                          start === void 0 ? 0 : start,
                          deleteCount === void 0 ? (this.length - start) : deleteCount
                      ].concat(slice.call(arguments, 2)));
                  }
              };
          }
          else { //IE8
              Array.prototype.splice = function (pos, removeCount) {
                  var length = this.length;
                  if (pos > 0) {
                      if (pos > length)
                          pos = length;
                  }
                  else if (pos == void 0) {
                      pos = 0;
                  }
                  else if (pos < 0) {
                      pos = Math.max(length + pos, 0);
                  }
                  if (!(pos + removeCount < length))
                      removeCount = length - pos;
                  var removed = this.slice(pos, pos + removeCount);
                  var insert = slice.call(arguments, 2);
                  var add = insert.length;
                  if (pos === length) {
                      if (add) {
                          this.push.apply(this, insert);
                      }
                  }
                  else {
                      var remove = Math.min(removeCount, length - pos);
                      var tailOldPos = pos + remove;
                      var tailNewPos = tailOldPos + add - remove;
                      var tailCount = length - tailOldPos;
                      var lengthAfterRemove = length - remove;
                      if (tailNewPos < tailOldPos) { // case A
                          for (var i = 0; i < tailCount; ++i) {
                              this[tailNewPos + i] = this[tailOldPos + i];
                          }
                      }
                      else if (tailNewPos > tailOldPos) { // case B
                          for (i = tailCount; i--;) {
                              this[tailNewPos + i] = this[tailOldPos + i];
                          }
                      } // else, add == remove (nothing to do)
                      if (add && pos === lengthAfterRemove) {
                          this.length = lengthAfterRemove; // truncate array
                          this.push.apply(this, insert);
                      }
                      else {
                          this.length = lengthAfterRemove + add; // reserves space
                          for (i = 0; i < add; ++i) {
                              this[pos + i] = insert[i];
                          }
                      }
                  }
                  return removed;
              };
          }
      }
      if (!Array.isArray) {
          Array.isArray = function isArray(obj) {
              return _toString(obj) == "[object Array]";
          };
      }
      var boxedString = Object("a"), splitString = boxedString[0] != "a" || !(0 in boxedString);
      if (!Array.prototype.forEach) {
          Array.prototype.forEach = function forEach(fun /*, thisp*/) {
              var object = toObject(this), self = splitString && _toString(this) == "[object String]" ?
                  this.split("") :
                  object, thisp = arguments[1], i = -1, length = self.length >>> 0;
              if (_toString(fun) != "[object Function]") {
                  throw new TypeError(); // TODO message
              }
              while (++i < length) {
                  if (i in self) {
                      fun.call(thisp, self[i], i, object);
                  }
              }
          };
      }
      if (!Array.prototype.map) {
          Array.prototype.map = function map(fun /*, thisp*/) {
              var object = toObject(this), self = splitString && _toString(this) == "[object String]" ?
                  this.split("") :
                  object, length = self.length >>> 0, result = Array(length), thisp = arguments[1];
              if (_toString(fun) != "[object Function]") {
                  throw new TypeError(fun + " is not a function");
              }
              for (var i = 0; i < length; i++) {
                  if (i in self)
                      result[i] = fun.call(thisp, self[i], i, object);
              }
              return result;
          };
      }
      if (!Array.prototype.filter) {
          Array.prototype.filter = function filter(fun /*, thisp */) {
              var object = toObject(this), self = splitString && _toString(this) == "[object String]" ?
                  this.split("") :
                  object, length = self.length >>> 0, result = [], value, thisp = arguments[1];
              if (_toString(fun) != "[object Function]") {
                  throw new TypeError(fun + " is not a function");
              }
              for (var i = 0; i < length; i++) {
                  if (i in self) {
                      value = self[i];
                      if (fun.call(thisp, value, i, object)) {
                          result.push(value);
                      }
                  }
              }
              return result;
          };
      }
      if (!Array.prototype.every) {
          Array.prototype.every = function every(fun /*, thisp */) {
              var object = toObject(this), self = splitString && _toString(this) == "[object String]" ?
                  this.split("") :
                  object, length = self.length >>> 0, thisp = arguments[1];
              if (_toString(fun) != "[object Function]") {
                  throw new TypeError(fun + " is not a function");
              }
              for (var i = 0; i < length; i++) {
                  if (i in self && !fun.call(thisp, self[i], i, object)) {
                      return false;
                  }
              }
              return true;
          };
      }
      if (!Array.prototype.some) {
          Array.prototype.some = function some(fun /*, thisp */) {
              var object = toObject(this), self = splitString && _toString(this) == "[object String]" ?
                  this.split("") :
                  object, length = self.length >>> 0, thisp = arguments[1];
              if (_toString(fun) != "[object Function]") {
                  throw new TypeError(fun + " is not a function");
              }
              for (var i = 0; i < length; i++) {
                  if (i in self && fun.call(thisp, self[i], i, object)) {
                      return true;
                  }
              }
              return false;
          };
      }
      if (!Array.prototype.reduce) {
          Array.prototype.reduce = function reduce(fun /*, initial*/) {
              var object = toObject(this), self = splitString && _toString(this) == "[object String]" ?
                  this.split("") :
                  object, length = self.length >>> 0;
              if (_toString(fun) != "[object Function]") {
                  throw new TypeError(fun + " is not a function");
              }
              if (!length && arguments.length == 1) {
                  throw new TypeError("reduce of empty array with no initial value");
              }
              var i = 0;
              var result;
              if (arguments.length >= 2) {
                  result = arguments[1];
              }
              else {
                  do {
                      if (i in self) {
                          result = self[i++];
                          break;
                      }
                      if (++i >= length) {
                          throw new TypeError("reduce of empty array with no initial value");
                      }
                  } while (true);
              }
              for (; i < length; i++) {
                  if (i in self) {
                      result = fun.call(void 0, result, self[i], i, object);
                  }
              }
              return result;
          };
      }
      if (!Array.prototype.reduceRight) {
          Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {
              var object = toObject(this), self = splitString && _toString(this) == "[object String]" ?
                  this.split("") :
                  object, length = self.length >>> 0;
              if (_toString(fun) != "[object Function]") {
                  throw new TypeError(fun + " is not a function");
              }
              if (!length && arguments.length == 1) {
                  throw new TypeError("reduceRight of empty array with no initial value");
              }
              var result, i = length - 1;
              if (arguments.length >= 2) {
                  result = arguments[1];
              }
              else {
                  do {
                      if (i in self) {
                          result = self[i--];
                          break;
                      }
                      if (--i < 0) {
                          throw new TypeError("reduceRight of empty array with no initial value");
                      }
                  } while (true);
              }
              do {
                  if (i in this) {
                      result = fun.call(void 0, result, self[i], i, object);
                  }
              } while (i--);
              return result;
          };
      }
      if (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {
          Array.prototype.indexOf = function indexOf(sought /*, fromIndex */) {
              var self = splitString && _toString(this) == "[object String]" ?
                  this.split("") :
                  toObject(this), length = self.length >>> 0;
              if (!length) {
                  return -1;
              }
              var i = 0;
              if (arguments.length > 1) {
                  i = toInteger(arguments[1]);
              }
              i = i >= 0 ? i : Math.max(0, length + i);
              for (; i < length; i++) {
                  if (i in self && self[i] === sought) {
                      return i;
                  }
              }
              return -1;
          };
      }
      if (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {
          Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {
              var self = splitString && _toString(this) == "[object String]" ?
                  this.split("") :
                  toObject(this), length = self.length >>> 0;
              if (!length) {
                  return -1;
              }
              var i = length - 1;
              if (arguments.length > 1) {
                  i = Math.min(i, toInteger(arguments[1]));
              }
              i = i >= 0 ? i : length - Math.abs(i);
              for (; i >= 0; i--) {
                  if (i in self && sought === self[i]) {
                      return i;
                  }
              }
              return -1;
          };
      }
      if (!Object.getPrototypeOf) {
          Object.getPrototypeOf = function getPrototypeOf(object) {
              return object.__proto__ || (object.constructor ?
                  object.constructor.prototype :
                  prototypeOfObject);
          };
      }
      if (!Object.getOwnPropertyDescriptor) {
          var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " +
              "non-object: ";
          Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
              if ((typeof object != "object" && typeof object != "function") || object === null)
                  throw new TypeError(ERR_NON_OBJECT + object);
              if (!owns(object, property))
                  return;
              var descriptor, getter, setter;
              descriptor = { enumerable: true, configurable: true };
              if (supportsAccessors) {
                  var prototype = object.__proto__;
                  object.__proto__ = prototypeOfObject;
                  var getter = lookupGetter(object, property);
                  var setter = lookupSetter(object, property);
                  object.__proto__ = prototype;
                  if (getter || setter) {
                      if (getter)
                          descriptor.get = getter;
                      if (setter)
                          descriptor.set = setter;
                      return descriptor;
                  }
              }
              descriptor.value = object[property];
              return descriptor;
          };
      }
      if (!Object.getOwnPropertyNames) {
          Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
              return Object.keys(object);
          };
      }
      if (!Object.create) {
          var createEmpty;
          if (Object.prototype.__proto__ === null) {
              createEmpty = function () {
                  return { "__proto__": null };
              };
          }
          else {
              createEmpty = function () {
                  var empty = {};
                  for (var i in empty)
                      empty[i] = null;
                  empty.constructor =
                      empty.hasOwnProperty =
                          empty.propertyIsEnumerable =
                              empty.isPrototypeOf =
                                  empty.toLocaleString =
                                      empty.toString =
                                          empty.valueOf =
                                              empty.__proto__ = null;
                  return empty;
              };
          }
          Object.create = function create(prototype, properties) {
              var object;
              if (prototype === null) {
                  object = createEmpty();
              }
              else {
                  if (typeof prototype != "object")
                      throw new TypeError("typeof prototype[" + (typeof prototype) + "] != 'object'");
                  var Type = function () { };
                  Type.prototype = prototype;
                  object = new Type();
                  object.__proto__ = prototype;
              }
              if (properties !== void 0)
                  Object.defineProperties(object, properties);
              return object;
          };
      }
      function doesDefinePropertyWork(object) {
          try {
              Object.defineProperty(object, "sentinel", {});
              return "sentinel" in object;
          }
          catch (exception) {
          }
      }
      if (Object.defineProperty) {
          var definePropertyWorksOnObject = doesDefinePropertyWork({});
          var definePropertyWorksOnDom = typeof document == "undefined" ||
              doesDefinePropertyWork(document.createElement("div"));
          if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
              var definePropertyFallback = Object.defineProperty;
          }
      }
      if (!Object.defineProperty || definePropertyFallback) {
          var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
          var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: ";
          var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " +
              "on this javascript engine";
          Object.defineProperty = function defineProperty(object, property, descriptor) {
              if ((typeof object != "object" && typeof object != "function") || object === null)
                  throw new TypeError(ERR_NON_OBJECT_TARGET + object);
              if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null)
                  throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
              if (definePropertyFallback) {
                  try {
                      return definePropertyFallback.call(Object, object, property, descriptor);
                  }
                  catch (exception) {
                  }
              }
              if (owns(descriptor, "value")) {
                  if (supportsAccessors && (lookupGetter(object, property) ||
                      lookupSetter(object, property))) {
                      var prototype = object.__proto__;
                      object.__proto__ = prototypeOfObject;
                      delete object[property];
                      object[property] = descriptor.value;
                      object.__proto__ = prototype;
                  }
                  else {
                      object[property] = descriptor.value;
                  }
              }
              else {
                  if (!supportsAccessors)
                      throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
                  if (owns(descriptor, "get"))
                      defineGetter(object, property, descriptor.get);
                  if (owns(descriptor, "set"))
                      defineSetter(object, property, descriptor.set);
              }
              return object;
          };
      }
      if (!Object.defineProperties) {
          Object.defineProperties = function defineProperties(object, properties) {
              for (var property in properties) {
                  if (owns(properties, property))
                      Object.defineProperty(object, property, properties[property]);
              }
              return object;
          };
      }
      if (!Object.seal) {
          Object.seal = function seal(object) {
              return object;
          };
      }
      if (!Object.freeze) {
          Object.freeze = function freeze(object) {
              return object;
          };
      }
      try {
          Object.freeze(function () { });
      }
      catch (exception) {
          Object.freeze = (function freeze(freezeObject) {
              return function freeze(object) {
                  if (typeof object == "function") {
                      return object;
                  }
                  else {
                      return freezeObject(object);
                  }
              };
          })(Object.freeze);
      }
      if (!Object.preventExtensions) {
          Object.preventExtensions = function preventExtensions(object) {
              return object;
          };
      }
      if (!Object.isSealed) {
          Object.isSealed = function isSealed(object) {
              return false;
          };
      }
      if (!Object.isFrozen) {
          Object.isFrozen = function isFrozen(object) {
              return false;
          };
      }
      if (!Object.isExtensible) {
          Object.isExtensible = function isExtensible(object) {
              if (Object(object) === object) {
                  throw new TypeError(); // TODO message
              }
              var name = '';
              while (owns(object, name)) {
                  name += '?';
              }
              object[name] = true;
              var returnValue = owns(object, name);
              delete object[name];
              return returnValue;
          };
      }
      if (!Object.keys) {
          var hasDontEnumBug = true, dontEnums = [
              "toString",
              "toLocaleString",
              "valueOf",
              "hasOwnProperty",
              "isPrototypeOf",
              "propertyIsEnumerable",
              "constructor"
          ], dontEnumsLength = dontEnums.length;
          for (var key in { "toString": null }) {
              hasDontEnumBug = false;
          }
          Object.keys = function keys(object) {
              if ((typeof object != "object" && typeof object != "function") ||
                  object === null) {
                  throw new TypeError("Object.keys called on a non-object");
              }
              var keys = [];
              for (var name in object) {
                  if (owns(object, name)) {
                      keys.push(name);
                  }
              }
              if (hasDontEnumBug) {
                  for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
                      var dontEnum = dontEnums[i];
                      if (owns(object, dontEnum)) {
                          keys.push(dontEnum);
                      }
                  }
              }
              return keys;
          };
      }
      if (!Date.now) {
          Date.now = function now() {
              return new Date().getTime();
          };
      }
      var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" +
          "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
          "\u2029\uFEFF";
      if (!String.prototype.trim || ws.trim()) {
          ws = "[" + ws + "]";
          var trimBeginRegexp = new RegExp("^" + ws + ws + "*"), trimEndRegexp = new RegExp(ws + ws + "*$");
          String.prototype.trim = function trim() {
              return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
          };
      }
      function toInteger(n) {
          n = +n;
          if (n !== n) { // isNaN
              n = 0;
          }
          else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
              n = (n > 0 || -1) * Math.floor(Math.abs(n));
          }
          return n;
      }
      var toObject = function (o) {
          if (o == null) { // this matches both null and undefined
              throw new TypeError("can't convert " + o + " to object");
          }
          return Object(o);
      };
  });
  ace.define("ace/lib/fixoldbrowsers", ["require", "exports", "module", "ace/lib/regexp", "ace/lib/es5-shim"], function (acequire, exports, module) {
      acequire("./regexp");
      acequire("./es5-shim");
  });
  ace.define("ace/lib/dom", ["require", "exports", "module"], function (acequire, exports, module) {
      var XHTML_NS = "http://www.w3.org/1999/xhtml";
      exports.getDocumentHead = function (doc) {
          if (!doc)
              doc = document;
          return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
      };
      exports.createElement = function (tag, ns) {
          return document.createElementNS ?
              document.createElementNS(ns || XHTML_NS, tag) :
              document.createElement(tag);
      };
      exports.hasCssClass = function (el, name) {
          var classes = (el.className + "").split(/\s+/g);
          return classes.indexOf(name) !== -1;
      };
      exports.addCssClass = function (el, name) {
          if (!exports.hasCssClass(el, name)) {
              el.className += " " + name;
          }
      };
      exports.removeCssClass = function (el, name) {
          var classes = el.className.split(/\s+/g);
          while (true) {
              var index = classes.indexOf(name);
              if (index == -1) {
                  break;
              }
              classes.splice(index, 1);
          }
          el.className = classes.join(" ");
      };
      exports.toggleCssClass = function (el, name) {
          var classes = el.className.split(/\s+/g), add = true;
          while (true) {
              var index = classes.indexOf(name);
              if (index == -1) {
                  break;
              }
              add = false;
              classes.splice(index, 1);
          }
          if (add)
              classes.push(name);
          el.className = classes.join(" ");
          return add;
      };
      exports.setCssClass = function (node, className, include) {
          if (include) {
              exports.addCssClass(node, className);
          }
          else {
              exports.removeCssClass(node, className);
          }
      };
      exports.hasCssString = function (id, doc) {
          var index = 0, sheets;
          doc = doc || document;
          if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
              while (index < sheets.length)
                  if (sheets[index++].owningElement.id === id)
                      return true;
          }
          else if ((sheets = doc.getElementsByTagName("style"))) {
              while (index < sheets.length)
                  if (sheets[index++].id === id)
                      return true;
          }
          return false;
      };
      exports.importCssString = function importCssString(cssText, id, doc) {
          doc = doc || document;
          if (id && exports.hasCssString(id, doc))
              return null;
          var style;
          if (id)
              cssText += "\n/*# sourceURL=ace/css/" + id + " */";
          if (doc.createStyleSheet) {
              style = doc.createStyleSheet();
              style.cssText = cssText;
              if (id)
                  style.owningElement.id = id;
          }
          else {
              style = exports.createElement("style");
              style.appendChild(doc.createTextNode(cssText));
              if (id)
                  style.id = id;
              exports.getDocumentHead(doc).appendChild(style);
          }
      };
      exports.importCssStylsheet = function (uri, doc) {
          if (doc.createStyleSheet) {
              doc.createStyleSheet(uri);
          }
          else {
              var link = exports.createElement('link');
              link.rel = 'stylesheet';
              link.href = uri;
              exports.getDocumentHead(doc).appendChild(link);
          }
      };
      exports.getInnerWidth = function (element) {
          return (parseInt(exports.computedStyle(element, "paddingLeft"), 10) +
              parseInt(exports.computedStyle(element, "paddingRight"), 10) +
              element.clientWidth);
      };
      exports.getInnerHeight = function (element) {
          return (parseInt(exports.computedStyle(element, "paddingTop"), 10) +
              parseInt(exports.computedStyle(element, "paddingBottom"), 10) +
              element.clientHeight);
      };
      exports.scrollbarWidth = function (document) {
          var inner = exports.createElement("ace_inner");
          inner.style.width = "100%";
          inner.style.minWidth = "0px";
          inner.style.height = "200px";
          inner.style.display = "block";
          var outer = exports.createElement("ace_outer");
          var style = outer.style;
          style.position = "absolute";
          style.left = "-10000px";
          style.overflow = "hidden";
          style.width = "200px";
          style.minWidth = "0px";
          style.height = "150px";
          style.display = "block";
          outer.appendChild(inner);
          var body = document.documentElement;
          body.appendChild(outer);
          var noScrollbar = inner.offsetWidth;
          style.overflow = "scroll";
          var withScrollbar = inner.offsetWidth;
          if (noScrollbar == withScrollbar) {
              withScrollbar = outer.clientWidth;
          }
          body.removeChild(outer);
          return noScrollbar - withScrollbar;
      };
      if (typeof document == "undefined") {
          exports.importCssString = function () { };
          return;
      }
      if (window.pageYOffset !== undefined) {
          exports.getPageScrollTop = function () {
              return window.pageYOffset;
          };
          exports.getPageScrollLeft = function () {
              return window.pageXOffset;
          };
      }
      else {
          exports.getPageScrollTop = function () {
              return document.body.scrollTop;
          };
          exports.getPageScrollLeft = function () {
              return document.body.scrollLeft;
          };
      }
      if (window.getComputedStyle)
          exports.computedStyle = function (element, style) {
              if (style)
                  return (window.getComputedStyle(element, "") || {})[style] || "";
              return window.getComputedStyle(element, "") || {};
          };
      else
          exports.computedStyle = function (element, style) {
              if (style)
                  return element.currentStyle[style];
              return element.currentStyle;
          };
      exports.setInnerHtml = function (el, innerHtml) {
          var element = el.cloneNode(false); //document.createElement("div");
          element.innerHTML = innerHtml;
          el.parentNode.replaceChild(element, el);
          return element;
      };
      if ("textContent" in document.documentElement) {
          exports.setInnerText = function (el, innerText) {
              el.textContent = innerText;
          };
          exports.getInnerText = function (el) {
              return el.textContent;
          };
      }
      else {
          exports.setInnerText = function (el, innerText) {
              el.innerText = innerText;
          };
          exports.getInnerText = function (el) {
              return el.innerText;
          };
      }
      exports.getParentWindow = function (document) {
          return document.defaultView || document.parentWindow;
      };
  });
  ace.define("ace/lib/oop", ["require", "exports", "module"], function (acequire, exports, module) {
      exports.inherits = function (ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                  value: ctor,
                  enumerable: false,
                  writable: true,
                  configurable: true
              }
          });
      };
      exports.mixin = function (obj, mixin) {
          for (var key in mixin) {
              obj[key] = mixin[key];
          }
          return obj;
      };
      exports.implement = function (proto, mixin) {
          exports.mixin(proto, mixin);
      };
  });
  ace.define("ace/lib/keys", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/oop"], function (acequire, exports, module) {
      acequire("./fixoldbrowsers");
      var oop = acequire("./oop");
      var Keys = (function () {
          var ret = {
              MODIFIER_KEYS: {
                  16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta'
              },
              KEY_MODS: {
                  "ctrl": 1, "alt": 2, "option": 2, "shift": 4,
                  "super": 8, "meta": 8, "command": 8, "cmd": 8
              },
              FUNCTION_KEYS: {
                  8: "Backspace",
                  9: "Tab",
                  13: "Return",
                  19: "Pause",
                  27: "Esc",
                  32: "Space",
                  33: "PageUp",
                  34: "PageDown",
                  35: "End",
                  36: "Home",
                  37: "Left",
                  38: "Up",
                  39: "Right",
                  40: "Down",
                  44: "Print",
                  45: "Insert",
                  46: "Delete",
                  96: "Numpad0",
                  97: "Numpad1",
                  98: "Numpad2",
                  99: "Numpad3",
                  100: "Numpad4",
                  101: "Numpad5",
                  102: "Numpad6",
                  103: "Numpad7",
                  104: "Numpad8",
                  105: "Numpad9",
                  '-13': "NumpadEnter",
                  112: "F1",
                  113: "F2",
                  114: "F3",
                  115: "F4",
                  116: "F5",
                  117: "F6",
                  118: "F7",
                  119: "F8",
                  120: "F9",
                  121: "F10",
                  122: "F11",
                  123: "F12",
                  144: "Numlock",
                  145: "Scrolllock"
              },
              PRINTABLE_KEYS: {
                  32: ' ', 48: '0', 49: '1', 50: '2', 51: '3', 52: '4', 53: '5',
                  54: '6', 55: '7', 56: '8', 57: '9', 59: ';', 61: '=', 65: 'a',
                  66: 'b', 67: 'c', 68: 'd', 69: 'e', 70: 'f', 71: 'g', 72: 'h',
                  73: 'i', 74: 'j', 75: 'k', 76: 'l', 77: 'm', 78: 'n', 79: 'o',
                  80: 'p', 81: 'q', 82: 'r', 83: 's', 84: 't', 85: 'u', 86: 'v',
                  87: 'w', 88: 'x', 89: 'y', 90: 'z', 107: '+', 109: '-', 110: '.',
                  186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`',
                  219: '[', 220: '\\', 221: ']', 222: "'", 111: '/', 106: '*'
              }
          };
          var name, i;
          for (i in ret.FUNCTION_KEYS) {
              name = ret.FUNCTION_KEYS[i].toLowerCase();
              ret[name] = parseInt(i, 10);
          }
          for (i in ret.PRINTABLE_KEYS) {
              name = ret.PRINTABLE_KEYS[i].toLowerCase();
              ret[name] = parseInt(i, 10);
          }
          oop.mixin(ret, ret.MODIFIER_KEYS);
          oop.mixin(ret, ret.PRINTABLE_KEYS);
          oop.mixin(ret, ret.FUNCTION_KEYS);
          ret.enter = ret["return"];
          ret.escape = ret.esc;
          ret.del = ret["delete"];
          ret[173] = '-';
          (function () {
              var mods = ["cmd", "ctrl", "alt", "shift"];
              for (var i = Math.pow(2, mods.length); i--;) {
                  ret.KEY_MODS[i] = mods.filter(function (x) {
                      return i & ret.KEY_MODS[x];
                  }).join("-") + "-";
              }
          })();
          ret.KEY_MODS[0] = "";
          ret.KEY_MODS[-1] = "input-";
          return ret;
      })();
      oop.mixin(exports, Keys);
      exports.keyCodeToString = function (keyCode) {
          var keyString = Keys[keyCode];
          if (typeof keyString != "string")
              keyString = String.fromCharCode(keyCode);
          return keyString.toLowerCase();
      };
  });
  ace.define("ace/lib/useragent", ["require", "exports", "module"], function (acequire, exports, module) {
      exports.OS = {
          LINUX: "LINUX",
          MAC: "MAC",
          WINDOWS: "WINDOWS"
      };
      exports.getOS = function () {
          if (exports.isMac) {
              return exports.OS.MAC;
          }
          else if (exports.isLinux) {
              return exports.OS.LINUX;
          }
          else {
              return exports.OS.WINDOWS;
          }
      };
      if (typeof navigator != "object")
          return;
      var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
      var ua = navigator.userAgent;
      exports.isWin = (os == "win");
      exports.isMac = (os == "mac");
      exports.isLinux = (os == "linux");
      exports.isIE =
          (navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0)
              ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1])
              : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]); // for ie
      exports.isOldIE = exports.isIE && exports.isIE < 9;
      exports.isGecko = exports.isMozilla = (window.Controllers || window.controllers) && window.navigator.product === "Gecko";
      exports.isOldGecko = exports.isGecko && parseInt((ua.match(/rv:(\d+)/) || [])[1], 10) < 4;
      exports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";
      exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;
      exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;
      exports.isAIR = ua.indexOf("AdobeAIR") >= 0;
      exports.isIPad = ua.indexOf("iPad") >= 0;
      exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;
      exports.isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;
      if (exports.isIOS)
          exports.isMac = true;
  });
  ace.define("ace/lib/event", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function (acequire, exports, module) {
      var keys = acequire("./keys");
      var useragent = acequire("./useragent");
      var pressedKeys = null;
      var ts = 0;
      exports.addListener = function (elem, type, callback) {
          if (elem.addEventListener) {
              return elem.addEventListener(type, callback, false);
          }
          if (elem.attachEvent) {
              var wrapper = function () {
                  callback.call(elem, window.event);
              };
              callback._wrapper = wrapper;
              elem.attachEvent("on" + type, wrapper);
          }
      };
      exports.removeListener = function (elem, type, callback) {
          if (elem.removeEventListener) {
              return elem.removeEventListener(type, callback, false);
          }
          if (elem.detachEvent) {
              elem.detachEvent("on" + type, callback._wrapper || callback);
          }
      };
      exports.stopEvent = function (e) {
          exports.stopPropagation(e);
          exports.preventDefault(e);
          return false;
      };
      exports.stopPropagation = function (e) {
          if (e.stopPropagation)
              e.stopPropagation();
          else
              e.cancelBubble = true;
      };
      exports.preventDefault = function (e) {
          if (e.preventDefault)
              e.preventDefault();
          else
              e.returnValue = false;
      };
      exports.getButton = function (e) {
          if (e.type == "dblclick")
              return 0;
          if (e.type == "contextmenu" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
              return 2;
          if (e.preventDefault) {
              return e.button;
          }
          else {
              return { 1: 0, 2: 2, 4: 1 }[e.button];
          }
      };
      exports.capture = function (el, eventHandler, releaseCaptureHandler) {
          function onMouseUp(e) {
              eventHandler && eventHandler(e);
              releaseCaptureHandler && releaseCaptureHandler(e);
              exports.removeListener(document, "mousemove", eventHandler, true);
              exports.removeListener(document, "mouseup", onMouseUp, true);
              exports.removeListener(document, "dragstart", onMouseUp, true);
          }
          exports.addListener(document, "mousemove", eventHandler, true);
          exports.addListener(document, "mouseup", onMouseUp, true);
          exports.addListener(document, "dragstart", onMouseUp, true);
          return onMouseUp;
      };
      exports.addTouchMoveListener = function (el, callback) {
          var startx, starty;
          exports.addListener(el, "touchstart", function (e) {
              var touches = e.touches;
              var touchObj = touches[0];
              startx = touchObj.clientX;
              starty = touchObj.clientY;
          });
          exports.addListener(el, "touchmove", function (e) {
              var touches = e.touches;
              if (touches.length > 1)
                  return;
              var touchObj = touches[0];
              e.wheelX = startx - touchObj.clientX;
              e.wheelY = starty - touchObj.clientY;
              startx = touchObj.clientX;
              starty = touchObj.clientY;
              callback(e);
          });
      };
      exports.addMouseWheelListener = function (el, callback) {
          if ("onmousewheel" in el) {
              exports.addListener(el, "mousewheel", function (e) {
                  var factor = 8;
                  if (e.wheelDeltaX !== undefined) {
                      e.wheelX = -e.wheelDeltaX / factor;
                      e.wheelY = -e.wheelDeltaY / factor;
                  }
                  else {
                      e.wheelX = 0;
                      e.wheelY = -e.wheelDelta / factor;
                  }
                  callback(e);
              });
          }
          else if ("onwheel" in el) {
              exports.addListener(el, "wheel", function (e) {
                  var factor = 0.35;
                  switch (e.deltaMode) {
                      case e.DOM_DELTA_PIXEL:
                          e.wheelX = e.deltaX * factor || 0;
                          e.wheelY = e.deltaY * factor || 0;
                          break;
                      case e.DOM_DELTA_LINE:
                      case e.DOM_DELTA_PAGE:
                          e.wheelX = (e.deltaX || 0) * 5;
                          e.wheelY = (e.deltaY || 0) * 5;
                          break;
                  }
                  callback(e);
              });
          }
          else {
              exports.addListener(el, "DOMMouseScroll", function (e) {
                  if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
                      e.wheelX = (e.detail || 0) * 5;
                      e.wheelY = 0;
                  }
                  else {
                      e.wheelX = 0;
                      e.wheelY = (e.detail || 0) * 5;
                  }
                  callback(e);
              });
          }
      };
      exports.addMultiMouseDownListener = function (elements, timeouts, eventHandler, callbackName) {
          var clicks = 0;
          var startX, startY, timer;
          var eventNames = {
              2: "dblclick",
              3: "tripleclick",
              4: "quadclick"
          };
          function onMousedown(e) {
              if (exports.getButton(e) !== 0) {
                  clicks = 0;
              }
              else if (e.detail > 1) {
                  clicks++;
                  if (clicks > 4)
                      clicks = 1;
              }
              else {
                  clicks = 1;
              }
              if (useragent.isIE) {
                  var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
                  if (!timer || isNewClick)
                      clicks = 1;
                  if (timer)
                      clearTimeout(timer);
                  timer = setTimeout(function () { timer = null; }, timeouts[clicks - 1] || 600);
                  if (clicks == 1) {
                      startX = e.clientX;
                      startY = e.clientY;
                  }
              }
              e._clicks = clicks;
              eventHandler[callbackName]("mousedown", e);
              if (clicks > 4)
                  clicks = 0;
              else if (clicks > 1)
                  return eventHandler[callbackName](eventNames[clicks], e);
          }
          function onDblclick(e) {
              clicks = 2;
              if (timer)
                  clearTimeout(timer);
              timer = setTimeout(function () { timer = null; }, timeouts[clicks - 1] || 600);
              eventHandler[callbackName]("mousedown", e);
              eventHandler[callbackName](eventNames[clicks], e);
          }
          if (!Array.isArray(elements))
              elements = [elements];
          elements.forEach(function (el) {
              exports.addListener(el, "mousedown", onMousedown);
              if (useragent.isOldIE)
                  exports.addListener(el, "dblclick", onDblclick);
          });
      };
      var getModifierHash = useragent.isMac && useragent.isOpera && !("KeyboardEvent" in window)
          ? function (e) {
              return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
          }
          : function (e) {
              return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
          };
      exports.getModifierString = function (e) {
          return keys.KEY_MODS[getModifierHash(e)];
      };
      function normalizeCommandKeys(callback, e, keyCode) {
          var hashId = getModifierHash(e);
          if (!useragent.isMac && pressedKeys) {
              if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win")))
                  hashId |= 8;
              if (pressedKeys.altGr) {
                  if ((3 & hashId) != 3)
                      pressedKeys.altGr = 0;
                  else
                      return;
              }
              if (keyCode === 18 || keyCode === 17) {
                  var location = "location" in e ? e.location : e.keyLocation;
                  if (keyCode === 17 && location === 1) {
                      if (pressedKeys[keyCode] == 1)
                          ts = e.timeStamp;
                  }
                  else if (keyCode === 18 && hashId === 3 && location === 2) {
                      var dt = e.timeStamp - ts;
                      if (dt < 50)
                          pressedKeys.altGr = true;
                  }
              }
          }
          if (keyCode in keys.MODIFIER_KEYS) {
              keyCode = -1;
          }
          if (hashId & 8 && (keyCode >= 91 && keyCode <= 93)) {
              keyCode = -1;
          }
          if (!hashId && keyCode === 13) {
              var location = "location" in e ? e.location : e.keyLocation;
              if (location === 3) {
                  callback(e, hashId, -keyCode);
                  if (e.defaultPrevented)
                      return;
              }
          }
          if (useragent.isChromeOS && hashId & 8) {
              callback(e, hashId, keyCode);
              if (e.defaultPrevented)
                  return;
              else
                  hashId &= ~8;
          }
          if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
              return false;
          }
          return callback(e, hashId, keyCode);
      }
      exports.addCommandKeyListener = function (el, callback) {
          var addListener = exports.addListener;
          if (useragent.isOldGecko || (useragent.isOpera && !("KeyboardEvent" in window))) {
              var lastKeyDownKeyCode = null;
              addListener(el, "keydown", function (e) {
                  lastKeyDownKeyCode = e.keyCode;
              });
              addListener(el, "keypress", function (e) {
                  return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
              });
          }
          else {
              var lastDefaultPrevented = null;
              addListener(el, "keydown", function (e) {
                  pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
                  var result = normalizeCommandKeys(callback, e, e.keyCode);
                  lastDefaultPrevented = e.defaultPrevented;
                  return result;
              });
              addListener(el, "keypress", function (e) {
                  if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                      exports.stopEvent(e);
                      lastDefaultPrevented = null;
                  }
              });
              addListener(el, "keyup", function (e) {
                  pressedKeys[e.keyCode] = null;
              });
              if (!pressedKeys) {
                  resetPressedKeys();
                  addListener(window, "focus", resetPressedKeys);
              }
          }
      };
      function resetPressedKeys() {
          pressedKeys = Object.create(null);
      }
      if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
          var postMessageId = 1;
          exports.nextTick = function (callback, win) {
              win = win || window;
              var messageName = "zero-timeout-message-" + postMessageId;
              exports.addListener(win, "message", function listener(e) {
                  if (e.data == messageName) {
                      exports.stopPropagation(e);
                      exports.removeListener(win, "message", listener);
                      callback();
                  }
              });
              win.postMessage(messageName, "*");
          };
      }
      exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame
          || window.mozRequestAnimationFrame
          || window.webkitRequestAnimationFrame
          || window.msRequestAnimationFrame
          || window.oRequestAnimationFrame);
      if (exports.nextFrame)
          exports.nextFrame = exports.nextFrame.bind(window);
      else
          exports.nextFrame = function (callback) {
              setTimeout(callback, 17);
          };
  });
  ace.define("ace/lib/lang", ["require", "exports", "module"], function (acequire, exports, module) {
      exports.last = function (a) {
          return a[a.length - 1];
      };
      exports.stringReverse = function (string) {
          return string.split("").reverse().join("");
      };
      exports.stringRepeat = function (string, count) {
          var result = '';
          while (count > 0) {
              if (count & 1)
                  result += string;
              if (count >>= 1)
                  string += string;
          }
          return result;
      };
      var trimBeginRegexp = /^\s\s*/;
      var trimEndRegexp = /\s\s*$/;
      exports.stringTrimLeft = function (string) {
          return string.replace(trimBeginRegexp, '');
      };
      exports.stringTrimRight = function (string) {
          return string.replace(trimEndRegexp, '');
      };
      exports.copyObject = function (obj) {
          var copy = {};
          for (var key in obj) {
              copy[key] = obj[key];
          }
          return copy;
      };
      exports.copyArray = function (array) {
          var copy = [];
          for (var i = 0, l = array.length; i < l; i++) {
              if (array[i] && typeof array[i] == "object")
                  copy[i] = this.copyObject(array[i]);
              else
                  copy[i] = array[i];
          }
          return copy;
      };
      exports.deepCopy = function deepCopy(obj) {
          if (typeof obj !== "object" || !obj)
              return obj;
          var copy;
          if (Array.isArray(obj)) {
              copy = [];
              for (var key = 0; key < obj.length; key++) {
                  copy[key] = deepCopy(obj[key]);
              }
              return copy;
          }
          if (Object.prototype.toString.call(obj) !== "[object Object]")
              return obj;
          copy = {};
          for (var key in obj)
              copy[key] = deepCopy(obj[key]);
          return copy;
      };
      exports.arrayToMap = function (arr) {
          var map = {};
          for (var i = 0; i < arr.length; i++) {
              map[arr[i]] = 1;
          }
          return map;
      };
      exports.createMap = function (props) {
          var map = Object.create(null);
          for (var i in props) {
              map[i] = props[i];
          }
          return map;
      };
      exports.arrayRemove = function (array, value) {
          for (var i = 0; i <= array.length; i++) {
              if (value === array[i]) {
                  array.splice(i, 1);
              }
          }
      };
      exports.escapeRegExp = function (str) {
          return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
      };
      exports.escapeHTML = function (str) {
          return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
      };
      exports.getMatchOffsets = function (string, regExp) {
          var matches = [];
          string.replace(regExp, function (str) {
              matches.push({
                  offset: arguments[arguments.length - 2],
                  length: str.length
              });
          });
          return matches;
      };
      exports.deferredCall = function (fcn) {
          var timer = null;
          var callback = function () {
              timer = null;
              fcn();
          };
          var deferred = function (timeout) {
              deferred.cancel();
              timer = setTimeout(callback, timeout || 0);
              return deferred;
          };
          deferred.schedule = deferred;
          deferred.call = function () {
              this.cancel();
              fcn();
              return deferred;
          };
          deferred.cancel = function () {
              clearTimeout(timer);
              timer = null;
              return deferred;
          };
          deferred.isPending = function () {
              return timer;
          };
          return deferred;
      };
      exports.delayedCall = function (fcn, defaultTimeout) {
          var timer = null;
          var callback = function () {
              timer = null;
              fcn();
          };
          var _self = function (timeout) {
              if (timer == null)
                  timer = setTimeout(callback, timeout || defaultTimeout);
          };
          _self.delay = function (timeout) {
              timer && clearTimeout(timer);
              timer = setTimeout(callback, timeout || defaultTimeout);
          };
          _self.schedule = _self;
          _self.call = function () {
              this.cancel();
              fcn();
          };
          _self.cancel = function () {
              timer && clearTimeout(timer);
              timer = null;
          };
          _self.isPending = function () {
              return timer;
          };
          return _self;
      };
  });
  ace.define("ace/keyboard/textinput_ios", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang", "ace/lib/keys"], function (acequire, exports, module) {
      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      var dom = acequire("../lib/dom");
      var lang = acequire("../lib/lang");
      var KEYS = acequire("../lib/keys");
      var MODS = KEYS.KEY_MODS;
      var BROKEN_SETDATA = useragent.isChrome < 18;
      var USE_IE_MIME_TYPE = useragent.isIE;
      var TextInput = function (parentNode, host) {
          var text = dom.createElement("textarea");
          text.className = useragent.isIOS ? "ace_text-input ace_text-input-ios" : "ace_text-input";
          if (useragent.isTouchPad)
              text.setAttribute("x-palm-disable-auto-cap", true);
          text.setAttribute("wrap", "off");
          text.setAttribute("autocorrect", "off");
          text.setAttribute("autocapitalize", "off");
          text.setAttribute("spellcheck", false);
          text.style.opacity = "0";
          parentNode.insertBefore(text, parentNode.firstChild);
          var PLACEHOLDER = "\n aaaa a\n";
          var copied = false;
          var cut = false;
          var pasted = false;
          var inComposition = false;
          var tempStyle = '';
          var isSelectionEmpty = true;
          try {
              var isFocused = document.activeElement === text;
          }
          catch (e) { }
          event.addListener(text, "blur", function (e) {
              host.onBlur(e);
              isFocused = false;
          });
          event.addListener(text, "focus", function (e) {
              isFocused = true;
              host.onFocus(e);
              resetSelection();
          });
          this.focus = function () {
              if (tempStyle)
                  return text.focus();
              text.style.position = "fixed";
              text.focus();
          };
          this.blur = function () {
              text.blur();
          };
          this.isFocused = function () {
              return isFocused;
          };
          var syncSelection = lang.delayedCall(function () {
              isFocused && resetSelection(isSelectionEmpty);
          });
          var syncValue = lang.delayedCall(function () {
              if (!inComposition) {
                  text.value = PLACEHOLDER;
                  isFocused && resetSelection();
              }
          });
          function resetSelection(isEmpty) {
              if (inComposition)
                  return;
              inComposition = true;
              if (inputHandler) {
                  selectionStart = 0;
                  selectionEnd = isEmpty ? 0 : text.value.length - 1;
              }
              else {
                  var selectionStart = 4;
                  var selectionEnd = 5;
              }
              try {
                  text.setSelectionRange(selectionStart, selectionEnd);
              }
              catch (e) { }
              inComposition = false;
          }
          function resetValue() {
              if (inComposition)
                  return;
              text.value = PLACEHOLDER;
              if (useragent.isWebKit)
                  syncValue.schedule();
          }
          useragent.isWebKit || host.addEventListener('changeSelection', function () {
              if (host.selection.isEmpty() != isSelectionEmpty) {
                  isSelectionEmpty = !isSelectionEmpty;
                  syncSelection.schedule();
              }
          });
          resetValue();
          if (isFocused)
              host.onFocus();
          var isAllSelected = function (text) {
              return text.selectionStart === 0 && text.selectionEnd === text.value.length;
          };
          var onSelect = function (e) {
              if (isAllSelected(text)) {
                  host.selectAll();
                  resetSelection();
              }
              else if (inputHandler) {
                  resetSelection(host.selection.isEmpty());
              }
          };
          var inputHandler = null;
          this.setInputHandler = function (cb) { inputHandler = cb; };
          this.getInputHandler = function () { return inputHandler; };
          var afterContextMenu = false;
          var sendText = function (data) {
              if (text.selectionStart === 4 && text.selectionEnd === 5) {
                  return;
              }
              if (inputHandler) {
                  data = inputHandler(data);
                  inputHandler = null;
              }
              if (pasted) {
                  resetSelection();
                  if (data)
                      host.onPaste(data);
                  pasted = false;
              }
              else if (data == PLACEHOLDER.substr(0) && text.selectionStart === 4) {
                  if (afterContextMenu)
                      host.execCommand("del", { source: "ace" });
                  else // some versions of android do not fire keydown when pressing backspace
                      host.execCommand("backspace", { source: "ace" });
              }
              else if (!copied) {
                  if (data.substring(0, 9) == PLACEHOLDER && data.length > PLACEHOLDER.length)
                      data = data.substr(9);
                  else if (data.substr(0, 4) == PLACEHOLDER.substr(0, 4))
                      data = data.substr(4, data.length - PLACEHOLDER.length + 1);
                  else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                      data = data.slice(0, -1);
                  if (data == PLACEHOLDER.charAt(0)) ;
                  else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                      data = data.slice(0, -1);
                  if (data)
                      host.onTextInput(data);
              }
              if (copied) {
                  copied = false;
              }
              if (afterContextMenu)
                  afterContextMenu = false;
          };
          var onInput = function (e) {
              if (inComposition)
                  return;
              var data = text.value;
              sendText(data);
              resetValue();
          };
          var handleClipboardData = function (e, data, forceIEMime) {
              var clipboardData = e.clipboardData || window.clipboardData;
              if (!clipboardData || BROKEN_SETDATA)
                  return;
              var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
              try {
                  if (data) {
                      return clipboardData.setData(mime, data) !== false;
                  }
                  else {
                      return clipboardData.getData(mime);
                  }
              }
              catch (e) {
                  if (!forceIEMime)
                      return handleClipboardData(e, data, true);
              }
          };
          var doCopy = function (e, isCut) {
              var data = host.getCopyText();
              if (!data)
                  return event.preventDefault(e);
              if (handleClipboardData(e, data)) {
                  if (useragent.isIOS) {
                      cut = isCut;
                      text.value = "\n aa" + data + "a a\n";
                      text.setSelectionRange(4, 4 + data.length);
                      copied = {
                          value: data
                      };
                  }
                  isCut ? host.onCut() : host.onCopy();
                  if (!useragent.isIOS)
                      event.preventDefault(e);
              }
              else {
                  copied = true;
                  text.value = data;
                  text.select();
                  setTimeout(function () {
                      copied = false;
                      resetValue();
                      resetSelection();
                      isCut ? host.onCut() : host.onCopy();
                  });
              }
          };
          var onCut = function (e) {
              doCopy(e, true);
          };
          var onCopy = function (e) {
              doCopy(e, false);
          };
          var onPaste = function (e) {
              var data = handleClipboardData(e);
              if (typeof data == "string") {
                  if (data)
                      host.onPaste(data, e);
                  if (useragent.isIE)
                      setTimeout(resetSelection);
                  event.preventDefault(e);
              }
              else {
                  text.value = "";
                  pasted = true;
              }
          };
          event.addCommandKeyListener(text, host.onCommandKey.bind(host));
          event.addListener(text, "select", onSelect);
          event.addListener(text, "input", onInput);
          event.addListener(text, "cut", onCut);
          event.addListener(text, "copy", onCopy);
          event.addListener(text, "paste", onPaste);
          var onCompositionStart = function (e) {
              if (inComposition || !host.onCompositionStart || host.$readOnly)
                  return;
              inComposition = {};
              inComposition.canUndo = host.session.$undoManager;
              host.onCompositionStart();
              setTimeout(onCompositionUpdate, 0);
              host.on("mousedown", onCompositionEnd);
              if (inComposition.canUndo && !host.selection.isEmpty()) {
                  host.insert("");
                  host.session.markUndoGroup();
                  host.selection.clearSelection();
              }
              host.session.markUndoGroup();
          };
          var onCompositionUpdate = function () {
              if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
                  return;
              var val = text.value.replace(/\x01/g, "");
              if (inComposition.lastValue === val)
                  return;
              host.onCompositionUpdate(val);
              if (inComposition.lastValue)
                  host.undo();
              if (inComposition.canUndo)
                  inComposition.lastValue = val;
              if (inComposition.lastValue) {
                  var r = host.selection.getRange();
                  host.insert(inComposition.lastValue);
                  host.session.markUndoGroup();
                  inComposition.range = host.selection.getRange();
                  host.selection.setRange(r);
                  host.selection.clearSelection();
              }
          };
          var onCompositionEnd = function (e) {
              if (!host.onCompositionEnd || host.$readOnly)
                  return;
              var c = inComposition;
              inComposition = false;
              var timer = setTimeout(function () {
                  timer = null;
                  var str = text.value.replace(/\x01/g, "");
                  if (inComposition)
                      return;
                  else if (str == c.lastValue)
                      resetValue();
                  else if (!c.lastValue && str) {
                      resetValue();
                      sendText(str);
                  }
              });
              inputHandler = function compositionInputHandler(str) {
                  if (timer)
                      clearTimeout(timer);
                  str = str.replace(/\x01/g, "");
                  if (str == c.lastValue)
                      return "";
                  if (c.lastValue && timer)
                      host.undo();
                  return str;
              };
              host.onCompositionEnd();
              host.removeListener("mousedown", onCompositionEnd);
              if (e.type == "compositionend" && c.range) {
                  host.selection.setRange(c.range);
              }
              var needsOnInput = (!!useragent.isChrome && useragent.isChrome >= 53) ||
                  (!!useragent.isWebKit && useragent.isWebKit >= 603);
              if (needsOnInput) {
                  onInput();
              }
          };
          var syncComposition = lang.delayedCall(onCompositionUpdate, 50);
          event.addListener(text, "compositionstart", onCompositionStart);
          if (useragent.isGecko) {
              event.addListener(text, "text", function () { syncComposition.schedule(); });
          }
          else {
              event.addListener(text, "keyup", function () { syncComposition.schedule(); });
              event.addListener(text, "keydown", function () { syncComposition.schedule(); });
          }
          event.addListener(text, "compositionend", onCompositionEnd);
          this.getElement = function () {
              return text;
          };
          this.setReadOnly = function (readOnly) {
              text.readOnly = readOnly;
          };
          this.onContextMenu = function (e) {
              afterContextMenu = true;
              resetSelection(host.selection.isEmpty());
              host._emit("nativecontextmenu", { target: host, domEvent: e });
              this.moveToMouse(e, true);
          };
          this.moveToMouse = function (e, bringToFront) {
              if (!tempStyle)
                  tempStyle = text.style.cssText;
              text.style.cssText = (bringToFront ? "z-index:100000;" : "")
                  + "height:" + text.style.height + ";"
                  + (useragent.isIE ? "opacity:0.1;" : "");
              var rect = host.container.getBoundingClientRect();
              var style = dom.computedStyle(host.container);
              var top = rect.top + (parseInt(style.borderTopWidth) || 0);
              var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
              var maxTop = rect.bottom - top - text.clientHeight - 2;
              var move = function (e) {
                  text.style.left = e.clientX - left - 2 + "px";
                  text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
              };
              move(e);
              if (e.type != "mousedown")
                  return;
              if (host.renderer.$keepTextAreaAtCursor)
                  host.renderer.$keepTextAreaAtCursor = null;
              clearTimeout(closeTimeout);
              if (useragent.isWin)
                  event.capture(host.container, move, onContextMenuClose);
          };
          this.onContextMenuClose = onContextMenuClose;
          var closeTimeout;
          function onContextMenuClose() {
              clearTimeout(closeTimeout);
              closeTimeout = setTimeout(function () {
                  if (tempStyle) {
                      text.style.cssText = tempStyle;
                      tempStyle = '';
                  }
                  if (host.renderer.$keepTextAreaAtCursor == null) {
                      host.renderer.$keepTextAreaAtCursor = true;
                      host.renderer.$moveTextAreaToCursor();
                  }
              }, 0);
          }
          var onContextMenu = function (e) {
              host.textInput.onContextMenu(e);
              onContextMenuClose();
          };
          event.addListener(text, "mouseup", onContextMenu);
          event.addListener(text, "mousedown", function (e) {
              e.preventDefault();
              onContextMenuClose();
          });
          event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
          event.addListener(text, "contextmenu", onContextMenu);
          if (useragent.isIOS) {
              var typingResetTimeout = null;
              var typing = false;
              parentNode.addEventListener("keydown", function (e) {
                  if (typingResetTimeout)
                      clearTimeout(typingResetTimeout);
                  typing = true;
              });
              parentNode.addEventListener("keyup", function (e) {
                  typingResetTimeout = setTimeout(function () {
                      typing = false;
                  }, 100);
              });
              var detectArrowKeys = function (e) {
                  if (document.activeElement !== text)
                      return;
                  if (typing)
                      return;
                  if (cut) {
                      return setTimeout(function () {
                          cut = false;
                      }, 100);
                  }
                  var selectionStart = text.selectionStart;
                  var selectionEnd = text.selectionEnd;
                  text.setSelectionRange(4, 5);
                  if (selectionStart == selectionEnd) {
                      switch (selectionStart) {
                          case 0:
                              host.onCommandKey(null, 0, KEYS.up);
                              break;
                          case 1:
                              host.onCommandKey(null, 0, KEYS.home);
                              break;
                          case 2:
                              host.onCommandKey(null, MODS.option, KEYS.left);
                              break;
                          case 4:
                              host.onCommandKey(null, 0, KEYS.left);
                              break;
                          case 5:
                              host.onCommandKey(null, 0, KEYS.right);
                              break;
                          case 7:
                              host.onCommandKey(null, MODS.option, KEYS.right);
                              break;
                          case 8:
                              host.onCommandKey(null, 0, KEYS.end);
                              break;
                          case 9:
                              host.onCommandKey(null, 0, KEYS.down);
                              break;
                      }
                  }
                  else {
                      switch (selectionEnd) {
                          case 6:
                              host.onCommandKey(null, MODS.shift, KEYS.right);
                              break;
                          case 7:
                              host.onCommandKey(null, MODS.shift | MODS.option, KEYS.right);
                              break;
                          case 8:
                              host.onCommandKey(null, MODS.shift, KEYS.end);
                              break;
                          case 9:
                              host.onCommandKey(null, MODS.shift, KEYS.down);
                              break;
                      }
                      switch (selectionStart) {
                          case 0:
                              host.onCommandKey(null, MODS.shift, KEYS.up);
                              break;
                          case 1:
                              host.onCommandKey(null, MODS.shift, KEYS.home);
                              break;
                          case 2:
                              host.onCommandKey(null, MODS.shift | MODS.option, KEYS.left);
                              break;
                          case 3:
                              host.onCommandKey(null, MODS.shift, KEYS.left);
                              break;
                      }
                  }
              };
              document.addEventListener("selectionchange", detectArrowKeys);
              host.on("destroy", function () {
                  document.removeEventListener("selectionchange", detectArrowKeys);
              });
          }
      };
      exports.TextInput = TextInput;
  });
  ace.define("ace/keyboard/textinput", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang", "ace/keyboard/textinput_ios"], function (acequire, exports, module) {
      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      var dom = acequire("../lib/dom");
      var lang = acequire("../lib/lang");
      var BROKEN_SETDATA = useragent.isChrome < 18;
      var USE_IE_MIME_TYPE = useragent.isIE;
      var TextInputIOS = acequire("./textinput_ios").TextInput;
      var TextInput = function (parentNode, host) {
          if (useragent.isIOS)
              return TextInputIOS.call(this, parentNode, host);
          var text = dom.createElement("textarea");
          text.className = "ace_text-input";
          text.setAttribute("wrap", "off");
          text.setAttribute("autocorrect", "off");
          text.setAttribute("autocapitalize", "off");
          text.setAttribute("spellcheck", false);
          text.style.opacity = "0";
          parentNode.insertBefore(text, parentNode.firstChild);
          var PLACEHOLDER = "\u2028\u2028";
          var copied = false;
          var pasted = false;
          var inComposition = false;
          var tempStyle = '';
          var isSelectionEmpty = true;
          try {
              var isFocused = document.activeElement === text;
          }
          catch (e) { }
          event.addListener(text, "blur", function (e) {
              host.onBlur(e);
              isFocused = false;
          });
          event.addListener(text, "focus", function (e) {
              isFocused = true;
              host.onFocus(e);
              resetSelection();
          });
          this.focus = function () {
              if (tempStyle)
                  return text.focus();
              var top = text.style.top;
              text.style.position = "fixed";
              text.style.top = "0px";
              text.focus();
              setTimeout(function () {
                  text.style.position = "";
                  if (text.style.top == "0px")
                      text.style.top = top;
              }, 0);
          };
          this.blur = function () {
              text.blur();
          };
          this.isFocused = function () {
              return isFocused;
          };
          var syncSelection = lang.delayedCall(function () {
              isFocused && resetSelection(isSelectionEmpty);
          });
          var syncValue = lang.delayedCall(function () {
              if (!inComposition) {
                  text.value = PLACEHOLDER;
                  isFocused && resetSelection();
              }
          });
          function resetSelection(isEmpty) {
              if (inComposition)
                  return;
              inComposition = true;
              if (inputHandler) {
                  var selectionStart = 0;
                  var selectionEnd = isEmpty ? 0 : text.value.length - 1;
              }
              else {
                  var selectionStart = isEmpty ? 2 : 1;
                  var selectionEnd = 2;
              }
              try {
                  text.setSelectionRange(selectionStart, selectionEnd);
              }
              catch (e) { }
              inComposition = false;
          }
          function resetValue() {
              if (inComposition)
                  return;
              text.value = PLACEHOLDER;
              if (useragent.isWebKit)
                  syncValue.schedule();
          }
          useragent.isWebKit || host.addEventListener('changeSelection', function () {
              if (host.selection.isEmpty() != isSelectionEmpty) {
                  isSelectionEmpty = !isSelectionEmpty;
                  syncSelection.schedule();
              }
          });
          resetValue();
          if (isFocused)
              host.onFocus();
          var isAllSelected = function (text) {
              return text.selectionStart === 0 && text.selectionEnd === text.value.length;
          };
          var onSelect = function (e) {
              if (copied) {
                  copied = false;
              }
              else if (isAllSelected(text)) {
                  host.selectAll();
                  resetSelection();
              }
              else if (inputHandler) {
                  resetSelection(host.selection.isEmpty());
              }
          };
          var inputHandler = null;
          this.setInputHandler = function (cb) { inputHandler = cb; };
          this.getInputHandler = function () { return inputHandler; };
          var afterContextMenu = false;
          var sendText = function (data) {
              if (inputHandler) {
                  data = inputHandler(data);
                  inputHandler = null;
              }
              if (pasted) {
                  resetSelection();
                  if (data)
                      host.onPaste(data);
                  pasted = false;
              }
              else if (data == PLACEHOLDER.charAt(0)) {
                  if (afterContextMenu)
                      host.execCommand("del", { source: "ace" });
                  else // some versions of android do not fire keydown when pressing backspace
                      host.execCommand("backspace", { source: "ace" });
              }
              else {
                  if (data.substring(0, 2) == PLACEHOLDER)
                      data = data.substr(2);
                  else if (data.charAt(0) == PLACEHOLDER.charAt(0))
                      data = data.substr(1);
                  else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                      data = data.slice(0, -1);
                  if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
                      data = data.slice(0, -1);
                  if (data)
                      host.onTextInput(data);
              }
              if (afterContextMenu)
                  afterContextMenu = false;
          };
          var onInput = function (e) {
              if (inComposition)
                  return;
              var data = text.value;
              sendText(data);
              resetValue();
          };
          var handleClipboardData = function (e, data, forceIEMime) {
              var clipboardData = e.clipboardData || window.clipboardData;
              if (!clipboardData || BROKEN_SETDATA)
                  return;
              var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
              try {
                  if (data) {
                      return clipboardData.setData(mime, data) !== false;
                  }
                  else {
                      return clipboardData.getData(mime);
                  }
              }
              catch (e) {
                  if (!forceIEMime)
                      return handleClipboardData(e, data, true);
              }
          };
          var doCopy = function (e, isCut) {
              var data = host.getCopyText();
              if (!data)
                  return event.preventDefault(e);
              if (handleClipboardData(e, data)) {
                  isCut ? host.onCut() : host.onCopy();
                  event.preventDefault(e);
              }
              else {
                  copied = true;
                  text.value = data;
                  text.select();
                  setTimeout(function () {
                      copied = false;
                      resetValue();
                      resetSelection();
                      isCut ? host.onCut() : host.onCopy();
                  });
              }
          };
          var onCut = function (e) {
              doCopy(e, true);
          };
          var onCopy = function (e) {
              doCopy(e, false);
          };
          var onPaste = function (e) {
              var data = handleClipboardData(e);
              if (typeof data == "string") {
                  if (data)
                      host.onPaste(data, e);
                  if (useragent.isIE)
                      setTimeout(resetSelection);
                  event.preventDefault(e);
              }
              else {
                  text.value = "";
                  pasted = true;
              }
          };
          event.addCommandKeyListener(text, host.onCommandKey.bind(host));
          event.addListener(text, "select", onSelect);
          event.addListener(text, "input", onInput);
          event.addListener(text, "cut", onCut);
          event.addListener(text, "copy", onCopy);
          event.addListener(text, "paste", onPaste);
          if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {
              event.addListener(parentNode, "keydown", function (e) {
                  if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)
                      return;
                  switch (e.keyCode) {
                      case 67:
                          onCopy(e);
                          break;
                      case 86:
                          onPaste(e);
                          break;
                      case 88:
                          onCut(e);
                          break;
                  }
              });
          }
          var onCompositionStart = function (e) {
              if (inComposition || !host.onCompositionStart || host.$readOnly)
                  return;
              inComposition = {};
              inComposition.canUndo = host.session.$undoManager;
              host.onCompositionStart();
              setTimeout(onCompositionUpdate, 0);
              host.on("mousedown", onCompositionEnd);
              if (inComposition.canUndo && !host.selection.isEmpty()) {
                  host.insert("");
                  host.session.markUndoGroup();
                  host.selection.clearSelection();
              }
              host.session.markUndoGroup();
          };
          var onCompositionUpdate = function () {
              if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
                  return;
              var val = text.value.replace(/\u2028/g, "");
              if (inComposition.lastValue === val)
                  return;
              host.onCompositionUpdate(val);
              if (inComposition.lastValue)
                  host.undo();
              if (inComposition.canUndo)
                  inComposition.lastValue = val;
              if (inComposition.lastValue) {
                  var r = host.selection.getRange();
                  host.insert(inComposition.lastValue);
                  host.session.markUndoGroup();
                  inComposition.range = host.selection.getRange();
                  host.selection.setRange(r);
                  host.selection.clearSelection();
              }
          };
          var onCompositionEnd = function (e) {
              if (!host.onCompositionEnd || host.$readOnly)
                  return;
              var c = inComposition;
              inComposition = false;
              var timer = setTimeout(function () {
                  timer = null;
                  var str = text.value.replace(/\u2028/g, "");
                  if (inComposition)
                      return;
                  else if (str == c.lastValue)
                      resetValue();
                  else if (!c.lastValue && str) {
                      resetValue();
                      sendText(str);
                  }
              });
              inputHandler = function compositionInputHandler(str) {
                  if (timer)
                      clearTimeout(timer);
                  str = str.replace(/\u2028/g, "");
                  if (str == c.lastValue)
                      return "";
                  if (c.lastValue && timer)
                      host.undo();
                  return str;
              };
              host.onCompositionEnd();
              host.removeListener("mousedown", onCompositionEnd);
              if (e.type == "compositionend" && c.range) {
                  host.selection.setRange(c.range);
              }
              var needsOnInput = (!!useragent.isChrome && useragent.isChrome >= 53) ||
                  (!!useragent.isWebKit && useragent.isWebKit >= 603);
              if (needsOnInput) {
                  onInput();
              }
          };
          var syncComposition = lang.delayedCall(onCompositionUpdate, 50);
          event.addListener(text, "compositionstart", onCompositionStart);
          if (useragent.isGecko) {
              event.addListener(text, "text", function () { syncComposition.schedule(); });
          }
          else {
              event.addListener(text, "keyup", function () { syncComposition.schedule(); });
              event.addListener(text, "keydown", function () { syncComposition.schedule(); });
          }
          event.addListener(text, "compositionend", onCompositionEnd);
          this.getElement = function () {
              return text;
          };
          this.setReadOnly = function (readOnly) {
              text.readOnly = readOnly;
          };
          this.onContextMenu = function (e) {
              afterContextMenu = true;
              resetSelection(host.selection.isEmpty());
              host._emit("nativecontextmenu", { target: host, domEvent: e });
              this.moveToMouse(e, true);
          };
          this.moveToMouse = function (e, bringToFront) {
              if (!tempStyle)
                  tempStyle = text.style.cssText;
              text.style.cssText = (bringToFront ? "z-index:100000;" : "")
                  + "height:" + text.style.height + ";"
                  + (useragent.isIE ? "opacity:0.1;" : "");
              var rect = host.container.getBoundingClientRect();
              var style = dom.computedStyle(host.container);
              var top = rect.top + (parseInt(style.borderTopWidth) || 0);
              var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
              var maxTop = rect.bottom - top - text.clientHeight - 2;
              var move = function (e) {
                  text.style.left = e.clientX - left - 2 + "px";
                  text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
              };
              move(e);
              if (e.type != "mousedown")
                  return;
              if (host.renderer.$keepTextAreaAtCursor)
                  host.renderer.$keepTextAreaAtCursor = null;
              clearTimeout(closeTimeout);
              if (useragent.isWin)
                  event.capture(host.container, move, onContextMenuClose);
          };
          this.onContextMenuClose = onContextMenuClose;
          var closeTimeout;
          function onContextMenuClose() {
              clearTimeout(closeTimeout);
              closeTimeout = setTimeout(function () {
                  if (tempStyle) {
                      text.style.cssText = tempStyle;
                      tempStyle = '';
                  }
                  if (host.renderer.$keepTextAreaAtCursor == null) {
                      host.renderer.$keepTextAreaAtCursor = true;
                      host.renderer.$moveTextAreaToCursor();
                  }
              }, 0);
          }
          var onContextMenu = function (e) {
              host.textInput.onContextMenu(e);
              onContextMenuClose();
          };
          event.addListener(text, "mouseup", onContextMenu);
          event.addListener(text, "mousedown", function (e) {
              e.preventDefault();
              onContextMenuClose();
          });
          event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
          event.addListener(text, "contextmenu", onContextMenu);
      };
      exports.TextInput = TextInput;
  });
  ace.define("ace/mouse/default_handlers", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function (acequire, exports, module) {
      var dom = acequire("../lib/dom");
      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      var DRAG_OFFSET = 0; // pixels
      var SCROLL_COOLDOWN_T = 250; // milliseconds
      function DefaultHandlers(mouseHandler) {
          mouseHandler.$clickSelection = null;
          var editor = mouseHandler.editor;
          editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
          editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
          editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
          editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
          editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
          editor.setDefaultHandler("touchmove", this.onTouchMove.bind(mouseHandler));
          var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd",
              "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];
          exports.forEach(function (x) {
              mouseHandler[x] = this[x];
          }, this);
          mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
          mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
      }
      (function () {
          this.onMouseDown = function (ev) {
              var inSelection = ev.inSelection();
              var pos = ev.getDocumentPosition();
              this.mousedownEvent = ev;
              var editor = this.editor;
              var button = ev.getButton();
              if (button !== 0) {
                  var selectionRange = editor.getSelectionRange();
                  var selectionEmpty = selectionRange.isEmpty();
                  editor.$blockScrolling++;
                  if (selectionEmpty || button == 1)
                      editor.selection.moveToPosition(pos);
                  editor.$blockScrolling--;
                  if (button == 2) {
                      editor.textInput.onContextMenu(ev.domEvent);
                      if (!useragent.isMozilla)
                          ev.preventDefault();
                  }
                  return;
              }
              this.mousedownEvent.time = Date.now();
              if (inSelection && !editor.isFocused()) {
                  editor.focus();
                  if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {
                      this.setState("focusWait");
                      this.captureMouse(ev);
                      return;
                  }
              }
              this.captureMouse(ev);
              this.startSelect(pos, ev.domEvent._clicks > 1);
              return ev.preventDefault();
          };
          this.startSelect = function (pos, waitForClickSelection) {
              pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
              var editor = this.editor;
              editor.$blockScrolling++;
              if (this.mousedownEvent.getShiftKey())
                  editor.selection.selectToPosition(pos);
              else if (!waitForClickSelection)
                  editor.selection.moveToPosition(pos);
              if (!waitForClickSelection)
                  this.select();
              if (editor.renderer.scroller.setCapture) {
                  editor.renderer.scroller.setCapture();
              }
              editor.setStyle("ace_selecting");
              this.setState("select");
              editor.$blockScrolling--;
          };
          this.select = function () {
              var anchor, editor = this.editor;
              var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
              editor.$blockScrolling++;
              if (this.$clickSelection) {
                  var cmp = this.$clickSelection.comparePoint(cursor);
                  if (cmp == -1) {
                      anchor = this.$clickSelection.end;
                  }
                  else if (cmp == 1) {
                      anchor = this.$clickSelection.start;
                  }
                  else {
                      var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                      cursor = orientedRange.cursor;
                      anchor = orientedRange.anchor;
                  }
                  editor.selection.setSelectionAnchor(anchor.row, anchor.column);
              }
              editor.selection.selectToPosition(cursor);
              editor.$blockScrolling--;
              editor.renderer.scrollCursorIntoView();
          };
          this.extendSelectionBy = function (unitName) {
              var anchor, editor = this.editor;
              var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
              var range = editor.selection[unitName](cursor.row, cursor.column);
              editor.$blockScrolling++;
              if (this.$clickSelection) {
                  var cmpStart = this.$clickSelection.comparePoint(range.start);
                  var cmpEnd = this.$clickSelection.comparePoint(range.end);
                  if (cmpStart == -1 && cmpEnd <= 0) {
                      anchor = this.$clickSelection.end;
                      if (range.end.row != cursor.row || range.end.column != cursor.column)
                          cursor = range.start;
                  }
                  else if (cmpEnd == 1 && cmpStart >= 0) {
                      anchor = this.$clickSelection.start;
                      if (range.start.row != cursor.row || range.start.column != cursor.column)
                          cursor = range.end;
                  }
                  else if (cmpStart == -1 && cmpEnd == 1) {
                      cursor = range.end;
                      anchor = range.start;
                  }
                  else {
                      var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                      cursor = orientedRange.cursor;
                      anchor = orientedRange.anchor;
                  }
                  editor.selection.setSelectionAnchor(anchor.row, anchor.column);
              }
              editor.selection.selectToPosition(cursor);
              editor.$blockScrolling--;
              editor.renderer.scrollCursorIntoView();
          };
          this.selectEnd =
              this.selectAllEnd =
                  this.selectByWordsEnd =
                      this.selectByLinesEnd = function () {
                          this.$clickSelection = null;
                          this.editor.unsetStyle("ace_selecting");
                          if (this.editor.renderer.scroller.releaseCapture) {
                              this.editor.renderer.scroller.releaseCapture();
                          }
                      };
          this.focusWait = function () {
              var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
              var time = Date.now();
              if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout)
                  this.startSelect(this.mousedownEvent.getDocumentPosition());
          };
          this.onDoubleClick = function (ev) {
              var pos = ev.getDocumentPosition();
              var editor = this.editor;
              var session = editor.session;
              var range = session.getBracketRange(pos);
              if (range) {
                  if (range.isEmpty()) {
                      range.start.column--;
                      range.end.column++;
                  }
                  this.setState("select");
              }
              else {
                  range = editor.selection.getWordRange(pos.row, pos.column);
                  this.setState("selectByWords");
              }
              this.$clickSelection = range;
              this.select();
          };
          this.onTripleClick = function (ev) {
              var pos = ev.getDocumentPosition();
              var editor = this.editor;
              this.setState("selectByLines");
              var range = editor.getSelectionRange();
              if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
                  this.$clickSelection = editor.selection.getLineRange(range.start.row);
                  this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
              }
              else {
                  this.$clickSelection = editor.selection.getLineRange(pos.row);
              }
              this.select();
          };
          this.onQuadClick = function (ev) {
              var editor = this.editor;
              editor.selectAll();
              this.$clickSelection = editor.getSelectionRange();
              this.setState("selectAll");
          };
          this.onMouseWheel = function (ev) {
              if (ev.getAccelKey())
                  return;
              if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
                  ev.wheelX = ev.wheelY;
                  ev.wheelY = 0;
              }
              var editor = this.editor;
              if (!this.$lastScroll)
                  this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };
              var prevScroll = this.$lastScroll;
              var t = ev.domEvent.timeStamp;
              var dt = t - prevScroll.t;
              var vx = ev.wheelX / dt;
              var vy = ev.wheelY / dt;
              if (dt < SCROLL_COOLDOWN_T) {
                  vx = (vx + prevScroll.vx) / 2;
                  vy = (vy + prevScroll.vy) / 2;
              }
              var direction = Math.abs(vx / vy);
              var canScroll = false;
              if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))
                  canScroll = true;
              if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))
                  canScroll = true;
              if (canScroll) {
                  prevScroll.allowed = t;
              }
              else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {
                  var isSlower = Math.abs(vx) <= 1.1 * Math.abs(prevScroll.vx)
                      && Math.abs(vy) <= 1.1 * Math.abs(prevScroll.vy);
                  if (isSlower) {
                      canScroll = true;
                      prevScroll.allowed = t;
                  }
                  else {
                      prevScroll.allowed = 0;
                  }
              }
              prevScroll.t = t;
              prevScroll.vx = vx;
              prevScroll.vy = vy;
              if (canScroll) {
                  editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                  return ev.stop();
              }
          };
          this.onTouchMove = function (ev) {
              this.editor._emit("mousewheel", ev);
          };
      }).call(DefaultHandlers.prototype);
      exports.DefaultHandlers = DefaultHandlers;
      function calcDistance(ax, ay, bx, by) {
          return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
      }
      function calcRangeOrientation(range, cursor) {
          if (range.start.row == range.end.row)
              var cmp = 2 * cursor.column - range.start.column - range.end.column;
          else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
              var cmp = cursor.column - 4;
          else
              var cmp = 2 * cursor.row - range.start.row - range.end.row;
          if (cmp < 0)
              return { cursor: range.start, anchor: range.end };
          else
              return { cursor: range.end, anchor: range.start };
      }
  });
  ace.define("ace/tooltip", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom"], function (acequire, exports, module) {
      var oop = acequire("./lib/oop");
      var dom = acequire("./lib/dom");
      function Tooltip(parentNode) {
          this.isOpen = false;
          this.$element = null;
          this.$parentNode = parentNode;
      }
      (function () {
          this.$init = function () {
              this.$element = dom.createElement("div");
              this.$element.className = "ace_tooltip";
              this.$element.style.display = "none";
              this.$parentNode.appendChild(this.$element);
              return this.$element;
          };
          this.getElement = function () {
              return this.$element || this.$init();
          };
          this.setText = function (text) {
              dom.setInnerText(this.getElement(), text);
          };
          this.setHtml = function (html) {
              this.getElement().innerHTML = html;
          };
          this.setPosition = function (x, y) {
              this.getElement().style.left = x + "px";
              this.getElement().style.top = y + "px";
          };
          this.setClassName = function (className) {
              dom.addCssClass(this.getElement(), className);
          };
          this.show = function (text, x, y) {
              if (text != null)
                  this.setText(text);
              if (x != null && y != null)
                  this.setPosition(x, y);
              if (!this.isOpen) {
                  this.getElement().style.display = "block";
                  this.isOpen = true;
              }
          };
          this.hide = function () {
              if (this.isOpen) {
                  this.getElement().style.display = "none";
                  this.isOpen = false;
              }
          };
          this.getHeight = function () {
              return this.getElement().offsetHeight;
          };
          this.getWidth = function () {
              return this.getElement().offsetWidth;
          };
          this.destroy = function () {
              this.isOpen = false;
              if (this.$element && this.$element.parentNode) {
                  this.$element.parentNode.removeChild(this.$element);
              }
          };
      }).call(Tooltip.prototype);
      exports.Tooltip = Tooltip;
  });
  ace.define("ace/mouse/default_gutter_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event", "ace/tooltip"], function (acequire, exports, module) {
      var dom = acequire("../lib/dom");
      var oop = acequire("../lib/oop");
      var event = acequire("../lib/event");
      var Tooltip = acequire("../tooltip").Tooltip;
      function GutterHandler(mouseHandler) {
          var editor = mouseHandler.editor;
          var gutter = editor.renderer.$gutterLayer;
          var tooltip = new GutterTooltip(editor.container);
          mouseHandler.editor.setDefaultHandler("guttermousedown", function (e) {
              if (!editor.isFocused() || e.getButton() != 0)
                  return;
              var gutterRegion = gutter.getRegion(e);
              if (gutterRegion == "foldWidgets")
                  return;
              var row = e.getDocumentPosition().row;
              var selection = editor.session.selection;
              if (e.getShiftKey())
                  selection.selectTo(row, 0);
              else {
                  if (e.domEvent.detail == 2) {
                      editor.selectAll();
                      return e.preventDefault();
                  }
                  mouseHandler.$clickSelection = editor.selection.getLineRange(row);
              }
              mouseHandler.setState("selectByLines");
              mouseHandler.captureMouse(e);
              return e.preventDefault();
          });
          var tooltipTimeout, mouseEvent, tooltipAnnotation;
          function showTooltip() {
              var row = mouseEvent.getDocumentPosition().row;
              var annotation = gutter.$annotations[row];
              if (!annotation)
                  return hideTooltip();
              var maxRow = editor.session.getLength();
              if (row == maxRow) {
                  var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
                  var pos = mouseEvent.$pos;
                  if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
                      return hideTooltip();
              }
              if (tooltipAnnotation == annotation)
                  return;
              tooltipAnnotation = annotation.text.join("<br/>");
              tooltip.setHtml(tooltipAnnotation);
              tooltip.show();
              editor._signal("showGutterTooltip", tooltip);
              editor.on("mousewheel", hideTooltip);
              if (mouseHandler.$tooltipFollowsMouse) {
                  moveTooltip(mouseEvent);
              }
              else {
                  var gutterElement = mouseEvent.domEvent.target;
                  var rect = gutterElement.getBoundingClientRect();
                  var style = tooltip.getElement().style;
                  style.left = rect.right + "px";
                  style.top = rect.bottom + "px";
              }
          }
          function hideTooltip() {
              if (tooltipTimeout)
                  tooltipTimeout = clearTimeout(tooltipTimeout);
              if (tooltipAnnotation) {
                  tooltip.hide();
                  tooltipAnnotation = null;
                  editor._signal("hideGutterTooltip", tooltip);
                  editor.removeEventListener("mousewheel", hideTooltip);
              }
          }
          function moveTooltip(e) {
              tooltip.setPosition(e.x, e.y);
          }
          mouseHandler.editor.setDefaultHandler("guttermousemove", function (e) {
              var target = e.domEvent.target || e.domEvent.srcElement;
              if (dom.hasCssClass(target, "ace_fold-widget"))
                  return hideTooltip();
              if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)
                  moveTooltip(e);
              mouseEvent = e;
              if (tooltipTimeout)
                  return;
              tooltipTimeout = setTimeout(function () {
                  tooltipTimeout = null;
                  if (mouseEvent && !mouseHandler.isMousePressed)
                      showTooltip();
                  else
                      hideTooltip();
              }, 50);
          });
          event.addListener(editor.renderer.$gutter, "mouseout", function (e) {
              mouseEvent = null;
              if (!tooltipAnnotation || tooltipTimeout)
                  return;
              tooltipTimeout = setTimeout(function () {
                  tooltipTimeout = null;
                  hideTooltip();
              }, 50);
          });
          editor.on("changeSession", hideTooltip);
      }
      function GutterTooltip(parentNode) {
          Tooltip.call(this, parentNode);
      }
      oop.inherits(GutterTooltip, Tooltip);
      (function () {
          this.setPosition = function (x, y) {
              var windowWidth = window.innerWidth || document.documentElement.clientWidth;
              var windowHeight = window.innerHeight || document.documentElement.clientHeight;
              var width = this.getWidth();
              var height = this.getHeight();
              x += 15;
              y += 15;
              if (x + width > windowWidth) {
                  x -= (x + width) - windowWidth;
              }
              if (y + height > windowHeight) {
                  y -= 20 + height;
              }
              Tooltip.prototype.setPosition.call(this, x, y);
          };
      }).call(GutterTooltip.prototype);
      exports.GutterHandler = GutterHandler;
  });
  ace.define("ace/mouse/mouse_event", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function (acequire, exports, module) {
      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      var MouseEvent = exports.MouseEvent = function (domEvent, editor) {
          this.domEvent = domEvent;
          this.editor = editor;
          this.x = this.clientX = domEvent.clientX;
          this.y = this.clientY = domEvent.clientY;
          this.$pos = null;
          this.$inSelection = null;
          this.propagationStopped = false;
          this.defaultPrevented = false;
      };
      (function () {
          this.stopPropagation = function () {
              event.stopPropagation(this.domEvent);
              this.propagationStopped = true;
          };
          this.preventDefault = function () {
              event.preventDefault(this.domEvent);
              this.defaultPrevented = true;
          };
          this.stop = function () {
              this.stopPropagation();
              this.preventDefault();
          };
          this.getDocumentPosition = function () {
              if (this.$pos)
                  return this.$pos;
              this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
              return this.$pos;
          };
          this.inSelection = function () {
              if (this.$inSelection !== null)
                  return this.$inSelection;
              var editor = this.editor;
              var selectionRange = editor.getSelectionRange();
              if (selectionRange.isEmpty())
                  this.$inSelection = false;
              else {
                  var pos = this.getDocumentPosition();
                  this.$inSelection = selectionRange.contains(pos.row, pos.column);
              }
              return this.$inSelection;
          };
          this.getButton = function () {
              return event.getButton(this.domEvent);
          };
          this.getShiftKey = function () {
              return this.domEvent.shiftKey;
          };
          this.getAccelKey = useragent.isMac
              ? function () { return this.domEvent.metaKey; }
              : function () { return this.domEvent.ctrlKey; };
      }).call(MouseEvent.prototype);
  });
  ace.define("ace/mouse/dragdrop_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function (acequire, exports, module) {
      var dom = acequire("../lib/dom");
      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      var AUTOSCROLL_DELAY = 200;
      var SCROLL_CURSOR_DELAY = 200;
      var SCROLL_CURSOR_HYSTERESIS = 5;
      function DragdropHandler(mouseHandler) {
          var editor = mouseHandler.editor;
          var blankImage = dom.createElement("img");
          blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
          if (useragent.isOpera)
              blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";
          var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];
          exports.forEach(function (x) {
              mouseHandler[x] = this[x];
          }, this);
          editor.addEventListener("mousedown", this.onMouseDown.bind(mouseHandler));
          var mouseTarget = editor.container;
          var dragSelectionMarker, x, y;
          var timerId, range;
          var dragCursor, counter = 0;
          var dragOperation;
          var isInternal;
          var autoScrollStartTime;
          var cursorMovedTime;
          var cursorPointOnCaretMoved;
          this.onDragStart = function (e) {
              if (this.cancelDrag || !mouseTarget.draggable) {
                  var self = this;
                  setTimeout(function () {
                      self.startSelect();
                      self.captureMouse(e);
                  }, 0);
                  return e.preventDefault();
              }
              range = editor.getSelectionRange();
              var dataTransfer = e.dataTransfer;
              dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
              if (useragent.isOpera) {
                  editor.container.appendChild(blankImage);
                  blankImage.scrollTop = 0;
              }
              dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
              if (useragent.isOpera) {
                  editor.container.removeChild(blankImage);
              }
              dataTransfer.clearData();
              dataTransfer.setData("Text", editor.session.getTextRange());
              isInternal = true;
              this.setState("drag");
          };
          this.onDragEnd = function (e) {
              mouseTarget.draggable = false;
              isInternal = false;
              this.setState(null);
              if (!editor.getReadOnly()) {
                  var dropEffect = e.dataTransfer.dropEffect;
                  if (!dragOperation && dropEffect == "move")
                      editor.session.remove(editor.getSelectionRange());
                  editor.renderer.$cursorLayer.setBlinking(true);
              }
              this.editor.unsetStyle("ace_dragging");
              this.editor.renderer.setCursorStyle("");
          };
          this.onDragEnter = function (e) {
              if (editor.getReadOnly() || !canAccept(e.dataTransfer))
                  return;
              x = e.clientX;
              y = e.clientY;
              if (!dragSelectionMarker)
                  addDragMarker();
              counter++;
              e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
              return event.preventDefault(e);
          };
          this.onDragOver = function (e) {
              if (editor.getReadOnly() || !canAccept(e.dataTransfer))
                  return;
              x = e.clientX;
              y = e.clientY;
              if (!dragSelectionMarker) {
                  addDragMarker();
                  counter++;
              }
              if (onMouseMoveTimer !== null)
                  onMouseMoveTimer = null;
              e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
              return event.preventDefault(e);
          };
          this.onDragLeave = function (e) {
              counter--;
              if (counter <= 0 && dragSelectionMarker) {
                  clearDragMarker();
                  dragOperation = null;
                  return event.preventDefault(e);
              }
          };
          this.onDrop = function (e) {
              if (!dragCursor)
                  return;
              var dataTransfer = e.dataTransfer;
              if (isInternal) {
                  switch (dragOperation) {
                      case "move":
                          if (range.contains(dragCursor.row, dragCursor.column)) {
                              range = {
                                  start: dragCursor,
                                  end: dragCursor
                              };
                          }
                          else {
                              range = editor.moveText(range, dragCursor);
                          }
                          break;
                      case "copy":
                          range = editor.moveText(range, dragCursor, true);
                          break;
                  }
              }
              else {
                  var dropData = dataTransfer.getData('Text');
                  range = {
                      start: dragCursor,
                      end: editor.session.insert(dragCursor, dropData)
                  };
                  editor.focus();
                  dragOperation = null;
              }
              clearDragMarker();
              return event.preventDefault(e);
          };
          event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler));
          event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler));
          event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler));
          event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler));
          event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler));
          event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler));
          function scrollCursorIntoView(cursor, prevCursor) {
              var now = Date.now();
              var vMovement = !prevCursor || cursor.row != prevCursor.row;
              var hMovement = !prevCursor || cursor.column != prevCursor.column;
              if (!cursorMovedTime || vMovement || hMovement) {
                  editor.$blockScrolling += 1;
                  editor.moveCursorToPosition(cursor);
                  editor.$blockScrolling -= 1;
                  cursorMovedTime = now;
                  cursorPointOnCaretMoved = { x: x, y: y };
              }
              else {
                  var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
                  if (distance > SCROLL_CURSOR_HYSTERESIS) {
                      cursorMovedTime = null;
                  }
                  else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
                      editor.renderer.scrollCursorIntoView();
                      cursorMovedTime = null;
                  }
              }
          }
          function autoScroll(cursor, prevCursor) {
              var now = Date.now();
              var lineHeight = editor.renderer.layerConfig.lineHeight;
              var characterWidth = editor.renderer.layerConfig.characterWidth;
              var editorRect = editor.renderer.scroller.getBoundingClientRect();
              var offsets = {
                  x: {
                      left: x - editorRect.left,
                      right: editorRect.right - x
                  },
                  y: {
                      top: y - editorRect.top,
                      bottom: editorRect.bottom - y
                  }
              };
              var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
              var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
              var scrollCursor = { row: cursor.row, column: cursor.column };
              if (nearestXOffset / characterWidth <= 2) {
                  scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);
              }
              if (nearestYOffset / lineHeight <= 1) {
                  scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);
              }
              var vScroll = cursor.row != scrollCursor.row;
              var hScroll = cursor.column != scrollCursor.column;
              var vMovement = !prevCursor || cursor.row != prevCursor.row;
              if (vScroll || (hScroll && !vMovement)) {
                  if (!autoScrollStartTime)
                      autoScrollStartTime = now;
                  else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
                      editor.renderer.scrollCursorIntoView(scrollCursor);
              }
              else {
                  autoScrollStartTime = null;
              }
          }
          function onDragInterval() {
              var prevCursor = dragCursor;
              dragCursor = editor.renderer.screenToTextCoordinates(x, y);
              scrollCursorIntoView(dragCursor, prevCursor);
              autoScroll(dragCursor, prevCursor);
          }
          function addDragMarker() {
              range = editor.selection.toOrientedRange();
              dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
              editor.clearSelection();
              if (editor.isFocused())
                  editor.renderer.$cursorLayer.setBlinking(false);
              clearInterval(timerId);
              onDragInterval();
              timerId = setInterval(onDragInterval, 20);
              counter = 0;
              event.addListener(document, "mousemove", onMouseMove);
          }
          function clearDragMarker() {
              clearInterval(timerId);
              editor.session.removeMarker(dragSelectionMarker);
              dragSelectionMarker = null;
              editor.$blockScrolling += 1;
              editor.selection.fromOrientedRange(range);
              editor.$blockScrolling -= 1;
              if (editor.isFocused() && !isInternal)
                  editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
              range = null;
              dragCursor = null;
              counter = 0;
              autoScrollStartTime = null;
              cursorMovedTime = null;
              event.removeListener(document, "mousemove", onMouseMove);
          }
          var onMouseMoveTimer = null;
          function onMouseMove() {
              if (onMouseMoveTimer == null) {
                  onMouseMoveTimer = setTimeout(function () {
                      if (onMouseMoveTimer != null && dragSelectionMarker)
                          clearDragMarker();
                  }, 20);
              }
          }
          function canAccept(dataTransfer) {
              var types = dataTransfer.types;
              return !types || Array.prototype.some.call(types, function (type) {
                  return type == 'text/plain' || type == 'Text';
              });
          }
          function getDropEffect(e) {
              var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
              var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];
              var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
              var effectAllowed = "uninitialized";
              try {
                  effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
              }
              catch (e) { }
              var dropEffect = "none";
              if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
                  dropEffect = "copy";
              else if (moveAllowed.indexOf(effectAllowed) >= 0)
                  dropEffect = "move";
              else if (copyAllowed.indexOf(effectAllowed) >= 0)
                  dropEffect = "copy";
              return dropEffect;
          }
      }
      (function () {
          this.dragWait = function () {
              var interval = Date.now() - this.mousedownEvent.time;
              if (interval > this.editor.getDragDelay())
                  this.startDrag();
          };
          this.dragWaitEnd = function () {
              var target = this.editor.container;
              target.draggable = false;
              this.startSelect(this.mousedownEvent.getDocumentPosition());
              this.selectEnd();
          };
          this.dragReadyEnd = function (e) {
              this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
              this.editor.unsetStyle("ace_dragging");
              this.editor.renderer.setCursorStyle("");
              this.dragWaitEnd();
          };
          this.startDrag = function () {
              this.cancelDrag = false;
              var editor = this.editor;
              var target = editor.container;
              target.draggable = true;
              editor.renderer.$cursorLayer.setBlinking(false);
              editor.setStyle("ace_dragging");
              var cursorStyle = useragent.isWin ? "default" : "move";
              editor.renderer.setCursorStyle(cursorStyle);
              this.setState("dragReady");
          };
          this.onMouseDrag = function (e) {
              var target = this.editor.container;
              if (useragent.isIE && this.state == "dragReady") {
                  var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                  if (distance > 3)
                      target.dragDrop();
              }
              if (this.state === "dragWait") {
                  var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                  if (distance > 0) {
                      target.draggable = false;
                      this.startSelect(this.mousedownEvent.getDocumentPosition());
                  }
              }
          };
          this.onMouseDown = function (e) {
              if (!this.$dragEnabled)
                  return;
              this.mousedownEvent = e;
              var editor = this.editor;
              var inSelection = e.inSelection();
              var button = e.getButton();
              var clickCount = e.domEvent.detail || 1;
              if (clickCount === 1 && button === 0 && inSelection) {
                  if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
                      return;
                  this.mousedownEvent.time = Date.now();
                  var eventTarget = e.domEvent.target || e.domEvent.srcElement;
                  if ("unselectable" in eventTarget)
                      eventTarget.unselectable = "on";
                  if (editor.getDragDelay()) {
                      if (useragent.isWebKit) {
                          this.cancelDrag = true;
                          var mouseTarget = editor.container;
                          mouseTarget.draggable = true;
                      }
                      this.setState("dragWait");
                  }
                  else {
                      this.startDrag();
                  }
                  this.captureMouse(e, this.onMouseDrag.bind(this));
                  e.defaultPrevented = true;
              }
          };
      }).call(DragdropHandler.prototype);
      function calcDistance(ax, ay, bx, by) {
          return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
      }
      exports.DragdropHandler = DragdropHandler;
  });
  ace.define("ace/lib/net", ["require", "exports", "module", "ace/lib/dom"], function (acequire, exports, module) {
      var dom = acequire("./dom");
      exports.get = function (url, callback) {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', url, true);
          xhr.onreadystatechange = function () {
              if (xhr.readyState === 4) {
                  callback(xhr.responseText);
              }
          };
          xhr.send(null);
      };
      exports.loadScript = function (path, callback) {
          var head = dom.getDocumentHead();
          var s = document.createElement('script');
          s.src = path;
          head.appendChild(s);
          s.onload = s.onreadystatechange = function (_, isAbort) {
              if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
                  s = s.onload = s.onreadystatechange = null;
                  if (!isAbort)
                      callback();
              }
          };
      };
      exports.qualifyURL = function (url) {
          var a = document.createElement('a');
          a.href = url;
          return a.href;
      };
  });
  ace.define("ace/lib/event_emitter", ["require", "exports", "module"], function (acequire, exports, module) {
      var EventEmitter = {};
      var stopPropagation = function () { this.propagationStopped = true; };
      var preventDefault = function () { this.defaultPrevented = true; };
      EventEmitter._emit =
          EventEmitter._dispatchEvent = function (eventName, e) {
              this._eventRegistry || (this._eventRegistry = {});
              this._defaultHandlers || (this._defaultHandlers = {});
              var listeners = this._eventRegistry[eventName] || [];
              var defaultHandler = this._defaultHandlers[eventName];
              if (!listeners.length && !defaultHandler)
                  return;
              if (typeof e != "object" || !e)
                  e = {};
              if (!e.type)
                  e.type = eventName;
              if (!e.stopPropagation)
                  e.stopPropagation = stopPropagation;
              if (!e.preventDefault)
                  e.preventDefault = preventDefault;
              listeners = listeners.slice();
              for (var i = 0; i < listeners.length; i++) {
                  listeners[i](e, this);
                  if (e.propagationStopped)
                      break;
              }
              if (defaultHandler && !e.defaultPrevented)
                  return defaultHandler(e, this);
          };
      EventEmitter._signal = function (eventName, e) {
          var listeners = (this._eventRegistry || {})[eventName];
          if (!listeners)
              return;
          listeners = listeners.slice();
          for (var i = 0; i < listeners.length; i++)
              listeners[i](e, this);
      };
      EventEmitter.once = function (eventName, callback) {
          var _self = this;
          callback && this.addEventListener(eventName, function newCallback() {
              _self.removeEventListener(eventName, newCallback);
              callback.apply(null, arguments);
          });
      };
      EventEmitter.setDefaultHandler = function (eventName, callback) {
          var handlers = this._defaultHandlers;
          if (!handlers)
              handlers = this._defaultHandlers = { _disabled_: {} };
          if (handlers[eventName]) {
              var old = handlers[eventName];
              var disabled = handlers._disabled_[eventName];
              if (!disabled)
                  handlers._disabled_[eventName] = disabled = [];
              disabled.push(old);
              var i = disabled.indexOf(callback);
              if (i != -1)
                  disabled.splice(i, 1);
          }
          handlers[eventName] = callback;
      };
      EventEmitter.removeDefaultHandler = function (eventName, callback) {
          var handlers = this._defaultHandlers;
          if (!handlers)
              return;
          var disabled = handlers._disabled_[eventName];
          if (handlers[eventName] == callback) {
              var old = handlers[eventName];
              if (disabled)
                  this.setDefaultHandler(eventName, disabled.pop());
          }
          else if (disabled) {
              var i = disabled.indexOf(callback);
              if (i != -1)
                  disabled.splice(i, 1);
          }
      };
      EventEmitter.on =
          EventEmitter.addEventListener = function (eventName, callback, capturing) {
              this._eventRegistry = this._eventRegistry || {};
              var listeners = this._eventRegistry[eventName];
              if (!listeners)
                  listeners = this._eventRegistry[eventName] = [];
              if (listeners.indexOf(callback) == -1)
                  listeners[capturing ? "unshift" : "push"](callback);
              return callback;
          };
      EventEmitter.off =
          EventEmitter.removeListener =
              EventEmitter.removeEventListener = function (eventName, callback) {
                  this._eventRegistry = this._eventRegistry || {};
                  var listeners = this._eventRegistry[eventName];
                  if (!listeners)
                      return;
                  var index = listeners.indexOf(callback);
                  if (index !== -1)
                      listeners.splice(index, 1);
              };
      EventEmitter.removeAllListeners = function (eventName) {
          if (this._eventRegistry)
              this._eventRegistry[eventName] = [];
      };
      exports.EventEmitter = EventEmitter;
  });
  ace.define("ace/lib/app_config", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function (acequire, exports, module) {
      "no use strict";
      var oop = acequire("./oop");
      var EventEmitter = acequire("./event_emitter").EventEmitter;
      var optionsProvider = {
          setOptions: function (optList) {
              Object.keys(optList).forEach(function (key) {
                  this.setOption(key, optList[key]);
              }, this);
          },
          getOptions: function (optionNames) {
              var result = {};
              if (!optionNames) {
                  optionNames = Object.keys(this.$options);
              }
              else if (!Array.isArray(optionNames)) {
                  result = optionNames;
                  optionNames = Object.keys(result);
              }
              optionNames.forEach(function (key) {
                  result[key] = this.getOption(key);
              }, this);
              return result;
          },
          setOption: function (name, value) {
              if (this["$" + name] === value)
                  return;
              var opt = this.$options[name];
              if (!opt) {
                  return warn('misspelled option "' + name + '"');
              }
              if (opt.forwardTo)
                  return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
              if (!opt.handlesSet)
                  this["$" + name] = value;
              if (opt && opt.set)
                  opt.set.call(this, value);
          },
          getOption: function (name) {
              var opt = this.$options[name];
              if (!opt) {
                  return warn('misspelled option "' + name + '"');
              }
              if (opt.forwardTo)
                  return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
              return opt && opt.get ? opt.get.call(this) : this["$" + name];
          }
      };
      function warn(message) {
          if (typeof console != "undefined" && console.warn)
              console.warn.apply(console, arguments);
      }
      function reportError(msg, data) {
          var e = new Error(msg);
          e.data = data;
          if (typeof console == "object" && console.error)
              console.error(e);
          setTimeout(function () { throw e; });
      }
      var AppConfig = function () {
          this.$defaultOptions = {};
      };
      (function () {
          oop.implement(this, EventEmitter);
          this.defineOptions = function (obj, path, options) {
              if (!obj.$options)
                  this.$defaultOptions[path] = obj.$options = {};
              Object.keys(options).forEach(function (key) {
                  var opt = options[key];
                  if (typeof opt == "string")
                      opt = { forwardTo: opt };
                  opt.name || (opt.name = key);
                  obj.$options[opt.name] = opt;
                  if ("initialValue" in opt)
                      obj["$" + opt.name] = opt.initialValue;
              });
              oop.implement(obj, optionsProvider);
              return this;
          };
          this.resetOptions = function (obj) {
              Object.keys(obj.$options).forEach(function (key) {
                  var opt = obj.$options[key];
                  if ("value" in opt)
                      obj.setOption(key, opt.value);
              });
          };
          this.setDefaultValue = function (path, name, value) {
              var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
              if (opts[name]) {
                  if (opts.forwardTo)
                      this.setDefaultValue(opts.forwardTo, name, value);
                  else
                      opts[name].value = value;
              }
          };
          this.setDefaultValues = function (path, optionHash) {
              Object.keys(optionHash).forEach(function (key) {
                  this.setDefaultValue(path, key, optionHash[key]);
              }, this);
          };
          this.warn = warn;
          this.reportError = reportError;
      }).call(AppConfig.prototype);
      exports.AppConfig = AppConfig;
  });
  ace.define("ace/config", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/lib/net", "ace/lib/app_config"], function (acequire, exports, module) {
      "no use strict";
      var lang = acequire("./lib/lang");
      var oop = acequire("./lib/oop");
      var net = acequire("./lib/net");
      var AppConfig = acequire("./lib/app_config").AppConfig;
      module.exports = exports = new AppConfig();
      var global = (function () {
          return this || typeof window != "undefined" && window;
      })();
      var options = {
          packaged: false,
          workerPath: null,
          modePath: null,
          themePath: null,
          basePath: "",
          suffix: ".js",
          $moduleUrls: {}
      };
      exports.get = function (key) {
          if (!options.hasOwnProperty(key))
              throw new Error("Unknown config key: " + key);
          return options[key];
      };
      exports.set = function (key, value) {
          if (!options.hasOwnProperty(key))
              throw new Error("Unknown config key: " + key);
          options[key] = value;
      };
      exports.all = function () {
          return lang.copyObject(options);
      };
      exports.moduleUrl = function (name, component) {
          if (options.$moduleUrls[name])
              return options.$moduleUrls[name];
          var parts = name.split("/");
          component = component || parts[parts.length - 2] || "";
          var sep = component == "snippets" ? "/" : "-";
          var base = parts[parts.length - 1];
          if (component == "worker" && sep == "-") {
              var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
              base = base.replace(re, "");
          }
          if ((!base || base == component) && parts.length > 1)
              base = parts[parts.length - 2];
          var path = options[component + "Path"];
          if (path == null) {
              path = options.basePath;
          }
          else if (sep == "/") {
              component = sep = "";
          }
          if (path && path.slice(-1) != "/")
              path += "/";
          return path + component + sep + base + this.get("suffix");
      };
      exports.setModuleUrl = function (name, subst) {
          return options.$moduleUrls[name] = subst;
      };
      exports.$loading = {};
      exports.loadModule = function (moduleName, onLoad) {
          var module, moduleType;
          if (Array.isArray(moduleName)) {
              moduleType = moduleName[0];
              moduleName = moduleName[1];
          }
          try {
              module = acequire(moduleName);
          }
          catch (e) { }
          if (module && !exports.$loading[moduleName])
              return onLoad && onLoad(module);
          if (!exports.$loading[moduleName])
              exports.$loading[moduleName] = [];
          exports.$loading[moduleName].push(onLoad);
          if (exports.$loading[moduleName].length > 1)
              return;
          var afterLoad = function () {
              acequire([moduleName], function (module) {
                  exports._emit("load.module", { name: moduleName, module: module });
                  var listeners = exports.$loading[moduleName];
                  exports.$loading[moduleName] = null;
                  listeners.forEach(function (onLoad) {
                      onLoad && onLoad(module);
                  });
              });
          };
          if (!exports.get("packaged"))
              return afterLoad();
          net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
      };
      init(true);
      function init(packaged) {
          if (!global || !global.document)
              return;
          options.packaged = packaged || acequire.packaged || module.packaged || (global.define && undefined.packaged);
          var scriptOptions = {};
          var scriptUrl = "";
          var currentScript = (document.currentScript || document._currentScript); // native or polyfill
          var currentDocument = currentScript && currentScript.ownerDocument || document;
          var scripts = currentDocument.getElementsByTagName("script");
          for (var i = 0; i < scripts.length; i++) {
              var script = scripts[i];
              var src = script.src || script.getAttribute("src");
              if (!src)
                  continue;
              var attributes = script.attributes;
              for (var j = 0, l = attributes.length; j < l; j++) {
                  var attr = attributes[j];
                  if (attr.name.indexOf("data-ace-") === 0) {
                      scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
                  }
              }
              var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
              if (m)
                  scriptUrl = m[1];
          }
          if (scriptUrl) {
              scriptOptions.base = scriptOptions.base || scriptUrl;
              scriptOptions.packaged = true;
          }
          scriptOptions.basePath = scriptOptions.base;
          scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
          scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
          scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
          delete scriptOptions.base;
          for (var key in scriptOptions)
              if (typeof scriptOptions[key] !== "undefined")
                  exports.set(key, scriptOptions[key]);
      }
      exports.init = init;
      function deHyphenate(str) {
          return str.replace(/-(.)/g, function (m, m1) { return m1.toUpperCase(); });
      }
  });
  ace.define("ace/mouse/mouse_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/mouse/default_handlers", "ace/mouse/default_gutter_handler", "ace/mouse/mouse_event", "ace/mouse/dragdrop_handler", "ace/config"], function (acequire, exports, module) {
      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      var DefaultHandlers = acequire("./default_handlers").DefaultHandlers;
      var DefaultGutterHandler = acequire("./default_gutter_handler").GutterHandler;
      var MouseEvent = acequire("./mouse_event").MouseEvent;
      var DragdropHandler = acequire("./dragdrop_handler").DragdropHandler;
      var config = acequire("../config");
      var MouseHandler = function (editor) {
          var _self = this;
          this.editor = editor;
          new DefaultHandlers(this);
          new DefaultGutterHandler(this);
          new DragdropHandler(this);
          var focusEditor = function (e) {
              var windowBlurred = !document.hasFocus || !document.hasFocus()
                  || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
              if (windowBlurred)
                  window.focus();
              editor.focus();
          };
          var mouseTarget = editor.renderer.getMouseEventTarget();
          event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
          event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
          event.addMultiMouseDownListener([
              mouseTarget,
              editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
              editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
              editor.textInput && editor.textInput.getElement()
          ].filter(Boolean), [400, 300, 250], this, "onMouseEvent");
          event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
          event.addTouchMoveListener(editor.container, this.onTouchMove.bind(this, "touchmove"));
          var gutterEl = editor.renderer.$gutter;
          event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
          event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
          event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
          event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));
          event.addListener(mouseTarget, "mousedown", focusEditor);
          event.addListener(gutterEl, "mousedown", focusEditor);
          if (useragent.isIE && editor.renderer.scrollBarV) {
              event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor);
              event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor);
          }
          editor.on("mousemove", function (e) {
              if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
                  return;
              var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
              var range = editor.session.selection.getRange();
              var renderer = editor.renderer;
              if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
                  renderer.setCursorStyle("default");
              }
              else {
                  renderer.setCursorStyle("");
              }
          });
      };
      (function () {
          this.onMouseEvent = function (name, e) {
              this.editor._emit(name, new MouseEvent(e, this.editor));
          };
          this.onMouseMove = function (name, e) {
              var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
              if (!listeners || !listeners.length)
                  return;
              this.editor._emit(name, new MouseEvent(e, this.editor));
          };
          this.onMouseWheel = function (name, e) {
              var mouseEvent = new MouseEvent(e, this.editor);
              mouseEvent.speed = this.$scrollSpeed * 2;
              mouseEvent.wheelX = e.wheelX;
              mouseEvent.wheelY = e.wheelY;
              this.editor._emit(name, mouseEvent);
          };
          this.onTouchMove = function (name, e) {
              var mouseEvent = new MouseEvent(e, this.editor);
              mouseEvent.speed = 1; //this.$scrollSpeed * 2;
              mouseEvent.wheelX = e.wheelX;
              mouseEvent.wheelY = e.wheelY;
              this.editor._emit(name, mouseEvent);
          };
          this.setState = function (state) {
              this.state = state;
          };
          this.captureMouse = function (ev, mouseMoveHandler) {
              this.x = ev.x;
              this.y = ev.y;
              this.isMousePressed = true;
              var renderer = this.editor.renderer;
              if (renderer.$keepTextAreaAtCursor)
                  renderer.$keepTextAreaAtCursor = null;
              var self = this;
              var onMouseMove = function (e) {
                  if (!e)
                      return;
                  if (useragent.isWebKit && !e.which && self.releaseMouse)
                      return self.releaseMouse();
                  self.x = e.clientX;
                  self.y = e.clientY;
                  mouseMoveHandler && mouseMoveHandler(e);
                  self.mouseEvent = new MouseEvent(e, self.editor);
                  self.$mouseMoved = true;
              };
              var onCaptureEnd = function (e) {
                  clearInterval(timerId);
                  onCaptureInterval();
                  self[self.state + "End"] && self[self.state + "End"](e);
                  self.state = "";
                  if (renderer.$keepTextAreaAtCursor == null) {
                      renderer.$keepTextAreaAtCursor = true;
                      renderer.$moveTextAreaToCursor();
                  }
                  self.isMousePressed = false;
                  self.$onCaptureMouseMove = self.releaseMouse = null;
                  e && self.onMouseEvent("mouseup", e);
              };
              var onCaptureInterval = function () {
                  self[self.state] && self[self.state]();
                  self.$mouseMoved = false;
              };
              if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
                  return setTimeout(function () { onCaptureEnd(ev); });
              }
              self.$onCaptureMouseMove = onMouseMove;
              self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
              var timerId = setInterval(onCaptureInterval, 20);
          };
          this.releaseMouse = null;
          this.cancelContextMenu = function () {
              var stop = function (e) {
                  if (e && e.domEvent && e.domEvent.type != "contextmenu")
                      return;
                  this.editor.off("nativecontextmenu", stop);
                  if (e && e.domEvent)
                      event.stopEvent(e.domEvent);
              }.bind(this);
              setTimeout(stop, 10);
              this.editor.on("nativecontextmenu", stop);
          };
      }).call(MouseHandler.prototype);
      config.defineOptions(MouseHandler.prototype, "mouseHandler", {
          scrollSpeed: { initialValue: 2 },
          dragDelay: { initialValue: (useragent.isMac ? 150 : 0) },
          dragEnabled: { initialValue: true },
          focusTimout: { initialValue: 0 },
          tooltipFollowsMouse: { initialValue: true }
      });
      exports.MouseHandler = MouseHandler;
  });
  ace.define("ace/mouse/fold_handler", ["require", "exports", "module"], function (acequire, exports, module) {
      function FoldHandler(editor) {
          editor.on("click", function (e) {
              var position = e.getDocumentPosition();
              var session = editor.session;
              var fold = session.getFoldAt(position.row, position.column, 1);
              if (fold) {
                  if (e.getAccelKey())
                      session.removeFold(fold);
                  else
                      session.expandFold(fold);
                  e.stop();
              }
          });
          editor.on("gutterclick", function (e) {
              var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
              if (gutterRegion == "foldWidgets") {
                  var row = e.getDocumentPosition().row;
                  var session = editor.session;
                  if (session.foldWidgets && session.foldWidgets[row])
                      editor.session.onFoldWidgetClick(row, e);
                  if (!editor.isFocused())
                      editor.focus();
                  e.stop();
              }
          });
          editor.on("gutterdblclick", function (e) {
              var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
              if (gutterRegion == "foldWidgets") {
                  var row = e.getDocumentPosition().row;
                  var session = editor.session;
                  var data = session.getParentFoldRangeData(row, true);
                  var range = data.range || data.firstRange;
                  if (range) {
                      row = range.start.row;
                      var fold = session.getFoldAt(row, session.getLine(row).length, 1);
                      if (fold) {
                          session.removeFold(fold);
                      }
                      else {
                          session.addFold("...", range);
                          editor.renderer.scrollCursorIntoView({ row: range.start.row, column: 0 });
                      }
                  }
                  e.stop();
              }
          });
      }
      exports.FoldHandler = FoldHandler;
  });
  ace.define("ace/keyboard/keybinding", ["require", "exports", "module", "ace/lib/keys", "ace/lib/event"], function (acequire, exports, module) {
      var keyUtil = acequire("../lib/keys");
      var event = acequire("../lib/event");
      var KeyBinding = function (editor) {
          this.$editor = editor;
          this.$data = { editor: editor };
          this.$handlers = [];
          this.setDefaultHandler(editor.commands);
      };
      (function () {
          this.setDefaultHandler = function (kb) {
              this.removeKeyboardHandler(this.$defaultHandler);
              this.$defaultHandler = kb;
              this.addKeyboardHandler(kb, 0);
          };
          this.setKeyboardHandler = function (kb) {
              var h = this.$handlers;
              if (h[h.length - 1] == kb)
                  return;
              while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
                  this.removeKeyboardHandler(h[h.length - 1]);
              this.addKeyboardHandler(kb, 1);
          };
          this.addKeyboardHandler = function (kb, pos) {
              if (!kb)
                  return;
              if (typeof kb == "function" && !kb.handleKeyboard)
                  kb.handleKeyboard = kb;
              var i = this.$handlers.indexOf(kb);
              if (i != -1)
                  this.$handlers.splice(i, 1);
              if (pos == undefined)
                  this.$handlers.push(kb);
              else
                  this.$handlers.splice(pos, 0, kb);
              if (i == -1 && kb.attach)
                  kb.attach(this.$editor);
          };
          this.removeKeyboardHandler = function (kb) {
              var i = this.$handlers.indexOf(kb);
              if (i == -1)
                  return false;
              this.$handlers.splice(i, 1);
              kb.detach && kb.detach(this.$editor);
              return true;
          };
          this.getKeyboardHandler = function () {
              return this.$handlers[this.$handlers.length - 1];
          };
          this.getStatusText = function () {
              var data = this.$data;
              var editor = data.editor;
              return this.$handlers.map(function (h) {
                  return h.getStatusText && h.getStatusText(editor, data) || "";
              }).filter(Boolean).join(" ");
          };
          this.$callKeyboardHandlers = function (hashId, keyString, keyCode, e) {
              var toExecute;
              var success = false;
              var commands = this.$editor.commands;
              for (var i = this.$handlers.length; i--;) {
                  toExecute = this.$handlers[i].handleKeyboard(this.$data, hashId, keyString, keyCode, e);
                  if (!toExecute || !toExecute.command)
                      continue;
                  if (toExecute.command == "null") {
                      success = true;
                  }
                  else {
                      success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
                  }
                  if (success && e && hashId != -1 &&
                      toExecute.passEvent != true && toExecute.command.passEvent != true) {
                      event.stopEvent(e);
                  }
                  if (success)
                      break;
              }
              if (!success && hashId == -1) {
                  toExecute = { command: "insertstring" };
                  success = commands.exec("insertstring", this.$editor, keyString);
              }
              if (success && this.$editor._signal)
                  this.$editor._signal("keyboardActivity", toExecute);
              return success;
          };
          this.onCommandKey = function (e, hashId, keyCode) {
              var keyString = keyUtil.keyCodeToString(keyCode);
              this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
          };
          this.onTextInput = function (text) {
              this.$callKeyboardHandlers(-1, text);
          };
      }).call(KeyBinding.prototype);
      exports.KeyBinding = KeyBinding;
  });
  ace.define("ace/lib/bidiutil", ["require", "exports", "module"], function (acequire, exports, module) {
      var dir = 0, hiLevel = 0;
      var lastArabic = false, hasUBAT_B = false, hasUBAT_S = false;
      var impTab_LTR = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 0x11, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 0x15, 0x15, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]
      ];
      var impTab_RTL = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 0x21, 3, 1, 1]
      ];
      var LTR = 0, RTL = 1;
      var L = 0;
      var R = 1;
      var EN = 2;
      var AN = 3;
      var ON = 4;
      var B = 5;
      var S = 6;
      var AL = 7;
      var WS = 8;
      var CS = 9;
      var ES = 10;
      var ET = 11;
      var NSM = 12;
      var LRE = 13;
      var RLE = 14;
      var PDF = 15;
      var LRO = 16;
      var RLO = 17;
      var BN = 18;
      var UnicodeTBL00 = [
          BN, BN, BN, BN, BN, BN, BN, BN, BN, S, B, S, WS, B, BN, BN,
          BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, B, B, B, S,
          WS, ON, ON, ET, ET, ET, ON, ON, ON, ON, ON, ES, CS, ES, CS, CS,
          EN, EN, EN, EN, EN, EN, EN, EN, EN, EN, CS, ON, ON, ON, ON, ON,
          ON, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L,
          L, L, L, L, L, L, L, L, L, L, L, ON, ON, ON, ON, ON,
          ON, L, L, L, L, L, L, L, L, L, L, L, L, L, L, L,
          L, L, L, L, L, L, L, L, L, L, L, ON, ON, ON, ON, BN,
          BN, BN, BN, BN, BN, B, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
          BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN, BN,
          CS, ON, ET, ET, ET, ET, ON, ON, ON, ON, L, ON, ON, BN, ON, ON,
          ET, ET, EN, EN, ON, L, ON, ON, ON, EN, L, ON, ON, ON, ON, ON
      ];
      var UnicodeTBL20 = [
          WS, WS, WS, WS, WS, WS, WS, WS, WS, WS, WS, BN, BN, BN, L, R,
          ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
          ON, ON, ON, ON, ON, ON, ON, ON, WS, B, LRE, RLE, PDF, LRO, RLO, CS,
          ET, ET, ET, ET, ET, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
          ON, ON, ON, ON, CS, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON,
          ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, ON, WS
      ];
      function _computeLevels(chars, levels, len, charTypes) {
          var impTab = dir ? impTab_RTL : impTab_LTR, prevState = null, newClass = null, newLevel = null, newState = 0, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];
          if (!charTypes) {
              for (i = 0, charTypes = []; i < len; i++) {
                  charTypes[i] = _getCharacterType(chars[i]);
              }
          }
          hiLevel = dir;
          lastArabic = false;
          hasUBAT_B = false;
          hasUBAT_S = false;
          for (ix = 0; ix < len; ix++) {
              prevState = newState;
              classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
              newState = impTab[prevState][newClass];
              action = newState & 0xF0;
              newState &= 0x0F;
              levels[ix] = newLevel = impTab[newState][5];
              if (action > 0) {
                  if (action == 0x10) {
                      for (i = condPos; i < ix; i++) {
                          levels[i] = 1;
                      }
                      condPos = -1;
                  }
                  else {
                      condPos = -1;
                  }
              }
              cond = impTab[newState][6];
              if (cond) {
                  if (condPos == -1) {
                      condPos = ix;
                  }
              }
              else {
                  if (condPos > -1) {
                      for (i = condPos; i < ix; i++) {
                          levels[i] = newLevel;
                      }
                      condPos = -1;
                  }
              }
              if (charTypes[ix] == B) {
                  levels[ix] = 0;
              }
              hiLevel |= newLevel;
          }
          if (hasUBAT_S) {
              for (i = 0; i < len; i++) {
                  if (charTypes[i] == S) {
                      levels[i] = dir;
                      for (var j = i - 1; j >= 0; j--) {
                          if (charTypes[j] == WS) {
                              levels[j] = dir;
                          }
                          else {
                              break;
                          }
                      }
                  }
              }
          }
      }
      function _invertLevel(lev, levels, _array) {
          if (hiLevel < lev) {
              return;
          }
          if (lev == 1 && dir == RTL && !hasUBAT_B) {
              _array.reverse();
              return;
          }
          var len = _array.length, start = 0, end, lo, hi, tmp;
          while (start < len) {
              if (levels[start] >= lev) {
                  end = start + 1;
                  while (end < len && levels[end] >= lev) {
                      end++;
                  }
                  for (lo = start, hi = end - 1; lo < hi; lo++, hi--) {
                      tmp = _array[lo];
                      _array[lo] = _array[hi];
                      _array[hi] = tmp;
                  }
                  start = end;
              }
              start++;
          }
      }
      function _getCharClass(chars, types, classes, ix) {
          var cType = types[ix], wType, nType, len, i;
          switch (cType) {
              case L:
              case R:
                  lastArabic = false;
              case ON:
              case AN:
                  return cType;
              case EN:
                  return lastArabic ? AN : EN;
              case AL:
                  lastArabic = true;
                  return R;
              case WS:
                  return ON;
              case CS:
                  if (ix < 1 || (ix + 1) >= types.length ||
                      ((wType = classes[ix - 1]) != EN && wType != AN) ||
                      ((nType = types[ix + 1]) != EN && nType != AN)) {
                      return ON;
                  }
                  if (lastArabic) {
                      nType = AN;
                  }
                  return nType == wType ? nType : ON;
              case ES:
                  wType = ix > 0 ? classes[ix - 1] : B;
                  if (wType == EN && (ix + 1) < types.length && types[ix + 1] == EN) {
                      return EN;
                  }
                  return ON;
              case ET:
                  if (ix > 0 && classes[ix - 1] == EN) {
                      return EN;
                  }
                  if (lastArabic) {
                      return ON;
                  }
                  i = ix + 1;
                  len = types.length;
                  while (i < len && types[i] == ET) {
                      i++;
                  }
                  if (i < len && types[i] == EN) {
                      return EN;
                  }
                  return ON;
              case NSM:
                  len = types.length;
                  i = ix + 1;
                  while (i < len && types[i] == NSM) {
                      i++;
                  }
                  if (i < len) {
                      var c = chars[ix], rtlCandidate = (c >= 0x0591 && c <= 0x08FF) || c == 0xFB1E;
                      wType = types[i];
                      if (rtlCandidate && (wType == R || wType == AL)) {
                          return R;
                      }
                  }
                  if (ix < 1 || (wType = types[ix - 1]) == B) {
                      return ON;
                  }
                  return classes[ix - 1];
              case B:
                  lastArabic = false;
                  hasUBAT_B = true;
                  return dir;
              case S:
                  hasUBAT_S = true;
                  return ON;
              case LRE:
              case RLE:
              case LRO:
              case RLO:
              case PDF:
                  lastArabic = false;
              case BN:
                  return ON;
          }
      }
      function _getCharacterType(ch) {
          var uc = ch.charCodeAt(0), hi = uc >> 8;
          if (hi == 0) {
              return ((uc > 0x00BF) ? L : UnicodeTBL00[uc]);
          }
          else if (hi == 5) {
              return (/[\u0591-\u05f4]/.test(ch) ? R : L);
          }
          else if (hi == 6) {
              if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch))
                  return NSM;
              else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch))
                  return AN;
              else if (uc == 0x066A)
                  return ET;
              else if (/[\u06f0-\u06f9]/.test(ch))
                  return EN;
              else
                  return AL;
          }
          else if (hi == 0x20 && uc <= 0x205F) {
              return UnicodeTBL20[uc & 0xFF];
          }
          else if (hi == 0xFE) {
              return (uc >= 0xFE70 ? AL : ON);
          }
          return ON;
      }
      exports.L = L;
      exports.R = R;
      exports.EN = EN;
      exports.ON_R = 3;
      exports.AN = 4;
      exports.R_H = 5;
      exports.B = 6;
      exports.DOT = "\xB7";
      exports.doBidiReorder = function (text, textCharTypes, isRtl) {
          if (text.length < 2)
              return {};
          var chars = text.split(""), logicalFromVisual = new Array(chars.length), bidiLevels = new Array(chars.length), levels = [];
          dir = isRtl ? RTL : LTR;
          _computeLevels(chars, levels, chars.length, textCharTypes);
          for (var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++)
              ;
          _invertLevel(2, levels, logicalFromVisual);
          _invertLevel(1, levels, logicalFromVisual);
          for (var i = 0; i < logicalFromVisual.length - 1; i++) { //fix levels to reflect character width
              if (textCharTypes[i] === AN) {
                  levels[i] = exports.AN;
              }
              else if (levels[i] === R && ((textCharTypes[i] > AL && textCharTypes[i] < LRE)
                  || textCharTypes[i] === ON || textCharTypes[i] === BN)) {
                  levels[i] = exports.ON_R;
              }
              else if ((i > 0 && chars[i - 1] === '\u0644') && /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
                  levels[i - 1] = levels[i] = exports.R_H;
                  i++;
              }
          }
          if (chars[chars.length - 1] === exports.DOT)
              levels[chars.length - 1] = exports.B;
          for (var i = 0; i < logicalFromVisual.length; i++) {
              bidiLevels[i] = levels[logicalFromVisual[i]];
          }
          return { 'logicalFromVisual': logicalFromVisual, 'bidiLevels': bidiLevels };
      };
      exports.hasBidiCharacters = function (text, textCharTypes) {
          var ret = false;
          for (var i = 0; i < text.length; i++) {
              textCharTypes[i] = _getCharacterType(text.charAt(i));
              if (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL))
                  ret = true;
          }
          return ret;
      };
      exports.getVisualFromLogicalIdx = function (logIdx, rowMap) {
          for (var i = 0; i < rowMap.logicalFromVisual.length; i++) {
              if (rowMap.logicalFromVisual[i] == logIdx)
                  return i;
          }
          return 0;
      };
  });
  ace.define("ace/bidihandler", ["require", "exports", "module", "ace/lib/bidiutil", "ace/lib/lang", "ace/lib/useragent"], function (acequire, exports, module) {
      var bidiUtil = acequire("./lib/bidiutil");
      var lang = acequire("./lib/lang");
      var useragent = acequire("./lib/useragent");
      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
      var BidiHandler = function (session) {
          this.session = session;
          this.bidiMap = {};
          this.currentRow = null;
          this.bidiUtil = bidiUtil;
          this.charWidths = [];
          this.EOL = "\xAC";
          this.showInvisibles = true;
          this.isRtlDir = false;
          this.line = "";
          this.wrapIndent = 0;
          this.isLastRow = false;
          this.EOF = "\xB6";
          this.seenBidi = false;
      };
      (function () {
          this.isBidiRow = function (screenRow, docRow, splitIndex) {
              if (!this.seenBidi)
                  return false;
              if (screenRow !== this.currentRow) {
                  this.currentRow = screenRow;
                  this.updateRowLine(docRow, splitIndex);
                  this.updateBidiMap();
              }
              return this.bidiMap.bidiLevels;
          };
          this.onChange = function (delta) {
              if (!this.seenBidi) {
                  if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
                      this.seenBidi = true;
                      this.currentRow = null;
                  }
              }
              else {
                  this.currentRow = null;
              }
          };
          this.getDocumentRow = function () {
              var docRow = 0;
              var rowCache = this.session.$screenRowCache;
              if (rowCache.length) {
                  var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
                  if (index >= 0)
                      docRow = this.session.$docRowCache[index];
              }
              return docRow;
          };
          this.getSplitIndex = function () {
              var splitIndex = 0;
              var rowCache = this.session.$screenRowCache;
              if (rowCache.length) {
                  var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
                  while (this.currentRow - splitIndex > 0) {
                      currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
                      if (currentIndex !== prevIndex)
                          break;
                      prevIndex = currentIndex;
                      splitIndex++;
                  }
              }
              return splitIndex;
          };
          this.updateRowLine = function (docRow, splitIndex) {
              if (docRow === undefined)
                  docRow = this.getDocumentRow();
              this.wrapIndent = 0;
              this.isLastRow = (docRow === this.session.getLength() - 1);
              this.line = this.session.getLine(docRow);
              if (this.session.$useWrapMode) {
                  var splits = this.session.$wrapData[docRow];
                  if (splits) {
                      if (splitIndex === undefined)
                          splitIndex = this.getSplitIndex();
                      if (splitIndex > 0 && splits.length) {
                          this.wrapIndent = splits.indent;
                          this.line = (splitIndex < splits.length) ?
                              this.line.substring(splits[splitIndex - 1], splits[splits.length - 1]) :
                              this.line.substring(splits[splits.length - 1]);
                      }
                      else {
                          this.line = this.line.substring(0, splits[splitIndex]);
                      }
                  }
              }
              var session = this.session, shift = 0, size;
              this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function (ch, i) {
                  if (ch === '\t' || session.isFullWidth(ch.charCodeAt(0))) {
                      size = (ch === '\t') ? session.getScreenTabSize(i + shift) : 2;
                      shift += size - 1;
                      return lang.stringRepeat(bidiUtil.DOT, size);
                  }
                  return ch;
              });
          };
          this.updateBidiMap = function () {
              var textCharTypes = [], endOfLine = this.isLastRow ? this.EOF : this.EOL;
              var line = this.line + (this.showInvisibles ? endOfLine : bidiUtil.DOT);
              if (bidiUtil.hasBidiCharacters(line, textCharTypes)) {
                  this.bidiMap = bidiUtil.doBidiReorder(line, textCharTypes, this.isRtlDir);
              }
              else {
                  this.bidiMap = {};
              }
          };
          this.markAsDirty = function () {
              this.currentRow = null;
          };
          this.updateCharacterWidths = function (fontMetrics) {
              if (!this.seenBidi)
                  return;
              if (this.characterWidth === fontMetrics.$characterSize.width)
                  return;
              var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
              var bidiCharWidth = fontMetrics.$measureCharWidth("\u05d4");
              this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
              this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
              this.charWidths[bidiUtil.R_H] = useragent.isChrome ? bidiCharWidth : bidiCharWidth * 0.45;
              this.charWidths[bidiUtil.B] = 0;
              this.currentRow = null;
          };
          this.getShowInvisibles = function () {
              return this.showInvisibles;
          };
          this.setShowInvisibles = function (showInvisibles) {
              this.showInvisibles = showInvisibles;
              this.currentRow = null;
          };
          this.setEolChar = function (eolChar) {
              this.EOL = eolChar;
          };
          this.setTextDir = function (isRtlDir) {
              this.isRtlDir = isRtlDir;
          };
          this.getPosLeft = function (col) {
              col -= this.wrapIndent;
              var visualIdx = bidiUtil.getVisualFromLogicalIdx(col > 0 ? col - 1 : 0, this.bidiMap), levels = this.bidiMap.bidiLevels, left = 0;
              if (col === 0 && levels[visualIdx] % 2 !== 0)
                  visualIdx++;
              for (var i = 0; i < visualIdx; i++) {
                  left += this.charWidths[levels[i]];
              }
              if (col !== 0 && levels[visualIdx] % 2 === 0)
                  left += this.charWidths[levels[visualIdx]];
              if (this.wrapIndent)
                  left += this.wrapIndent * this.charWidths[bidiUtil.L];
              return left;
          };
          this.getSelections = function (startCol, endCol) {
              var map = this.bidiMap, levels = map.bidiLevels, level, offset = this.wrapIndent * this.charWidths[bidiUtil.L], selections = [], selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent, isSelected = false, isSelectedPrev = false, selectionStart = 0;
              for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {
                  logIdx = map.logicalFromVisual[visIdx];
                  level = levels[visIdx];
                  isSelected = (logIdx >= selColMin) && (logIdx < selColMax);
                  if (isSelected && !isSelectedPrev) {
                      selectionStart = offset;
                  }
                  else if (!isSelected && isSelectedPrev) {
                      selections.push({ left: selectionStart, width: offset - selectionStart });
                  }
                  offset += this.charWidths[level];
                  isSelectedPrev = isSelected;
              }
              if (isSelected && (visIdx === levels.length)) {
                  selections.push({ left: selectionStart, width: offset - selectionStart });
              }
              return selections;
          };
          this.offsetToCol = function (posX) {
              var logicalIdx = 0, posX = Math.max(posX, 0), offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels, charWidth = this.charWidths[levels[visualIdx]];
              if (this.wrapIndent) {
                  posX -= this.wrapIndent * this.charWidths[bidiUtil.L];
              }
              while (posX > offset + charWidth / 2) {
                  offset += charWidth;
                  if (visualIdx === levels.length - 1) {
                      charWidth = 0;
                      break;
                  }
                  charWidth = this.charWidths[levels[++visualIdx]];
              }
              if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && (levels[visualIdx] % 2 === 0)) {
                  if (posX < offset)
                      visualIdx--;
                  logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
              }
              else if (visualIdx > 0 && (levels[visualIdx - 1] % 2 === 0) && (levels[visualIdx] % 2 !== 0)) {
                  logicalIdx = 1 + ((posX > offset) ? this.bidiMap.logicalFromVisual[visualIdx]
                      : this.bidiMap.logicalFromVisual[visualIdx - 1]);
              }
              else if ((this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && (levels[visualIdx - 1] % 2 === 0))
                  || (!this.isRtlDir && visualIdx === 0 && (levels[visualIdx] % 2 !== 0))) {
                  logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
              }
              else {
                  if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && charWidth !== 0)
                      visualIdx--;
                  logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
              }
              return (logicalIdx + this.wrapIndent);
          };
      }).call(BidiHandler.prototype);
      exports.BidiHandler = BidiHandler;
  });
  ace.define("ace/range", ["require", "exports", "module"], function (acequire, exports, module) {
      var comparePoints = function (p1, p2) {
          return p1.row - p2.row || p1.column - p2.column;
      };
      var Range = function (startRow, startColumn, endRow, endColumn) {
          this.start = {
              row: startRow,
              column: startColumn
          };
          this.end = {
              row: endRow,
              column: endColumn
          };
      };
      (function () {
          this.isEqual = function (range) {
              return this.start.row === range.start.row &&
                  this.end.row === range.end.row &&
                  this.start.column === range.start.column &&
                  this.end.column === range.end.column;
          };
          this.toString = function () {
              return ("Range: [" + this.start.row + "/" + this.start.column +
                  "] -> [" + this.end.row + "/" + this.end.column + "]");
          };
          this.contains = function (row, column) {
              return this.compare(row, column) == 0;
          };
          this.compareRange = function (range) {
              var cmp, end = range.end, start = range.start;
              cmp = this.compare(end.row, end.column);
              if (cmp == 1) {
                  cmp = this.compare(start.row, start.column);
                  if (cmp == 1) {
                      return 2;
                  }
                  else if (cmp == 0) {
                      return 1;
                  }
                  else {
                      return 0;
                  }
              }
              else if (cmp == -1) {
                  return -2;
              }
              else {
                  cmp = this.compare(start.row, start.column);
                  if (cmp == -1) {
                      return -1;
                  }
                  else if (cmp == 1) {
                      return 42;
                  }
                  else {
                      return 0;
                  }
              }
          };
          this.comparePoint = function (p) {
              return this.compare(p.row, p.column);
          };
          this.containsRange = function (range) {
              return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
          };
          this.intersects = function (range) {
              var cmp = this.compareRange(range);
              return (cmp == -1 || cmp == 0 || cmp == 1);
          };
          this.isEnd = function (row, column) {
              return this.end.row == row && this.end.column == column;
          };
          this.isStart = function (row, column) {
              return this.start.row == row && this.start.column == column;
          };
          this.setStart = function (row, column) {
              if (typeof row == "object") {
                  this.start.column = row.column;
                  this.start.row = row.row;
              }
              else {
                  this.start.row = row;
                  this.start.column = column;
              }
          };
          this.setEnd = function (row, column) {
              if (typeof row == "object") {
                  this.end.column = row.column;
                  this.end.row = row.row;
              }
              else {
                  this.end.row = row;
                  this.end.column = column;
              }
          };
          this.inside = function (row, column) {
              if (this.compare(row, column) == 0) {
                  if (this.isEnd(row, column) || this.isStart(row, column)) {
                      return false;
                  }
                  else {
                      return true;
                  }
              }
              return false;
          };
          this.insideStart = function (row, column) {
              if (this.compare(row, column) == 0) {
                  if (this.isEnd(row, column)) {
                      return false;
                  }
                  else {
                      return true;
                  }
              }
              return false;
          };
          this.insideEnd = function (row, column) {
              if (this.compare(row, column) == 0) {
                  if (this.isStart(row, column)) {
                      return false;
                  }
                  else {
                      return true;
                  }
              }
              return false;
          };
          this.compare = function (row, column) {
              if (!this.isMultiLine()) {
                  if (row === this.start.row) {
                      return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
                  }
              }
              if (row < this.start.row)
                  return -1;
              if (row > this.end.row)
                  return 1;
              if (this.start.row === row)
                  return column >= this.start.column ? 0 : -1;
              if (this.end.row === row)
                  return column <= this.end.column ? 0 : 1;
              return 0;
          };
          this.compareStart = function (row, column) {
              if (this.start.row == row && this.start.column == column) {
                  return -1;
              }
              else {
                  return this.compare(row, column);
              }
          };
          this.compareEnd = function (row, column) {
              if (this.end.row == row && this.end.column == column) {
                  return 1;
              }
              else {
                  return this.compare(row, column);
              }
          };
          this.compareInside = function (row, column) {
              if (this.end.row == row && this.end.column == column) {
                  return 1;
              }
              else if (this.start.row == row && this.start.column == column) {
                  return -1;
              }
              else {
                  return this.compare(row, column);
              }
          };
          this.clipRows = function (firstRow, lastRow) {
              if (this.end.row > lastRow)
                  var end = { row: lastRow + 1, column: 0 };
              else if (this.end.row < firstRow)
                  var end = { row: firstRow, column: 0 };
              if (this.start.row > lastRow)
                  var start = { row: lastRow + 1, column: 0 };
              else if (this.start.row < firstRow)
                  var start = { row: firstRow, column: 0 };
              return Range.fromPoints(start || this.start, end || this.end);
          };
          this.extend = function (row, column) {
              var cmp = this.compare(row, column);
              if (cmp == 0)
                  return this;
              else if (cmp == -1)
                  var start = { row: row, column: column };
              else
                  var end = { row: row, column: column };
              return Range.fromPoints(start || this.start, end || this.end);
          };
          this.isEmpty = function () {
              return (this.start.row === this.end.row && this.start.column === this.end.column);
          };
          this.isMultiLine = function () {
              return (this.start.row !== this.end.row);
          };
          this.clone = function () {
              return Range.fromPoints(this.start, this.end);
          };
          this.collapseRows = function () {
              if (this.end.column == 0)
                  return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
              else
                  return new Range(this.start.row, 0, this.end.row, 0);
          };
          this.toScreenRange = function (session) {
              var screenPosStart = session.documentToScreenPosition(this.start);
              var screenPosEnd = session.documentToScreenPosition(this.end);
              return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
          };
          this.moveBy = function (row, column) {
              this.start.row += row;
              this.start.column += column;
              this.end.row += row;
              this.end.column += column;
          };
      }).call(Range.prototype);
      Range.fromPoints = function (start, end) {
          return new Range(start.row, start.column, end.row, end.column);
      };
      Range.comparePoints = comparePoints;
      Range.comparePoints = function (p1, p2) {
          return p1.row - p2.row || p1.column - p2.column;
      };
      exports.Range = Range;
  });
  ace.define("ace/selection", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/range"], function (acequire, exports, module) {
      var oop = acequire("./lib/oop");
      var lang = acequire("./lib/lang");
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var Range = acequire("./range").Range;
      var Selection = function (session) {
          this.session = session;
          this.doc = session.getDocument();
          this.clearSelection();
          this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
          this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);
          var self = this;
          this.lead.on("change", function (e) {
              self._emit("changeCursor");
              if (!self.$isEmpty)
                  self._emit("changeSelection");
              if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
                  self.$desiredColumn = null;
          });
          this.selectionAnchor.on("change", function () {
              if (!self.$isEmpty)
                  self._emit("changeSelection");
          });
      };
      (function () {
          oop.implement(this, EventEmitter);
          this.isEmpty = function () {
              return (this.$isEmpty || (this.anchor.row == this.lead.row &&
                  this.anchor.column == this.lead.column));
          };
          this.isMultiLine = function () {
              if (this.isEmpty()) {
                  return false;
              }
              return this.getRange().isMultiLine();
          };
          this.getCursor = function () {
              return this.lead.getPosition();
          };
          this.setSelectionAnchor = function (row, column) {
              this.anchor.setPosition(row, column);
              if (this.$isEmpty) {
                  this.$isEmpty = false;
                  this._emit("changeSelection");
              }
          };
          this.getSelectionAnchor = function () {
              if (this.$isEmpty)
                  return this.getSelectionLead();
              else
                  return this.anchor.getPosition();
          };
          this.getSelectionLead = function () {
              return this.lead.getPosition();
          };
          this.shiftSelection = function (columns) {
              if (this.$isEmpty) {
                  this.moveCursorTo(this.lead.row, this.lead.column + columns);
                  return;
              }
              var anchor = this.getSelectionAnchor();
              var lead = this.getSelectionLead();
              var isBackwards = this.isBackwards();
              if (!isBackwards || anchor.column !== 0)
                  this.setSelectionAnchor(anchor.row, anchor.column + columns);
              if (isBackwards || lead.column !== 0) {
                  this.$moveSelection(function () {
                      this.moveCursorTo(lead.row, lead.column + columns);
                  });
              }
          };
          this.isBackwards = function () {
              var anchor = this.anchor;
              var lead = this.lead;
              return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
          };
          this.getRange = function () {
              var anchor = this.anchor;
              var lead = this.lead;
              if (this.isEmpty())
                  return Range.fromPoints(lead, lead);
              if (this.isBackwards()) {
                  return Range.fromPoints(lead, anchor);
              }
              else {
                  return Range.fromPoints(anchor, lead);
              }
          };
          this.clearSelection = function () {
              if (!this.$isEmpty) {
                  this.$isEmpty = true;
                  this._emit("changeSelection");
              }
          };
          this.selectAll = function () {
              var lastRow = this.doc.getLength() - 1;
              this.setSelectionAnchor(0, 0);
              this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
          };
          this.setRange =
              this.setSelectionRange = function (range, reverse) {
                  if (reverse) {
                      this.setSelectionAnchor(range.end.row, range.end.column);
                      this.selectTo(range.start.row, range.start.column);
                  }
                  else {
                      this.setSelectionAnchor(range.start.row, range.start.column);
                      this.selectTo(range.end.row, range.end.column);
                  }
                  if (this.getRange().isEmpty())
                      this.$isEmpty = true;
                  this.$desiredColumn = null;
              };
          this.$moveSelection = function (mover) {
              var lead = this.lead;
              if (this.$isEmpty)
                  this.setSelectionAnchor(lead.row, lead.column);
              mover.call(this);
          };
          this.selectTo = function (row, column) {
              this.$moveSelection(function () {
                  this.moveCursorTo(row, column);
              });
          };
          this.selectToPosition = function (pos) {
              this.$moveSelection(function () {
                  this.moveCursorToPosition(pos);
              });
          };
          this.moveTo = function (row, column) {
              this.clearSelection();
              this.moveCursorTo(row, column);
          };
          this.moveToPosition = function (pos) {
              this.clearSelection();
              this.moveCursorToPosition(pos);
          };
          this.selectUp = function () {
              this.$moveSelection(this.moveCursorUp);
          };
          this.selectDown = function () {
              this.$moveSelection(this.moveCursorDown);
          };
          this.selectRight = function () {
              this.$moveSelection(this.moveCursorRight);
          };
          this.selectLeft = function () {
              this.$moveSelection(this.moveCursorLeft);
          };
          this.selectLineStart = function () {
              this.$moveSelection(this.moveCursorLineStart);
          };
          this.selectLineEnd = function () {
              this.$moveSelection(this.moveCursorLineEnd);
          };
          this.selectFileEnd = function () {
              this.$moveSelection(this.moveCursorFileEnd);
          };
          this.selectFileStart = function () {
              this.$moveSelection(this.moveCursorFileStart);
          };
          this.selectWordRight = function () {
              this.$moveSelection(this.moveCursorWordRight);
          };
          this.selectWordLeft = function () {
              this.$moveSelection(this.moveCursorWordLeft);
          };
          this.getWordRange = function (row, column) {
              if (typeof column == "undefined") {
                  var cursor = row || this.lead;
                  row = cursor.row;
                  column = cursor.column;
              }
              return this.session.getWordRange(row, column);
          };
          this.selectWord = function () {
              this.setSelectionRange(this.getWordRange());
          };
          this.selectAWord = function () {
              var cursor = this.getCursor();
              var range = this.session.getAWordRange(cursor.row, cursor.column);
              this.setSelectionRange(range);
          };
          this.getLineRange = function (row, excludeLastChar) {
              var rowStart = typeof row == "number" ? row : this.lead.row;
              var rowEnd;
              var foldLine = this.session.getFoldLine(rowStart);
              if (foldLine) {
                  rowStart = foldLine.start.row;
                  rowEnd = foldLine.end.row;
              }
              else {
                  rowEnd = rowStart;
              }
              if (excludeLastChar === true)
                  return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
              else
                  return new Range(rowStart, 0, rowEnd + 1, 0);
          };
          this.selectLine = function () {
              this.setSelectionRange(this.getLineRange());
          };
          this.moveCursorUp = function () {
              this.moveCursorBy(-1, 0);
          };
          this.moveCursorDown = function () {
              this.moveCursorBy(1, 0);
          };
          this.wouldMoveIntoSoftTab = function (cursor, tabSize, direction) {
              var start = cursor.column;
              var end = cursor.column + tabSize;
              if (direction < 0) {
                  start = cursor.column - tabSize;
                  end = cursor.column;
              }
              return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length - 1 == tabSize;
          };
          this.moveCursorLeft = function () {
              var cursor = this.lead.getPosition(), fold;
              if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
                  this.moveCursorTo(fold.start.row, fold.start.column);
              }
              else if (cursor.column === 0) {
                  if (cursor.row > 0) {
                      this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
                  }
              }
              else {
                  var tabSize = this.session.getTabSize();
                  if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {
                      this.moveCursorBy(0, -tabSize);
                  }
                  else {
                      this.moveCursorBy(0, -1);
                  }
              }
          };
          this.moveCursorRight = function () {
              var cursor = this.lead.getPosition(), fold;
              if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
                  this.moveCursorTo(fold.end.row, fold.end.column);
              }
              else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
                  if (this.lead.row < this.doc.getLength() - 1) {
                      this.moveCursorTo(this.lead.row + 1, 0);
                  }
              }
              else {
                  var tabSize = this.session.getTabSize();
                  var cursor = this.lead;
                  if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {
                      this.moveCursorBy(0, tabSize);
                  }
                  else {
                      this.moveCursorBy(0, 1);
                  }
              }
          };
          this.moveCursorLineStart = function () {
              var row = this.lead.row;
              var column = this.lead.column;
              var screenRow = this.session.documentToScreenRow(row, column);
              var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
              var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);
              var leadingSpace = beforeCursor.match(/^\s*/);
              if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
                  firstColumnPosition.column += leadingSpace[0].length;
              this.moveCursorToPosition(firstColumnPosition);
          };
          this.moveCursorLineEnd = function () {
              var lead = this.lead;
              var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
              if (this.lead.column == lineEnd.column) {
                  var line = this.session.getLine(lineEnd.row);
                  if (lineEnd.column == line.length) {
                      var textEnd = line.search(/\s+$/);
                      if (textEnd > 0)
                          lineEnd.column = textEnd;
                  }
              }
              this.moveCursorTo(lineEnd.row, lineEnd.column);
          };
          this.moveCursorFileEnd = function () {
              var row = this.doc.getLength() - 1;
              var column = this.doc.getLine(row).length;
              this.moveCursorTo(row, column);
          };
          this.moveCursorFileStart = function () {
              this.moveCursorTo(0, 0);
          };
          this.moveCursorLongWordRight = function () {
              var row = this.lead.row;
              var column = this.lead.column;
              var line = this.doc.getLine(row);
              var rightOfCursor = line.substring(column);
              var match;
              this.session.nonTokenRe.lastIndex = 0;
              this.session.tokenRe.lastIndex = 0;
              var fold = this.session.getFoldAt(row, column, 1);
              if (fold) {
                  this.moveCursorTo(fold.end.row, fold.end.column);
                  return;
              }
              if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
                  column += this.session.nonTokenRe.lastIndex;
                  this.session.nonTokenRe.lastIndex = 0;
                  rightOfCursor = line.substring(column);
              }
              if (column >= line.length) {
                  this.moveCursorTo(row, line.length);
                  this.moveCursorRight();
                  if (row < this.doc.getLength() - 1)
                      this.moveCursorWordRight();
                  return;
              }
              if (match = this.session.tokenRe.exec(rightOfCursor)) {
                  column += this.session.tokenRe.lastIndex;
                  this.session.tokenRe.lastIndex = 0;
              }
              this.moveCursorTo(row, column);
          };
          this.moveCursorLongWordLeft = function () {
              var row = this.lead.row;
              var column = this.lead.column;
              var fold;
              if (fold = this.session.getFoldAt(row, column, -1)) {
                  this.moveCursorTo(fold.start.row, fold.start.column);
                  return;
              }
              var str = this.session.getFoldStringAt(row, column, -1);
              if (str == null) {
                  str = this.doc.getLine(row).substring(0, column);
              }
              var leftOfCursor = lang.stringReverse(str);
              var match;
              this.session.nonTokenRe.lastIndex = 0;
              this.session.tokenRe.lastIndex = 0;
              if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
                  column -= this.session.nonTokenRe.lastIndex;
                  leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
                  this.session.nonTokenRe.lastIndex = 0;
              }
              if (column <= 0) {
                  this.moveCursorTo(row, 0);
                  this.moveCursorLeft();
                  if (row > 0)
                      this.moveCursorWordLeft();
                  return;
              }
              if (match = this.session.tokenRe.exec(leftOfCursor)) {
                  column -= this.session.tokenRe.lastIndex;
                  this.session.tokenRe.lastIndex = 0;
              }
              this.moveCursorTo(row, column);
          };
          this.$shortWordEndIndex = function (rightOfCursor) {
              var match, index = 0, ch;
              var whitespaceRe = /\s/;
              var tokenRe = this.session.tokenRe;
              tokenRe.lastIndex = 0;
              if (match = this.session.tokenRe.exec(rightOfCursor)) {
                  index = this.session.tokenRe.lastIndex;
              }
              else {
                  while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                      index++;
                  if (index < 1) {
                      tokenRe.lastIndex = 0;
                      while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                          tokenRe.lastIndex = 0;
                          index++;
                          if (whitespaceRe.test(ch)) {
                              if (index > 2) {
                                  index--;
                                  break;
                              }
                              else {
                                  while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                                      index++;
                                  if (index > 2)
                                      break;
                              }
                          }
                      }
                  }
              }
              tokenRe.lastIndex = 0;
              return index;
          };
          this.moveCursorShortWordRight = function () {
              var row = this.lead.row;
              var column = this.lead.column;
              var line = this.doc.getLine(row);
              var rightOfCursor = line.substring(column);
              var fold = this.session.getFoldAt(row, column, 1);
              if (fold)
                  return this.moveCursorTo(fold.end.row, fold.end.column);
              if (column == line.length) {
                  var l = this.doc.getLength();
                  do {
                      row++;
                      rightOfCursor = this.doc.getLine(row);
                  } while (row < l && /^\s*$/.test(rightOfCursor));
                  if (!/^\s+/.test(rightOfCursor))
                      rightOfCursor = "";
                  column = 0;
              }
              var index = this.$shortWordEndIndex(rightOfCursor);
              this.moveCursorTo(row, column + index);
          };
          this.moveCursorShortWordLeft = function () {
              var row = this.lead.row;
              var column = this.lead.column;
              var fold;
              if (fold = this.session.getFoldAt(row, column, -1))
                  return this.moveCursorTo(fold.start.row, fold.start.column);
              var line = this.session.getLine(row).substring(0, column);
              if (column === 0) {
                  do {
                      row--;
                      line = this.doc.getLine(row);
                  } while (row > 0 && /^\s*$/.test(line));
                  column = line.length;
                  if (!/\s+$/.test(line))
                      line = "";
              }
              var leftOfCursor = lang.stringReverse(line);
              var index = this.$shortWordEndIndex(leftOfCursor);
              return this.moveCursorTo(row, column - index);
          };
          this.moveCursorWordRight = function () {
              if (this.session.$selectLongWords)
                  this.moveCursorLongWordRight();
              else
                  this.moveCursorShortWordRight();
          };
          this.moveCursorWordLeft = function () {
              if (this.session.$selectLongWords)
                  this.moveCursorLongWordLeft();
              else
                  this.moveCursorShortWordLeft();
          };
          this.moveCursorBy = function (rows, chars) {
              var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);
              var offsetX;
              if (chars === 0) {
                  if (rows !== 0) {
                      if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
                          offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
                          screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
                      }
                      else {
                          offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
                      }
                  }
                  if (this.$desiredColumn)
                      screenPos.column = this.$desiredColumn;
                  else
                      this.$desiredColumn = screenPos.column;
              }
              var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);
              if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
                  if (this.session.lineWidgets && this.session.lineWidgets[docPos.row]) {
                      if (docPos.row > 0 || rows > 0)
                          docPos.row++;
                  }
              }
              this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
          };
          this.moveCursorToPosition = function (position) {
              this.moveCursorTo(position.row, position.column);
          };
          this.moveCursorTo = function (row, column, keepDesiredColumn) {
              var fold = this.session.getFoldAt(row, column, 1);
              if (fold) {
                  row = fold.start.row;
                  column = fold.start.column;
              }
              this.$keepDesiredColumnOnChange = true;
              var line = this.session.getLine(row);
              if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
                  if (this.lead.row == row && this.lead.column == column + 1)
                      column = column - 1;
                  else
                      column = column + 1;
              }
              this.lead.setPosition(row, column);
              this.$keepDesiredColumnOnChange = false;
              if (!keepDesiredColumn)
                  this.$desiredColumn = null;
          };
          this.moveCursorToScreen = function (row, column, keepDesiredColumn) {
              var pos = this.session.screenToDocumentPosition(row, column);
              this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
          };
          this.detach = function () {
              this.lead.detach();
              this.anchor.detach();
              this.session = this.doc = null;
          };
          this.fromOrientedRange = function (range) {
              this.setSelectionRange(range, range.cursor == range.start);
              this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
          };
          this.toOrientedRange = function (range) {
              var r = this.getRange();
              if (range) {
                  range.start.column = r.start.column;
                  range.start.row = r.start.row;
                  range.end.column = r.end.column;
                  range.end.row = r.end.row;
              }
              else {
                  range = r;
              }
              range.cursor = this.isBackwards() ? range.start : range.end;
              range.desiredColumn = this.$desiredColumn;
              return range;
          };
          this.getRangeOfMovements = function (func) {
              var start = this.getCursor();
              try {
                  func(this);
                  var end = this.getCursor();
                  return Range.fromPoints(start, end);
              }
              catch (e) {
                  return Range.fromPoints(start, start);
              }
              finally {
                  this.moveCursorToPosition(start);
              }
          };
          this.toJSON = function () {
              if (this.rangeCount) {
                  var data = this.ranges.map(function (r) {
                      var r1 = r.clone();
                      r1.isBackwards = r.cursor == r.start;
                      return r1;
                  });
              }
              else {
                  var data = this.getRange();
                  data.isBackwards = this.isBackwards();
              }
              return data;
          };
          this.fromJSON = function (data) {
              if (data.start == undefined) {
                  if (this.rangeList) {
                      this.toSingleRange(data[0]);
                      for (var i = data.length; i--;) {
                          var r = Range.fromPoints(data[i].start, data[i].end);
                          if (data[i].isBackwards)
                              r.cursor = r.start;
                          this.addRange(r, true);
                      }
                      return;
                  }
                  else
                      data = data[0];
              }
              if (this.rangeList)
                  this.toSingleRange(data);
              this.setSelectionRange(data, data.isBackwards);
          };
          this.isEqual = function (data) {
              if ((data.length || this.rangeCount) && data.length != this.rangeCount)
                  return false;
              if (!data.length || !this.ranges)
                  return this.getRange().isEqual(data);
              for (var i = this.ranges.length; i--;) {
                  if (!this.ranges[i].isEqual(data[i]))
                      return false;
              }
              return true;
          };
      }).call(Selection.prototype);
      exports.Selection = Selection;
  });
  ace.define("ace/tokenizer", ["require", "exports", "module", "ace/config"], function (acequire, exports, module) {
      var config = acequire("./config");
      var MAX_TOKEN_COUNT = 2000;
      var Tokenizer = function (rules) {
          this.states = rules;
          this.regExps = {};
          this.matchMappings = {};
          for (var key in this.states) {
              var state = this.states[key];
              var ruleRegExps = [];
              var matchTotal = 0;
              var mapping = this.matchMappings[key] = { defaultToken: "text" };
              var flag = "g";
              var splitterRurles = [];
              for (var i = 0; i < state.length; i++) {
                  var rule = state[i];
                  if (rule.defaultToken)
                      mapping.defaultToken = rule.defaultToken;
                  if (rule.caseInsensitive)
                      flag = "gi";
                  if (rule.regex == null)
                      continue;
                  if (rule.regex instanceof RegExp)
                      rule.regex = rule.regex.toString().slice(1, -1);
                  var adjustedregex = rule.regex;
                  var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
                  if (Array.isArray(rule.token)) {
                      if (rule.token.length == 1 || matchcount == 1) {
                          rule.token = rule.token[0];
                      }
                      else if (matchcount - 1 != rule.token.length) {
                          this.reportError("number of classes and regexp groups doesn't match", {
                              rule: rule,
                              groupCount: matchcount - 1
                          });
                          rule.token = rule.token[0];
                      }
                      else {
                          rule.tokenArray = rule.token;
                          rule.token = null;
                          rule.onMatch = this.$arrayTokens;
                      }
                  }
                  else if (typeof rule.token == "function" && !rule.onMatch) {
                      if (matchcount > 1)
                          rule.onMatch = this.$applyToken;
                      else
                          rule.onMatch = rule.token;
                  }
                  if (matchcount > 1) {
                      if (/\\\d/.test(rule.regex)) {
                          adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function (match, digit) {
                              return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                          });
                      }
                      else {
                          matchcount = 1;
                          adjustedregex = this.removeCapturingGroups(rule.regex);
                      }
                      if (!rule.splitRegex && typeof rule.token != "string")
                          splitterRurles.push(rule); // flag will be known only at the very end
                  }
                  mapping[matchTotal] = i;
                  matchTotal += matchcount;
                  ruleRegExps.push(adjustedregex);
                  if (!rule.onMatch)
                      rule.onMatch = null;
              }
              if (!ruleRegExps.length) {
                  mapping[0] = 0;
                  ruleRegExps.push("$");
              }
              splitterRurles.forEach(function (rule) {
                  rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
              }, this);
              this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
          }
      };
      (function () {
          this.$setMaxTokenCount = function (m) {
              MAX_TOKEN_COUNT = m | 0;
          };
          this.$applyToken = function (str) {
              var values = this.splitRegex.exec(str).slice(1);
              var types = this.token.apply(this, values);
              if (typeof types === "string")
                  return [{ type: types, value: str }];
              var tokens = [];
              for (var i = 0, l = types.length; i < l; i++) {
                  if (values[i])
                      tokens[tokens.length] = {
                          type: types[i],
                          value: values[i]
                      };
              }
              return tokens;
          };
          this.$arrayTokens = function (str) {
              if (!str)
                  return [];
              var values = this.splitRegex.exec(str);
              if (!values)
                  return "text";
              var tokens = [];
              var types = this.tokenArray;
              for (var i = 0, l = types.length; i < l; i++) {
                  if (values[i + 1])
                      tokens[tokens.length] = {
                          type: types[i],
                          value: values[i + 1]
                      };
              }
              return tokens;
          };
          this.removeCapturingGroups = function (src) {
              var r = src.replace(/\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g, function (x, y) { return y ? "(?:" : x; });
              return r;
          };
          this.createSplitterRegexp = function (src, flag) {
              if (src.indexOf("(?=") != -1) {
                  var stack = 0;
                  var inChClass = false;
                  var lastCapture = {};
                  src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function (m, esc, parenOpen, parenClose, square, index) {
                      if (inChClass) {
                          inChClass = square != "]";
                      }
                      else if (square) {
                          inChClass = true;
                      }
                      else if (parenClose) {
                          if (stack == lastCapture.stack) {
                              lastCapture.end = index + 1;
                              lastCapture.stack = -1;
                          }
                          stack--;
                      }
                      else if (parenOpen) {
                          stack++;
                          if (parenOpen.length != 1) {
                              lastCapture.stack = stack;
                              lastCapture.start = index;
                          }
                      }
                      return m;
                  });
                  if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
                      src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
              }
              if (src.charAt(0) != "^")
                  src = "^" + src;
              if (src.charAt(src.length - 1) != "$")
                  src += "$";
              return new RegExp(src, (flag || "").replace("g", ""));
          };
          this.getLineTokens = function (line, startState) {
              if (startState && typeof startState != "string") {
                  var stack = startState.slice(0);
                  startState = stack[0];
                  if (startState === "#tmp") {
                      stack.shift();
                      startState = stack.shift();
                  }
              }
              else
                  var stack = [];
              var currentState = startState || "start";
              var state = this.states[currentState];
              if (!state) {
                  currentState = "start";
                  state = this.states[currentState];
              }
              var mapping = this.matchMappings[currentState];
              var re = this.regExps[currentState];
              re.lastIndex = 0;
              var match, tokens = [];
              var lastIndex = 0;
              var matchAttempts = 0;
              var token = { type: null, value: "" };
              while (match = re.exec(line)) {
                  var type = mapping.defaultToken;
                  var rule = null;
                  var value = match[0];
                  var index = re.lastIndex;
                  if (index - value.length > lastIndex) {
                      var skipped = line.substring(lastIndex, index - value.length);
                      if (token.type == type) {
                          token.value += skipped;
                      }
                      else {
                          if (token.type)
                              tokens.push(token);
                          token = { type: type, value: skipped };
                      }
                  }
                  for (var i = 0; i < match.length - 2; i++) {
                      if (match[i + 1] === undefined)
                          continue;
                      rule = state[mapping[i]];
                      if (rule.onMatch)
                          type = rule.onMatch(value, currentState, stack, line);
                      else
                          type = rule.token;
                      if (rule.next) {
                          if (typeof rule.next == "string") {
                              currentState = rule.next;
                          }
                          else {
                              currentState = rule.next(currentState, stack);
                          }
                          state = this.states[currentState];
                          if (!state) {
                              this.reportError("state doesn't exist", currentState);
                              currentState = "start";
                              state = this.states[currentState];
                          }
                          mapping = this.matchMappings[currentState];
                          lastIndex = index;
                          re = this.regExps[currentState];
                          re.lastIndex = index;
                      }
                      if (rule.consumeLineEnd)
                          lastIndex = index;
                      break;
                  }
                  if (value) {
                      if (typeof type === "string") {
                          if ((!rule || rule.merge !== false) && token.type === type) {
                              token.value += value;
                          }
                          else {
                              if (token.type)
                                  tokens.push(token);
                              token = { type: type, value: value };
                          }
                      }
                      else if (type) {
                          if (token.type)
                              tokens.push(token);
                          token = { type: null, value: "" };
                          for (var i = 0; i < type.length; i++)
                              tokens.push(type[i]);
                      }
                  }
                  if (lastIndex == line.length)
                      break;
                  lastIndex = index;
                  if (matchAttempts++ > MAX_TOKEN_COUNT) {
                      if (matchAttempts > 2 * line.length) {
                          this.reportError("infinite loop with in ace tokenizer", {
                              startState: startState,
                              line: line
                          });
                      }
                      while (lastIndex < line.length) {
                          if (token.type)
                              tokens.push(token);
                          token = {
                              value: line.substring(lastIndex, lastIndex += 2000),
                              type: "overflow"
                          };
                      }
                      currentState = "start";
                      stack = [];
                      break;
                  }
              }
              if (token.type)
                  tokens.push(token);
              if (stack.length > 1) {
                  if (stack[0] !== currentState)
                      stack.unshift("#tmp", currentState);
              }
              return {
                  tokens: tokens,
                  state: stack.length ? stack : currentState
              };
          };
          this.reportError = config.reportError;
      }).call(Tokenizer.prototype);
      exports.Tokenizer = Tokenizer;
  });
  ace.define("ace/mode/text_highlight_rules", ["require", "exports", "module", "ace/lib/lang"], function (acequire, exports, module) {
      var lang = acequire("../lib/lang");
      var TextHighlightRules = function () {
          this.$rules = {
              "start": [{
                      token: "empty_line",
                      regex: '^$'
                  }, {
                      defaultToken: "text"
                  }]
          };
      };
      (function () {
          this.addRules = function (rules, prefix) {
              if (!prefix) {
                  for (var key in rules)
                      this.$rules[key] = rules[key];
                  return;
              }
              for (var key in rules) {
                  var state = rules[key];
                  for (var i = 0; i < state.length; i++) {
                      var rule = state[i];
                      if (rule.next || rule.onMatch) {
                          if (typeof rule.next == "string") {
                              if (rule.next.indexOf(prefix) !== 0)
                                  rule.next = prefix + rule.next;
                          }
                          if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                              rule.nextState = prefix + rule.nextState;
                      }
                  }
                  this.$rules[prefix + key] = state;
              }
          };
          this.getRules = function () {
              return this.$rules;
          };
          this.embedRules = function (HighlightRules, prefix, escapeRules, states, append) {
              var embedRules = typeof HighlightRules == "function"
                  ? new HighlightRules().getRules()
                  : HighlightRules;
              if (states) {
                  for (var i = 0; i < states.length; i++)
                      states[i] = prefix + states[i];
              }
              else {
                  states = [];
                  for (var key in embedRules)
                      states.push(prefix + key);
              }
              this.addRules(embedRules, prefix);
              if (escapeRules) {
                  var addRules = Array.prototype[append ? "push" : "unshift"];
                  for (var i = 0; i < states.length; i++)
                      addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
              }
              if (!this.$embeds)
                  this.$embeds = [];
              this.$embeds.push(prefix);
          };
          this.getEmbeds = function () {
              return this.$embeds;
          };
          var pushState = function (currentState, stack) {
              if (currentState != "start" || stack.length)
                  stack.unshift(this.nextState, currentState);
              return this.nextState;
          };
          var popState = function (currentState, stack) {
              stack.shift();
              return stack.shift() || "start";
          };
          this.normalizeRules = function () {
              var id = 0;
              var rules = this.$rules;
              function processState(key) {
                  var state = rules[key];
                  state.processed = true;
                  for (var i = 0; i < state.length; i++) {
                      var rule = state[i];
                      var toInsert = null;
                      if (Array.isArray(rule)) {
                          toInsert = rule;
                          rule = {};
                      }
                      if (!rule.regex && rule.start) {
                          rule.regex = rule.start;
                          if (!rule.next)
                              rule.next = [];
                          rule.next.push({
                              defaultToken: rule.token
                          }, {
                              token: rule.token + ".end",
                              regex: rule.end || rule.start,
                              next: "pop"
                          });
                          rule.token = rule.token + ".start";
                          rule.push = true;
                      }
                      var next = rule.next || rule.push;
                      if (next && Array.isArray(next)) {
                          var stateName = rule.stateName;
                          if (!stateName) {
                              stateName = rule.token;
                              if (typeof stateName != "string")
                                  stateName = stateName[0] || "";
                              if (rules[stateName])
                                  stateName += id++;
                          }
                          rules[stateName] = next;
                          rule.next = stateName;
                          processState(stateName);
                      }
                      else if (next == "pop") {
                          rule.next = popState;
                      }
                      if (rule.push) {
                          rule.nextState = rule.next || rule.push;
                          rule.next = pushState;
                          delete rule.push;
                      }
                      if (rule.rules) {
                          for (var r in rule.rules) {
                              if (rules[r]) {
                                  if (rules[r].push)
                                      rules[r].push.apply(rules[r], rule.rules[r]);
                              }
                              else {
                                  rules[r] = rule.rules[r];
                              }
                          }
                      }
                      var includeName = typeof rule == "string" ? rule : rule.include;
                      if (includeName) {
                          if (Array.isArray(includeName))
                              toInsert = includeName.map(function (x) { return rules[x]; });
                          else
                              toInsert = rules[includeName];
                      }
                      if (toInsert) {
                          var args = [i, 1].concat(toInsert);
                          if (rule.noEscape)
                              args = args.filter(function (x) { return !x.next; });
                          state.splice.apply(state, args);
                          i--;
                      }
                      if (rule.keywordMap) {
                          rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
                          delete rule.defaultToken;
                      }
                  }
              }
              Object.keys(rules).forEach(processState, this);
          };
          this.createKeywordMapper = function (map, defaultToken, ignoreCase, splitChar) {
              var keywords = Object.create(null);
              Object.keys(map).forEach(function (className) {
                  var a = map[className];
                  if (ignoreCase)
                      a = a.toLowerCase();
                  var list = a.split(splitChar || "|");
                  for (var i = list.length; i--;)
                      keywords[list[i]] = className;
              });
              if (Object.getPrototypeOf(keywords)) {
                  keywords.__proto__ = null;
              }
              this.$keywordList = Object.keys(keywords);
              map = null;
              return ignoreCase
                  ? function (value) { return keywords[value.toLowerCase()] || defaultToken; }
                  : function (value) { return keywords[value] || defaultToken; };
          };
          this.getKeywords = function () {
              return this.$keywords;
          };
      }).call(TextHighlightRules.prototype);
      exports.TextHighlightRules = TextHighlightRules;
  });
  ace.define("ace/mode/behaviour", ["require", "exports", "module"], function (acequire, exports, module) {
      var Behaviour = function () {
          this.$behaviours = {};
      };
      (function () {
          this.add = function (name, action, callback) {
              switch (undefined) {
                  case this.$behaviours:
                      this.$behaviours = {};
                  case this.$behaviours[name]:
                      this.$behaviours[name] = {};
              }
              this.$behaviours[name][action] = callback;
          };
          this.addBehaviours = function (behaviours) {
              for (var key in behaviours) {
                  for (var action in behaviours[key]) {
                      this.add(key, action, behaviours[key][action]);
                  }
              }
          };
          this.remove = function (name) {
              if (this.$behaviours && this.$behaviours[name]) {
                  delete this.$behaviours[name];
              }
          };
          this.inherit = function (mode, filter) {
              if (typeof mode === "function") {
                  var behaviours = new mode().getBehaviours(filter);
              }
              else {
                  var behaviours = mode.getBehaviours(filter);
              }
              this.addBehaviours(behaviours);
          };
          this.getBehaviours = function (filter) {
              if (!filter) {
                  return this.$behaviours;
              }
              else {
                  var ret = {};
                  for (var i = 0; i < filter.length; i++) {
                      if (this.$behaviours[filter[i]]) {
                          ret[filter[i]] = this.$behaviours[filter[i]];
                      }
                  }
                  return ret;
              }
          };
      }).call(Behaviour.prototype);
      exports.Behaviour = Behaviour;
  });
  ace.define("ace/token_iterator", ["require", "exports", "module", "ace/range"], function (acequire, exports, module) {
      var Range = acequire("./range").Range;
      var TokenIterator = function (session, initialRow, initialColumn) {
          this.$session = session;
          this.$row = initialRow;
          this.$rowTokens = session.getTokens(initialRow);
          var token = session.getTokenAt(initialRow, initialColumn);
          this.$tokenIndex = token ? token.index : -1;
      };
      (function () {
          this.stepBackward = function () {
              this.$tokenIndex -= 1;
              while (this.$tokenIndex < 0) {
                  this.$row -= 1;
                  if (this.$row < 0) {
                      this.$row = 0;
                      return null;
                  }
                  this.$rowTokens = this.$session.getTokens(this.$row);
                  this.$tokenIndex = this.$rowTokens.length - 1;
              }
              return this.$rowTokens[this.$tokenIndex];
          };
          this.stepForward = function () {
              this.$tokenIndex += 1;
              var rowCount;
              while (this.$tokenIndex >= this.$rowTokens.length) {
                  this.$row += 1;
                  if (!rowCount)
                      rowCount = this.$session.getLength();
                  if (this.$row >= rowCount) {
                      this.$row = rowCount - 1;
                      return null;
                  }
                  this.$rowTokens = this.$session.getTokens(this.$row);
                  this.$tokenIndex = 0;
              }
              return this.$rowTokens[this.$tokenIndex];
          };
          this.getCurrentToken = function () {
              return this.$rowTokens[this.$tokenIndex];
          };
          this.getCurrentTokenRow = function () {
              return this.$row;
          };
          this.getCurrentTokenColumn = function () {
              var rowTokens = this.$rowTokens;
              var tokenIndex = this.$tokenIndex;
              var column = rowTokens[tokenIndex].start;
              if (column !== undefined)
                  return column;
              column = 0;
              while (tokenIndex > 0) {
                  tokenIndex -= 1;
                  column += rowTokens[tokenIndex].value.length;
              }
              return column;
          };
          this.getCurrentTokenPosition = function () {
              return { row: this.$row, column: this.getCurrentTokenColumn() };
          };
          this.getCurrentTokenRange = function () {
              var token = this.$rowTokens[this.$tokenIndex];
              var column = this.getCurrentTokenColumn();
              return new Range(this.$row, column, this.$row, column + token.value.length);
          };
      }).call(TokenIterator.prototype);
      exports.TokenIterator = TokenIterator;
  });
  ace.define("ace/mode/behaviour/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator", "ace/lib/lang"], function (acequire, exports, module) {
      var oop = acequire("../../lib/oop");
      var Behaviour = acequire("../behaviour").Behaviour;
      var TokenIterator = acequire("../../token_iterator").TokenIterator;
      var lang = acequire("../../lib/lang");
      var SAFE_INSERT_IN_TOKENS = ["text", "paren.rparen", "punctuation.operator"];
      var SAFE_INSERT_BEFORE_TOKENS = ["text", "paren.rparen", "punctuation.operator", "comment"];
      var context;
      var contextCache = {};
      var defaultQuotes = { '"': '"', "'": "'" };
      var initContext = function (editor) {
          var id = -1;
          if (editor.multiSelect) {
              id = editor.selection.index;
              if (contextCache.rangeCount != editor.multiSelect.rangeCount)
                  contextCache = { rangeCount: editor.multiSelect.rangeCount };
          }
          if (contextCache[id])
              return context = contextCache[id];
          context = contextCache[id] = {
              autoInsertedBrackets: 0,
              autoInsertedRow: -1,
              autoInsertedLineEnd: "",
              maybeInsertedBrackets: 0,
              maybeInsertedRow: -1,
              maybeInsertedLineStart: "",
              maybeInsertedLineEnd: ""
          };
      };
      var getWrapped = function (selection, selected, opening, closing) {
          var rowDiff = selection.end.row - selection.start.row;
          return {
              text: opening + selected + closing,
              selection: [
                  0,
                  selection.start.column + 1,
                  rowDiff,
                  selection.end.column + (rowDiff ? 0 : 1)
              ]
          };
      };
      var CstyleBehaviour = function (options) {
          this.add("braces", "insertion", function (state, action, editor, session, text) {
              var cursor = editor.getCursorPosition();
              var line = session.doc.getLine(cursor.row);
              if (text == '{') {
                  initContext(editor);
                  var selection = editor.getSelectionRange();
                  var selected = session.doc.getTextRange(selection);
                  if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
                      return getWrapped(selection, selected, '{', '}');
                  }
                  else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                      if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options && options.braces) {
                          CstyleBehaviour.recordAutoInsert(editor, session, "}");
                          return {
                              text: '{}',
                              selection: [1, 1]
                          };
                      }
                      else {
                          CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                          return {
                              text: '{',
                              selection: [1, 1]
                          };
                      }
                  }
              }
              else if (text == '}') {
                  initContext(editor);
                  var rightChar = line.substring(cursor.column, cursor.column + 1);
                  if (rightChar == '}') {
                      var matching = session.$findOpeningBracket('}', { column: cursor.column + 1, row: cursor.row });
                      if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                          CstyleBehaviour.popAutoInsertedClosing();
                          return {
                              text: '',
                              selection: [1, 1]
                          };
                      }
                  }
              }
              else if (text == "\n" || text == "\r\n") {
                  initContext(editor);
                  var closing = "";
                  if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                      closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
                      CstyleBehaviour.clearMaybeInsertedClosing();
                  }
                  var rightChar = line.substring(cursor.column, cursor.column + 1);
                  if (rightChar === '}') {
                      var openBracePos = session.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 }, '}');
                      if (!openBracePos)
                          return null;
                      var next_indent = this.$getIndent(session.getLine(openBracePos.row));
                  }
                  else if (closing) {
                      var next_indent = this.$getIndent(line);
                  }
                  else {
                      CstyleBehaviour.clearMaybeInsertedClosing();
                      return;
                  }
                  var indent = next_indent + session.getTabString();
                  return {
                      text: '\n' + indent + '\n' + next_indent + closing,
                      selection: [1, indent.length, 1, indent.length]
                  };
              }
              else {
                  CstyleBehaviour.clearMaybeInsertedClosing();
              }
          });
          this.add("braces", "deletion", function (state, action, editor, session, range) {
              var selected = session.doc.getTextRange(range);
              if (!range.isMultiLine() && selected == '{') {
                  initContext(editor);
                  var line = session.doc.getLine(range.start.row);
                  var rightChar = line.substring(range.end.column, range.end.column + 1);
                  if (rightChar == '}') {
                      range.end.column++;
                      return range;
                  }
                  else {
                      context.maybeInsertedBrackets--;
                  }
              }
          });
          this.add("parens", "insertion", function (state, action, editor, session, text) {
              if (text == '(') {
                  initContext(editor);
                  var selection = editor.getSelectionRange();
                  var selected = session.doc.getTextRange(selection);
                  if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                      return getWrapped(selection, selected, '(', ')');
                  }
                  else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                      CstyleBehaviour.recordAutoInsert(editor, session, ")");
                      return {
                          text: '()',
                          selection: [1, 1]
                      };
                  }
              }
              else if (text == ')') {
                  initContext(editor);
                  var cursor = editor.getCursorPosition();
                  var line = session.doc.getLine(cursor.row);
                  var rightChar = line.substring(cursor.column, cursor.column + 1);
                  if (rightChar == ')') {
                      var matching = session.$findOpeningBracket(')', { column: cursor.column + 1, row: cursor.row });
                      if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                          CstyleBehaviour.popAutoInsertedClosing();
                          return {
                              text: '',
                              selection: [1, 1]
                          };
                      }
                  }
              }
          });
          this.add("parens", "deletion", function (state, action, editor, session, range) {
              var selected = session.doc.getTextRange(range);
              if (!range.isMultiLine() && selected == '(') {
                  initContext(editor);
                  var line = session.doc.getLine(range.start.row);
                  var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                  if (rightChar == ')') {
                      range.end.column++;
                      return range;
                  }
              }
          });
          this.add("brackets", "insertion", function (state, action, editor, session, text) {
              if (text == '[') {
                  initContext(editor);
                  var selection = editor.getSelectionRange();
                  var selected = session.doc.getTextRange(selection);
                  if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                      return getWrapped(selection, selected, '[', ']');
                  }
                  else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                      CstyleBehaviour.recordAutoInsert(editor, session, "]");
                      return {
                          text: '[]',
                          selection: [1, 1]
                      };
                  }
              }
              else if (text == ']') {
                  initContext(editor);
                  var cursor = editor.getCursorPosition();
                  var line = session.doc.getLine(cursor.row);
                  var rightChar = line.substring(cursor.column, cursor.column + 1);
                  if (rightChar == ']') {
                      var matching = session.$findOpeningBracket(']', { column: cursor.column + 1, row: cursor.row });
                      if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                          CstyleBehaviour.popAutoInsertedClosing();
                          return {
                              text: '',
                              selection: [1, 1]
                          };
                      }
                  }
              }
          });
          this.add("brackets", "deletion", function (state, action, editor, session, range) {
              var selected = session.doc.getTextRange(range);
              if (!range.isMultiLine() && selected == '[') {
                  initContext(editor);
                  var line = session.doc.getLine(range.start.row);
                  var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                  if (rightChar == ']') {
                      range.end.column++;
                      return range;
                  }
              }
          });
          this.add("string_dquotes", "insertion", function (state, action, editor, session, text) {
              var quotes = session.$mode.$quotes || defaultQuotes;
              if (text.length == 1 && quotes[text]) {
                  if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1)
                      return;
                  initContext(editor);
                  var quote = text;
                  var selection = editor.getSelectionRange();
                  var selected = session.doc.getTextRange(selection);
                  if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {
                      return getWrapped(selection, selected, quote, quote);
                  }
                  else if (!selected) {
                      var cursor = editor.getCursorPosition();
                      var line = session.doc.getLine(cursor.row);
                      var leftChar = line.substring(cursor.column - 1, cursor.column);
                      var rightChar = line.substring(cursor.column, cursor.column + 1);
                      var token = session.getTokenAt(cursor.row, cursor.column);
                      var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
                      if (leftChar == "\\" && token && /escape/.test(token.type))
                          return null;
                      var stringBefore = token && /string|escape/.test(token.type);
                      var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
                      var pair;
                      if (rightChar == quote) {
                          pair = stringBefore !== stringAfter;
                          if (pair && /string\.end/.test(rightToken.type))
                              pair = false;
                      }
                      else {
                          if (stringBefore && !stringAfter)
                              return null; // wrap string with different quote
                          if (stringBefore && stringAfter)
                              return null; // do not pair quotes inside strings
                          var wordRe = session.$mode.tokenRe;
                          wordRe.lastIndex = 0;
                          var isWordBefore = wordRe.test(leftChar);
                          wordRe.lastIndex = 0;
                          var isWordAfter = wordRe.test(leftChar);
                          if (isWordBefore || isWordAfter)
                              return null; // before or after alphanumeric
                          if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
                              return null; // there is rightChar and it isn't closing
                          pair = true;
                      }
                      return {
                          text: pair ? quote + quote : "",
                          selection: [1, 1]
                      };
                  }
              }
          });
          this.add("string_dquotes", "deletion", function (state, action, editor, session, range) {
              var selected = session.doc.getTextRange(range);
              if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
                  initContext(editor);
                  var line = session.doc.getLine(range.start.row);
                  var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                  if (rightChar == selected) {
                      range.end.column++;
                      return range;
                  }
              }
          });
      };
      CstyleBehaviour.isSaneInsertion = function (editor, session) {
          var cursor = editor.getCursorPosition();
          var iterator = new TokenIterator(session, cursor.row, cursor.column);
          if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
              var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
              if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
                  return false;
          }
          iterator.stepForward();
          return iterator.getCurrentTokenRow() !== cursor.row ||
              this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
      };
      CstyleBehaviour.$matchTokenType = function (token, types) {
          return types.indexOf(token.type || token) > -1;
      };
      CstyleBehaviour.recordAutoInsert = function (editor, session, bracket) {
          var cursor = editor.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
              context.autoInsertedBrackets = 0;
          context.autoInsertedRow = cursor.row;
          context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
          context.autoInsertedBrackets++;
      };
      CstyleBehaviour.recordMaybeInsert = function (editor, session, bracket) {
          var cursor = editor.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          if (!this.isMaybeInsertedClosing(cursor, line))
              context.maybeInsertedBrackets = 0;
          context.maybeInsertedRow = cursor.row;
          context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
          context.maybeInsertedLineEnd = line.substr(cursor.column);
          context.maybeInsertedBrackets++;
      };
      CstyleBehaviour.isAutoInsertedClosing = function (cursor, line, bracket) {
          return context.autoInsertedBrackets > 0 &&
              cursor.row === context.autoInsertedRow &&
              bracket === context.autoInsertedLineEnd[0] &&
              line.substr(cursor.column) === context.autoInsertedLineEnd;
      };
      CstyleBehaviour.isMaybeInsertedClosing = function (cursor, line) {
          return context.maybeInsertedBrackets > 0 &&
              cursor.row === context.maybeInsertedRow &&
              line.substr(cursor.column) === context.maybeInsertedLineEnd &&
              line.substr(0, cursor.column) == context.maybeInsertedLineStart;
      };
      CstyleBehaviour.popAutoInsertedClosing = function () {
          context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
          context.autoInsertedBrackets--;
      };
      CstyleBehaviour.clearMaybeInsertedClosing = function () {
          if (context) {
              context.maybeInsertedBrackets = 0;
              context.maybeInsertedRow = -1;
          }
      };
      oop.inherits(CstyleBehaviour, Behaviour);
      exports.CstyleBehaviour = CstyleBehaviour;
  });
  ace.define("ace/unicode", ["require", "exports", "module"], function (acequire, exports, module) {
      exports.packages = {};
      addUnicodePackage({
          L: "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
          Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
          Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
          Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
          Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
          Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
          M: "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
          Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
          Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
          Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
          N: "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
          Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
          Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
          No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
          P: "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
          Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
          Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
          Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
          Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
          Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
          Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
          Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
          S: "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
          Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
          Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
          Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
          So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
          Z: "002000A01680180E2000-200A20282029202F205F3000",
          Zs: "002000A01680180E2000-200A202F205F3000",
          Zl: "2028",
          Zp: "2029",
          C: "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
          Cc: "0000-001F007F-009F",
          Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
          Co: "E000-F8FF",
          Cs: "D800-DFFF",
          Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
      });
      function addUnicodePackage(pack) {
          var codePoint = /\w{4}/g;
          for (var name in pack)
              exports.packages[name] = pack[name].replace(codePoint, "\\u$&");
      }
  });
  ace.define("ace/mode/text", ["require", "exports", "module", "ace/tokenizer", "ace/mode/text_highlight_rules", "ace/mode/behaviour/cstyle", "ace/unicode", "ace/lib/lang", "ace/token_iterator", "ace/range"], function (acequire, exports, module) {
      var Tokenizer = acequire("../tokenizer").Tokenizer;
      var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;
      var CstyleBehaviour = acequire("./behaviour/cstyle").CstyleBehaviour;
      var unicode = acequire("../unicode");
      var lang = acequire("../lib/lang");
      var TokenIterator = acequire("../token_iterator").TokenIterator;
      var Range = acequire("../range").Range;
      var Mode = function () {
          this.HighlightRules = TextHighlightRules;
      };
      (function () {
          this.$defaultBehaviour = new CstyleBehaviour();
          this.tokenRe = new RegExp("^["
              + unicode.packages.L
              + unicode.packages.Mn + unicode.packages.Mc
              + unicode.packages.Nd
              + unicode.packages.Pc + "\\$_]+", "g");
          this.nonTokenRe = new RegExp("^(?:[^"
              + unicode.packages.L
              + unicode.packages.Mn + unicode.packages.Mc
              + unicode.packages.Nd
              + unicode.packages.Pc + "\\$_]|\\s])+", "g");
          this.getTokenizer = function () {
              if (!this.$tokenizer) {
                  this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
                  this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
              }
              return this.$tokenizer;
          };
          this.lineCommentStart = "";
          this.blockComment = "";
          this.toggleCommentLines = function (state, session, startRow, endRow) {
              var doc = session.doc;
              var ignoreBlankLines = true;
              var shouldRemove = true;
              var minIndent = Infinity;
              var tabSize = session.getTabSize();
              var insertAtTabStop = false;
              if (!this.lineCommentStart) {
                  if (!this.blockComment)
                      return false;
                  var lineCommentStart = this.blockComment.start;
                  var lineCommentEnd = this.blockComment.end;
                  var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
                  var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");
                  var comment = function (line, i) {
                      if (testRemove(line, i))
                          return;
                      if (!ignoreBlankLines || /\S/.test(line)) {
                          doc.insertInLine({ row: i, column: line.length }, lineCommentEnd);
                          doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
                      }
                  };
                  var uncomment = function (line, i) {
                      var m;
                      if (m = line.match(regexpEnd))
                          doc.removeInLine(i, line.length - m[0].length, line.length);
                      if (m = line.match(regexpStart))
                          doc.removeInLine(i, m[1].length, m[0].length);
                  };
                  var testRemove = function (line, row) {
                      if (regexpStart.test(line))
                          return true;
                      var tokens = session.getTokens(row);
                      for (var i = 0; i < tokens.length; i++) {
                          if (tokens[i].type === "comment")
                              return true;
                      }
                  };
              }
              else {
                  if (Array.isArray(this.lineCommentStart)) {
                      var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
                      var lineCommentStart = this.lineCommentStart[0];
                  }
                  else {
                      var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                      var lineCommentStart = this.lineCommentStart;
                  }
                  regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
                  insertAtTabStop = session.getUseSoftTabs();
                  var uncomment = function (line, i) {
                      var m = line.match(regexpStart);
                      if (!m)
                          return;
                      var start = m[1].length, end = m[0].length;
                      if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
                          end--;
                      doc.removeInLine(i, start, end);
                  };
                  var commentWithSpace = lineCommentStart + " ";
                  var comment = function (line, i) {
                      if (!ignoreBlankLines || /\S/.test(line)) {
                          if (shouldInsertSpace(line, minIndent, minIndent))
                              doc.insertInLine({ row: i, column: minIndent }, commentWithSpace);
                          else
                              doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
                      }
                  };
                  var testRemove = function (line, i) {
                      return regexpStart.test(line);
                  };
                  var shouldInsertSpace = function (line, before, after) {
                      var spaces = 0;
                      while (before-- && line.charAt(before) == " ")
                          spaces++;
                      if (spaces % tabSize != 0)
                          return false;
                      var spaces = 0;
                      while (line.charAt(after++) == " ")
                          spaces++;
                      if (tabSize > 2)
                          return spaces % tabSize != tabSize - 1;
                      else
                          return spaces % tabSize == 0;
                      return true;
                  };
              }
              function iter(fun) {
                  for (var i = startRow; i <= endRow; i++)
                      fun(doc.getLine(i), i);
              }
              var minEmptyLength = Infinity;
              iter(function (line, i) {
                  var indent = line.search(/\S/);
                  if (indent !== -1) {
                      if (indent < minIndent)
                          minIndent = indent;
                      if (shouldRemove && !testRemove(line, i))
                          shouldRemove = false;
                  }
                  else if (minEmptyLength > line.length) {
                      minEmptyLength = line.length;
                  }
              });
              if (minIndent == Infinity) {
                  minIndent = minEmptyLength;
                  ignoreBlankLines = false;
                  shouldRemove = false;
              }
              if (insertAtTabStop && minIndent % tabSize != 0)
                  minIndent = Math.floor(minIndent / tabSize) * tabSize;
              iter(shouldRemove ? uncomment : comment);
          };
          this.toggleBlockComment = function (state, session, range, cursor) {
              var comment = this.blockComment;
              if (!comment)
                  return;
              if (!comment.start && comment[0])
                  comment = comment[0];
              var iterator = new TokenIterator(session, cursor.row, cursor.column);
              var token = iterator.getCurrentToken();
              var sel = session.selection;
              var initialRange = session.selection.toOrientedRange();
              var startRow, colDiff;
              if (token && /comment/.test(token.type)) {
                  var startRange, endRange;
                  while (token && /comment/.test(token.type)) {
                      var i = token.value.indexOf(comment.start);
                      if (i != -1) {
                          var row = iterator.getCurrentTokenRow();
                          var column = iterator.getCurrentTokenColumn() + i;
                          startRange = new Range(row, column, row, column + comment.start.length);
                          break;
                      }
                      token = iterator.stepBackward();
                  }
                  var iterator = new TokenIterator(session, cursor.row, cursor.column);
                  var token = iterator.getCurrentToken();
                  while (token && /comment/.test(token.type)) {
                      var i = token.value.indexOf(comment.end);
                      if (i != -1) {
                          var row = iterator.getCurrentTokenRow();
                          var column = iterator.getCurrentTokenColumn() + i;
                          endRange = new Range(row, column, row, column + comment.end.length);
                          break;
                      }
                      token = iterator.stepForward();
                  }
                  if (endRange)
                      session.remove(endRange);
                  if (startRange) {
                      session.remove(startRange);
                      startRow = startRange.start.row;
                      colDiff = -comment.start.length;
                  }
              }
              else {
                  colDiff = comment.start.length;
                  startRow = range.start.row;
                  session.insert(range.end, comment.end);
                  session.insert(range.start, comment.start);
              }
              if (initialRange.start.row == startRow)
                  initialRange.start.column += colDiff;
              if (initialRange.end.row == startRow)
                  initialRange.end.column += colDiff;
              session.selection.fromOrientedRange(initialRange);
          };
          this.getNextLineIndent = function (state, line, tab) {
              return this.$getIndent(line);
          };
          this.checkOutdent = function (state, line, input) {
              return false;
          };
          this.autoOutdent = function (state, doc, row) {
          };
          this.$getIndent = function (line) {
              return line.match(/^\s*/)[0];
          };
          this.createWorker = function (session) {
              return null;
          };
          this.createModeDelegates = function (mapping) {
              this.$embeds = [];
              this.$modes = {};
              for (var i in mapping) {
                  if (mapping[i]) {
                      this.$embeds.push(i);
                      this.$modes[i] = new mapping[i]();
                  }
              }
              var delegations = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent",
                  "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];
              for (var i = 0; i < delegations.length; i++) {
                  (function (scope) {
                      var functionName = delegations[i];
                      var defaultHandler = scope[functionName];
                      scope[delegations[i]] = function () {
                          return this.$delegator(functionName, arguments, defaultHandler);
                      };
                  }(this));
              }
          };
          this.$delegator = function (method, args, defaultHandler) {
              var state = args[0];
              if (typeof state != "string")
                  state = state[0];
              for (var i = 0; i < this.$embeds.length; i++) {
                  if (!this.$modes[this.$embeds[i]])
                      continue;
                  var split = state.split(this.$embeds[i]);
                  if (!split[0] && split[1]) {
                      args[0] = split[1];
                      var mode = this.$modes[this.$embeds[i]];
                      return mode[method].apply(mode, args);
                  }
              }
              var ret = defaultHandler.apply(this, args);
              return defaultHandler ? ret : undefined;
          };
          this.transformAction = function (state, action, editor, session, param) {
              if (this.$behaviour) {
                  var behaviours = this.$behaviour.getBehaviours();
                  for (var key in behaviours) {
                      if (behaviours[key][action]) {
                          var ret = behaviours[key][action].apply(this, arguments);
                          if (ret) {
                              return ret;
                          }
                      }
                  }
              }
          };
          this.getKeywords = function (append) {
              if (!this.completionKeywords) {
                  var rules = this.$tokenizer.rules;
                  var completionKeywords = [];
                  for (var rule in rules) {
                      var ruleItr = rules[rule];
                      for (var r = 0, l = ruleItr.length; r < l; r++) {
                          if (typeof ruleItr[r].token === "string") {
                              if (/keyword|support|storage/.test(ruleItr[r].token))
                                  completionKeywords.push(ruleItr[r].regex);
                          }
                          else if (typeof ruleItr[r].token === "object") {
                              for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {
                                  if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                      var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                      completionKeywords.push(rule.substr(1, rule.length - 2));
                                  }
                              }
                          }
                      }
                  }
                  this.completionKeywords = completionKeywords;
              }
              if (!append)
                  return this.$keywordList;
              return completionKeywords.concat(this.$keywordList || []);
          };
          this.$createKeywordList = function () {
              if (!this.$highlightRules)
                  this.getTokenizer();
              return this.$keywordList = this.$highlightRules.$keywordList || [];
          };
          this.getCompletions = function (state, session, pos, prefix) {
              var keywords = this.$keywordList || this.$createKeywordList();
              return keywords.map(function (word) {
                  return {
                      name: word,
                      value: word,
                      score: 0,
                      meta: "keyword"
                  };
              });
          };
          this.$id = "ace/mode/text";
      }).call(Mode.prototype);
      exports.Mode = Mode;
  });
  ace.define("ace/apply_delta", ["require", "exports", "module"], function (acequire, exports, module) {
      exports.applyDelta = function (docLines, delta, doNotValidate) {
          var row = delta.start.row;
          var startColumn = delta.start.column;
          var line = docLines[row] || "";
          switch (delta.action) {
              case "insert":
                  var lines = delta.lines;
                  if (lines.length === 1) {
                      docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
                  }
                  else {
                      var args = [row, 1].concat(delta.lines);
                      docLines.splice.apply(docLines, args);
                      docLines[row] = line.substring(0, startColumn) + docLines[row];
                      docLines[row + delta.lines.length - 1] += line.substring(startColumn);
                  }
                  break;
              case "remove":
                  var endColumn = delta.end.column;
                  var endRow = delta.end.row;
                  if (row === endRow) {
                      docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
                  }
                  else {
                      docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
                  }
                  break;
          }
      };
  });
  ace.define("ace/anchor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function (acequire, exports, module) {
      var oop = acequire("./lib/oop");
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var Anchor = exports.Anchor = function (doc, row, column) {
          this.$onChange = this.onChange.bind(this);
          this.attach(doc);
          if (typeof column == "undefined")
              this.setPosition(row.row, row.column);
          else
              this.setPosition(row, column);
      };
      (function () {
          oop.implement(this, EventEmitter);
          this.getPosition = function () {
              return this.$clipPositionToDocument(this.row, this.column);
          };
          this.getDocument = function () {
              return this.document;
          };
          this.$insertRight = false;
          this.onChange = function (delta) {
              if (delta.start.row == delta.end.row && delta.start.row != this.row)
                  return;
              if (delta.start.row > this.row)
                  return;
              var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);
              this.setPosition(point.row, point.column, true);
          };
          function $pointsInOrder(point1, point2, equalPointsInOrder) {
              var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
              return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);
          }
          function $getTransformedPoint(delta, point, moveIfEqual) {
              var deltaIsInsert = delta.action == "insert";
              var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
              var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
              var deltaStart = delta.start;
              var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
              if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
                  return {
                      row: point.row,
                      column: point.column
                  };
              }
              if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
                  return {
                      row: point.row + deltaRowShift,
                      column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
                  };
              }
              return {
                  row: deltaStart.row,
                  column: deltaStart.column
              };
          }
          this.setPosition = function (row, column, noClip) {
              var pos;
              if (noClip) {
                  pos = {
                      row: row,
                      column: column
                  };
              }
              else {
                  pos = this.$clipPositionToDocument(row, column);
              }
              if (this.row == pos.row && this.column == pos.column)
                  return;
              var old = {
                  row: this.row,
                  column: this.column
              };
              this.row = pos.row;
              this.column = pos.column;
              this._signal("change", {
                  old: old,
                  value: pos
              });
          };
          this.detach = function () {
              this.document.removeEventListener("change", this.$onChange);
          };
          this.attach = function (doc) {
              this.document = doc || this.document;
              this.document.on("change", this.$onChange);
          };
          this.$clipPositionToDocument = function (row, column) {
              var pos = {};
              if (row >= this.document.getLength()) {
                  pos.row = Math.max(0, this.document.getLength() - 1);
                  pos.column = this.document.getLine(pos.row).length;
              }
              else if (row < 0) {
                  pos.row = 0;
                  pos.column = 0;
              }
              else {
                  pos.row = row;
                  pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
              }
              if (column < 0)
                  pos.column = 0;
              return pos;
          };
      }).call(Anchor.prototype);
  });
  ace.define("ace/document", ["require", "exports", "module", "ace/lib/oop", "ace/apply_delta", "ace/lib/event_emitter", "ace/range", "ace/anchor"], function (acequire, exports, module) {
      var oop = acequire("./lib/oop");
      var applyDelta = acequire("./apply_delta").applyDelta;
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var Range = acequire("./range").Range;
      var Anchor = acequire("./anchor").Anchor;
      var Document = function (textOrLines) {
          this.$lines = [""];
          if (textOrLines.length === 0) {
              this.$lines = [""];
          }
          else if (Array.isArray(textOrLines)) {
              this.insertMergedLines({ row: 0, column: 0 }, textOrLines);
          }
          else {
              this.insert({ row: 0, column: 0 }, textOrLines);
          }
      };
      (function () {
          oop.implement(this, EventEmitter);
          this.setValue = function (text) {
              var len = this.getLength() - 1;
              this.remove(new Range(0, 0, len, this.getLine(len).length));
              this.insert({ row: 0, column: 0 }, text);
          };
          this.getValue = function () {
              return this.getAllLines().join(this.getNewLineCharacter());
          };
          this.createAnchor = function (row, column) {
              return new Anchor(this, row, column);
          };
          if ("aaa".split(/a/).length === 0) {
              this.$split = function (text) {
                  return text.replace(/\r\n|\r/g, "\n").split("\n");
              };
          }
          else {
              this.$split = function (text) {
                  return text.split(/\r\n|\r|\n/);
              };
          }
          this.$detectNewLine = function (text) {
              var match = text.match(/^.*?(\r\n|\r|\n)/m);
              this.$autoNewLine = match ? match[1] : "\n";
              this._signal("changeNewLineMode");
          };
          this.getNewLineCharacter = function () {
              switch (this.$newLineMode) {
                  case "windows":
                      return "\r\n";
                  case "unix":
                      return "\n";
                  default:
                      return this.$autoNewLine || "\n";
              }
          };
          this.$autoNewLine = "";
          this.$newLineMode = "auto";
          this.setNewLineMode = function (newLineMode) {
              if (this.$newLineMode === newLineMode)
                  return;
              this.$newLineMode = newLineMode;
              this._signal("changeNewLineMode");
          };
          this.getNewLineMode = function () {
              return this.$newLineMode;
          };
          this.isNewLine = function (text) {
              return (text == "\r\n" || text == "\r" || text == "\n");
          };
          this.getLine = function (row) {
              return this.$lines[row] || "";
          };
          this.getLines = function (firstRow, lastRow) {
              return this.$lines.slice(firstRow, lastRow + 1);
          };
          this.getAllLines = function () {
              return this.getLines(0, this.getLength());
          };
          this.getLength = function () {
              return this.$lines.length;
          };
          this.getTextRange = function (range) {
              return this.getLinesForRange(range).join(this.getNewLineCharacter());
          };
          this.getLinesForRange = function (range) {
              var lines;
              if (range.start.row === range.end.row) {
                  lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
              }
              else {
                  lines = this.getLines(range.start.row, range.end.row);
                  lines[0] = (lines[0] || "").substring(range.start.column);
                  var l = lines.length - 1;
                  if (range.end.row - range.start.row == l)
                      lines[l] = lines[l].substring(0, range.end.column);
              }
              return lines;
          };
          this.insertLines = function (row, lines) {
              console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
              return this.insertFullLines(row, lines);
          };
          this.removeLines = function (firstRow, lastRow) {
              console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
              return this.removeFullLines(firstRow, lastRow);
          };
          this.insertNewLine = function (position) {
              console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
              return this.insertMergedLines(position, ["", ""]);
          };
          this.insert = function (position, text) {
              if (this.getLength() <= 1)
                  this.$detectNewLine(text);
              return this.insertMergedLines(position, this.$split(text));
          };
          this.insertInLine = function (position, text) {
              var start = this.clippedPos(position.row, position.column);
              var end = this.pos(position.row, position.column + text.length);
              this.applyDelta({
                  start: start,
                  end: end,
                  action: "insert",
                  lines: [text]
              }, true);
              return this.clonePos(end);
          };
          this.clippedPos = function (row, column) {
              var length = this.getLength();
              if (row === undefined) {
                  row = length;
              }
              else if (row < 0) {
                  row = 0;
              }
              else if (row >= length) {
                  row = length - 1;
                  column = undefined;
              }
              var line = this.getLine(row);
              if (column == undefined)
                  column = line.length;
              column = Math.min(Math.max(column, 0), line.length);
              return { row: row, column: column };
          };
          this.clonePos = function (pos) {
              return { row: pos.row, column: pos.column };
          };
          this.pos = function (row, column) {
              return { row: row, column: column };
          };
          this.$clipPosition = function (position) {
              var length = this.getLength();
              if (position.row >= length) {
                  position.row = Math.max(0, length - 1);
                  position.column = this.getLine(length - 1).length;
              }
              else {
                  position.row = Math.max(0, position.row);
                  position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
              }
              return position;
          };
          this.insertFullLines = function (row, lines) {
              row = Math.min(Math.max(row, 0), this.getLength());
              var column = 0;
              if (row < this.getLength()) {
                  lines = lines.concat([""]);
                  column = 0;
              }
              else {
                  lines = [""].concat(lines);
                  row--;
                  column = this.$lines[row].length;
              }
              this.insertMergedLines({ row: row, column: column }, lines);
          };
          this.insertMergedLines = function (position, lines) {
              var start = this.clippedPos(position.row, position.column);
              var end = {
                  row: start.row + lines.length - 1,
                  column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
              };
              this.applyDelta({
                  start: start,
                  end: end,
                  action: "insert",
                  lines: lines
              });
              return this.clonePos(end);
          };
          this.remove = function (range) {
              var start = this.clippedPos(range.start.row, range.start.column);
              var end = this.clippedPos(range.end.row, range.end.column);
              this.applyDelta({
                  start: start,
                  end: end,
                  action: "remove",
                  lines: this.getLinesForRange({ start: start, end: end })
              });
              return this.clonePos(start);
          };
          this.removeInLine = function (row, startColumn, endColumn) {
              var start = this.clippedPos(row, startColumn);
              var end = this.clippedPos(row, endColumn);
              this.applyDelta({
                  start: start,
                  end: end,
                  action: "remove",
                  lines: this.getLinesForRange({ start: start, end: end })
              }, true);
              return this.clonePos(start);
          };
          this.removeFullLines = function (firstRow, lastRow) {
              firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
              lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
              var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
              var deleteLastNewLine = lastRow < this.getLength() - 1;
              var startRow = (deleteFirstNewLine ? firstRow - 1 : firstRow);
              var startCol = (deleteFirstNewLine ? this.getLine(startRow).length : 0);
              var endRow = (deleteLastNewLine ? lastRow + 1 : lastRow);
              var endCol = (deleteLastNewLine ? 0 : this.getLine(endRow).length);
              var range = new Range(startRow, startCol, endRow, endCol);
              var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
              this.applyDelta({
                  start: range.start,
                  end: range.end,
                  action: "remove",
                  lines: this.getLinesForRange(range)
              });
              return deletedLines;
          };
          this.removeNewLine = function (row) {
              if (row < this.getLength() - 1 && row >= 0) {
                  this.applyDelta({
                      start: this.pos(row, this.getLine(row).length),
                      end: this.pos(row + 1, 0),
                      action: "remove",
                      lines: ["", ""]
                  });
              }
          };
          this.replace = function (range, text) {
              if (!(range instanceof Range))
                  range = Range.fromPoints(range.start, range.end);
              if (text.length === 0 && range.isEmpty())
                  return range.start;
              if (text == this.getTextRange(range))
                  return range.end;
              this.remove(range);
              var end;
              if (text) {
                  end = this.insert(range.start, text);
              }
              else {
                  end = range.start;
              }
              return end;
          };
          this.applyDeltas = function (deltas) {
              for (var i = 0; i < deltas.length; i++) {
                  this.applyDelta(deltas[i]);
              }
          };
          this.revertDeltas = function (deltas) {
              for (var i = deltas.length - 1; i >= 0; i--) {
                  this.revertDelta(deltas[i]);
              }
          };
          this.applyDelta = function (delta, doNotValidate) {
              var isInsert = delta.action == "insert";
              if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]
                  : !Range.comparePoints(delta.start, delta.end)) {
                  return;
              }
              if (isInsert && delta.lines.length > 20000)
                  this.$splitAndapplyLargeDelta(delta, 20000);
              applyDelta(this.$lines, delta, doNotValidate);
              this._signal("change", delta);
          };
          this.$splitAndapplyLargeDelta = function (delta, MAX) {
              var lines = delta.lines;
              var l = lines.length;
              var row = delta.start.row;
              var column = delta.start.column;
              var from = 0, to = 0;
              do {
                  from = to;
                  to += MAX - 1;
                  var chunk = lines.slice(from, to);
                  if (to > l) {
                      delta.lines = chunk;
                      delta.start.row = row + from;
                      delta.start.column = column;
                      break;
                  }
                  chunk.push("");
                  this.applyDelta({
                      start: this.pos(row + from, column),
                      end: this.pos(row + to, column = 0),
                      action: delta.action,
                      lines: chunk
                  }, true);
              } while (true);
          };
          this.revertDelta = function (delta) {
              this.applyDelta({
                  start: this.clonePos(delta.start),
                  end: this.clonePos(delta.end),
                  action: (delta.action == "insert" ? "remove" : "insert"),
                  lines: delta.lines.slice()
              });
          };
          this.indexToPosition = function (index, startRow) {
              var lines = this.$lines || this.getAllLines();
              var newlineLength = this.getNewLineCharacter().length;
              for (var i = startRow || 0, l = lines.length; i < l; i++) {
                  index -= lines[i].length + newlineLength;
                  if (index < 0)
                      return { row: i, column: index + lines[i].length + newlineLength };
              }
              return { row: l - 1, column: lines[l - 1].length };
          };
          this.positionToIndex = function (pos, startRow) {
              var lines = this.$lines || this.getAllLines();
              var newlineLength = this.getNewLineCharacter().length;
              var index = 0;
              var row = Math.min(pos.row, lines.length);
              for (var i = startRow || 0; i < row; ++i)
                  index += lines[i].length + newlineLength;
              return index + pos.column;
          };
      }).call(Document.prototype);
      exports.Document = Document;
  });
  ace.define("ace/background_tokenizer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function (acequire, exports, module) {
      var oop = acequire("./lib/oop");
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var BackgroundTokenizer = function (tokenizer, editor) {
          this.running = false;
          this.lines = [];
          this.states = [];
          this.currentLine = 0;
          this.tokenizer = tokenizer;
          var self = this;
          this.$worker = function () {
              if (!self.running) {
                  return;
              }
              var workerStart = new Date();
              var currentLine = self.currentLine;
              var endLine = -1;
              var doc = self.doc;
              var startLine = currentLine;
              while (self.lines[currentLine])
                  currentLine++;
              var len = doc.getLength();
              var processedLines = 0;
              self.running = false;
              while (currentLine < len) {
                  self.$tokenizeRow(currentLine);
                  endLine = currentLine;
                  do {
                      currentLine++;
                  } while (self.lines[currentLine]);
                  processedLines++;
                  if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {
                      self.running = setTimeout(self.$worker, 20);
                      break;
                  }
              }
              self.currentLine = currentLine;
              if (endLine == -1)
                  endLine = currentLine;
              if (startLine <= endLine)
                  self.fireUpdateEvent(startLine, endLine);
          };
      };
      (function () {
          oop.implement(this, EventEmitter);
          this.setTokenizer = function (tokenizer) {
              this.tokenizer = tokenizer;
              this.lines = [];
              this.states = [];
              this.start(0);
          };
          this.setDocument = function (doc) {
              this.doc = doc;
              this.lines = [];
              this.states = [];
              this.stop();
          };
          this.fireUpdateEvent = function (firstRow, lastRow) {
              var data = {
                  first: firstRow,
                  last: lastRow
              };
              this._signal("update", { data: data });
          };
          this.start = function (startRow) {
              this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
              this.lines.splice(this.currentLine, this.lines.length);
              this.states.splice(this.currentLine, this.states.length);
              this.stop();
              this.running = setTimeout(this.$worker, 700);
          };
          this.scheduleStart = function () {
              if (!this.running)
                  this.running = setTimeout(this.$worker, 700);
          };
          this.$updateOnChange = function (delta) {
              var startRow = delta.start.row;
              var len = delta.end.row - startRow;
              if (len === 0) {
                  this.lines[startRow] = null;
              }
              else if (delta.action == "remove") {
                  this.lines.splice(startRow, len + 1, null);
                  this.states.splice(startRow, len + 1, null);
              }
              else {
                  var args = Array(len + 1);
                  args.unshift(startRow, 1);
                  this.lines.splice.apply(this.lines, args);
                  this.states.splice.apply(this.states, args);
              }
              this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
              this.stop();
          };
          this.stop = function () {
              if (this.running)
                  clearTimeout(this.running);
              this.running = false;
          };
          this.getTokens = function (row) {
              return this.lines[row] || this.$tokenizeRow(row);
          };
          this.getState = function (row) {
              if (this.currentLine == row)
                  this.$tokenizeRow(row);
              return this.states[row] || "start";
          };
          this.$tokenizeRow = function (row) {
              var line = this.doc.getLine(row);
              var state = this.states[row - 1];
              var data = this.tokenizer.getLineTokens(line, state, row);
              if (this.states[row] + "" !== data.state + "") {
                  this.states[row] = data.state;
                  this.lines[row + 1] = null;
                  if (this.currentLine > row + 1)
                      this.currentLine = row + 1;
              }
              else if (this.currentLine == row) {
                  this.currentLine = row + 1;
              }
              return this.lines[row] = data.tokens;
          };
      }).call(BackgroundTokenizer.prototype);
      exports.BackgroundTokenizer = BackgroundTokenizer;
  });
  ace.define("ace/search_highlight", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function (acequire, exports, module) {
      var lang = acequire("./lib/lang");
      var oop = acequire("./lib/oop");
      var Range = acequire("./range").Range;
      var SearchHighlight = function (regExp, clazz, type) {
          this.setRegexp(regExp);
          this.clazz = clazz;
          this.type = type || "text";
      };
      (function () {
          this.MAX_RANGES = 500;
          this.setRegexp = function (regExp) {
              if (this.regExp + "" == regExp + "")
                  return;
              this.regExp = regExp;
              this.cache = [];
          };
          this.update = function (html, markerLayer, session, config) {
              if (!this.regExp)
                  return;
              var start = config.firstRow, end = config.lastRow;
              for (var i = start; i <= end; i++) {
                  var ranges = this.cache[i];
                  if (ranges == null) {
                      ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                      if (ranges.length > this.MAX_RANGES)
                          ranges = ranges.slice(0, this.MAX_RANGES);
                      ranges = ranges.map(function (match) {
                          return new Range(i, match.offset, i, match.offset + match.length);
                      });
                      this.cache[i] = ranges.length ? ranges : "";
                  }
                  for (var j = ranges.length; j--;) {
                      markerLayer.drawSingleLineMarker(html, ranges[j].toScreenRange(session), this.clazz, config);
                  }
              }
          };
      }).call(SearchHighlight.prototype);
      exports.SearchHighlight = SearchHighlight;
  });
  ace.define("ace/edit_session/fold_line", ["require", "exports", "module", "ace/range"], function (acequire, exports, module) {
      var Range = acequire("../range").Range;
      function FoldLine(foldData, folds) {
          this.foldData = foldData;
          if (Array.isArray(folds)) {
              this.folds = folds;
          }
          else {
              folds = this.folds = [folds];
          }
          var last = folds[folds.length - 1];
          this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
          this.start = this.range.start;
          this.end = this.range.end;
          this.folds.forEach(function (fold) {
              fold.setFoldLine(this);
          }, this);
      }
      (function () {
          this.shiftRow = function (shift) {
              this.start.row += shift;
              this.end.row += shift;
              this.folds.forEach(function (fold) {
                  fold.start.row += shift;
                  fold.end.row += shift;
              });
          };
          this.addFold = function (fold) {
              if (fold.sameRow) {
                  if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                      throw new Error("Can't add a fold to this FoldLine as it has no connection");
                  }
                  this.folds.push(fold);
                  this.folds.sort(function (a, b) {
                      return -a.range.compareEnd(b.start.row, b.start.column);
                  });
                  if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                      this.end.row = fold.end.row;
                      this.end.column = fold.end.column;
                  }
                  else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                      this.start.row = fold.start.row;
                      this.start.column = fold.start.column;
                  }
              }
              else if (fold.start.row == this.end.row) {
                  this.folds.push(fold);
                  this.end.row = fold.end.row;
                  this.end.column = fold.end.column;
              }
              else if (fold.end.row == this.start.row) {
                  this.folds.unshift(fold);
                  this.start.row = fold.start.row;
                  this.start.column = fold.start.column;
              }
              else {
                  throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
              }
              fold.foldLine = this;
          };
          this.containsRow = function (row) {
              return row >= this.start.row && row <= this.end.row;
          };
          this.walk = function (callback, endRow, endColumn) {
              var lastEnd = 0, folds = this.folds, fold, cmp, stop, isNewRow = true;
              if (endRow == null) {
                  endRow = this.end.row;
                  endColumn = this.end.column;
              }
              for (var i = 0; i < folds.length; i++) {
                  fold = folds[i];
                  cmp = fold.range.compareStart(endRow, endColumn);
                  if (cmp == -1) {
                      callback(null, endRow, endColumn, lastEnd, isNewRow);
                      return;
                  }
                  stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
                  stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
                  if (stop || cmp === 0) {
                      return;
                  }
                  isNewRow = !fold.sameRow;
                  lastEnd = fold.end.column;
              }
              callback(null, endRow, endColumn, lastEnd, isNewRow);
          };
          this.getNextFoldTo = function (row, column) {
              var fold, cmp;
              for (var i = 0; i < this.folds.length; i++) {
                  fold = this.folds[i];
                  cmp = fold.range.compareEnd(row, column);
                  if (cmp == -1) {
                      return {
                          fold: fold,
                          kind: "after"
                      };
                  }
                  else if (cmp === 0) {
                      return {
                          fold: fold,
                          kind: "inside"
                      };
                  }
              }
              return null;
          };
          this.addRemoveChars = function (row, column, len) {
              var ret = this.getNextFoldTo(row, column), fold, folds;
              if (ret) {
                  fold = ret.fold;
                  if (ret.kind == "inside"
                      && fold.start.column != column
                      && fold.start.row != row) {
                      window.console && window.console.log(row, column, fold);
                  }
                  else if (fold.start.row == row) {
                      folds = this.folds;
                      var i = folds.indexOf(fold);
                      if (i === 0) {
                          this.start.column += len;
                      }
                      for (i; i < folds.length; i++) {
                          fold = folds[i];
                          fold.start.column += len;
                          if (!fold.sameRow) {
                              return;
                          }
                          fold.end.column += len;
                      }
                      this.end.column += len;
                  }
              }
          };
          this.split = function (row, column) {
              var pos = this.getNextFoldTo(row, column);
              if (!pos || pos.kind == "inside")
                  return null;
              var fold = pos.fold;
              var folds = this.folds;
              var foldData = this.foldData;
              var i = folds.indexOf(fold);
              var foldBefore = folds[i - 1];
              this.end.row = foldBefore.end.row;
              this.end.column = foldBefore.end.column;
              folds = folds.splice(i, folds.length - i);
              var newFoldLine = new FoldLine(foldData, folds);
              foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
              return newFoldLine;
          };
          this.merge = function (foldLineNext) {
              var folds = foldLineNext.folds;
              for (var i = 0; i < folds.length; i++) {
                  this.addFold(folds[i]);
              }
              var foldData = this.foldData;
              foldData.splice(foldData.indexOf(foldLineNext), 1);
          };
          this.toString = function () {
              var ret = [this.range.toString() + ": ["];
              this.folds.forEach(function (fold) {
                  ret.push("  " + fold.toString());
              });
              ret.push("]");
              return ret.join("\n");
          };
          this.idxToPosition = function (idx) {
              var lastFoldEndColumn = 0;
              for (var i = 0; i < this.folds.length; i++) {
                  var fold = this.folds[i];
                  idx -= fold.start.column - lastFoldEndColumn;
                  if (idx < 0) {
                      return {
                          row: fold.start.row,
                          column: fold.start.column + idx
                      };
                  }
                  idx -= fold.placeholder.length;
                  if (idx < 0) {
                      return fold.start;
                  }
                  lastFoldEndColumn = fold.end.column;
              }
              return {
                  row: this.end.row,
                  column: this.end.column + idx
              };
          };
      }).call(FoldLine.prototype);
      exports.FoldLine = FoldLine;
  });
  ace.define("ace/range_list", ["require", "exports", "module", "ace/range"], function (acequire, exports, module) {
      var Range = acequire("./range").Range;
      var comparePoints = Range.comparePoints;
      var RangeList = function () {
          this.ranges = [];
      };
      (function () {
          this.comparePoints = comparePoints;
          this.pointIndex = function (pos, excludeEdges, startIndex) {
              var list = this.ranges;
              for (var i = startIndex || 0; i < list.length; i++) {
                  var range = list[i];
                  var cmpEnd = comparePoints(pos, range.end);
                  if (cmpEnd > 0)
                      continue;
                  var cmpStart = comparePoints(pos, range.start);
                  if (cmpEnd === 0)
                      return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
                  if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
                      return i;
                  return -i - 1;
              }
              return -i - 1;
          };
          this.add = function (range) {
              var excludeEdges = !range.isEmpty();
              var startIndex = this.pointIndex(range.start, excludeEdges);
              if (startIndex < 0)
                  startIndex = -startIndex - 1;
              var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
              if (endIndex < 0)
                  endIndex = -endIndex - 1;
              else
                  endIndex++;
              return this.ranges.splice(startIndex, endIndex - startIndex, range);
          };
          this.addList = function (list) {
              var removed = [];
              for (var i = list.length; i--;) {
                  removed.push.apply(removed, this.add(list[i]));
              }
              return removed;
          };
          this.substractPoint = function (pos) {
              var i = this.pointIndex(pos);
              if (i >= 0)
                  return this.ranges.splice(i, 1);
          };
          this.merge = function () {
              var removed = [];
              var list = this.ranges;
              list = list.sort(function (a, b) {
                  return comparePoints(a.start, b.start);
              });
              var next = list[0], range;
              for (var i = 1; i < list.length; i++) {
                  range = next;
                  next = list[i];
                  var cmp = comparePoints(range.end, next.start);
                  if (cmp < 0)
                      continue;
                  if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
                      continue;
                  if (comparePoints(range.end, next.end) < 0) {
                      range.end.row = next.end.row;
                      range.end.column = next.end.column;
                  }
                  list.splice(i, 1);
                  removed.push(next);
                  next = range;
                  i--;
              }
              this.ranges = list;
              return removed;
          };
          this.contains = function (row, column) {
              return this.pointIndex({ row: row, column: column }) >= 0;
          };
          this.containsPoint = function (pos) {
              return this.pointIndex(pos) >= 0;
          };
          this.rangeAtPoint = function (pos) {
              var i = this.pointIndex(pos);
              if (i >= 0)
                  return this.ranges[i];
          };
          this.clipRows = function (startRow, endRow) {
              var list = this.ranges;
              if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
                  return [];
              var startIndex = this.pointIndex({ row: startRow, column: 0 });
              if (startIndex < 0)
                  startIndex = -startIndex - 1;
              var endIndex = this.pointIndex({ row: endRow, column: 0 }, startIndex);
              if (endIndex < 0)
                  endIndex = -endIndex - 1;
              var clipped = [];
              for (var i = startIndex; i < endIndex; i++) {
                  clipped.push(list[i]);
              }
              return clipped;
          };
          this.removeAll = function () {
              return this.ranges.splice(0, this.ranges.length);
          };
          this.attach = function (session) {
              if (this.session)
                  this.detach();
              this.session = session;
              this.onChange = this.$onChange.bind(this);
              this.session.on('change', this.onChange);
          };
          this.detach = function () {
              if (!this.session)
                  return;
              this.session.removeListener('change', this.onChange);
              this.session = null;
          };
          this.$onChange = function (delta) {
              if (delta.action == "insert") {
                  var start = delta.start;
                  var end = delta.end;
              }
              else {
                  var end = delta.start;
                  var start = delta.end;
              }
              var startRow = start.row;
              var endRow = end.row;
              var lineDif = endRow - startRow;
              var colDiff = -start.column + end.column;
              var ranges = this.ranges;
              for (var i = 0, n = ranges.length; i < n; i++) {
                  var r = ranges[i];
                  if (r.end.row < startRow)
                      continue;
                  if (r.start.row > startRow)
                      break;
                  if (r.start.row == startRow && r.start.column >= start.column) {
                      if (r.start.column == start.column && this.$insertRight) ;
                      else {
                          r.start.column += colDiff;
                          r.start.row += lineDif;
                      }
                  }
                  if (r.end.row == startRow && r.end.column >= start.column) {
                      if (r.end.column == start.column && this.$insertRight) {
                          continue;
                      }
                      if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                          if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column)
                              r.end.column -= colDiff;
                      }
                      r.end.column += colDiff;
                      r.end.row += lineDif;
                  }
              }
              if (lineDif != 0 && i < n) {
                  for (; i < n; i++) {
                      var r = ranges[i];
                      r.start.row += lineDif;
                      r.end.row += lineDif;
                  }
              }
          };
      }).call(RangeList.prototype);
      exports.RangeList = RangeList;
  });
  ace.define("ace/edit_session/fold", ["require", "exports", "module", "ace/range", "ace/range_list", "ace/lib/oop"], function (acequire, exports, module) {
      var Range = acequire("../range").Range;
      var RangeList = acequire("../range_list").RangeList;
      var oop = acequire("../lib/oop");
      var Fold = exports.Fold = function (range, placeholder) {
          this.foldLine = null;
          this.placeholder = placeholder;
          this.range = range;
          this.start = range.start;
          this.end = range.end;
          this.sameRow = range.start.row == range.end.row;
          this.subFolds = this.ranges = [];
      };
      oop.inherits(Fold, RangeList);
      (function () {
          this.toString = function () {
              return '"' + this.placeholder + '" ' + this.range.toString();
          };
          this.setFoldLine = function (foldLine) {
              this.foldLine = foldLine;
              this.subFolds.forEach(function (fold) {
                  fold.setFoldLine(foldLine);
              });
          };
          this.clone = function () {
              var range = this.range.clone();
              var fold = new Fold(range, this.placeholder);
              this.subFolds.forEach(function (subFold) {
                  fold.subFolds.push(subFold.clone());
              });
              fold.collapseChildren = this.collapseChildren;
              return fold;
          };
          this.addSubFold = function (fold) {
              if (this.range.isEqual(fold))
                  return;
              if (!this.range.containsRange(fold))
                  throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
              consumeRange(fold, this.start);
              var row = fold.start.row, column = fold.start.column;
              for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
                  cmp = this.subFolds[i].range.compare(row, column);
                  if (cmp != 1)
                      break;
              }
              var afterStart = this.subFolds[i];
              if (cmp == 0)
                  return afterStart.addSubFold(fold);
              var row = fold.range.end.row, column = fold.range.end.column;
              for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
                  cmp = this.subFolds[j].range.compare(row, column);
                  if (cmp != 1)
                      break;
              }
              var afterEnd = this.subFolds[j];
              if (cmp == 0)
                  throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
              var consumedFolds = this.subFolds.splice(i, j - i, fold);
              fold.setFoldLine(this.foldLine);
              return fold;
          };
          this.restoreRange = function (range) {
              return restoreRange(range, this.start);
          };
      }).call(Fold.prototype);
      function consumePoint(point, anchor) {
          point.row -= anchor.row;
          if (point.row == 0)
              point.column -= anchor.column;
      }
      function consumeRange(range, anchor) {
          consumePoint(range.start, anchor);
          consumePoint(range.end, anchor);
      }
      function restorePoint(point, anchor) {
          if (point.row == 0)
              point.column += anchor.column;
          point.row += anchor.row;
      }
      function restoreRange(range, anchor) {
          restorePoint(range.start, anchor);
          restorePoint(range.end, anchor);
      }
  });
  ace.define("ace/edit_session/folding", ["require", "exports", "module", "ace/range", "ace/edit_session/fold_line", "ace/edit_session/fold", "ace/token_iterator"], function (acequire, exports, module) {
      var Range = acequire("../range").Range;
      var FoldLine = acequire("./fold_line").FoldLine;
      var Fold = acequire("./fold").Fold;
      var TokenIterator = acequire("../token_iterator").TokenIterator;
      function Folding() {
          this.getFoldAt = function (row, column, side) {
              var foldLine = this.getFoldLine(row);
              if (!foldLine)
                  return null;
              var folds = foldLine.folds;
              for (var i = 0; i < folds.length; i++) {
                  var fold = folds[i];
                  if (fold.range.contains(row, column)) {
                      if (side == 1 && fold.range.isEnd(row, column)) {
                          continue;
                      }
                      else if (side == -1 && fold.range.isStart(row, column)) {
                          continue;
                      }
                      return fold;
                  }
              }
          };
          this.getFoldsInRange = function (range) {
              var start = range.start;
              var end = range.end;
              var foldLines = this.$foldData;
              var foundFolds = [];
              start.column += 1;
              end.column -= 1;
              for (var i = 0; i < foldLines.length; i++) {
                  var cmp = foldLines[i].range.compareRange(range);
                  if (cmp == 2) {
                      continue;
                  }
                  else if (cmp == -2) {
                      break;
                  }
                  var folds = foldLines[i].folds;
                  for (var j = 0; j < folds.length; j++) {
                      var fold = folds[j];
                      cmp = fold.range.compareRange(range);
                      if (cmp == -2) {
                          break;
                      }
                      else if (cmp == 2) {
                          continue;
                      }
                      else if (cmp == 42) {
                          break;
                      }
                      foundFolds.push(fold);
                  }
              }
              start.column -= 1;
              end.column += 1;
              return foundFolds;
          };
          this.getFoldsInRangeList = function (ranges) {
              if (Array.isArray(ranges)) {
                  var folds = [];
                  ranges.forEach(function (range) {
                      folds = folds.concat(this.getFoldsInRange(range));
                  }, this);
              }
              else {
                  var folds = this.getFoldsInRange(ranges);
              }
              return folds;
          };
          this.getAllFolds = function () {
              var folds = [];
              var foldLines = this.$foldData;
              for (var i = 0; i < foldLines.length; i++)
                  for (var j = 0; j < foldLines[i].folds.length; j++)
                      folds.push(foldLines[i].folds[j]);
              return folds;
          };
          this.getFoldStringAt = function (row, column, trim, foldLine) {
              foldLine = foldLine || this.getFoldLine(row);
              if (!foldLine)
                  return null;
              var lastFold = {
                  end: { column: 0 }
              };
              var str, fold;
              for (var i = 0; i < foldLine.folds.length; i++) {
                  fold = foldLine.folds[i];
                  var cmp = fold.range.compareEnd(row, column);
                  if (cmp == -1) {
                      str = this
                          .getLine(fold.start.row)
                          .substring(lastFold.end.column, fold.start.column);
                      break;
                  }
                  else if (cmp === 0) {
                      return null;
                  }
                  lastFold = fold;
              }
              if (!str)
                  str = this.getLine(fold.start.row).substring(lastFold.end.column);
              if (trim == -1)
                  return str.substring(0, column - lastFold.end.column);
              else if (trim == 1)
                  return str.substring(column - lastFold.end.column);
              else
                  return str;
          };
          this.getFoldLine = function (docRow, startFoldLine) {
              var foldData = this.$foldData;
              var i = 0;
              if (startFoldLine)
                  i = foldData.indexOf(startFoldLine);
              if (i == -1)
                  i = 0;
              for (i; i < foldData.length; i++) {
                  var foldLine = foldData[i];
                  if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
                      return foldLine;
                  }
                  else if (foldLine.end.row > docRow) {
                      return null;
                  }
              }
              return null;
          };
          this.getNextFoldLine = function (docRow, startFoldLine) {
              var foldData = this.$foldData;
              var i = 0;
              if (startFoldLine)
                  i = foldData.indexOf(startFoldLine);
              if (i == -1)
                  i = 0;
              for (i; i < foldData.length; i++) {
                  var foldLine = foldData[i];
                  if (foldLine.end.row >= docRow) {
                      return foldLine;
                  }
              }
              return null;
          };
          this.getFoldedRowCount = function (first, last) {
              var foldData = this.$foldData, rowCount = last - first + 1;
              for (var i = 0; i < foldData.length; i++) {
                  var foldLine = foldData[i], end = foldLine.end.row, start = foldLine.start.row;
                  if (end >= last) {
                      if (start < last) {
                          if (start >= first)
                              rowCount -= last - start;
                          else
                              rowCount = 0; // in one fold
                      }
                      break;
                  }
                  else if (end >= first) {
                      if (start >= first) // fold inside range
                          rowCount -= end - start;
                      else
                          rowCount -= end - first + 1;
                  }
              }
              return rowCount;
          };
          this.$addFoldLine = function (foldLine) {
              this.$foldData.push(foldLine);
              this.$foldData.sort(function (a, b) {
                  return a.start.row - b.start.row;
              });
              return foldLine;
          };
          this.addFold = function (placeholder, range) {
              var foldData = this.$foldData;
              var added = false;
              var fold;
              if (placeholder instanceof Fold)
                  fold = placeholder;
              else {
                  fold = new Fold(range, placeholder);
                  fold.collapseChildren = range.collapseChildren;
              }
              this.$clipRangeToDocument(fold.range);
              var startRow = fold.start.row;
              var startColumn = fold.start.column;
              var endRow = fold.end.row;
              var endColumn = fold.end.column;
              if (!(startRow < endRow ||
                  startRow == endRow && startColumn <= endColumn - 2))
                  throw new Error("The range has to be at least 2 characters width");
              var startFold = this.getFoldAt(startRow, startColumn, 1);
              var endFold = this.getFoldAt(endRow, endColumn, -1);
              if (startFold && endFold == startFold)
                  return startFold.addSubFold(fold);
              if (startFold && !startFold.range.isStart(startRow, startColumn))
                  this.removeFold(startFold);
              if (endFold && !endFold.range.isEnd(endRow, endColumn))
                  this.removeFold(endFold);
              var folds = this.getFoldsInRange(fold.range);
              if (folds.length > 0) {
                  this.removeFolds(folds);
                  folds.forEach(function (subFold) {
                      fold.addSubFold(subFold);
                  });
              }
              for (var i = 0; i < foldData.length; i++) {
                  var foldLine = foldData[i];
                  if (endRow == foldLine.start.row) {
                      foldLine.addFold(fold);
                      added = true;
                      break;
                  }
                  else if (startRow == foldLine.end.row) {
                      foldLine.addFold(fold);
                      added = true;
                      if (!fold.sameRow) {
                          var foldLineNext = foldData[i + 1];
                          if (foldLineNext && foldLineNext.start.row == endRow) {
                              foldLine.merge(foldLineNext);
                              break;
                          }
                      }
                      break;
                  }
                  else if (endRow <= foldLine.start.row) {
                      break;
                  }
              }
              if (!added)
                  foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));
              if (this.$useWrapMode)
                  this.$updateWrapData(foldLine.start.row, foldLine.start.row);
              else
                  this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
              this.$modified = true;
              this._signal("changeFold", { data: fold, action: "add" });
              return fold;
          };
          this.addFolds = function (folds) {
              folds.forEach(function (fold) {
                  this.addFold(fold);
              }, this);
          };
          this.removeFold = function (fold) {
              var foldLine = fold.foldLine;
              var startRow = foldLine.start.row;
              var endRow = foldLine.end.row;
              var foldLines = this.$foldData;
              var folds = foldLine.folds;
              if (folds.length == 1) {
                  foldLines.splice(foldLines.indexOf(foldLine), 1);
              }
              else if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
                  folds.pop();
                  foldLine.end.row = folds[folds.length - 1].end.row;
                  foldLine.end.column = folds[folds.length - 1].end.column;
              }
              else if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
                  folds.shift();
                  foldLine.start.row = folds[0].start.row;
                  foldLine.start.column = folds[0].start.column;
              }
              else if (fold.sameRow) {
                  folds.splice(folds.indexOf(fold), 1);
              }
              else {
                  var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
                  folds = newFoldLine.folds;
                  folds.shift();
                  newFoldLine.start.row = folds[0].start.row;
                  newFoldLine.start.column = folds[0].start.column;
              }
              if (!this.$updating) {
                  if (this.$useWrapMode)
                      this.$updateWrapData(startRow, endRow);
                  else
                      this.$updateRowLengthCache(startRow, endRow);
              }
              this.$modified = true;
              this._signal("changeFold", { data: fold, action: "remove" });
          };
          this.removeFolds = function (folds) {
              var cloneFolds = [];
              for (var i = 0; i < folds.length; i++) {
                  cloneFolds.push(folds[i]);
              }
              cloneFolds.forEach(function (fold) {
                  this.removeFold(fold);
              }, this);
              this.$modified = true;
          };
          this.expandFold = function (fold) {
              this.removeFold(fold);
              fold.subFolds.forEach(function (subFold) {
                  fold.restoreRange(subFold);
                  this.addFold(subFold);
              }, this);
              if (fold.collapseChildren > 0) {
                  this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
              }
              fold.subFolds = [];
          };
          this.expandFolds = function (folds) {
              folds.forEach(function (fold) {
                  this.expandFold(fold);
              }, this);
          };
          this.unfold = function (location, expandInner) {
              var range, folds;
              if (location == null) {
                  range = new Range(0, 0, this.getLength(), 0);
                  expandInner = true;
              }
              else if (typeof location == "number")
                  range = new Range(location, 0, location, this.getLine(location).length);
              else if ("row" in location)
                  range = Range.fromPoints(location, location);
              else
                  range = location;
              folds = this.getFoldsInRangeList(range);
              if (expandInner) {
                  this.removeFolds(folds);
              }
              else {
                  var subFolds = folds;
                  while (subFolds.length) {
                      this.expandFolds(subFolds);
                      subFolds = this.getFoldsInRangeList(range);
                  }
              }
              if (folds.length)
                  return folds;
          };
          this.isRowFolded = function (docRow, startFoldRow) {
              return !!this.getFoldLine(docRow, startFoldRow);
          };
          this.getRowFoldEnd = function (docRow, startFoldRow) {
              var foldLine = this.getFoldLine(docRow, startFoldRow);
              return foldLine ? foldLine.end.row : docRow;
          };
          this.getRowFoldStart = function (docRow, startFoldRow) {
              var foldLine = this.getFoldLine(docRow, startFoldRow);
              return foldLine ? foldLine.start.row : docRow;
          };
          this.getFoldDisplayLine = function (foldLine, endRow, endColumn, startRow, startColumn) {
              if (startRow == null)
                  startRow = foldLine.start.row;
              if (startColumn == null)
                  startColumn = 0;
              if (endRow == null)
                  endRow = foldLine.end.row;
              if (endColumn == null)
                  endColumn = this.getLine(endRow).length;
              var doc = this.doc;
              var textLine = "";
              foldLine.walk(function (placeholder, row, column, lastColumn) {
                  if (row < startRow)
                      return;
                  if (row == startRow) {
                      if (column < startColumn)
                          return;
                      lastColumn = Math.max(startColumn, lastColumn);
                  }
                  if (placeholder != null) {
                      textLine += placeholder;
                  }
                  else {
                      textLine += doc.getLine(row).substring(lastColumn, column);
                  }
              }, endRow, endColumn);
              return textLine;
          };
          this.getDisplayLine = function (row, endColumn, startRow, startColumn) {
              var foldLine = this.getFoldLine(row);
              if (!foldLine) {
                  var line;
                  line = this.doc.getLine(row);
                  return line.substring(startColumn || 0, endColumn || line.length);
              }
              else {
                  return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
              }
          };
          this.$cloneFoldData = function () {
              var fd = [];
              fd = this.$foldData.map(function (foldLine) {
                  var folds = foldLine.folds.map(function (fold) {
                      return fold.clone();
                  });
                  return new FoldLine(fd, folds);
              });
              return fd;
          };
          this.toggleFold = function (tryToUnfold) {
              var selection = this.selection;
              var range = selection.getRange();
              var fold;
              var bracketPos;
              if (range.isEmpty()) {
                  var cursor = range.start;
                  fold = this.getFoldAt(cursor.row, cursor.column);
                  if (fold) {
                      this.expandFold(fold);
                      return;
                  }
                  else if (bracketPos = this.findMatchingBracket(cursor)) {
                      if (range.comparePoint(bracketPos) == 1) {
                          range.end = bracketPos;
                      }
                      else {
                          range.start = bracketPos;
                          range.start.column++;
                          range.end.column--;
                      }
                  }
                  else if (bracketPos = this.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 })) {
                      if (range.comparePoint(bracketPos) == 1)
                          range.end = bracketPos;
                      else
                          range.start = bracketPos;
                      range.start.column++;
                  }
                  else {
                      range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
                  }
              }
              else {
                  var folds = this.getFoldsInRange(range);
                  if (tryToUnfold && folds.length) {
                      this.expandFolds(folds);
                      return;
                  }
                  else if (folds.length == 1) {
                      fold = folds[0];
                  }
              }
              if (!fold)
                  fold = this.getFoldAt(range.start.row, range.start.column);
              if (fold && fold.range.toString() == range.toString()) {
                  this.expandFold(fold);
                  return;
              }
              var placeholder = "...";
              if (!range.isMultiLine()) {
                  placeholder = this.getTextRange(range);
                  if (placeholder.length < 4)
                      return;
                  placeholder = placeholder.trim().substring(0, 2) + "..";
              }
              this.addFold(placeholder, range);
          };
          this.getCommentFoldRange = function (row, column, dir) {
              var iterator = new TokenIterator(this, row, column);
              var token = iterator.getCurrentToken();
              var type = token.type;
              if (token && /^comment|string/.test(type)) {
                  type = type.match(/comment|string/)[0];
                  if (type == "comment")
                      type += "|doc-start";
                  var re = new RegExp(type);
                  var range = new Range();
                  if (dir != 1) {
                      do {
                          token = iterator.stepBackward();
                      } while (token && re.test(token.type));
                      iterator.stepForward();
                  }
                  range.start.row = iterator.getCurrentTokenRow();
                  range.start.column = iterator.getCurrentTokenColumn() + 2;
                  iterator = new TokenIterator(this, row, column);
                  if (dir != -1) {
                      var lastRow = -1;
                      do {
                          token = iterator.stepForward();
                          if (lastRow == -1) {
                              var state = this.getState(iterator.$row);
                              if (!re.test(state))
                                  lastRow = iterator.$row;
                          }
                          else if (iterator.$row > lastRow) {
                              break;
                          }
                      } while (token && re.test(token.type));
                      token = iterator.stepBackward();
                  }
                  else
                      token = iterator.getCurrentToken();
                  range.end.row = iterator.getCurrentTokenRow();
                  range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
                  return range;
              }
          };
          this.foldAll = function (startRow, endRow, depth) {
              if (depth == undefined)
                  depth = 100000; // JSON.stringify doesn't hanle Infinity
              var foldWidgets = this.foldWidgets;
              if (!foldWidgets)
                  return; // mode doesn't support folding
              endRow = endRow || this.getLength();
              startRow = startRow || 0;
              for (var row = startRow; row < endRow; row++) {
                  if (foldWidgets[row] == null)
                      foldWidgets[row] = this.getFoldWidget(row);
                  if (foldWidgets[row] != "start")
                      continue;
                  var range = this.getFoldWidgetRange(row);
                  if (range && range.isMultiLine()
                      && range.end.row <= endRow
                      && range.start.row >= startRow) {
                      row = range.end.row;
                      try {
                          var fold = this.addFold("...", range);
                          if (fold)
                              fold.collapseChildren = depth;
                      }
                      catch (e) { }
                  }
              }
          };
          this.$foldStyles = {
              "manual": 1,
              "markbegin": 1,
              "markbeginend": 1
          };
          this.$foldStyle = "markbegin";
          this.setFoldStyle = function (style) {
              if (!this.$foldStyles[style])
                  throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
              if (this.$foldStyle == style)
                  return;
              this.$foldStyle = style;
              if (style == "manual")
                  this.unfold();
              var mode = this.$foldMode;
              this.$setFolding(null);
              this.$setFolding(mode);
          };
          this.$setFolding = function (foldMode) {
              if (this.$foldMode == foldMode)
                  return;
              this.$foldMode = foldMode;
              this.off('change', this.$updateFoldWidgets);
              this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
              this._signal("changeAnnotation");
              if (!foldMode || this.$foldStyle == "manual") {
                  this.foldWidgets = null;
                  return;
              }
              this.foldWidgets = [];
              this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
              this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
              this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
              this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
              this.on('change', this.$updateFoldWidgets);
              this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
          };
          this.getParentFoldRangeData = function (row, ignoreCurrent) {
              var fw = this.foldWidgets;
              if (!fw || (ignoreCurrent && fw[row]))
                  return {};
              var i = row - 1, firstRange;
              while (i >= 0) {
                  var c = fw[i];
                  if (c == null)
                      c = fw[i] = this.getFoldWidget(i);
                  if (c == "start") {
                      var range = this.getFoldWidgetRange(i);
                      if (!firstRange)
                          firstRange = range;
                      if (range && range.end.row >= row)
                          break;
                  }
                  i--;
              }
              return {
                  range: i !== -1 && range,
                  firstRange: firstRange
              };
          };
          this.onFoldWidgetClick = function (row, e) {
              e = e.domEvent;
              var options = {
                  children: e.shiftKey,
                  all: e.ctrlKey || e.metaKey,
                  siblings: e.altKey
              };
              var range = this.$toggleFoldWidget(row, options);
              if (!range) {
                  var el = (e.target || e.srcElement);
                  if (el && /ace_fold-widget/.test(el.className))
                      el.className += " ace_invalid";
              }
          };
          this.$toggleFoldWidget = function (row, options) {
              if (!this.getFoldWidget)
                  return;
              var type = this.getFoldWidget(row);
              var line = this.getLine(row);
              var dir = type === "end" ? -1 : 1;
              var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
              if (fold) {
                  if (options.children || options.all)
                      this.removeFold(fold);
                  else
                      this.expandFold(fold);
                  return fold;
              }
              var range = this.getFoldWidgetRange(row, true);
              if (range && !range.isMultiLine()) {
                  fold = this.getFoldAt(range.start.row, range.start.column, 1);
                  if (fold && range.isEqual(fold.range)) {
                      this.removeFold(fold);
                      return fold;
                  }
              }
              if (options.siblings) {
                  var data = this.getParentFoldRangeData(row);
                  if (data.range) {
                      var startRow = data.range.start.row + 1;
                      var endRow = data.range.end.row;
                  }
                  this.foldAll(startRow, endRow, options.all ? 10000 : 0);
              }
              else if (options.children) {
                  endRow = range ? range.end.row : this.getLength();
                  this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
              }
              else if (range) {
                  if (options.all)
                      range.collapseChildren = 10000;
                  this.addFold("...", range);
              }
              return range;
          };
          this.toggleFoldWidget = function (toggleParent) {
              var row = this.selection.getCursor().row;
              row = this.getRowFoldStart(row);
              var range = this.$toggleFoldWidget(row, {});
              if (range)
                  return;
              var data = this.getParentFoldRangeData(row, true);
              range = data.range || data.firstRange;
              if (range) {
                  row = range.start.row;
                  var fold = this.getFoldAt(row, this.getLine(row).length, 1);
                  if (fold) {
                      this.removeFold(fold);
                  }
                  else {
                      this.addFold("...", range);
                  }
              }
          };
          this.updateFoldWidgets = function (delta) {
              var firstRow = delta.start.row;
              var len = delta.end.row - firstRow;
              if (len === 0) {
                  this.foldWidgets[firstRow] = null;
              }
              else if (delta.action == 'remove') {
                  this.foldWidgets.splice(firstRow, len + 1, null);
              }
              else {
                  var args = Array(len + 1);
                  args.unshift(firstRow, 1);
                  this.foldWidgets.splice.apply(this.foldWidgets, args);
              }
          };
          this.tokenizerUpdateFoldWidgets = function (e) {
              var rows = e.data;
              if (rows.first != rows.last) {
                  if (this.foldWidgets.length > rows.first)
                      this.foldWidgets.splice(rows.first, this.foldWidgets.length);
              }
          };
      }
      exports.Folding = Folding;
  });
  ace.define("ace/edit_session/bracket_match", ["require", "exports", "module", "ace/token_iterator", "ace/range"], function (acequire, exports, module) {
      var TokenIterator = acequire("../token_iterator").TokenIterator;
      var Range = acequire("../range").Range;
      function BracketMatch() {
          this.findMatchingBracket = function (position, chr) {
              if (position.column == 0)
                  return null;
              var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
              if (charBeforeCursor == "")
                  return null;
              var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
              if (!match)
                  return null;
              if (match[1])
                  return this.$findClosingBracket(match[1], position);
              else
                  return this.$findOpeningBracket(match[2], position);
          };
          this.getBracketRange = function (pos) {
              var line = this.getLine(pos.row);
              var before = true, range;
              var chr = line.charAt(pos.column - 1);
              var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
              if (!match) {
                  chr = line.charAt(pos.column);
                  pos = { row: pos.row, column: pos.column + 1 };
                  match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
                  before = false;
              }
              if (!match)
                  return null;
              if (match[1]) {
                  var bracketPos = this.$findClosingBracket(match[1], pos);
                  if (!bracketPos)
                      return null;
                  range = Range.fromPoints(pos, bracketPos);
                  if (!before) {
                      range.end.column++;
                      range.start.column--;
                  }
                  range.cursor = range.end;
              }
              else {
                  var bracketPos = this.$findOpeningBracket(match[2], pos);
                  if (!bracketPos)
                      return null;
                  range = Range.fromPoints(bracketPos, pos);
                  if (!before) {
                      range.start.column++;
                      range.end.column--;
                  }
                  range.cursor = range.start;
              }
              return range;
          };
          this.$brackets = {
              ")": "(",
              "(": ")",
              "]": "[",
              "[": "]",
              "{": "}",
              "}": "{"
          };
          this.$findOpeningBracket = function (bracket, position, typeRe) {
              var openBracket = this.$brackets[bracket];
              var depth = 1;
              var iterator = new TokenIterator(this, position.row, position.column);
              var token = iterator.getCurrentToken();
              if (!token)
                  token = iterator.stepForward();
              if (!token)
                  return;
              if (!typeRe) {
                  typeRe = new RegExp("(\\.?" +
                      token.type.replace(".", "\\.").replace("rparen", ".paren")
                          .replace(/\b(?:end)\b/, "(?:start|begin|end)")
                      + ")+");
              }
              var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
              var value = token.value;
              while (true) {
                  while (valueIndex >= 0) {
                      var chr = value.charAt(valueIndex);
                      if (chr == openBracket) {
                          depth -= 1;
                          if (depth == 0) {
                              return { row: iterator.getCurrentTokenRow(),
                                  column: valueIndex + iterator.getCurrentTokenColumn() };
                          }
                      }
                      else if (chr == bracket) {
                          depth += 1;
                      }
                      valueIndex -= 1;
                  }
                  do {
                      token = iterator.stepBackward();
                  } while (token && !typeRe.test(token.type));
                  if (token == null)
                      break;
                  value = token.value;
                  valueIndex = value.length - 1;
              }
              return null;
          };
          this.$findClosingBracket = function (bracket, position, typeRe) {
              var closingBracket = this.$brackets[bracket];
              var depth = 1;
              var iterator = new TokenIterator(this, position.row, position.column);
              var token = iterator.getCurrentToken();
              if (!token)
                  token = iterator.stepForward();
              if (!token)
                  return;
              if (!typeRe) {
                  typeRe = new RegExp("(\\.?" +
                      token.type.replace(".", "\\.").replace("lparen", ".paren")
                          .replace(/\b(?:start|begin)\b/, "(?:start|begin|end)")
                      + ")+");
              }
              var valueIndex = position.column - iterator.getCurrentTokenColumn();
              while (true) {
                  var value = token.value;
                  var valueLength = value.length;
                  while (valueIndex < valueLength) {
                      var chr = value.charAt(valueIndex);
                      if (chr == closingBracket) {
                          depth -= 1;
                          if (depth == 0) {
                              return { row: iterator.getCurrentTokenRow(),
                                  column: valueIndex + iterator.getCurrentTokenColumn() };
                          }
                      }
                      else if (chr == bracket) {
                          depth += 1;
                      }
                      valueIndex += 1;
                  }
                  do {
                      token = iterator.stepForward();
                  } while (token && !typeRe.test(token.type));
                  if (token == null)
                      break;
                  valueIndex = 0;
              }
              return null;
          };
      }
      exports.BracketMatch = BracketMatch;
  });
  ace.define("ace/edit_session", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/bidihandler", "ace/config", "ace/lib/event_emitter", "ace/selection", "ace/mode/text", "ace/range", "ace/document", "ace/background_tokenizer", "ace/search_highlight", "ace/edit_session/folding", "ace/edit_session/bracket_match"], function (acequire, exports, module) {
      var oop = acequire("./lib/oop");
      var lang = acequire("./lib/lang");
      var BidiHandler = acequire("./bidihandler").BidiHandler;
      var config = acequire("./config");
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var Selection = acequire("./selection").Selection;
      var TextMode = acequire("./mode/text").Mode;
      var Range = acequire("./range").Range;
      var Document = acequire("./document").Document;
      var BackgroundTokenizer = acequire("./background_tokenizer").BackgroundTokenizer;
      var SearchHighlight = acequire("./search_highlight").SearchHighlight;
      var EditSession = function (text, mode) {
          this.$breakpoints = [];
          this.$decorations = [];
          this.$frontMarkers = {};
          this.$backMarkers = {};
          this.$markerId = 1;
          this.$undoSelect = true;
          this.$foldData = [];
          this.id = "session" + (++EditSession.$uid);
          this.$foldData.toString = function () {
              return this.join("\n");
          };
          this.on("changeFold", this.onChangeFold.bind(this));
          this.$onChange = this.onChange.bind(this);
          if (typeof text != "object" || !text.getLine)
              text = new Document(text);
          this.$bidiHandler = new BidiHandler(this);
          this.setDocument(text);
          this.selection = new Selection(this);
          config.resetOptions(this);
          this.setMode(mode);
          config._signal("session", this);
      };
      EditSession.$uid = 0;
      (function () {
          oop.implement(this, EventEmitter);
          this.setDocument = function (doc) {
              if (this.doc)
                  this.doc.removeListener("change", this.$onChange);
              this.doc = doc;
              doc.on("change", this.$onChange);
              if (this.bgTokenizer)
                  this.bgTokenizer.setDocument(this.getDocument());
              this.resetCaches();
          };
          this.getDocument = function () {
              return this.doc;
          };
          this.$resetRowCache = function (docRow) {
              if (!docRow) {
                  this.$docRowCache = [];
                  this.$screenRowCache = [];
                  return;
              }
              var l = this.$docRowCache.length;
              var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
              if (l > i) {
                  this.$docRowCache.splice(i, l);
                  this.$screenRowCache.splice(i, l);
              }
          };
          this.$getRowCacheIndex = function (cacheArray, val) {
              var low = 0;
              var hi = cacheArray.length - 1;
              while (low <= hi) {
                  var mid = (low + hi) >> 1;
                  var c = cacheArray[mid];
                  if (val > c)
                      low = mid + 1;
                  else if (val < c)
                      hi = mid - 1;
                  else
                      return mid;
              }
              return low - 1;
          };
          this.resetCaches = function () {
              this.$modified = true;
              this.$wrapData = [];
              this.$rowLengthCache = [];
              this.$resetRowCache(0);
              if (this.bgTokenizer)
                  this.bgTokenizer.start(0);
          };
          this.onChangeFold = function (e) {
              var fold = e.data;
              this.$resetRowCache(fold.start.row);
          };
          this.onChange = function (delta) {
              this.$modified = true;
              this.$bidiHandler.onChange(delta);
              this.$resetRowCache(delta.start.row);
              var removedFolds = this.$updateInternalDataOnChange(delta);
              if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
                  this.$deltasDoc.push(delta);
                  if (removedFolds && removedFolds.length != 0) {
                      this.$deltasFold.push({
                          action: "removeFolds",
                          folds: removedFolds
                      });
                  }
                  this.$informUndoManager.schedule();
              }
              this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
              this._signal("change", delta);
          };
          this.setValue = function (text) {
              this.doc.setValue(text);
              this.selection.moveTo(0, 0);
              this.$resetRowCache(0);
              this.$deltas = [];
              this.$deltasDoc = [];
              this.$deltasFold = [];
              this.setUndoManager(this.$undoManager);
              this.getUndoManager().reset();
          };
          this.getValue =
              this.toString = function () {
                  return this.doc.getValue();
              };
          this.getSelection = function () {
              return this.selection;
          };
          this.getState = function (row) {
              return this.bgTokenizer.getState(row);
          };
          this.getTokens = function (row) {
              return this.bgTokenizer.getTokens(row);
          };
          this.getTokenAt = function (row, column) {
              var tokens = this.bgTokenizer.getTokens(row);
              var token, c = 0;
              if (column == null) {
                  var i = tokens.length - 1;
                  c = this.getLine(row).length;
              }
              else {
                  for (var i = 0; i < tokens.length; i++) {
                      c += tokens[i].value.length;
                      if (c >= column)
                          break;
                  }
              }
              token = tokens[i];
              if (!token)
                  return null;
              token.index = i;
              token.start = c - token.value.length;
              return token;
          };
          this.setUndoManager = function (undoManager) {
              this.$undoManager = undoManager;
              this.$deltas = [];
              this.$deltasDoc = [];
              this.$deltasFold = [];
              if (this.$informUndoManager)
                  this.$informUndoManager.cancel();
              if (undoManager) {
                  var self = this;
                  this.$syncInformUndoManager = function () {
                      self.$informUndoManager.cancel();
                      if (self.$deltasFold.length) {
                          self.$deltas.push({
                              group: "fold",
                              deltas: self.$deltasFold
                          });
                          self.$deltasFold = [];
                      }
                      if (self.$deltasDoc.length) {
                          self.$deltas.push({
                              group: "doc",
                              deltas: self.$deltasDoc
                          });
                          self.$deltasDoc = [];
                      }
                      if (self.$deltas.length > 0) {
                          undoManager.execute({
                              action: "aceupdate",
                              args: [self.$deltas, self],
                              merge: self.mergeUndoDeltas
                          });
                      }
                      self.mergeUndoDeltas = false;
                      self.$deltas = [];
                  };
                  this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
              }
          };
          this.markUndoGroup = function () {
              if (this.$syncInformUndoManager)
                  this.$syncInformUndoManager();
          };
          this.$defaultUndoManager = {
              undo: function () { },
              redo: function () { },
              reset: function () { }
          };
          this.getUndoManager = function () {
              return this.$undoManager || this.$defaultUndoManager;
          };
          this.getTabString = function () {
              if (this.getUseSoftTabs()) {
                  return lang.stringRepeat(" ", this.getTabSize());
              }
              else {
                  return "\t";
              }
          };
          this.setUseSoftTabs = function (val) {
              this.setOption("useSoftTabs", val);
          };
          this.getUseSoftTabs = function () {
              return this.$useSoftTabs && !this.$mode.$indentWithTabs;
          };
          this.setTabSize = function (tabSize) {
              this.setOption("tabSize", tabSize);
          };
          this.getTabSize = function () {
              return this.$tabSize;
          };
          this.isTabStop = function (position) {
              return this.$useSoftTabs && (position.column % this.$tabSize === 0);
          };
          this.setNavigateWithinSoftTabs = function (navigateWithinSoftTabs) {
              this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
          };
          this.getNavigateWithinSoftTabs = function () {
              return this.$navigateWithinSoftTabs;
          };
          this.$overwrite = false;
          this.setOverwrite = function (overwrite) {
              this.setOption("overwrite", overwrite);
          };
          this.getOverwrite = function () {
              return this.$overwrite;
          };
          this.toggleOverwrite = function () {
              this.setOverwrite(!this.$overwrite);
          };
          this.addGutterDecoration = function (row, className) {
              if (!this.$decorations[row])
                  this.$decorations[row] = "";
              this.$decorations[row] += " " + className;
              this._signal("changeBreakpoint", {});
          };
          this.removeGutterDecoration = function (row, className) {
              this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
              this._signal("changeBreakpoint", {});
          };
          this.getBreakpoints = function () {
              return this.$breakpoints;
          };
          this.setBreakpoints = function (rows) {
              this.$breakpoints = [];
              for (var i = 0; i < rows.length; i++) {
                  this.$breakpoints[rows[i]] = "ace_breakpoint";
              }
              this._signal("changeBreakpoint", {});
          };
          this.clearBreakpoints = function () {
              this.$breakpoints = [];
              this._signal("changeBreakpoint", {});
          };
          this.setBreakpoint = function (row, className) {
              if (className === undefined)
                  className = "ace_breakpoint";
              if (className)
                  this.$breakpoints[row] = className;
              else
                  delete this.$breakpoints[row];
              this._signal("changeBreakpoint", {});
          };
          this.clearBreakpoint = function (row) {
              delete this.$breakpoints[row];
              this._signal("changeBreakpoint", {});
          };
          this.addMarker = function (range, clazz, type, inFront) {
              var id = this.$markerId++;
              var marker = {
                  range: range,
                  type: type || "line",
                  renderer: typeof type == "function" ? type : null,
                  clazz: clazz,
                  inFront: !!inFront,
                  id: id
              };
              if (inFront) {
                  this.$frontMarkers[id] = marker;
                  this._signal("changeFrontMarker");
              }
              else {
                  this.$backMarkers[id] = marker;
                  this._signal("changeBackMarker");
              }
              return id;
          };
          this.addDynamicMarker = function (marker, inFront) {
              if (!marker.update)
                  return;
              var id = this.$markerId++;
              marker.id = id;
              marker.inFront = !!inFront;
              if (inFront) {
                  this.$frontMarkers[id] = marker;
                  this._signal("changeFrontMarker");
              }
              else {
                  this.$backMarkers[id] = marker;
                  this._signal("changeBackMarker");
              }
              return marker;
          };
          this.removeMarker = function (markerId) {
              var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
              if (!marker)
                  return;
              var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
              if (marker) {
                  delete (markers[markerId]);
                  this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
              }
          };
          this.getMarkers = function (inFront) {
              return inFront ? this.$frontMarkers : this.$backMarkers;
          };
          this.highlight = function (re) {
              if (!this.$searchHighlight) {
                  var highlight = new SearchHighlight(null, "ace_selected-word", "text");
                  this.$searchHighlight = this.addDynamicMarker(highlight);
              }
              this.$searchHighlight.setRegexp(re);
          };
          this.highlightLines = function (startRow, endRow, clazz, inFront) {
              if (typeof endRow != "number") {
                  clazz = endRow;
                  endRow = startRow;
              }
              if (!clazz)
                  clazz = "ace_step";
              var range = new Range(startRow, 0, endRow, Infinity);
              range.id = this.addMarker(range, clazz, "fullLine", inFront);
              return range;
          };
          this.setAnnotations = function (annotations) {
              this.$annotations = annotations;
              this._signal("changeAnnotation", {});
          };
          this.getAnnotations = function () {
              return this.$annotations || [];
          };
          this.clearAnnotations = function () {
              this.setAnnotations([]);
          };
          this.$detectNewLine = function (text) {
              var match = text.match(/^.*?(\r?\n)/m);
              if (match) {
                  this.$autoNewLine = match[1];
              }
              else {
                  this.$autoNewLine = "\n";
              }
          };
          this.getWordRange = function (row, column) {
              var line = this.getLine(row);
              var inToken = false;
              if (column > 0)
                  inToken = !!line.charAt(column - 1).match(this.tokenRe);
              if (!inToken)
                  inToken = !!line.charAt(column).match(this.tokenRe);
              if (inToken)
                  var re = this.tokenRe;
              else if (/^\s+$/.test(line.slice(column - 1, column + 1)))
                  var re = /\s/;
              else
                  var re = this.nonTokenRe;
              var start = column;
              if (start > 0) {
                  do {
                      start--;
                  } while (start >= 0 && line.charAt(start).match(re));
                  start++;
              }
              var end = column;
              while (end < line.length && line.charAt(end).match(re)) {
                  end++;
              }
              return new Range(row, start, row, end);
          };
          this.getAWordRange = function (row, column) {
              var wordRange = this.getWordRange(row, column);
              var line = this.getLine(wordRange.end.row);
              while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
                  wordRange.end.column += 1;
              }
              return wordRange;
          };
          this.setNewLineMode = function (newLineMode) {
              this.doc.setNewLineMode(newLineMode);
          };
          this.getNewLineMode = function () {
              return this.doc.getNewLineMode();
          };
          this.setUseWorker = function (useWorker) { this.setOption("useWorker", useWorker); };
          this.getUseWorker = function () { return this.$useWorker; };
          this.onReloadTokenizer = function (e) {
              var rows = e.data;
              this.bgTokenizer.start(rows.first);
              this._signal("tokenizerUpdate", e);
          };
          this.$modes = {};
          this.$mode = null;
          this.$modeId = null;
          this.setMode = function (mode, cb) {
              if (mode && typeof mode === "object") {
                  if (mode.getTokenizer)
                      return this.$onChangeMode(mode);
                  var options = mode;
                  var path = options.path;
              }
              else {
                  path = mode || "ace/mode/text";
              }
              if (!this.$modes["ace/mode/text"])
                  this.$modes["ace/mode/text"] = new TextMode();
              if (this.$modes[path] && !options) {
                  this.$onChangeMode(this.$modes[path]);
                  cb && cb();
                  return;
              }
              this.$modeId = path;
              config.loadModule(["mode", path], function (m) {
                  if (this.$modeId !== path)
                      return cb && cb();
                  if (this.$modes[path] && !options) {
                      this.$onChangeMode(this.$modes[path]);
                  }
                  else if (m && m.Mode) {
                      m = new m.Mode(options);
                      if (!options) {
                          this.$modes[path] = m;
                          m.$id = path;
                      }
                      this.$onChangeMode(m);
                  }
                  cb && cb();
              }.bind(this));
              if (!this.$mode)
                  this.$onChangeMode(this.$modes["ace/mode/text"], true);
          };
          this.$onChangeMode = function (mode, $isPlaceholder) {
              if (!$isPlaceholder)
                  this.$modeId = mode.$id;
              if (this.$mode === mode)
                  return;
              this.$mode = mode;
              this.$stopWorker();
              if (this.$useWorker)
                  this.$startWorker();
              var tokenizer = mode.getTokenizer();
              if (tokenizer.addEventListener !== undefined) {
                  var onReloadTokenizer = this.onReloadTokenizer.bind(this);
                  tokenizer.addEventListener("update", onReloadTokenizer);
              }
              if (!this.bgTokenizer) {
                  this.bgTokenizer = new BackgroundTokenizer(tokenizer);
                  var _self = this;
                  this.bgTokenizer.addEventListener("update", function (e) {
                      _self._signal("tokenizerUpdate", e);
                  });
              }
              else {
                  this.bgTokenizer.setTokenizer(tokenizer);
              }
              this.bgTokenizer.setDocument(this.getDocument());
              this.tokenRe = mode.tokenRe;
              this.nonTokenRe = mode.nonTokenRe;
              if (!$isPlaceholder) {
                  if (mode.attachToSession)
                      mode.attachToSession(this);
                  this.$options.wrapMethod.set.call(this, this.$wrapMethod);
                  this.$setFolding(mode.foldingRules);
                  this.bgTokenizer.start(0);
                  this._emit("changeMode");
              }
          };
          this.$stopWorker = function () {
              if (this.$worker) {
                  this.$worker.terminate();
                  this.$worker = null;
              }
          };
          this.$startWorker = function () {
              try {
                  this.$worker = this.$mode.createWorker(this);
              }
              catch (e) {
                  config.warn("Could not load worker", e);
                  this.$worker = null;
              }
          };
          this.getMode = function () {
              return this.$mode;
          };
          this.$scrollTop = 0;
          this.setScrollTop = function (scrollTop) {
              if (this.$scrollTop === scrollTop || isNaN(scrollTop))
                  return;
              this.$scrollTop = scrollTop;
              this._signal("changeScrollTop", scrollTop);
          };
          this.getScrollTop = function () {
              return this.$scrollTop;
          };
          this.$scrollLeft = 0;
          this.setScrollLeft = function (scrollLeft) {
              if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
                  return;
              this.$scrollLeft = scrollLeft;
              this._signal("changeScrollLeft", scrollLeft);
          };
          this.getScrollLeft = function () {
              return this.$scrollLeft;
          };
          this.getScreenWidth = function () {
              this.$computeWidth();
              if (this.lineWidgets)
                  return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
              return this.screenWidth;
          };
          this.getLineWidgetMaxWidth = function () {
              if (this.lineWidgetsWidth != null)
                  return this.lineWidgetsWidth;
              var width = 0;
              this.lineWidgets.forEach(function (w) {
                  if (w && w.screenWidth > width)
                      width = w.screenWidth;
              });
              return this.lineWidgetWidth = width;
          };
          this.$computeWidth = function (force) {
              if (this.$modified || force) {
                  this.$modified = false;
                  if (this.$useWrapMode)
                      return this.screenWidth = this.$wrapLimit;
                  var lines = this.doc.getAllLines();
                  var cache = this.$rowLengthCache;
                  var longestScreenLine = 0;
                  var foldIndex = 0;
                  var foldLine = this.$foldData[foldIndex];
                  var foldStart = foldLine ? foldLine.start.row : Infinity;
                  var len = lines.length;
                  for (var i = 0; i < len; i++) {
                      if (i > foldStart) {
                          i = foldLine.end.row + 1;
                          if (i >= len)
                              break;
                          foldLine = this.$foldData[foldIndex++];
                          foldStart = foldLine ? foldLine.start.row : Infinity;
                      }
                      if (cache[i] == null)
                          cache[i] = this.$getStringScreenWidth(lines[i])[0];
                      if (cache[i] > longestScreenLine)
                          longestScreenLine = cache[i];
                  }
                  this.screenWidth = longestScreenLine;
              }
          };
          this.getLine = function (row) {
              return this.doc.getLine(row);
          };
          this.getLines = function (firstRow, lastRow) {
              return this.doc.getLines(firstRow, lastRow);
          };
          this.getLength = function () {
              return this.doc.getLength();
          };
          this.getTextRange = function (range) {
              return this.doc.getTextRange(range || this.selection.getRange());
          };
          this.insert = function (position, text) {
              return this.doc.insert(position, text);
          };
          this.remove = function (range) {
              return this.doc.remove(range);
          };
          this.removeFullLines = function (firstRow, lastRow) {
              return this.doc.removeFullLines(firstRow, lastRow);
          };
          this.undoChanges = function (deltas, dontSelect) {
              if (!deltas.length)
                  return;
              this.$fromUndo = true;
              var lastUndoRange = null;
              for (var i = deltas.length - 1; i != -1; i--) {
                  var delta = deltas[i];
                  if (delta.group == "doc") {
                      this.doc.revertDeltas(delta.deltas);
                      lastUndoRange =
                          this.$getUndoSelection(delta.deltas, true, lastUndoRange);
                  }
                  else {
                      delta.deltas.forEach(function (foldDelta) {
                          this.addFolds(foldDelta.folds);
                      }, this);
                  }
              }
              this.$fromUndo = false;
              lastUndoRange &&
                  this.$undoSelect &&
                  !dontSelect &&
                  this.selection.setSelectionRange(lastUndoRange);
              return lastUndoRange;
          };
          this.redoChanges = function (deltas, dontSelect) {
              if (!deltas.length)
                  return;
              this.$fromUndo = true;
              var lastUndoRange = null;
              for (var i = 0; i < deltas.length; i++) {
                  var delta = deltas[i];
                  if (delta.group == "doc") {
                      this.doc.applyDeltas(delta.deltas);
                      lastUndoRange =
                          this.$getUndoSelection(delta.deltas, false, lastUndoRange);
                  }
              }
              this.$fromUndo = false;
              lastUndoRange &&
                  this.$undoSelect &&
                  !dontSelect &&
                  this.selection.setSelectionRange(lastUndoRange);
              return lastUndoRange;
          };
          this.setUndoSelect = function (enable) {
              this.$undoSelect = enable;
          };
          this.$getUndoSelection = function (deltas, isUndo, lastUndoRange) {
              function isInsert(delta) {
                  return isUndo ? delta.action !== "insert" : delta.action === "insert";
              }
              var delta = deltas[0];
              var range, point;
              if (isInsert(delta)) {
                  range = Range.fromPoints(delta.start, delta.end);
              }
              else {
                  range = Range.fromPoints(delta.start, delta.start);
              }
              for (var i = 1; i < deltas.length; i++) {
                  delta = deltas[i];
                  if (isInsert(delta)) {
                      point = delta.start;
                      if (range.compare(point.row, point.column) == -1) {
                          range.setStart(point);
                      }
                      point = delta.end;
                      if (range.compare(point.row, point.column) == 1) {
                          range.setEnd(point);
                      }
                  }
                  else {
                      point = delta.start;
                      if (range.compare(point.row, point.column) == -1) {
                          range = Range.fromPoints(delta.start, delta.start);
                      }
                  }
              }
              if (lastUndoRange != null) {
                  if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
                      lastUndoRange.start.column += range.end.column - range.start.column;
                      lastUndoRange.end.column += range.end.column - range.start.column;
                  }
                  var cmp = lastUndoRange.compareRange(range);
                  if (cmp == 1) {
                      range.setStart(lastUndoRange.start);
                  }
                  else if (cmp == -1) {
                      range.setEnd(lastUndoRange.end);
                  }
              }
              return range;
          };
          this.replace = function (range, text) {
              return this.doc.replace(range, text);
          };
          this.moveText = function (fromRange, toPosition, copy) {
              var text = this.getTextRange(fromRange);
              var folds = this.getFoldsInRange(fromRange);
              var toRange = Range.fromPoints(toPosition, toPosition);
              if (!copy) {
                  this.remove(fromRange);
                  var rowDiff = fromRange.start.row - fromRange.end.row;
                  var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
                  if (collDiff) {
                      if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                          toRange.start.column += collDiff;
                      if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                          toRange.end.column += collDiff;
                  }
                  if (rowDiff && toRange.start.row >= fromRange.end.row) {
                      toRange.start.row += rowDiff;
                      toRange.end.row += rowDiff;
                  }
              }
              toRange.end = this.insert(toRange.start, text);
              if (folds.length) {
                  var oldStart = fromRange.start;
                  var newStart = toRange.start;
                  var rowDiff = newStart.row - oldStart.row;
                  var collDiff = newStart.column - oldStart.column;
                  this.addFolds(folds.map(function (x) {
                      x = x.clone();
                      if (x.start.row == oldStart.row)
                          x.start.column += collDiff;
                      if (x.end.row == oldStart.row)
                          x.end.column += collDiff;
                      x.start.row += rowDiff;
                      x.end.row += rowDiff;
                      return x;
                  }));
              }
              return toRange;
          };
          this.indentRows = function (startRow, endRow, indentString) {
              indentString = indentString.replace(/\t/g, this.getTabString());
              for (var row = startRow; row <= endRow; row++)
                  this.doc.insertInLine({ row: row, column: 0 }, indentString);
          };
          this.outdentRows = function (range) {
              var rowRange = range.collapseRows();
              var deleteRange = new Range(0, 0, 0, 0);
              var size = this.getTabSize();
              for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
                  var line = this.getLine(i);
                  deleteRange.start.row = i;
                  deleteRange.end.row = i;
                  for (var j = 0; j < size; ++j)
                      if (line.charAt(j) != ' ')
                          break;
                  if (j < size && line.charAt(j) == '\t') {
                      deleteRange.start.column = j;
                      deleteRange.end.column = j + 1;
                  }
                  else {
                      deleteRange.start.column = 0;
                      deleteRange.end.column = j;
                  }
                  this.remove(deleteRange);
              }
          };
          this.$moveLines = function (firstRow, lastRow, dir) {
              firstRow = this.getRowFoldStart(firstRow);
              lastRow = this.getRowFoldEnd(lastRow);
              if (dir < 0) {
                  var row = this.getRowFoldStart(firstRow + dir);
                  if (row < 0)
                      return 0;
                  var diff = row - firstRow;
              }
              else if (dir > 0) {
                  var row = this.getRowFoldEnd(lastRow + dir);
                  if (row > this.doc.getLength() - 1)
                      return 0;
                  var diff = row - lastRow;
              }
              else {
                  firstRow = this.$clipRowToDocument(firstRow);
                  lastRow = this.$clipRowToDocument(lastRow);
                  var diff = lastRow - firstRow + 1;
              }
              var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
              var folds = this.getFoldsInRange(range).map(function (x) {
                  x = x.clone();
                  x.start.row += diff;
                  x.end.row += diff;
                  return x;
              });
              var lines = dir == 0
                  ? this.doc.getLines(firstRow, lastRow)
                  : this.doc.removeFullLines(firstRow, lastRow);
              this.doc.insertFullLines(firstRow + diff, lines);
              folds.length && this.addFolds(folds);
              return diff;
          };
          this.moveLinesUp = function (firstRow, lastRow) {
              return this.$moveLines(firstRow, lastRow, -1);
          };
          this.moveLinesDown = function (firstRow, lastRow) {
              return this.$moveLines(firstRow, lastRow, 1);
          };
          this.duplicateLines = function (firstRow, lastRow) {
              return this.$moveLines(firstRow, lastRow, 0);
          };
          this.$clipRowToDocument = function (row) {
              return Math.max(0, Math.min(row, this.doc.getLength() - 1));
          };
          this.$clipColumnToRow = function (row, column) {
              if (column < 0)
                  return 0;
              return Math.min(this.doc.getLine(row).length, column);
          };
          this.$clipPositionToDocument = function (row, column) {
              column = Math.max(0, column);
              if (row < 0) {
                  row = 0;
                  column = 0;
              }
              else {
                  var len = this.doc.getLength();
                  if (row >= len) {
                      row = len - 1;
                      column = this.doc.getLine(len - 1).length;
                  }
                  else {
                      column = Math.min(this.doc.getLine(row).length, column);
                  }
              }
              return {
                  row: row,
                  column: column
              };
          };
          this.$clipRangeToDocument = function (range) {
              if (range.start.row < 0) {
                  range.start.row = 0;
                  range.start.column = 0;
              }
              else {
                  range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
              }
              var len = this.doc.getLength() - 1;
              if (range.end.row > len) {
                  range.end.row = len;
                  range.end.column = this.doc.getLine(len).length;
              }
              else {
                  range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
              }
              return range;
          };
          this.$wrapLimit = 80;
          this.$useWrapMode = false;
          this.$wrapLimitRange = {
              min: null,
              max: null
          };
          this.setUseWrapMode = function (useWrapMode) {
              if (useWrapMode != this.$useWrapMode) {
                  this.$useWrapMode = useWrapMode;
                  this.$modified = true;
                  this.$resetRowCache(0);
                  if (useWrapMode) {
                      var len = this.getLength();
                      this.$wrapData = Array(len);
                      this.$updateWrapData(0, len - 1);
                  }
                  this._signal("changeWrapMode");
              }
          };
          this.getUseWrapMode = function () {
              return this.$useWrapMode;
          };
          this.setWrapLimitRange = function (min, max) {
              if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
                  this.$wrapLimitRange = { min: min, max: max };
                  this.$modified = true;
                  this.$bidiHandler.markAsDirty();
                  if (this.$useWrapMode)
                      this._signal("changeWrapMode");
              }
          };
          this.adjustWrapLimit = function (desiredLimit, $printMargin) {
              var limits = this.$wrapLimitRange;
              if (limits.max < 0)
                  limits = { min: $printMargin, max: $printMargin };
              var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
              if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
                  this.$wrapLimit = wrapLimit;
                  this.$modified = true;
                  if (this.$useWrapMode) {
                      this.$updateWrapData(0, this.getLength() - 1);
                      this.$resetRowCache(0);
                      this._signal("changeWrapLimit");
                  }
                  return true;
              }
              return false;
          };
          this.$constrainWrapLimit = function (wrapLimit, min, max) {
              if (min)
                  wrapLimit = Math.max(min, wrapLimit);
              if (max)
                  wrapLimit = Math.min(max, wrapLimit);
              return wrapLimit;
          };
          this.getWrapLimit = function () {
              return this.$wrapLimit;
          };
          this.setWrapLimit = function (limit) {
              this.setWrapLimitRange(limit, limit);
          };
          this.getWrapLimitRange = function () {
              return {
                  min: this.$wrapLimitRange.min,
                  max: this.$wrapLimitRange.max
              };
          };
          this.$updateInternalDataOnChange = function (delta) {
              var useWrapMode = this.$useWrapMode;
              var action = delta.action;
              var start = delta.start;
              var end = delta.end;
              var firstRow = start.row;
              var lastRow = end.row;
              var len = lastRow - firstRow;
              var removedFolds = null;
              this.$updating = true;
              if (len != 0) {
                  if (action === "remove") {
                      this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);
                      var foldLines = this.$foldData;
                      removedFolds = this.getFoldsInRange(delta);
                      this.removeFolds(removedFolds);
                      var foldLine = this.getFoldLine(end.row);
                      var idx = 0;
                      if (foldLine) {
                          foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                          foldLine.shiftRow(-len);
                          var foldLineBefore = this.getFoldLine(firstRow);
                          if (foldLineBefore && foldLineBefore !== foldLine) {
                              foldLineBefore.merge(foldLine);
                              foldLine = foldLineBefore;
                          }
                          idx = foldLines.indexOf(foldLine) + 1;
                      }
                      for (idx; idx < foldLines.length; idx++) {
                          var foldLine = foldLines[idx];
                          if (foldLine.start.row >= end.row) {
                              foldLine.shiftRow(-len);
                          }
                      }
                      lastRow = firstRow;
                  }
                  else {
                      var args = Array(len);
                      args.unshift(firstRow, 0);
                      var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                      arr.splice.apply(arr, args);
                      var foldLines = this.$foldData;
                      var foldLine = this.getFoldLine(firstRow);
                      var idx = 0;
                      if (foldLine) {
                          var cmp = foldLine.range.compareInside(start.row, start.column);
                          if (cmp == 0) {
                              foldLine = foldLine.split(start.row, start.column);
                              if (foldLine) {
                                  foldLine.shiftRow(len);
                                  foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                              }
                          }
                          else if (cmp == -1) {
                              foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                              foldLine.shiftRow(len);
                          }
                          idx = foldLines.indexOf(foldLine) + 1;
                      }
                      for (idx; idx < foldLines.length; idx++) {
                          var foldLine = foldLines[idx];
                          if (foldLine.start.row >= firstRow) {
                              foldLine.shiftRow(len);
                          }
                      }
                  }
              }
              else {
                  len = Math.abs(delta.start.column - delta.end.column);
                  if (action === "remove") {
                      removedFolds = this.getFoldsInRange(delta);
                      this.removeFolds(removedFolds);
                      len = -len;
                  }
                  var foldLine = this.getFoldLine(firstRow);
                  if (foldLine) {
                      foldLine.addRemoveChars(firstRow, start.column, len);
                  }
              }
              if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
                  console.error("doc.getLength() and $wrapData.length have to be the same!");
              }
              this.$updating = false;
              if (useWrapMode)
                  this.$updateWrapData(firstRow, lastRow);
              else
                  this.$updateRowLengthCache(firstRow, lastRow);
              return removedFolds;
          };
          this.$updateRowLengthCache = function (firstRow, lastRow, b) {
              this.$rowLengthCache[firstRow] = null;
              this.$rowLengthCache[lastRow] = null;
          };
          this.$updateWrapData = function (firstRow, lastRow) {
              var lines = this.doc.getAllLines();
              var tabSize = this.getTabSize();
              var wrapData = this.$wrapData;
              var wrapLimit = this.$wrapLimit;
              var tokens;
              var foldLine;
              var row = firstRow;
              lastRow = Math.min(lastRow, lines.length - 1);
              while (row <= lastRow) {
                  foldLine = this.getFoldLine(row, foldLine);
                  if (!foldLine) {
                      tokens = this.$getDisplayTokens(lines[row]);
                      wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                      row++;
                  }
                  else {
                      tokens = [];
                      foldLine.walk(function (placeholder, row, column, lastColumn) {
                          var walkTokens;
                          if (placeholder != null) {
                              walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
                              walkTokens[0] = PLACEHOLDER_START;
                              for (var i = 1; i < walkTokens.length; i++) {
                                  walkTokens[i] = PLACEHOLDER_BODY;
                              }
                          }
                          else {
                              walkTokens = this.$getDisplayTokens(lines[row].substring(lastColumn, column), tokens.length);
                          }
                          tokens = tokens.concat(walkTokens);
                      }.bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);
                      wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                      row = foldLine.end.row + 1;
                  }
              }
          };
          var CHAR = 1, CHAR_EXT = 2, PLACEHOLDER_START = 3, PLACEHOLDER_BODY = 4, PUNCTUATION = 9, SPACE = 10, TAB = 11, TAB_SPACE = 12;
          this.$computeWrapSplits = function (tokens, wrapLimit, tabSize) {
              if (tokens.length == 0) {
                  return [];
              }
              var splits = [];
              var displayLength = tokens.length;
              var lastSplit = 0, lastDocSplit = 0;
              var isCode = this.$wrapAsCode;
              var indentedSoftWrap = this.$indentedSoftWrap;
              var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8)
                  || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);
              function getWrapIndent() {
                  var indentation = 0;
                  if (maxIndent === 0)
                      return indentation;
                  if (indentedSoftWrap) {
                      for (var i = 0; i < tokens.length; i++) {
                          var token = tokens[i];
                          if (token == SPACE)
                              indentation += 1;
                          else if (token == TAB)
                              indentation += tabSize;
                          else if (token == TAB_SPACE)
                              continue;
                          else
                              break;
                      }
                  }
                  if (isCode && indentedSoftWrap !== false)
                      indentation += tabSize;
                  return Math.min(indentation, maxIndent);
              }
              function addSplit(screenPos) {
                  var displayed = tokens.slice(lastSplit, screenPos);
                  var len = displayed.length;
                  displayed.join("")
                      .replace(/12/g, function () {
                      len -= 1;
                  })
                      .replace(/2/g, function () {
                      len -= 1;
                  });
                  if (!splits.length) {
                      indent = getWrapIndent();
                      splits.indent = indent;
                  }
                  lastDocSplit += len;
                  splits.push(lastDocSplit);
                  lastSplit = screenPos;
              }
              var indent = 0;
              while (displayLength - lastSplit > wrapLimit - indent) {
                  var split = lastSplit + wrapLimit - indent;
                  if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                      addSplit(split);
                      continue;
                  }
                  if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                      for (split; split != lastSplit - 1; split--) {
                          if (tokens[split] == PLACEHOLDER_START) {
                              break;
                          }
                      }
                      if (split > lastSplit) {
                          addSplit(split);
                          continue;
                      }
                      split = lastSplit + wrapLimit;
                      for (split; split < tokens.length; split++) {
                          if (tokens[split] != PLACEHOLDER_BODY) {
                              break;
                          }
                      }
                      if (split == tokens.length) {
                          break; // Breaks the while-loop.
                      }
                      addSplit(split);
                      continue;
                  }
                  var minSplit = Math.max(split - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
                  while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                      split--;
                  }
                  if (isCode) {
                      while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                          split--;
                      }
                      while (split > minSplit && tokens[split] == PUNCTUATION) {
                          split--;
                      }
                  }
                  else {
                      while (split > minSplit && tokens[split] < SPACE) {
                          split--;
                      }
                  }
                  if (split > minSplit) {
                      addSplit(++split);
                      continue;
                  }
                  split = lastSplit + wrapLimit;
                  if (tokens[split] == CHAR_EXT)
                      split--;
                  addSplit(split - indent);
              }
              return splits;
          };
          this.$getDisplayTokens = function (str, offset) {
              var arr = [];
              var tabSize;
              offset = offset || 0;
              for (var i = 0; i < str.length; i++) {
                  var c = str.charCodeAt(i);
                  if (c == 9) {
                      tabSize = this.getScreenTabSize(arr.length + offset);
                      arr.push(TAB);
                      for (var n = 1; n < tabSize; n++) {
                          arr.push(TAB_SPACE);
                      }
                  }
                  else if (c == 32) {
                      arr.push(SPACE);
                  }
                  else if ((c > 39 && c < 48) || (c > 57 && c < 64)) {
                      arr.push(PUNCTUATION);
                  }
                  else if (c >= 0x1100 && isFullWidth(c)) {
                      arr.push(CHAR, CHAR_EXT);
                  }
                  else {
                      arr.push(CHAR);
                  }
              }
              return arr;
          };
          this.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {
              if (maxScreenColumn == 0)
                  return [0, 0];
              if (maxScreenColumn == null)
                  maxScreenColumn = Infinity;
              screenColumn = screenColumn || 0;
              var c, column;
              for (column = 0; column < str.length; column++) {
                  c = str.charCodeAt(column);
                  if (c == 9) {
                      screenColumn += this.getScreenTabSize(screenColumn);
                  }
                  else if (c >= 0x1100 && isFullWidth(c)) {
                      screenColumn += 2;
                  }
                  else {
                      screenColumn += 1;
                  }
                  if (screenColumn > maxScreenColumn) {
                      break;
                  }
              }
              return [screenColumn, column];
          };
          this.lineWidgets = null;
          this.getRowLength = function (row) {
              if (this.lineWidgets)
                  var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
              else
                  h = 0;
              if (!this.$useWrapMode || !this.$wrapData[row]) {
                  return 1 + h;
              }
              else {
                  return this.$wrapData[row].length + 1 + h;
              }
          };
          this.getRowLineCount = function (row) {
              if (!this.$useWrapMode || !this.$wrapData[row]) {
                  return 1;
              }
              else {
                  return this.$wrapData[row].length + 1;
              }
          };
          this.getRowWrapIndent = function (screenRow) {
              if (this.$useWrapMode) {
                  var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
                  var splits = this.$wrapData[pos.row];
                  return splits.length && splits[0] < pos.column ? splits.indent : 0;
              }
              else {
                  return 0;
              }
          };
          this.getScreenLastRowColumn = function (screenRow) {
              var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
              return this.documentToScreenColumn(pos.row, pos.column);
          };
          this.getDocumentLastRowColumn = function (docRow, docColumn) {
              var screenRow = this.documentToScreenRow(docRow, docColumn);
              return this.getScreenLastRowColumn(screenRow);
          };
          this.getDocumentLastRowColumnPosition = function (docRow, docColumn) {
              var screenRow = this.documentToScreenRow(docRow, docColumn);
              return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
          };
          this.getRowSplitData = function (row) {
              if (!this.$useWrapMode) {
                  return undefined;
              }
              else {
                  return this.$wrapData[row];
              }
          };
          this.getScreenTabSize = function (screenColumn) {
              return this.$tabSize - screenColumn % this.$tabSize;
          };
          this.screenToDocumentRow = function (screenRow, screenColumn) {
              return this.screenToDocumentPosition(screenRow, screenColumn).row;
          };
          this.screenToDocumentColumn = function (screenRow, screenColumn) {
              return this.screenToDocumentPosition(screenRow, screenColumn).column;
          };
          this.screenToDocumentPosition = function (screenRow, screenColumn, offsetX) {
              if (screenRow < 0)
                  return { row: 0, column: 0 };
              var line;
              var docRow = 0;
              var docColumn = 0;
              var column;
              var row = 0;
              var rowLength = 0;
              var rowCache = this.$screenRowCache;
              var i = this.$getRowCacheIndex(rowCache, screenRow);
              var l = rowCache.length;
              if (l && i >= 0) {
                  var row = rowCache[i];
                  var docRow = this.$docRowCache[i];
                  var doCache = screenRow > rowCache[l - 1];
              }
              else {
                  var doCache = !l;
              }
              var maxRow = this.getLength() - 1;
              var foldLine = this.getNextFoldLine(docRow);
              var foldStart = foldLine ? foldLine.start.row : Infinity;
              while (row <= screenRow) {
                  rowLength = this.getRowLength(docRow);
                  if (row + rowLength > screenRow || docRow >= maxRow) {
                      break;
                  }
                  else {
                      row += rowLength;
                      docRow++;
                      if (docRow > foldStart) {
                          docRow = foldLine.end.row + 1;
                          foldLine = this.getNextFoldLine(docRow, foldLine);
                          foldStart = foldLine ? foldLine.start.row : Infinity;
                      }
                  }
                  if (doCache) {
                      this.$docRowCache.push(docRow);
                      this.$screenRowCache.push(row);
                  }
              }
              if (foldLine && foldLine.start.row <= docRow) {
                  line = this.getFoldDisplayLine(foldLine);
                  docRow = foldLine.start.row;
              }
              else if (row + rowLength <= screenRow || docRow > maxRow) {
                  return {
                      row: maxRow,
                      column: this.getLine(maxRow).length
                  };
              }
              else {
                  line = this.getLine(docRow);
                  foldLine = null;
              }
              var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
              if (this.$useWrapMode) {
                  var splits = this.$wrapData[docRow];
                  if (splits) {
                      column = splits[splitIndex];
                      if (splitIndex > 0 && splits.length) {
                          wrapIndent = splits.indent;
                          docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                          line = line.substring(docColumn);
                      }
                  }
              }
              if (offsetX !== undefined && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))
                  screenColumn = this.$bidiHandler.offsetToCol(offsetX);
              docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
              if (this.$useWrapMode && docColumn >= column)
                  docColumn = column - 1;
              if (foldLine)
                  return foldLine.idxToPosition(docColumn);
              return { row: docRow, column: docColumn };
          };
          this.documentToScreenPosition = function (docRow, docColumn) {
              if (typeof docColumn === "undefined")
                  var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
              else
                  pos = this.$clipPositionToDocument(docRow, docColumn);
              docRow = pos.row;
              docColumn = pos.column;
              var screenRow = 0;
              var foldStartRow = null;
              var fold = null;
              fold = this.getFoldAt(docRow, docColumn, 1);
              if (fold) {
                  docRow = fold.start.row;
                  docColumn = fold.start.column;
              }
              var rowEnd, row = 0;
              var rowCache = this.$docRowCache;
              var i = this.$getRowCacheIndex(rowCache, docRow);
              var l = rowCache.length;
              if (l && i >= 0) {
                  var row = rowCache[i];
                  var screenRow = this.$screenRowCache[i];
                  var doCache = docRow > rowCache[l - 1];
              }
              else {
                  var doCache = !l;
              }
              var foldLine = this.getNextFoldLine(row);
              var foldStart = foldLine ? foldLine.start.row : Infinity;
              while (row < docRow) {
                  if (row >= foldStart) {
                      rowEnd = foldLine.end.row + 1;
                      if (rowEnd > docRow)
                          break;
                      foldLine = this.getNextFoldLine(rowEnd, foldLine);
                      foldStart = foldLine ? foldLine.start.row : Infinity;
                  }
                  else {
                      rowEnd = row + 1;
                  }
                  screenRow += this.getRowLength(row);
                  row = rowEnd;
                  if (doCache) {
                      this.$docRowCache.push(row);
                      this.$screenRowCache.push(screenRow);
                  }
              }
              var textLine = "";
              if (foldLine && row >= foldStart) {
                  textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
                  foldStartRow = foldLine.start.row;
              }
              else {
                  textLine = this.getLine(docRow).substring(0, docColumn);
                  foldStartRow = docRow;
              }
              var wrapIndent = 0;
              if (this.$useWrapMode) {
                  var wrapRow = this.$wrapData[foldStartRow];
                  if (wrapRow) {
                      var screenRowOffset = 0;
                      while (textLine.length >= wrapRow[screenRowOffset]) {
                          screenRow++;
                          screenRowOffset++;
                      }
                      textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
                      wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
                  }
              }
              return {
                  row: screenRow,
                  column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
              };
          };
          this.documentToScreenColumn = function (row, docColumn) {
              return this.documentToScreenPosition(row, docColumn).column;
          };
          this.documentToScreenRow = function (docRow, docColumn) {
              return this.documentToScreenPosition(docRow, docColumn).row;
          };
          this.getScreenLength = function () {
              var screenRows = 0;
              var fold = null;
              if (!this.$useWrapMode) {
                  screenRows = this.getLength();
                  var foldData = this.$foldData;
                  for (var i = 0; i < foldData.length; i++) {
                      fold = foldData[i];
                      screenRows -= fold.end.row - fold.start.row;
                  }
              }
              else {
                  var lastRow = this.$wrapData.length;
                  var row = 0, i = 0;
                  var fold = this.$foldData[i++];
                  var foldStart = fold ? fold.start.row : Infinity;
                  while (row < lastRow) {
                      var splits = this.$wrapData[row];
                      screenRows += splits ? splits.length + 1 : 1;
                      row++;
                      if (row > foldStart) {
                          row = fold.end.row + 1;
                          fold = this.$foldData[i++];
                          foldStart = fold ? fold.start.row : Infinity;
                      }
                  }
              }
              if (this.lineWidgets)
                  screenRows += this.$getWidgetScreenLength();
              return screenRows;
          };
          this.$setFontMetrics = function (fm) {
              if (!this.$enableVarChar)
                  return;
              this.$getStringScreenWidth = function (str, maxScreenColumn, screenColumn) {
                  if (maxScreenColumn === 0)
                      return [0, 0];
                  if (!maxScreenColumn)
                      maxScreenColumn = Infinity;
                  screenColumn = screenColumn || 0;
                  var c, column;
                  for (column = 0; column < str.length; column++) {
                      c = str.charAt(column);
                      if (c === "\t") {
                          screenColumn += this.getScreenTabSize(screenColumn);
                      }
                      else {
                          screenColumn += fm.getCharacterWidth(c);
                      }
                      if (screenColumn > maxScreenColumn) {
                          break;
                      }
                  }
                  return [screenColumn, column];
              };
          };
          this.destroy = function () {
              if (this.bgTokenizer) {
                  this.bgTokenizer.setDocument(null);
                  this.bgTokenizer = null;
              }
              this.$stopWorker();
          };
          this.isFullWidth = isFullWidth;
          function isFullWidth(c) {
              if (c < 0x1100)
                  return false;
              return c >= 0x1100 && c <= 0x115F ||
                  c >= 0x11A3 && c <= 0x11A7 ||
                  c >= 0x11FA && c <= 0x11FF ||
                  c >= 0x2329 && c <= 0x232A ||
                  c >= 0x2E80 && c <= 0x2E99 ||
                  c >= 0x2E9B && c <= 0x2EF3 ||
                  c >= 0x2F00 && c <= 0x2FD5 ||
                  c >= 0x2FF0 && c <= 0x2FFB ||
                  c >= 0x3000 && c <= 0x303E ||
                  c >= 0x3041 && c <= 0x3096 ||
                  c >= 0x3099 && c <= 0x30FF ||
                  c >= 0x3105 && c <= 0x312D ||
                  c >= 0x3131 && c <= 0x318E ||
                  c >= 0x3190 && c <= 0x31BA ||
                  c >= 0x31C0 && c <= 0x31E3 ||
                  c >= 0x31F0 && c <= 0x321E ||
                  c >= 0x3220 && c <= 0x3247 ||
                  c >= 0x3250 && c <= 0x32FE ||
                  c >= 0x3300 && c <= 0x4DBF ||
                  c >= 0x4E00 && c <= 0xA48C ||
                  c >= 0xA490 && c <= 0xA4C6 ||
                  c >= 0xA960 && c <= 0xA97C ||
                  c >= 0xAC00 && c <= 0xD7A3 ||
                  c >= 0xD7B0 && c <= 0xD7C6 ||
                  c >= 0xD7CB && c <= 0xD7FB ||
                  c >= 0xF900 && c <= 0xFAFF ||
                  c >= 0xFE10 && c <= 0xFE19 ||
                  c >= 0xFE30 && c <= 0xFE52 ||
                  c >= 0xFE54 && c <= 0xFE66 ||
                  c >= 0xFE68 && c <= 0xFE6B ||
                  c >= 0xFF01 && c <= 0xFF60 ||
                  c >= 0xFFE0 && c <= 0xFFE6;
          }
      }).call(EditSession.prototype);
      acequire("./edit_session/folding").Folding.call(EditSession.prototype);
      acequire("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);
      config.defineOptions(EditSession.prototype, "session", {
          wrap: {
              set: function (value) {
                  if (!value || value == "off")
                      value = false;
                  else if (value == "free")
                      value = true;
                  else if (value == "printMargin")
                      value = -1;
                  else if (typeof value == "string")
                      value = parseInt(value, 10) || false;
                  if (this.$wrap == value)
                      return;
                  this.$wrap = value;
                  if (!value) {
                      this.setUseWrapMode(false);
                  }
                  else {
                      var col = typeof value == "number" ? value : null;
                      this.setWrapLimitRange(col, col);
                      this.setUseWrapMode(true);
                  }
              },
              get: function () {
                  if (this.getUseWrapMode()) {
                      if (this.$wrap == -1)
                          return "printMargin";
                      if (!this.getWrapLimitRange().min)
                          return "free";
                      return this.$wrap;
                  }
                  return "off";
              },
              handlesSet: true
          },
          wrapMethod: {
              set: function (val) {
                  val = val == "auto"
                      ? this.$mode.type != "text"
                      : val != "text";
                  if (val != this.$wrapAsCode) {
                      this.$wrapAsCode = val;
                      if (this.$useWrapMode) {
                          this.$modified = true;
                          this.$resetRowCache(0);
                          this.$updateWrapData(0, this.getLength() - 1);
                      }
                  }
              },
              initialValue: "auto"
          },
          indentedSoftWrap: { initialValue: true },
          firstLineNumber: {
              set: function () { this._signal("changeBreakpoint"); },
              initialValue: 1
          },
          useWorker: {
              set: function (useWorker) {
                  this.$useWorker = useWorker;
                  this.$stopWorker();
                  if (useWorker)
                      this.$startWorker();
              },
              initialValue: true
          },
          useSoftTabs: { initialValue: true },
          tabSize: {
              set: function (tabSize) {
                  if (isNaN(tabSize) || this.$tabSize === tabSize)
                      return;
                  this.$modified = true;
                  this.$rowLengthCache = [];
                  this.$tabSize = tabSize;
                  this._signal("changeTabSize");
              },
              initialValue: 4,
              handlesSet: true
          },
          navigateWithinSoftTabs: { initialValue: false },
          overwrite: {
              set: function (val) { this._signal("changeOverwrite"); },
              initialValue: false
          },
          newLineMode: {
              set: function (val) { this.doc.setNewLineMode(val); },
              get: function () { return this.doc.getNewLineMode(); },
              handlesSet: true
          },
          mode: {
              set: function (val) { this.setMode(val); },
              get: function () { return this.$modeId; }
          }
      });
      exports.EditSession = EditSession;
  });
  ace.define("ace/search", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function (acequire, exports, module) {
      var lang = acequire("./lib/lang");
      var oop = acequire("./lib/oop");
      var Range = acequire("./range").Range;
      var Search = function () {
          this.$options = {};
      };
      (function () {
          this.set = function (options) {
              oop.mixin(this.$options, options);
              return this;
          };
          this.getOptions = function () {
              return lang.copyObject(this.$options);
          };
          this.setOptions = function (options) {
              this.$options = options;
          };
          this.find = function (session) {
              var options = this.$options;
              var iterator = this.$matchIterator(session, options);
              if (!iterator)
                  return false;
              var firstRange = null;
              iterator.forEach(function (sr, sc, er, ec) {
                  firstRange = new Range(sr, sc, er, ec);
                  if (sc == ec && options.start && options.start.start
                      && options.skipCurrent != false && firstRange.isEqual(options.start)) {
                      firstRange = null;
                      return false;
                  }
                  return true;
              });
              return firstRange;
          };
          this.findAll = function (session) {
              var options = this.$options;
              if (!options.needle)
                  return [];
              this.$assembleRegExp(options);
              var range = options.range;
              var lines = range
                  ? session.getLines(range.start.row, range.end.row)
                  : session.doc.getAllLines();
              var ranges = [];
              var re = options.re;
              if (options.$isMultiLine) {
                  var len = re.length;
                  var maxRow = lines.length - len;
                  var prevRange;
                  outer: for (var row = re.offset || 0; row <= maxRow; row++) {
                      for (var j = 0; j < len; j++)
                          if (lines[row + j].search(re[j]) == -1)
                              continue outer;
                      var startLine = lines[row];
                      var line = lines[row + len - 1];
                      var startIndex = startLine.length - startLine.match(re[0])[0].length;
                      var endIndex = line.match(re[len - 1])[0].length;
                      if (prevRange && prevRange.end.row === row &&
                          prevRange.end.column > startIndex) {
                          continue;
                      }
                      ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
                      if (len > 2)
                          row = row + len - 2;
                  }
              }
              else {
                  for (var i = 0; i < lines.length; i++) {
                      var matches = lang.getMatchOffsets(lines[i], re);
                      for (var j = 0; j < matches.length; j++) {
                          var match = matches[j];
                          ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                      }
                  }
              }
              if (range) {
                  var startColumn = range.start.column;
                  var endColumn = range.start.column;
                  var i = 0, j = ranges.length - 1;
                  while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
                      i++;
                  while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
                      j--;
                  ranges = ranges.slice(i, j + 1);
                  for (i = 0, j = ranges.length; i < j; i++) {
                      ranges[i].start.row += range.start.row;
                      ranges[i].end.row += range.start.row;
                  }
              }
              return ranges;
          };
          this.replace = function (input, replacement) {
              var options = this.$options;
              var re = this.$assembleRegExp(options);
              if (options.$isMultiLine)
                  return replacement;
              if (!re)
                  return;
              var match = re.exec(input);
              if (!match || match[0].length != input.length)
                  return null;
              replacement = input.replace(re, replacement);
              if (options.preserveCase) {
                  replacement = replacement.split("");
                  for (var i = Math.min(input.length, input.length); i--;) {
                      var ch = input[i];
                      if (ch && ch.toLowerCase() != ch)
                          replacement[i] = replacement[i].toUpperCase();
                      else
                          replacement[i] = replacement[i].toLowerCase();
                  }
                  replacement = replacement.join("");
              }
              return replacement;
          };
          this.$assembleRegExp = function (options, $disableFakeMultiline) {
              if (options.needle instanceof RegExp)
                  return options.re = options.needle;
              var needle = options.needle;
              if (!options.needle)
                  return options.re = false;
              if (!options.regExp)
                  needle = lang.escapeRegExp(needle);
              if (options.wholeWord)
                  needle = addWordBoundary(needle, options);
              var modifier = options.caseSensitive ? "gm" : "gmi";
              options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
              if (options.$isMultiLine)
                  return options.re = this.$assembleMultilineRegExp(needle, modifier);
              try {
                  var re = new RegExp(needle, modifier);
              }
              catch (e) {
                  re = false;
              }
              return options.re = re;
          };
          this.$assembleMultilineRegExp = function (needle, modifier) {
              var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
              var re = [];
              for (var i = 0; i < parts.length; i++)
                  try {
                      re.push(new RegExp(parts[i], modifier));
                  }
                  catch (e) {
                      return false;
                  }
              return re;
          };
          this.$matchIterator = function (session, options) {
              var re = this.$assembleRegExp(options);
              if (!re)
                  return false;
              var backwards = options.backwards == true;
              var skipCurrent = options.skipCurrent != false;
              var range = options.range;
              var start = options.start;
              if (!start)
                  start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
              if (start.start)
                  start = start[skipCurrent != backwards ? "end" : "start"];
              var firstRow = range ? range.start.row : 0;
              var lastRow = range ? range.end.row : session.getLength() - 1;
              if (backwards) {
                  var forEach = function (callback) {
                      var row = start.row;
                      if (forEachInLine(row, start.column, callback))
                          return;
                      for (row--; row >= firstRow; row--)
                          if (forEachInLine(row, Number.MAX_VALUE, callback))
                              return;
                      if (options.wrap == false)
                          return;
                      for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
                          if (forEachInLine(row, Number.MAX_VALUE, callback))
                              return;
                  };
              }
              else {
                  var forEach = function (callback) {
                      var row = start.row;
                      if (forEachInLine(row, start.column, callback))
                          return;
                      for (row = row + 1; row <= lastRow; row++)
                          if (forEachInLine(row, 0, callback))
                              return;
                      if (options.wrap == false)
                          return;
                      for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
                          if (forEachInLine(row, 0, callback))
                              return;
                  };
              }
              if (options.$isMultiLine) {
                  var len = re.length;
                  var forEachInLine = function (row, offset, callback) {
                      var startRow = backwards ? row - len + 1 : row;
                      if (startRow < 0)
                          return;
                      var line = session.getLine(startRow);
                      var startIndex = line.search(re[0]);
                      if (!backwards && startIndex < offset || startIndex === -1)
                          return;
                      for (var i = 1; i < len; i++) {
                          line = session.getLine(startRow + i);
                          if (line.search(re[i]) == -1)
                              return;
                      }
                      var endIndex = line.match(re[len - 1])[0].length;
                      if (backwards && endIndex > offset)
                          return;
                      if (callback(startRow, startIndex, startRow + len - 1, endIndex))
                          return true;
                  };
              }
              else if (backwards) {
                  var forEachInLine = function (row, endIndex, callback) {
                      var line = session.getLine(row);
                      var matches = [];
                      var m, last = 0;
                      re.lastIndex = 0;
                      while ((m = re.exec(line))) {
                          var length = m[0].length;
                          last = m.index;
                          if (!length) {
                              if (last >= line.length)
                                  break;
                              re.lastIndex = last += 1;
                          }
                          if (m.index + length > endIndex)
                              break;
                          matches.push(m.index, length);
                      }
                      for (var i = matches.length - 1; i >= 0; i -= 2) {
                          var column = matches[i - 1];
                          var length = matches[i];
                          if (callback(row, column, row, column + length))
                              return true;
                      }
                  };
              }
              else {
                  var forEachInLine = function (row, startIndex, callback) {
                      var line = session.getLine(row);
                      var m;
                      var last = startIndex;
                      re.lastIndex = startIndex;
                      while ((m = re.exec(line))) {
                          var length = m[0].length;
                          last = m.index;
                          if (callback(row, last, row, last + length))
                              return true;
                          if (!length) {
                              re.lastIndex = last += 1;
                              if (last >= line.length)
                                  return false;
                          }
                      }
                  };
              }
              return { forEach: forEach };
          };
      }).call(Search.prototype);
      function addWordBoundary(needle, options) {
          function wordBoundary(c) {
              if (/\w/.test(c) || options.regExp)
                  return "\\b";
              return "";
          }
          return wordBoundary(needle[0]) + needle
              + wordBoundary(needle[needle.length - 1]);
      }
      exports.Search = Search;
  });
  ace.define("ace/keyboard/hash_handler", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function (acequire, exports, module) {
      var keyUtil = acequire("../lib/keys");
      var useragent = acequire("../lib/useragent");
      var KEY_MODS = keyUtil.KEY_MODS;
      function HashHandler(config, platform) {
          this.platform = platform || (useragent.isMac ? "mac" : "win");
          this.commands = {};
          this.commandKeyBinding = {};
          this.addCommands(config);
          this.$singleCommand = true;
      }
      function MultiHashHandler(config, platform) {
          HashHandler.call(this, config, platform);
          this.$singleCommand = false;
      }
      MultiHashHandler.prototype = HashHandler.prototype;
      (function () {
          this.addCommand = function (command) {
              if (this.commands[command.name])
                  this.removeCommand(command);
              this.commands[command.name] = command;
              if (command.bindKey)
                  this._buildKeyHash(command);
          };
          this.removeCommand = function (command, keepCommand) {
              var name = command && (typeof command === 'string' ? command : command.name);
              command = this.commands[name];
              if (!keepCommand)
                  delete this.commands[name];
              var ckb = this.commandKeyBinding;
              for (var keyId in ckb) {
                  var cmdGroup = ckb[keyId];
                  if (cmdGroup == command) {
                      delete ckb[keyId];
                  }
                  else if (Array.isArray(cmdGroup)) {
                      var i = cmdGroup.indexOf(command);
                      if (i != -1) {
                          cmdGroup.splice(i, 1);
                          if (cmdGroup.length == 1)
                              ckb[keyId] = cmdGroup[0];
                      }
                  }
              }
          };
          this.bindKey = function (key, command, position) {
              if (typeof key == "object" && key) {
                  if (position == undefined)
                      position = key.position;
                  key = key[this.platform];
              }
              if (!key)
                  return;
              if (typeof command == "function")
                  return this.addCommand({ exec: command, bindKey: key, name: command.name || key });
              key.split("|").forEach(function (keyPart) {
                  var chain = "";
                  if (keyPart.indexOf(" ") != -1) {
                      var parts = keyPart.split(/\s+/);
                      keyPart = parts.pop();
                      parts.forEach(function (keyPart) {
                          var binding = this.parseKeys(keyPart);
                          var id = KEY_MODS[binding.hashId] + binding.key;
                          chain += (chain ? " " : "") + id;
                          this._addCommandToBinding(chain, "chainKeys");
                      }, this);
                      chain += " ";
                  }
                  var binding = this.parseKeys(keyPart);
                  var id = KEY_MODS[binding.hashId] + binding.key;
                  this._addCommandToBinding(chain + id, command, position);
              }, this);
          };
          function getPosition(command) {
              return typeof command == "object" && command.bindKey
                  && command.bindKey.position
                  || (command.isDefault ? -100 : 0);
          }
          this._addCommandToBinding = function (keyId, command, position) {
              var ckb = this.commandKeyBinding, i;
              if (!command) {
                  delete ckb[keyId];
              }
              else if (!ckb[keyId] || this.$singleCommand) {
                  ckb[keyId] = command;
              }
              else {
                  if (!Array.isArray(ckb[keyId])) {
                      ckb[keyId] = [ckb[keyId]];
                  }
                  else if ((i = ckb[keyId].indexOf(command)) != -1) {
                      ckb[keyId].splice(i, 1);
                  }
                  if (typeof position != "number") {
                      position = getPosition(command);
                  }
                  var commands = ckb[keyId];
                  for (i = 0; i < commands.length; i++) {
                      var other = commands[i];
                      var otherPos = getPosition(other);
                      if (otherPos > position)
                          break;
                  }
                  commands.splice(i, 0, command);
              }
          };
          this.addCommands = function (commands) {
              commands && Object.keys(commands).forEach(function (name) {
                  var command = commands[name];
                  if (!command)
                      return;
                  if (typeof command === "string")
                      return this.bindKey(command, name);
                  if (typeof command === "function")
                      command = { exec: command };
                  if (typeof command !== "object")
                      return;
                  if (!command.name)
                      command.name = name;
                  this.addCommand(command);
              }, this);
          };
          this.removeCommands = function (commands) {
              Object.keys(commands).forEach(function (name) {
                  this.removeCommand(commands[name]);
              }, this);
          };
          this.bindKeys = function (keyList) {
              Object.keys(keyList).forEach(function (key) {
                  this.bindKey(key, keyList[key]);
              }, this);
          };
          this._buildKeyHash = function (command) {
              this.bindKey(command.bindKey, command);
          };
          this.parseKeys = function (keys) {
              var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function (x) { return x; });
              var key = parts.pop();
              var keyCode = keyUtil[key];
              if (keyUtil.FUNCTION_KEYS[keyCode])
                  key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
              else if (!parts.length)
                  return { key: key, hashId: -1 };
              else if (parts.length == 1 && parts[0] == "shift")
                  return { key: key.toUpperCase(), hashId: -1 };
              var hashId = 0;
              for (var i = parts.length; i--;) {
                  var modifier = keyUtil.KEY_MODS[parts[i]];
                  if (modifier == null) {
                      if (typeof console != "undefined")
                          console.error("invalid modifier " + parts[i] + " in " + keys);
                      return false;
                  }
                  hashId |= modifier;
              }
              return { key: key, hashId: hashId };
          };
          this.findKeyCommand = function findKeyCommand(hashId, keyString) {
              var key = KEY_MODS[hashId] + keyString;
              return this.commandKeyBinding[key];
          };
          this.handleKeyboard = function (data, hashId, keyString, keyCode) {
              if (keyCode < 0)
                  return;
              var key = KEY_MODS[hashId] + keyString;
              var command = this.commandKeyBinding[key];
              if (data.$keyChain) {
                  data.$keyChain += " " + key;
                  command = this.commandKeyBinding[data.$keyChain] || command;
              }
              if (command) {
                  if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                      data.$keyChain = data.$keyChain || key;
                      return { command: "null" };
                  }
              }
              if (data.$keyChain) {
                  if ((!hashId || hashId == 4) && keyString.length == 1)
                      data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
                  else if (hashId == -1 || keyCode > 0)
                      data.$keyChain = ""; // reset keyChain
              }
              return { command: command };
          };
          this.getStatusText = function (editor, data) {
              return data.$keyChain || "";
          };
      }).call(HashHandler.prototype);
      exports.HashHandler = HashHandler;
      exports.MultiHashHandler = MultiHashHandler;
  });
  ace.define("ace/commands/command_manager", ["require", "exports", "module", "ace/lib/oop", "ace/keyboard/hash_handler", "ace/lib/event_emitter"], function (acequire, exports, module) {
      var oop = acequire("../lib/oop");
      var MultiHashHandler = acequire("../keyboard/hash_handler").MultiHashHandler;
      var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
      var CommandManager = function (platform, commands) {
          MultiHashHandler.call(this, commands, platform);
          this.byName = this.commands;
          this.setDefaultHandler("exec", function (e) {
              return e.command.exec(e.editor, e.args || {});
          });
      };
      oop.inherits(CommandManager, MultiHashHandler);
      (function () {
          oop.implement(this, EventEmitter);
          this.exec = function (command, editor, args) {
              if (Array.isArray(command)) {
                  for (var i = command.length; i--;) {
                      if (this.exec(command[i], editor, args))
                          return true;
                  }
                  return false;
              }
              if (typeof command === "string")
                  command = this.commands[command];
              if (!command)
                  return false;
              if (editor && editor.$readOnly && !command.readOnly)
                  return false;
              if (command.isAvailable && !command.isAvailable(editor))
                  return false;
              var e = { editor: editor, command: command, args: args };
              e.returnValue = this._emit("exec", e);
              this._signal("afterExec", e);
              return e.returnValue === false ? false : true;
          };
          this.toggleRecording = function (editor) {
              if (this.$inReplay)
                  return;
              editor && editor._emit("changeStatus");
              if (this.recording) {
                  this.macro.pop();
                  this.removeEventListener("exec", this.$addCommandToMacro);
                  if (!this.macro.length)
                      this.macro = this.oldMacro;
                  return this.recording = false;
              }
              if (!this.$addCommandToMacro) {
                  this.$addCommandToMacro = function (e) {
                      this.macro.push([e.command, e.args]);
                  }.bind(this);
              }
              this.oldMacro = this.macro;
              this.macro = [];
              this.on("exec", this.$addCommandToMacro);
              return this.recording = true;
          };
          this.replay = function (editor) {
              if (this.$inReplay || !this.macro)
                  return;
              if (this.recording)
                  return this.toggleRecording(editor);
              try {
                  this.$inReplay = true;
                  this.macro.forEach(function (x) {
                      if (typeof x == "string")
                          this.exec(x, editor);
                      else
                          this.exec(x[0], editor, x[1]);
                  }, this);
              }
              finally {
                  this.$inReplay = false;
              }
          };
          this.trimMacro = function (m) {
              return m.map(function (x) {
                  if (typeof x[0] != "string")
                      x[0] = x[0].name;
                  if (!x[1])
                      x = x[0];
                  return x;
              });
          };
      }).call(CommandManager.prototype);
      exports.CommandManager = CommandManager;
  });
  ace.define("ace/commands/default_commands", ["require", "exports", "module", "ace/lib/lang", "ace/config", "ace/range"], function (acequire, exports, module) {
      var lang = acequire("../lib/lang");
      var config = acequire("../config");
      var Range = acequire("../range").Range;
      function bindKey(win, mac) {
          return { win: win, mac: mac };
      }
      exports.commands = [{
              name: "showSettingsMenu",
              bindKey: bindKey("Ctrl-,", "Command-,"),
              exec: function (editor) {
                  config.loadModule("ace/ext/settings_menu", function (module) {
                      module.init(editor);
                      editor.showSettingsMenu();
                  });
              },
              readOnly: true
          }, {
              name: "goToNextError",
              bindKey: bindKey("Alt-E", "F4"),
              exec: function (editor) {
                  config.loadModule("ace/ext/error_marker", function (module) {
                      module.showErrorMarker(editor, 1);
                  });
              },
              scrollIntoView: "animate",
              readOnly: true
          }, {
              name: "goToPreviousError",
              bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
              exec: function (editor) {
                  config.loadModule("ace/ext/error_marker", function (module) {
                      module.showErrorMarker(editor, -1);
                  });
              },
              scrollIntoView: "animate",
              readOnly: true
          }, {
              name: "selectall",
              bindKey: bindKey("Ctrl-A", "Command-A"),
              exec: function (editor) { editor.selectAll(); },
              readOnly: true
          }, {
              name: "centerselection",
              bindKey: bindKey(null, "Ctrl-L"),
              exec: function (editor) { editor.centerSelection(); },
              readOnly: true
          }, {
              name: "gotoline",
              bindKey: bindKey("Ctrl-L", "Command-L"),
              exec: function (editor) {
                  var line = parseInt(prompt("Enter line number:"), 10);
                  if (!isNaN(line)) {
                      editor.gotoLine(line);
                  }
              },
              readOnly: true
          }, {
              name: "fold",
              bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
              exec: function (editor) { editor.session.toggleFold(false); },
              multiSelectAction: "forEach",
              scrollIntoView: "center",
              readOnly: true
          }, {
              name: "unfold",
              bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
              exec: function (editor) { editor.session.toggleFold(true); },
              multiSelectAction: "forEach",
              scrollIntoView: "center",
              readOnly: true
          }, {
              name: "toggleFoldWidget",
              bindKey: bindKey("F2", "F2"),
              exec: function (editor) { editor.session.toggleFoldWidget(); },
              multiSelectAction: "forEach",
              scrollIntoView: "center",
              readOnly: true
          }, {
              name: "toggleParentFoldWidget",
              bindKey: bindKey("Alt-F2", "Alt-F2"),
              exec: function (editor) { editor.session.toggleFoldWidget(true); },
              multiSelectAction: "forEach",
              scrollIntoView: "center",
              readOnly: true
          }, {
              name: "foldall",
              bindKey: bindKey(null, "Ctrl-Command-Option-0"),
              exec: function (editor) { editor.session.foldAll(); },
              scrollIntoView: "center",
              readOnly: true
          }, {
              name: "foldOther",
              bindKey: bindKey("Alt-0", "Command-Option-0"),
              exec: function (editor) {
                  editor.session.foldAll();
                  editor.session.unfold(editor.selection.getAllRanges());
              },
              scrollIntoView: "center",
              readOnly: true
          }, {
              name: "unfoldall",
              bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
              exec: function (editor) { editor.session.unfold(); },
              scrollIntoView: "center",
              readOnly: true
          }, {
              name: "findnext",
              bindKey: bindKey("Ctrl-K", "Command-G"),
              exec: function (editor) { editor.findNext(); },
              multiSelectAction: "forEach",
              scrollIntoView: "center",
              readOnly: true
          }, {
              name: "findprevious",
              bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
              exec: function (editor) { editor.findPrevious(); },
              multiSelectAction: "forEach",
              scrollIntoView: "center",
              readOnly: true
          }, {
              name: "selectOrFindNext",
              bindKey: bindKey("Alt-K", "Ctrl-G"),
              exec: function (editor) {
                  if (editor.selection.isEmpty())
                      editor.selection.selectWord();
                  else
                      editor.findNext();
              },
              readOnly: true
          }, {
              name: "selectOrFindPrevious",
              bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
              exec: function (editor) {
                  if (editor.selection.isEmpty())
                      editor.selection.selectWord();
                  else
                      editor.findPrevious();
              },
              readOnly: true
          }, {
              name: "find",
              bindKey: bindKey("Ctrl-F", "Command-F"),
              exec: function (editor) {
                  config.loadModule("ace/ext/searchbox", function (e) { e.Search(editor); });
              },
              readOnly: true
          }, {
              name: "overwrite",
              bindKey: "Insert",
              exec: function (editor) { editor.toggleOverwrite(); },
              readOnly: true
          }, {
              name: "selecttostart",
              bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
              exec: function (editor) { editor.getSelection().selectFileStart(); },
              multiSelectAction: "forEach",
              readOnly: true,
              scrollIntoView: "animate",
              aceCommandGroup: "fileJump"
          }, {
              name: "gotostart",
              bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
              exec: function (editor) { editor.navigateFileStart(); },
              multiSelectAction: "forEach",
              readOnly: true,
              scrollIntoView: "animate",
              aceCommandGroup: "fileJump"
          }, {
              name: "selectup",
              bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
              exec: function (editor) { editor.getSelection().selectUp(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "golineup",
              bindKey: bindKey("Up", "Up|Ctrl-P"),
              exec: function (editor, args) { editor.navigateUp(args.times); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "selecttoend",
              bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
              exec: function (editor) { editor.getSelection().selectFileEnd(); },
              multiSelectAction: "forEach",
              readOnly: true,
              scrollIntoView: "animate",
              aceCommandGroup: "fileJump"
          }, {
              name: "gotoend",
              bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
              exec: function (editor) { editor.navigateFileEnd(); },
              multiSelectAction: "forEach",
              readOnly: true,
              scrollIntoView: "animate",
              aceCommandGroup: "fileJump"
          }, {
              name: "selectdown",
              bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
              exec: function (editor) { editor.getSelection().selectDown(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "golinedown",
              bindKey: bindKey("Down", "Down|Ctrl-N"),
              exec: function (editor, args) { editor.navigateDown(args.times); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "selectwordleft",
              bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
              exec: function (editor) { editor.getSelection().selectWordLeft(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "gotowordleft",
              bindKey: bindKey("Ctrl-Left", "Option-Left"),
              exec: function (editor) { editor.navigateWordLeft(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "selecttolinestart",
              bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
              exec: function (editor) { editor.getSelection().selectLineStart(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "gotolinestart",
              bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
              exec: function (editor) { editor.navigateLineStart(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "selectleft",
              bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
              exec: function (editor) { editor.getSelection().selectLeft(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "gotoleft",
              bindKey: bindKey("Left", "Left|Ctrl-B"),
              exec: function (editor, args) { editor.navigateLeft(args.times); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "selectwordright",
              bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
              exec: function (editor) { editor.getSelection().selectWordRight(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "gotowordright",
              bindKey: bindKey("Ctrl-Right", "Option-Right"),
              exec: function (editor) { editor.navigateWordRight(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "selecttolineend",
              bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
              exec: function (editor) { editor.getSelection().selectLineEnd(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "gotolineend",
              bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
              exec: function (editor) { editor.navigateLineEnd(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "selectright",
              bindKey: bindKey("Shift-Right", "Shift-Right"),
              exec: function (editor) { editor.getSelection().selectRight(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "gotoright",
              bindKey: bindKey("Right", "Right|Ctrl-F"),
              exec: function (editor, args) { editor.navigateRight(args.times); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "selectpagedown",
              bindKey: "Shift-PageDown",
              exec: function (editor) { editor.selectPageDown(); },
              readOnly: true
          }, {
              name: "pagedown",
              bindKey: bindKey(null, "Option-PageDown"),
              exec: function (editor) { editor.scrollPageDown(); },
              readOnly: true
          }, {
              name: "gotopagedown",
              bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
              exec: function (editor) { editor.gotoPageDown(); },
              readOnly: true
          }, {
              name: "selectpageup",
              bindKey: "Shift-PageUp",
              exec: function (editor) { editor.selectPageUp(); },
              readOnly: true
          }, {
              name: "pageup",
              bindKey: bindKey(null, "Option-PageUp"),
              exec: function (editor) { editor.scrollPageUp(); },
              readOnly: true
          }, {
              name: "gotopageup",
              bindKey: "PageUp",
              exec: function (editor) { editor.gotoPageUp(); },
              readOnly: true
          }, {
              name: "scrollup",
              bindKey: bindKey("Ctrl-Up", null),
              exec: function (e) { e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight); },
              readOnly: true
          }, {
              name: "scrolldown",
              bindKey: bindKey("Ctrl-Down", null),
              exec: function (e) { e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight); },
              readOnly: true
          }, {
              name: "selectlinestart",
              bindKey: "Shift-Home",
              exec: function (editor) { editor.getSelection().selectLineStart(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "selectlineend",
              bindKey: "Shift-End",
              exec: function (editor) { editor.getSelection().selectLineEnd(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "togglerecording",
              bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
              exec: function (editor) { editor.commands.toggleRecording(editor); },
              readOnly: true
          }, {
              name: "replaymacro",
              bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
              exec: function (editor) { editor.commands.replay(editor); },
              readOnly: true
          }, {
              name: "jumptomatching",
              bindKey: bindKey("Ctrl-P", "Ctrl-P"),
              exec: function (editor) { editor.jumpToMatching(); },
              multiSelectAction: "forEach",
              scrollIntoView: "animate",
              readOnly: true
          }, {
              name: "selecttomatching",
              bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
              exec: function (editor) { editor.jumpToMatching(true); },
              multiSelectAction: "forEach",
              scrollIntoView: "animate",
              readOnly: true
          }, {
              name: "expandToMatching",
              bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
              exec: function (editor) { editor.jumpToMatching(true, true); },
              multiSelectAction: "forEach",
              scrollIntoView: "animate",
              readOnly: true
          }, {
              name: "passKeysToBrowser",
              bindKey: bindKey(null, null),
              exec: function () { },
              passEvent: true,
              readOnly: true
          }, {
              name: "copy",
              exec: function (editor) {
              },
              readOnly: true
          },
          {
              name: "cut",
              exec: function (editor) {
                  var range = editor.getSelectionRange();
                  editor._emit("cut", range);
                  if (!editor.selection.isEmpty()) {
                      editor.session.remove(range);
                      editor.clearSelection();
                  }
              },
              scrollIntoView: "cursor",
              multiSelectAction: "forEach"
          }, {
              name: "paste",
              exec: function (editor, args) {
                  editor.$handlePaste(args);
              },
              scrollIntoView: "cursor"
          }, {
              name: "removeline",
              bindKey: bindKey("Ctrl-D", "Command-D"),
              exec: function (editor) { editor.removeLines(); },
              scrollIntoView: "cursor",
              multiSelectAction: "forEachLine"
          }, {
              name: "duplicateSelection",
              bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
              exec: function (editor) { editor.duplicateSelection(); },
              scrollIntoView: "cursor",
              multiSelectAction: "forEach"
          }, {
              name: "sortlines",
              bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
              exec: function (editor) { editor.sortLines(); },
              scrollIntoView: "selection",
              multiSelectAction: "forEachLine"
          }, {
              name: "togglecomment",
              bindKey: bindKey("Ctrl-/", "Command-/"),
              exec: function (editor) { editor.toggleCommentLines(); },
              multiSelectAction: "forEachLine",
              scrollIntoView: "selectionPart"
          }, {
              name: "toggleBlockComment",
              bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
              exec: function (editor) { editor.toggleBlockComment(); },
              multiSelectAction: "forEach",
              scrollIntoView: "selectionPart"
          }, {
              name: "modifyNumberUp",
              bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
              exec: function (editor) { editor.modifyNumber(1); },
              scrollIntoView: "cursor",
              multiSelectAction: "forEach"
          }, {
              name: "modifyNumberDown",
              bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
              exec: function (editor) { editor.modifyNumber(-1); },
              scrollIntoView: "cursor",
              multiSelectAction: "forEach"
          }, {
              name: "replace",
              bindKey: bindKey("Ctrl-H", "Command-Option-F"),
              exec: function (editor) {
                  config.loadModule("ace/ext/searchbox", function (e) { e.Search(editor, true); });
              }
          }, {
              name: "undo",
              bindKey: bindKey("Ctrl-Z", "Command-Z"),
              exec: function (editor) { editor.undo(); }
          }, {
              name: "redo",
              bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
              exec: function (editor) { editor.redo(); }
          }, {
              name: "copylinesup",
              bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
              exec: function (editor) { editor.copyLinesUp(); },
              scrollIntoView: "cursor"
          }, {
              name: "movelinesup",
              bindKey: bindKey("Alt-Up", "Option-Up"),
              exec: function (editor) { editor.moveLinesUp(); },
              scrollIntoView: "cursor"
          }, {
              name: "copylinesdown",
              bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
              exec: function (editor) { editor.copyLinesDown(); },
              scrollIntoView: "cursor"
          }, {
              name: "movelinesdown",
              bindKey: bindKey("Alt-Down", "Option-Down"),
              exec: function (editor) { editor.moveLinesDown(); },
              scrollIntoView: "cursor"
          }, {
              name: "del",
              bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
              exec: function (editor) { editor.remove("right"); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor"
          }, {
              name: "backspace",
              bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
              exec: function (editor) { editor.remove("left"); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor"
          }, {
              name: "cut_or_delete",
              bindKey: bindKey("Shift-Delete", null),
              exec: function (editor) {
                  if (editor.selection.isEmpty()) {
                      editor.remove("left");
                  }
                  else {
                      return false;
                  }
              },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor"
          }, {
              name: "removetolinestart",
              bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
              exec: function (editor) { editor.removeToLineStart(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor"
          }, {
              name: "removetolineend",
              bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
              exec: function (editor) { editor.removeToLineEnd(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor"
          }, {
              name: "removetolinestarthard",
              bindKey: bindKey("Ctrl-Shift-Backspace", null),
              exec: function (editor) {
                  var range = editor.selection.getRange();
                  range.start.column = 0;
                  editor.session.remove(range);
              },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor"
          }, {
              name: "removetolineendhard",
              bindKey: bindKey("Ctrl-Shift-Delete", null),
              exec: function (editor) {
                  var range = editor.selection.getRange();
                  range.end.column = Number.MAX_VALUE;
                  editor.session.remove(range);
              },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor"
          }, {
              name: "removewordleft",
              bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
              exec: function (editor) { editor.removeWordLeft(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor"
          }, {
              name: "removewordright",
              bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
              exec: function (editor) { editor.removeWordRight(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor"
          }, {
              name: "outdent",
              bindKey: bindKey("Shift-Tab", "Shift-Tab"),
              exec: function (editor) { editor.blockOutdent(); },
              multiSelectAction: "forEach",
              scrollIntoView: "selectionPart"
          }, {
              name: "indent",
              bindKey: bindKey("Tab", "Tab"),
              exec: function (editor) { editor.indent(); },
              multiSelectAction: "forEach",
              scrollIntoView: "selectionPart"
          }, {
              name: "blockoutdent",
              bindKey: bindKey("Ctrl-[", "Ctrl-["),
              exec: function (editor) { editor.blockOutdent(); },
              multiSelectAction: "forEachLine",
              scrollIntoView: "selectionPart"
          }, {
              name: "blockindent",
              bindKey: bindKey("Ctrl-]", "Ctrl-]"),
              exec: function (editor) { editor.blockIndent(); },
              multiSelectAction: "forEachLine",
              scrollIntoView: "selectionPart"
          }, {
              name: "insertstring",
              exec: function (editor, str) { editor.insert(str); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor"
          }, {
              name: "inserttext",
              exec: function (editor, args) {
                  editor.insert(lang.stringRepeat(args.text || "", args.times || 1));
              },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor"
          }, {
              name: "splitline",
              bindKey: bindKey(null, "Ctrl-O"),
              exec: function (editor) { editor.splitLine(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor"
          }, {
              name: "transposeletters",
              bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
              exec: function (editor) { editor.transposeLetters(); },
              multiSelectAction: function (editor) { editor.transposeSelections(1); },
              scrollIntoView: "cursor"
          }, {
              name: "touppercase",
              bindKey: bindKey("Ctrl-U", "Ctrl-U"),
              exec: function (editor) { editor.toUpperCase(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor"
          }, {
              name: "tolowercase",
              bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
              exec: function (editor) { editor.toLowerCase(); },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor"
          }, {
              name: "expandtoline",
              bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
              exec: function (editor) {
                  var range = editor.selection.getRange();
                  range.start.column = range.end.column = 0;
                  range.end.row++;
                  editor.selection.setRange(range, false);
              },
              multiSelectAction: "forEach",
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "joinlines",
              bindKey: bindKey(null, null),
              exec: function (editor) {
                  var isBackwards = editor.selection.isBackwards();
                  var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
                  var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
                  var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
                  var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
                  var selectedCount = selectedText.replace(/\n\s*/, " ").length;
                  var insertLine = editor.session.doc.getLine(selectionStart.row);
                  for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
                      var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
                      if (curLine.length !== 0) {
                          curLine = " " + curLine;
                      }
                      insertLine += curLine;
                  }
                  if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
                      insertLine += editor.session.doc.getNewLineCharacter();
                  }
                  editor.clearSelection();
                  editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
                  if (selectedCount > 0) {
                      editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
                      editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
                  }
                  else {
                      firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
                      editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
                  }
              },
              multiSelectAction: "forEach",
              readOnly: true
          }, {
              name: "invertSelection",
              bindKey: bindKey(null, null),
              exec: function (editor) {
                  var endRow = editor.session.doc.getLength() - 1;
                  var endCol = editor.session.doc.getLine(endRow).length;
                  var ranges = editor.selection.rangeList.ranges;
                  var newRanges = [];
                  if (ranges.length < 1) {
                      ranges = [editor.selection.getRange()];
                  }
                  for (var i = 0; i < ranges.length; i++) {
                      if (i == (ranges.length - 1)) {
                          if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                              newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                          }
                      }
                      if (i === 0) {
                          if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                              newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                          }
                      }
                      else {
                          newRanges.push(new Range(ranges[i - 1].end.row, ranges[i - 1].end.column, ranges[i].start.row, ranges[i].start.column));
                      }
                  }
                  editor.exitMultiSelectMode();
                  editor.clearSelection();
                  for (var i = 0; i < newRanges.length; i++) {
                      editor.selection.addRange(newRanges[i], false);
                  }
              },
              readOnly: true,
              scrollIntoView: "none"
          }];
  });
  ace.define("ace/editor", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/keyboard/textinput", "ace/mouse/mouse_handler", "ace/mouse/fold_handler", "ace/keyboard/keybinding", "ace/edit_session", "ace/search", "ace/range", "ace/lib/event_emitter", "ace/commands/command_manager", "ace/commands/default_commands", "ace/config", "ace/token_iterator"], function (acequire, exports, module) {
      acequire("./lib/fixoldbrowsers");
      var oop = acequire("./lib/oop");
      var dom = acequire("./lib/dom");
      var lang = acequire("./lib/lang");
      var useragent = acequire("./lib/useragent");
      var TextInput = acequire("./keyboard/textinput").TextInput;
      var MouseHandler = acequire("./mouse/mouse_handler").MouseHandler;
      var FoldHandler = acequire("./mouse/fold_handler").FoldHandler;
      var KeyBinding = acequire("./keyboard/keybinding").KeyBinding;
      var EditSession = acequire("./edit_session").EditSession;
      var Search = acequire("./search").Search;
      var Range = acequire("./range").Range;
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var CommandManager = acequire("./commands/command_manager").CommandManager;
      var defaultCommands = acequire("./commands/default_commands").commands;
      var config = acequire("./config");
      var TokenIterator = acequire("./token_iterator").TokenIterator;
      var Editor = function (renderer, session) {
          var container = renderer.getContainerElement();
          this.container = container;
          this.renderer = renderer;
          this.id = "editor" + (++Editor.$uid);
          this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
          if (typeof document == "object") {
              this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
              this.renderer.textarea = this.textInput.getElement();
              this.$mouseHandler = new MouseHandler(this);
              new FoldHandler(this);
          }
          this.keyBinding = new KeyBinding(this);
          this.$blockScrolling = 0;
          this.$search = new Search().set({
              wrap: true
          });
          this.$historyTracker = this.$historyTracker.bind(this);
          this.commands.on("exec", this.$historyTracker);
          this.$initOperationListeners();
          this._$emitInputEvent = lang.delayedCall(function () {
              this._signal("input", {});
              if (this.session && this.session.bgTokenizer)
                  this.session.bgTokenizer.scheduleStart();
          }.bind(this));
          this.on("change", function (_, _self) {
              _self._$emitInputEvent.schedule(31);
          });
          this.setSession(session || new EditSession(""));
          config.resetOptions(this);
          config._signal("editor", this);
      };
      Editor.$uid = 0;
      (function () {
          oop.implement(this, EventEmitter);
          this.$initOperationListeners = function () {
              this.selections = [];
              this.commands.on("exec", this.startOperation.bind(this), true);
              this.commands.on("afterExec", this.endOperation.bind(this), true);
              this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));
              this.on("change", function () {
                  this.curOp || this.startOperation();
                  this.curOp.docChanged = true;
              }.bind(this), true);
              this.on("changeSelection", function () {
                  this.curOp || this.startOperation();
                  this.curOp.selectionChanged = true;
              }.bind(this), true);
          };
          this.curOp = null;
          this.prevOp = {};
          this.startOperation = function (commadEvent) {
              if (this.curOp) {
                  if (!commadEvent || this.curOp.command)
                      return;
                  this.prevOp = this.curOp;
              }
              if (!commadEvent) {
                  this.previousCommand = null;
                  commadEvent = {};
              }
              this.$opResetTimer.schedule();
              this.curOp = {
                  command: commadEvent.command || {},
                  args: commadEvent.args,
                  scrollTop: this.renderer.scrollTop
              };
              if (this.curOp.command.name && this.curOp.command.scrollIntoView !== undefined)
                  this.$blockScrolling++;
          };
          this.endOperation = function (e) {
              if (this.curOp) {
                  if (e && e.returnValue === false)
                      return this.curOp = null;
                  this._signal("beforeEndOperation");
                  var command = this.curOp.command;
                  if (command.name && this.$blockScrolling > 0)
                      this.$blockScrolling--;
                  var scrollIntoView = command && command.scrollIntoView;
                  if (scrollIntoView) {
                      switch (scrollIntoView) {
                          case "center-animate":
                              scrollIntoView = "animate";
                          case "center":
                              this.renderer.scrollCursorIntoView(null, 0.5);
                              break;
                          case "animate":
                          case "cursor":
                              this.renderer.scrollCursorIntoView();
                              break;
                          case "selectionPart":
                              var range = this.selection.getRange();
                              var config = this.renderer.layerConfig;
                              if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                                  this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                              }
                              break;
                          default:
                              break;
                      }
                      if (scrollIntoView == "animate")
                          this.renderer.animateScrolling(this.curOp.scrollTop);
                  }
                  this.prevOp = this.curOp;
                  this.curOp = null;
              }
          };
          this.$mergeableCommands = ["backspace", "del", "insertstring"];
          this.$historyTracker = function (e) {
              if (!this.$mergeUndoDeltas)
                  return;
              var prev = this.prevOp;
              var mergeableCommands = this.$mergeableCommands;
              var shouldMerge = prev.command && (e.command.name == prev.command.name);
              if (e.command.name == "insertstring") {
                  var text = e.args;
                  if (this.mergeNextCommand === undefined)
                      this.mergeNextCommand = true;
                  shouldMerge = shouldMerge
                      && this.mergeNextCommand // previous command allows to coalesce with
                      && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type
                  this.mergeNextCommand = true;
              }
              else {
                  shouldMerge = shouldMerge
                      && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
              }
              if (this.$mergeUndoDeltas != "always"
                  && Date.now() - this.sequenceStartTime > 2000) {
                  shouldMerge = false; // the sequence is too long
              }
              if (shouldMerge)
                  this.session.mergeUndoDeltas = true;
              else if (mergeableCommands.indexOf(e.command.name) !== -1)
                  this.sequenceStartTime = Date.now();
          };
          this.setKeyboardHandler = function (keyboardHandler, cb) {
              if (keyboardHandler && typeof keyboardHandler === "string") {
                  this.$keybindingId = keyboardHandler;
                  var _self = this;
                  config.loadModule(["keybinding", keyboardHandler], function (module) {
                      if (_self.$keybindingId == keyboardHandler)
                          _self.keyBinding.setKeyboardHandler(module && module.handler);
                      cb && cb();
                  });
              }
              else {
                  this.$keybindingId = null;
                  this.keyBinding.setKeyboardHandler(keyboardHandler);
                  cb && cb();
              }
          };
          this.getKeyboardHandler = function () {
              return this.keyBinding.getKeyboardHandler();
          };
          this.setSession = function (session) {
              if (this.session == session)
                  return;
              if (this.curOp)
                  this.endOperation();
              this.curOp = {};
              var oldSession = this.session;
              if (oldSession) {
                  this.session.off("change", this.$onDocumentChange);
                  this.session.off("changeMode", this.$onChangeMode);
                  this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
                  this.session.off("changeTabSize", this.$onChangeTabSize);
                  this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
                  this.session.off("changeWrapMode", this.$onChangeWrapMode);
                  this.session.off("changeFold", this.$onChangeFold);
                  this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
                  this.session.off("changeBackMarker", this.$onChangeBackMarker);
                  this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
                  this.session.off("changeAnnotation", this.$onChangeAnnotation);
                  this.session.off("changeOverwrite", this.$onCursorChange);
                  this.session.off("changeScrollTop", this.$onScrollTopChange);
                  this.session.off("changeScrollLeft", this.$onScrollLeftChange);
                  var selection = this.session.getSelection();
                  selection.off("changeCursor", this.$onCursorChange);
                  selection.off("changeSelection", this.$onSelectionChange);
              }
              this.session = session;
              if (session) {
                  this.$onDocumentChange = this.onDocumentChange.bind(this);
                  session.on("change", this.$onDocumentChange);
                  this.renderer.setSession(session);
                  this.$onChangeMode = this.onChangeMode.bind(this);
                  session.on("changeMode", this.$onChangeMode);
                  this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
                  session.on("tokenizerUpdate", this.$onTokenizerUpdate);
                  this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
                  session.on("changeTabSize", this.$onChangeTabSize);
                  this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
                  session.on("changeWrapLimit", this.$onChangeWrapLimit);
                  this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
                  session.on("changeWrapMode", this.$onChangeWrapMode);
                  this.$onChangeFold = this.onChangeFold.bind(this);
                  session.on("changeFold", this.$onChangeFold);
                  this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
                  this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
                  this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
                  this.session.on("changeBackMarker", this.$onChangeBackMarker);
                  this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
                  this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
                  this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
                  this.session.on("changeAnnotation", this.$onChangeAnnotation);
                  this.$onCursorChange = this.onCursorChange.bind(this);
                  this.session.on("changeOverwrite", this.$onCursorChange);
                  this.$onScrollTopChange = this.onScrollTopChange.bind(this);
                  this.session.on("changeScrollTop", this.$onScrollTopChange);
                  this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
                  this.session.on("changeScrollLeft", this.$onScrollLeftChange);
                  this.selection = session.getSelection();
                  this.selection.on("changeCursor", this.$onCursorChange);
                  this.$onSelectionChange = this.onSelectionChange.bind(this);
                  this.selection.on("changeSelection", this.$onSelectionChange);
                  this.onChangeMode();
                  this.$blockScrolling += 1;
                  this.onCursorChange();
                  this.$blockScrolling -= 1;
                  this.onScrollTopChange();
                  this.onScrollLeftChange();
                  this.onSelectionChange();
                  this.onChangeFrontMarker();
                  this.onChangeBackMarker();
                  this.onChangeBreakpoint();
                  this.onChangeAnnotation();
                  this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
                  this.renderer.updateFull();
              }
              else {
                  this.selection = null;
                  this.renderer.setSession(session);
              }
              this._signal("changeSession", {
                  session: session,
                  oldSession: oldSession
              });
              this.curOp = null;
              oldSession && oldSession._signal("changeEditor", { oldEditor: this });
              session && session._signal("changeEditor", { editor: this });
              if (session && session.bgTokenizer)
                  session.bgTokenizer.scheduleStart();
          };
          this.getSession = function () {
              return this.session;
          };
          this.setValue = function (val, cursorPos) {
              this.session.doc.setValue(val);
              if (!cursorPos)
                  this.selectAll();
              else if (cursorPos == 1)
                  this.navigateFileEnd();
              else if (cursorPos == -1)
                  this.navigateFileStart();
              return val;
          };
          this.getValue = function () {
              return this.session.getValue();
          };
          this.getSelection = function () {
              return this.selection;
          };
          this.resize = function (force) {
              this.renderer.onResize(force);
          };
          this.setTheme = function (theme, cb) {
              this.renderer.setTheme(theme, cb);
          };
          this.getTheme = function () {
              return this.renderer.getTheme();
          };
          this.setStyle = function (style) {
              this.renderer.setStyle(style);
          };
          this.unsetStyle = function (style) {
              this.renderer.unsetStyle(style);
          };
          this.getFontSize = function () {
              return this.getOption("fontSize") ||
                  dom.computedStyle(this.container, "fontSize");
          };
          this.setFontSize = function (size) {
              this.setOption("fontSize", size);
          };
          this.$highlightBrackets = function () {
              if (this.session.$bracketHighlight) {
                  this.session.removeMarker(this.session.$bracketHighlight);
                  this.session.$bracketHighlight = null;
              }
              if (this.$highlightPending) {
                  return;
              }
              var self = this;
              this.$highlightPending = true;
              setTimeout(function () {
                  self.$highlightPending = false;
                  var session = self.session;
                  if (!session || !session.bgTokenizer)
                      return;
                  var pos = session.findMatchingBracket(self.getCursorPosition());
                  if (pos) {
                      var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
                  }
                  else if (session.$mode.getMatching) {
                      var range = session.$mode.getMatching(self.session);
                  }
                  if (range)
                      session.$bracketHighlight = session.addMarker(range, "ace_bracket", "text");
              }, 50);
          };
          this.$highlightTags = function () {
              if (this.$highlightTagPending)
                  return;
              var self = this;
              this.$highlightTagPending = true;
              setTimeout(function () {
                  self.$highlightTagPending = false;
                  var session = self.session;
                  if (!session || !session.bgTokenizer)
                      return;
                  var pos = self.getCursorPosition();
                  var iterator = new TokenIterator(self.session, pos.row, pos.column);
                  var token = iterator.getCurrentToken();
                  if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
                      session.removeMarker(session.$tagHighlight);
                      session.$tagHighlight = null;
                      return;
                  }
                  if (token.type.indexOf("tag-open") != -1) {
                      token = iterator.stepForward();
                      if (!token)
                          return;
                  }
                  var tag = token.value;
                  var depth = 0;
                  var prevToken = iterator.stepBackward();
                  if (prevToken.value == '<') {
                      do {
                          prevToken = token;
                          token = iterator.stepForward();
                          if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                              if (prevToken.value === '<') {
                                  depth++;
                              }
                              else if (prevToken.value === '</') {
                                  depth--;
                              }
                          }
                      } while (token && depth >= 0);
                  }
                  else {
                      do {
                          token = prevToken;
                          prevToken = iterator.stepBackward();
                          if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                              if (prevToken.value === '<') {
                                  depth++;
                              }
                              else if (prevToken.value === '</') {
                                  depth--;
                              }
                          }
                      } while (prevToken && depth <= 0);
                      iterator.stepForward();
                  }
                  if (!token) {
                      session.removeMarker(session.$tagHighlight);
                      session.$tagHighlight = null;
                      return;
                  }
                  var row = iterator.getCurrentTokenRow();
                  var column = iterator.getCurrentTokenColumn();
                  var range = new Range(row, column, row, column + token.value.length);
                  var sbm = session.$backMarkers[session.$tagHighlight];
                  if (session.$tagHighlight && sbm != undefined && range.compareRange(sbm.range) !== 0) {
                      session.removeMarker(session.$tagHighlight);
                      session.$tagHighlight = null;
                  }
                  if (range && !session.$tagHighlight)
                      session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
              }, 50);
          };
          this.focus = function () {
              var _self = this;
              setTimeout(function () {
                  _self.textInput.focus();
              });
              this.textInput.focus();
          };
          this.isFocused = function () {
              return this.textInput.isFocused();
          };
          this.blur = function () {
              this.textInput.blur();
          };
          this.onFocus = function (e) {
              if (this.$isFocused)
                  return;
              this.$isFocused = true;
              this.renderer.showCursor();
              this.renderer.visualizeFocus();
              this._emit("focus", e);
          };
          this.onBlur = function (e) {
              if (!this.$isFocused)
                  return;
              this.$isFocused = false;
              this.renderer.hideCursor();
              this.renderer.visualizeBlur();
              this._emit("blur", e);
          };
          this.$cursorChange = function () {
              this.renderer.updateCursor();
          };
          this.onDocumentChange = function (delta) {
              var wrap = this.session.$useWrapMode;
              var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);
              this.renderer.updateLines(delta.start.row, lastRow, wrap);
              this._signal("change", delta);
              this.$cursorChange();
              this.$updateHighlightActiveLine();
          };
          this.onTokenizerUpdate = function (e) {
              var rows = e.data;
              this.renderer.updateLines(rows.first, rows.last);
          };
          this.onScrollTopChange = function () {
              this.renderer.scrollToY(this.session.getScrollTop());
          };
          this.onScrollLeftChange = function () {
              this.renderer.scrollToX(this.session.getScrollLeft());
          };
          this.onCursorChange = function () {
              this.$cursorChange();
              if (!this.$blockScrolling) {
                  config.warn("Automatically scrolling cursor into view after selection change", "this will be disabled in the next version", "set editor.$blockScrolling = Infinity to disable this message");
                  this.renderer.scrollCursorIntoView();
              }
              this.$highlightBrackets();
              this.$highlightTags();
              this.$updateHighlightActiveLine();
              this._signal("changeSelection");
          };
          this.$updateHighlightActiveLine = function () {
              var session = this.getSession();
              var highlight;
              if (this.$highlightActiveLine) {
                  if ((this.$selectionStyle != "line" || !this.selection.isMultiLine()))
                      highlight = this.getCursorPosition();
                  if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
                      highlight = false;
              }
              if (session.$highlightLineMarker && !highlight) {
                  session.removeMarker(session.$highlightLineMarker.id);
                  session.$highlightLineMarker = null;
              }
              else if (!session.$highlightLineMarker && highlight) {
                  var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
                  range.id = session.addMarker(range, "ace_active-line", "screenLine");
                  session.$highlightLineMarker = range;
              }
              else if (highlight) {
                  session.$highlightLineMarker.start.row = highlight.row;
                  session.$highlightLineMarker.end.row = highlight.row;
                  session.$highlightLineMarker.start.column = highlight.column;
                  session._signal("changeBackMarker");
              }
          };
          this.onSelectionChange = function (e) {
              var session = this.session;
              if (session.$selectionMarker) {
                  session.removeMarker(session.$selectionMarker);
              }
              session.$selectionMarker = null;
              if (!this.selection.isEmpty()) {
                  var range = this.selection.getRange();
                  var style = this.getSelectionStyle();
                  session.$selectionMarker = session.addMarker(range, "ace_selection", style);
              }
              else {
                  this.$updateHighlightActiveLine();
              }
              var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
              this.session.highlight(re);
              this._signal("changeSelection");
          };
          this.$getSelectionHighLightRegexp = function () {
              var session = this.session;
              var selection = this.getSelectionRange();
              if (selection.isEmpty() || selection.isMultiLine())
                  return;
              var startOuter = selection.start.column - 1;
              var endOuter = selection.end.column + 1;
              var line = session.getLine(selection.start.row);
              var lineCols = line.length;
              var needle = line.substring(Math.max(startOuter, 0), Math.min(endOuter, lineCols));
              if ((startOuter >= 0 && /^[\w\d]/.test(needle)) ||
                  (endOuter <= lineCols && /[\w\d]$/.test(needle)))
                  return;
              needle = line.substring(selection.start.column, selection.end.column);
              if (!/^[\w\d]+$/.test(needle))
                  return;
              var re = this.$search.$assembleRegExp({
                  wholeWord: true,
                  caseSensitive: true,
                  needle: needle
              });
              return re;
          };
          this.onChangeFrontMarker = function () {
              this.renderer.updateFrontMarkers();
          };
          this.onChangeBackMarker = function () {
              this.renderer.updateBackMarkers();
          };
          this.onChangeBreakpoint = function () {
              this.renderer.updateBreakpoints();
          };
          this.onChangeAnnotation = function () {
              this.renderer.setAnnotations(this.session.getAnnotations());
          };
          this.onChangeMode = function (e) {
              this.renderer.updateText();
              this._emit("changeMode", e);
          };
          this.onChangeWrapLimit = function () {
              this.renderer.updateFull();
          };
          this.onChangeWrapMode = function () {
              this.renderer.onResize(true);
          };
          this.onChangeFold = function () {
              this.$updateHighlightActiveLine();
              this.renderer.updateFull();
          };
          this.getSelectedText = function () {
              return this.session.getTextRange(this.getSelectionRange());
          };
          this.getCopyText = function () {
              var text = this.getSelectedText();
              this._signal("copy", text);
              return text;
          };
          this.onCopy = function () {
              this.commands.exec("copy", this);
          };
          this.onCut = function () {
              this.commands.exec("cut", this);
          };
          this.onPaste = function (text, event) {
              var e = { text: text, event: event };
              this.commands.exec("paste", this, e);
          };
          this.$handlePaste = function (e) {
              if (typeof e == "string")
                  e = { text: e };
              this._signal("paste", e);
              var text = e.text;
              if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
                  this.insert(text);
              }
              else {
                  var lines = text.split(/\r\n|\r|\n/);
                  var ranges = this.selection.rangeList.ranges;
                  if (lines.length > ranges.length || lines.length < 2 || !lines[1])
                      return this.commands.exec("insertstring", this, text);
                  for (var i = ranges.length; i--;) {
                      var range = ranges[i];
                      if (!range.isEmpty())
                          this.session.remove(range);
                      this.session.insert(range.start, lines[i]);
                  }
              }
          };
          this.execCommand = function (command, args) {
              return this.commands.exec(command, this, args);
          };
          this.insert = function (text, pasted) {
              var session = this.session;
              var mode = session.getMode();
              var cursor = this.getCursorPosition();
              if (this.getBehavioursEnabled() && !pasted) {
                  var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
                  if (transform) {
                      if (text !== transform.text) {
                          this.session.mergeUndoDeltas = false;
                          this.$mergeNextCommand = false;
                      }
                      text = transform.text;
                  }
              }
              if (text == "\t")
                  text = this.session.getTabString();
              if (!this.selection.isEmpty()) {
                  var range = this.getSelectionRange();
                  cursor = this.session.remove(range);
                  this.clearSelection();
              }
              else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
                  var range = new Range.fromPoints(cursor, cursor);
                  range.end.column += text.length;
                  this.session.remove(range);
              }
              if (text == "\n" || text == "\r\n") {
                  var line = session.getLine(cursor.row);
                  if (cursor.column > line.search(/\S|$/)) {
                      var d = line.substr(cursor.column).search(/\S|$/);
                      session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
                  }
              }
              this.clearSelection();
              var start = cursor.column;
              var lineState = session.getState(cursor.row);
              var line = session.getLine(cursor.row);
              var shouldOutdent = mode.checkOutdent(lineState, line, text);
              var end = session.insert(cursor, text);
              if (transform && transform.selection) {
                  if (transform.selection.length == 2) { // Transform relative to the current column
                      this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
                  }
                  else { // Transform relative to the current row.
                      this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
                  }
              }
              if (session.getDocument().isNewLine(text)) {
                  var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
                  session.insert({ row: cursor.row + 1, column: 0 }, lineIndent);
              }
              if (shouldOutdent)
                  mode.autoOutdent(lineState, session, cursor.row);
          };
          this.onTextInput = function (text) {
              this.keyBinding.onTextInput(text);
          };
          this.onCommandKey = function (e, hashId, keyCode) {
              this.keyBinding.onCommandKey(e, hashId, keyCode);
          };
          this.setOverwrite = function (overwrite) {
              this.session.setOverwrite(overwrite);
          };
          this.getOverwrite = function () {
              return this.session.getOverwrite();
          };
          this.toggleOverwrite = function () {
              this.session.toggleOverwrite();
          };
          this.setScrollSpeed = function (speed) {
              this.setOption("scrollSpeed", speed);
          };
          this.getScrollSpeed = function () {
              return this.getOption("scrollSpeed");
          };
          this.setDragDelay = function (dragDelay) {
              this.setOption("dragDelay", dragDelay);
          };
          this.getDragDelay = function () {
              return this.getOption("dragDelay");
          };
          this.setSelectionStyle = function (val) {
              this.setOption("selectionStyle", val);
          };
          this.getSelectionStyle = function () {
              return this.getOption("selectionStyle");
          };
          this.setHighlightActiveLine = function (shouldHighlight) {
              this.setOption("highlightActiveLine", shouldHighlight);
          };
          this.getHighlightActiveLine = function () {
              return this.getOption("highlightActiveLine");
          };
          this.setHighlightGutterLine = function (shouldHighlight) {
              this.setOption("highlightGutterLine", shouldHighlight);
          };
          this.getHighlightGutterLine = function () {
              return this.getOption("highlightGutterLine");
          };
          this.setHighlightSelectedWord = function (shouldHighlight) {
              this.setOption("highlightSelectedWord", shouldHighlight);
          };
          this.getHighlightSelectedWord = function () {
              return this.$highlightSelectedWord;
          };
          this.setAnimatedScroll = function (shouldAnimate) {
              this.renderer.setAnimatedScroll(shouldAnimate);
          };
          this.getAnimatedScroll = function () {
              return this.renderer.getAnimatedScroll();
          };
          this.setShowInvisibles = function (showInvisibles) {
              this.renderer.setShowInvisibles(showInvisibles);
          };
          this.getShowInvisibles = function () {
              return this.renderer.getShowInvisibles();
          };
          this.setDisplayIndentGuides = function (display) {
              this.renderer.setDisplayIndentGuides(display);
          };
          this.getDisplayIndentGuides = function () {
              return this.renderer.getDisplayIndentGuides();
          };
          this.setShowPrintMargin = function (showPrintMargin) {
              this.renderer.setShowPrintMargin(showPrintMargin);
          };
          this.getShowPrintMargin = function () {
              return this.renderer.getShowPrintMargin();
          };
          this.setPrintMarginColumn = function (showPrintMargin) {
              this.renderer.setPrintMarginColumn(showPrintMargin);
          };
          this.getPrintMarginColumn = function () {
              return this.renderer.getPrintMarginColumn();
          };
          this.setReadOnly = function (readOnly) {
              this.setOption("readOnly", readOnly);
          };
          this.getReadOnly = function () {
              return this.getOption("readOnly");
          };
          this.setBehavioursEnabled = function (enabled) {
              this.setOption("behavioursEnabled", enabled);
          };
          this.getBehavioursEnabled = function () {
              return this.getOption("behavioursEnabled");
          };
          this.setWrapBehavioursEnabled = function (enabled) {
              this.setOption("wrapBehavioursEnabled", enabled);
          };
          this.getWrapBehavioursEnabled = function () {
              return this.getOption("wrapBehavioursEnabled");
          };
          this.setShowFoldWidgets = function (show) {
              this.setOption("showFoldWidgets", show);
          };
          this.getShowFoldWidgets = function () {
              return this.getOption("showFoldWidgets");
          };
          this.setFadeFoldWidgets = function (fade) {
              this.setOption("fadeFoldWidgets", fade);
          };
          this.getFadeFoldWidgets = function () {
              return this.getOption("fadeFoldWidgets");
          };
          this.remove = function (dir) {
              if (this.selection.isEmpty()) {
                  if (dir == "left")
                      this.selection.selectLeft();
                  else
                      this.selection.selectRight();
              }
              var range = this.getSelectionRange();
              if (this.getBehavioursEnabled()) {
                  var session = this.session;
                  var state = session.getState(range.start.row);
                  var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);
                  if (range.end.column === 0) {
                      var text = session.getTextRange(range);
                      if (text[text.length - 1] == "\n") {
                          var line = session.getLine(range.end.row);
                          if (/^\s+$/.test(line)) {
                              range.end.column = line.length;
                          }
                      }
                  }
                  if (new_range)
                      range = new_range;
              }
              this.session.remove(range);
              this.clearSelection();
          };
          this.removeWordRight = function () {
              if (this.selection.isEmpty())
                  this.selection.selectWordRight();
              this.session.remove(this.getSelectionRange());
              this.clearSelection();
          };
          this.removeWordLeft = function () {
              if (this.selection.isEmpty())
                  this.selection.selectWordLeft();
              this.session.remove(this.getSelectionRange());
              this.clearSelection();
          };
          this.removeToLineStart = function () {
              if (this.selection.isEmpty())
                  this.selection.selectLineStart();
              this.session.remove(this.getSelectionRange());
              this.clearSelection();
          };
          this.removeToLineEnd = function () {
              if (this.selection.isEmpty())
                  this.selection.selectLineEnd();
              var range = this.getSelectionRange();
              if (range.start.column == range.end.column && range.start.row == range.end.row) {
                  range.end.column = 0;
                  range.end.row++;
              }
              this.session.remove(range);
              this.clearSelection();
          };
          this.splitLine = function () {
              if (!this.selection.isEmpty()) {
                  this.session.remove(this.getSelectionRange());
                  this.clearSelection();
              }
              var cursor = this.getCursorPosition();
              this.insert("\n");
              this.moveCursorToPosition(cursor);
          };
          this.transposeLetters = function () {
              if (!this.selection.isEmpty()) {
                  return;
              }
              var cursor = this.getCursorPosition();
              var column = cursor.column;
              if (column === 0)
                  return;
              var line = this.session.getLine(cursor.row);
              var swap, range;
              if (column < line.length) {
                  swap = line.charAt(column) + line.charAt(column - 1);
                  range = new Range(cursor.row, column - 1, cursor.row, column + 1);
              }
              else {
                  swap = line.charAt(column - 1) + line.charAt(column - 2);
                  range = new Range(cursor.row, column - 2, cursor.row, column);
              }
              this.session.replace(range, swap);
              this.session.selection.moveToPosition(range.end);
          };
          this.toLowerCase = function () {
              var originalRange = this.getSelectionRange();
              if (this.selection.isEmpty()) {
                  this.selection.selectWord();
              }
              var range = this.getSelectionRange();
              var text = this.session.getTextRange(range);
              this.session.replace(range, text.toLowerCase());
              this.selection.setSelectionRange(originalRange);
          };
          this.toUpperCase = function () {
              var originalRange = this.getSelectionRange();
              if (this.selection.isEmpty()) {
                  this.selection.selectWord();
              }
              var range = this.getSelectionRange();
              var text = this.session.getTextRange(range);
              this.session.replace(range, text.toUpperCase());
              this.selection.setSelectionRange(originalRange);
          };
          this.indent = function () {
              var session = this.session;
              var range = this.getSelectionRange();
              if (range.start.row < range.end.row) {
                  var rows = this.$getSelectedRows();
                  session.indentRows(rows.first, rows.last, "\t");
                  return;
              }
              else if (range.start.column < range.end.column) {
                  var text = session.getTextRange(range);
                  if (!/^\s+$/.test(text)) {
                      var rows = this.$getSelectedRows();
                      session.indentRows(rows.first, rows.last, "\t");
                      return;
                  }
              }
              var line = session.getLine(range.start.row);
              var position = range.start;
              var size = session.getTabSize();
              var column = session.documentToScreenColumn(position.row, position.column);
              if (this.session.getUseSoftTabs()) {
                  var count = (size - column % size);
                  var indentString = lang.stringRepeat(" ", count);
              }
              else {
                  var count = column % size;
                  while (line[range.start.column - 1] == " " && count) {
                      range.start.column--;
                      count--;
                  }
                  this.selection.setSelectionRange(range);
                  indentString = "\t";
              }
              return this.insert(indentString);
          };
          this.blockIndent = function () {
              var rows = this.$getSelectedRows();
              this.session.indentRows(rows.first, rows.last, "\t");
          };
          this.blockOutdent = function () {
              var selection = this.session.getSelection();
              this.session.outdentRows(selection.getRange());
          };
          this.sortLines = function () {
              var rows = this.$getSelectedRows();
              var session = this.session;
              var lines = [];
              for (var i = rows.first; i <= rows.last; i++)
                  lines.push(session.getLine(i));
              lines.sort(function (a, b) {
                  if (a.toLowerCase() < b.toLowerCase())
                      return -1;
                  if (a.toLowerCase() > b.toLowerCase())
                      return 1;
                  return 0;
              });
              var deleteRange = new Range(0, 0, 0, 0);
              for (var i = rows.first; i <= rows.last; i++) {
                  var line = session.getLine(i);
                  deleteRange.start.row = i;
                  deleteRange.end.row = i;
                  deleteRange.end.column = line.length;
                  session.replace(deleteRange, lines[i - rows.first]);
              }
          };
          this.toggleCommentLines = function () {
              var state = this.session.getState(this.getCursorPosition().row);
              var rows = this.$getSelectedRows();
              this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
          };
          this.toggleBlockComment = function () {
              var cursor = this.getCursorPosition();
              var state = this.session.getState(cursor.row);
              var range = this.getSelectionRange();
              this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
          };
          this.getNumberAt = function (row, column) {
              var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
              _numberRx.lastIndex = 0;
              var s = this.session.getLine(row);
              while (_numberRx.lastIndex < column) {
                  var m = _numberRx.exec(s);
                  if (m.index <= column && m.index + m[0].length >= column) {
                      var number = {
                          value: m[0],
                          start: m.index,
                          end: m.index + m[0].length
                      };
                      return number;
                  }
              }
              return null;
          };
          this.modifyNumber = function (amount) {
              var row = this.selection.getCursor().row;
              var column = this.selection.getCursor().column;
              var charRange = new Range(row, column - 1, row, column);
              var c = this.session.getTextRange(charRange);
              if (!isNaN(parseFloat(c)) && isFinite(c)) {
                  var nr = this.getNumberAt(row, column);
                  if (nr) {
                      var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                      var decimals = nr.start + nr.value.length - fp;
                      var t = parseFloat(nr.value);
                      t *= Math.pow(10, decimals);
                      if (fp !== nr.end && column < fp) {
                          amount *= Math.pow(10, nr.end - column - 1);
                      }
                      else {
                          amount *= Math.pow(10, nr.end - column);
                      }
                      t += amount;
                      t /= Math.pow(10, decimals);
                      var nnr = t.toFixed(decimals);
                      var replaceRange = new Range(row, nr.start, row, nr.end);
                      this.session.replace(replaceRange, nnr);
                      this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
                  }
              }
          };
          this.removeLines = function () {
              var rows = this.$getSelectedRows();
              this.session.removeFullLines(rows.first, rows.last);
              this.clearSelection();
          };
          this.duplicateSelection = function () {
              var sel = this.selection;
              var doc = this.session;
              var range = sel.getRange();
              var reverse = sel.isBackwards();
              if (range.isEmpty()) {
                  var row = range.start.row;
                  doc.duplicateLines(row, row);
              }
              else {
                  var point = reverse ? range.start : range.end;
                  var endPoint = doc.insert(point, doc.getTextRange(range), false);
                  range.start = point;
                  range.end = endPoint;
                  sel.setSelectionRange(range, reverse);
              }
          };
          this.moveLinesDown = function () {
              this.$moveLines(1, false);
          };
          this.moveLinesUp = function () {
              this.$moveLines(-1, false);
          };
          this.moveText = function (range, toPosition, copy) {
              return this.session.moveText(range, toPosition, copy);
          };
          this.copyLinesUp = function () {
              this.$moveLines(-1, true);
          };
          this.copyLinesDown = function () {
              this.$moveLines(1, true);
          };
          this.$moveLines = function (dir, copy) {
              var rows, moved;
              var selection = this.selection;
              if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
                  var range = selection.toOrientedRange();
                  rows = this.$getSelectedRows(range);
                  moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
                  if (copy && dir == -1)
                      moved = 0;
                  range.moveBy(moved, 0);
                  selection.fromOrientedRange(range);
              }
              else {
                  var ranges = selection.rangeList.ranges;
                  selection.rangeList.detach(this.session);
                  this.inVirtualSelectionMode = true;
                  var diff = 0;
                  var totalDiff = 0;
                  var l = ranges.length;
                  for (var i = 0; i < l; i++) {
                      var rangeIndex = i;
                      ranges[i].moveBy(diff, 0);
                      rows = this.$getSelectedRows(ranges[i]);
                      var first = rows.first;
                      var last = rows.last;
                      while (++i < l) {
                          if (totalDiff)
                              ranges[i].moveBy(totalDiff, 0);
                          var subRows = this.$getSelectedRows(ranges[i]);
                          if (copy && subRows.first != last)
                              break;
                          else if (!copy && subRows.first > last + 1)
                              break;
                          last = subRows.last;
                      }
                      i--;
                      diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                      if (copy && dir == -1)
                          rangeIndex = i + 1;
                      while (rangeIndex <= i) {
                          ranges[rangeIndex].moveBy(diff, 0);
                          rangeIndex++;
                      }
                      if (!copy)
                          diff = 0;
                      totalDiff += diff;
                  }
                  selection.fromOrientedRange(selection.ranges[0]);
                  selection.rangeList.attach(this.session);
                  this.inVirtualSelectionMode = false;
              }
          };
          this.$getSelectedRows = function (range) {
              range = (range || this.getSelectionRange()).collapseRows();
              return {
                  first: this.session.getRowFoldStart(range.start.row),
                  last: this.session.getRowFoldEnd(range.end.row)
              };
          };
          this.onCompositionStart = function (text) {
              this.renderer.showComposition(this.getCursorPosition());
          };
          this.onCompositionUpdate = function (text) {
              this.renderer.setCompositionText(text);
          };
          this.onCompositionEnd = function () {
              this.renderer.hideComposition();
          };
          this.getFirstVisibleRow = function () {
              return this.renderer.getFirstVisibleRow();
          };
          this.getLastVisibleRow = function () {
              return this.renderer.getLastVisibleRow();
          };
          this.isRowVisible = function (row) {
              return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
          };
          this.isRowFullyVisible = function (row) {
              return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
          };
          this.$getVisibleRowCount = function () {
              return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
          };
          this.$moveByPage = function (dir, select) {
              var renderer = this.renderer;
              var config = this.renderer.layerConfig;
              var rows = dir * Math.floor(config.height / config.lineHeight);
              this.$blockScrolling++;
              if (select === true) {
                  this.selection.$moveSelection(function () {
                      this.moveCursorBy(rows, 0);
                  });
              }
              else if (select === false) {
                  this.selection.moveCursorBy(rows, 0);
                  this.selection.clearSelection();
              }
              this.$blockScrolling--;
              var scrollTop = renderer.scrollTop;
              renderer.scrollBy(0, rows * config.lineHeight);
              if (select != null)
                  renderer.scrollCursorIntoView(null, 0.5);
              renderer.animateScrolling(scrollTop);
          };
          this.selectPageDown = function () {
              this.$moveByPage(1, true);
          };
          this.selectPageUp = function () {
              this.$moveByPage(-1, true);
          };
          this.gotoPageDown = function () {
              this.$moveByPage(1, false);
          };
          this.gotoPageUp = function () {
              this.$moveByPage(-1, false);
          };
          this.scrollPageDown = function () {
              this.$moveByPage(1);
          };
          this.scrollPageUp = function () {
              this.$moveByPage(-1);
          };
          this.scrollToRow = function (row) {
              this.renderer.scrollToRow(row);
          };
          this.scrollToLine = function (line, center, animate, callback) {
              this.renderer.scrollToLine(line, center, animate, callback);
          };
          this.centerSelection = function () {
              var range = this.getSelectionRange();
              var pos = {
                  row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
                  column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
              };
              this.renderer.alignCursor(pos, 0.5);
          };
          this.getCursorPosition = function () {
              return this.selection.getCursor();
          };
          this.getCursorPositionScreen = function () {
              return this.session.documentToScreenPosition(this.getCursorPosition());
          };
          this.getSelectionRange = function () {
              return this.selection.getRange();
          };
          this.selectAll = function () {
              this.$blockScrolling += 1;
              this.selection.selectAll();
              this.$blockScrolling -= 1;
          };
          this.clearSelection = function () {
              this.selection.clearSelection();
          };
          this.moveCursorTo = function (row, column) {
              this.selection.moveCursorTo(row, column);
          };
          this.moveCursorToPosition = function (pos) {
              this.selection.moveCursorToPosition(pos);
          };
          this.jumpToMatching = function (select, expand) {
              var cursor = this.getCursorPosition();
              var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
              var prevToken = iterator.getCurrentToken();
              var token = prevToken || iterator.stepForward();
              if (!token)
                  return;
              var matchType;
              var found = false;
              var depth = {};
              var i = cursor.column - token.start;
              var bracketType;
              var brackets = {
                  ")": "(",
                  "(": "(",
                  "]": "[",
                  "[": "[",
                  "{": "{",
                  "}": "{"
              };
              do {
                  if (token.value.match(/[{}()\[\]]/g)) {
                      for (; i < token.value.length && !found; i++) {
                          if (!brackets[token.value[i]]) {
                              continue;
                          }
                          bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");
                          if (isNaN(depth[bracketType])) {
                              depth[bracketType] = 0;
                          }
                          switch (token.value[i]) {
                              case '(':
                              case '[':
                              case '{':
                                  depth[bracketType]++;
                                  break;
                              case ')':
                              case ']':
                              case '}':
                                  depth[bracketType]--;
                                  if (depth[bracketType] === -1) {
                                      matchType = 'bracket';
                                      found = true;
                                  }
                                  break;
                          }
                      }
                  }
                  else if (token && token.type.indexOf('tag-name') !== -1) {
                      if (isNaN(depth[token.value])) {
                          depth[token.value] = 0;
                      }
                      if (prevToken.value === '<') {
                          depth[token.value]++;
                      }
                      else if (prevToken.value === '</') {
                          depth[token.value]--;
                      }
                      if (depth[token.value] === -1) {
                          matchType = 'tag';
                          found = true;
                      }
                  }
                  if (!found) {
                      prevToken = token;
                      token = iterator.stepForward();
                      i = 0;
                  }
              } while (token && !found);
              if (!matchType)
                  return;
              var range, pos;
              if (matchType === 'bracket') {
                  range = this.session.getBracketRange(cursor);
                  if (!range) {
                      range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);
                      pos = range.start;
                      if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
                          range = this.session.getBracketRange(pos);
                  }
              }
              else if (matchType === 'tag') {
                  if (token && token.type.indexOf('tag-name') !== -1)
                      var tag = token.value;
                  else
                      return;
                  range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
                  if (range.compare(cursor.row, cursor.column) === 0) {
                      found = false;
                      do {
                          token = prevToken;
                          prevToken = iterator.stepBackward();
                          if (prevToken) {
                              if (prevToken.type.indexOf('tag-close') !== -1) {
                                  range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                              }
                              if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
                                  if (prevToken.value === '<') {
                                      depth[tag]++;
                                  }
                                  else if (prevToken.value === '</') {
                                      depth[tag]--;
                                  }
                                  if (depth[tag] === 0)
                                      found = true;
                              }
                          }
                      } while (prevToken && !found);
                  }
                  if (token && token.type.indexOf('tag-name')) {
                      pos = range.start;
                      if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
                          pos = range.end;
                  }
              }
              pos = range && range.cursor || pos;
              if (pos) {
                  if (select) {
                      if (range && expand) {
                          this.selection.setRange(range);
                      }
                      else if (range && range.isEqual(this.getSelectionRange())) {
                          this.clearSelection();
                      }
                      else {
                          this.selection.selectTo(pos.row, pos.column);
                      }
                  }
                  else {
                      this.selection.moveTo(pos.row, pos.column);
                  }
              }
          };
          this.gotoLine = function (lineNumber, column, animate) {
              this.selection.clearSelection();
              this.session.unfold({ row: lineNumber - 1, column: column || 0 });
              this.$blockScrolling += 1;
              this.exitMultiSelectMode && this.exitMultiSelectMode();
              this.moveCursorTo(lineNumber - 1, column || 0);
              this.$blockScrolling -= 1;
              if (!this.isRowFullyVisible(lineNumber - 1))
                  this.scrollToLine(lineNumber - 1, true, animate);
          };
          this.navigateTo = function (row, column) {
              this.selection.moveTo(row, column);
          };
          this.navigateUp = function (times) {
              if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
                  var selectionStart = this.selection.anchor.getPosition();
                  return this.moveCursorToPosition(selectionStart);
              }
              this.selection.clearSelection();
              this.selection.moveCursorBy(-times || -1, 0);
          };
          this.navigateDown = function (times) {
              if (this.selection.isMultiLine() && this.selection.isBackwards()) {
                  var selectionEnd = this.selection.anchor.getPosition();
                  return this.moveCursorToPosition(selectionEnd);
              }
              this.selection.clearSelection();
              this.selection.moveCursorBy(times || 1, 0);
          };
          this.navigateLeft = function (times) {
              if (!this.selection.isEmpty()) {
                  var selectionStart = this.getSelectionRange().start;
                  this.moveCursorToPosition(selectionStart);
              }
              else {
                  times = times || 1;
                  while (times--) {
                      this.selection.moveCursorLeft();
                  }
              }
              this.clearSelection();
          };
          this.navigateRight = function (times) {
              if (!this.selection.isEmpty()) {
                  var selectionEnd = this.getSelectionRange().end;
                  this.moveCursorToPosition(selectionEnd);
              }
              else {
                  times = times || 1;
                  while (times--) {
                      this.selection.moveCursorRight();
                  }
              }
              this.clearSelection();
          };
          this.navigateLineStart = function () {
              this.selection.moveCursorLineStart();
              this.clearSelection();
          };
          this.navigateLineEnd = function () {
              this.selection.moveCursorLineEnd();
              this.clearSelection();
          };
          this.navigateFileEnd = function () {
              this.selection.moveCursorFileEnd();
              this.clearSelection();
          };
          this.navigateFileStart = function () {
              this.selection.moveCursorFileStart();
              this.clearSelection();
          };
          this.navigateWordRight = function () {
              this.selection.moveCursorWordRight();
              this.clearSelection();
          };
          this.navigateWordLeft = function () {
              this.selection.moveCursorWordLeft();
              this.clearSelection();
          };
          this.replace = function (replacement, options) {
              if (options)
                  this.$search.set(options);
              var range = this.$search.find(this.session);
              var replaced = 0;
              if (!range)
                  return replaced;
              if (this.$tryReplace(range, replacement)) {
                  replaced = 1;
              }
              if (range !== null) {
                  this.selection.setSelectionRange(range);
                  this.renderer.scrollSelectionIntoView(range.start, range.end);
              }
              return replaced;
          };
          this.replaceAll = function (replacement, options) {
              if (options) {
                  this.$search.set(options);
              }
              var ranges = this.$search.findAll(this.session);
              var replaced = 0;
              if (!ranges.length)
                  return replaced;
              this.$blockScrolling += 1;
              var selection = this.getSelectionRange();
              this.selection.moveTo(0, 0);
              for (var i = ranges.length - 1; i >= 0; --i) {
                  if (this.$tryReplace(ranges[i], replacement)) {
                      replaced++;
                  }
              }
              this.selection.setSelectionRange(selection);
              this.$blockScrolling -= 1;
              return replaced;
          };
          this.$tryReplace = function (range, replacement) {
              var input = this.session.getTextRange(range);
              replacement = this.$search.replace(input, replacement);
              if (replacement !== null) {
                  range.end = this.session.replace(range, replacement);
                  return range;
              }
              else {
                  return null;
              }
          };
          this.getLastSearchOptions = function () {
              return this.$search.getOptions();
          };
          this.find = function (needle, options, animate) {
              if (!options)
                  options = {};
              if (typeof needle == "string" || needle instanceof RegExp)
                  options.needle = needle;
              else if (typeof needle == "object")
                  oop.mixin(options, needle);
              var range = this.selection.getRange();
              if (options.needle == null) {
                  needle = this.session.getTextRange(range)
                      || this.$search.$options.needle;
                  if (!needle) {
                      range = this.session.getWordRange(range.start.row, range.start.column);
                      needle = this.session.getTextRange(range);
                  }
                  this.$search.set({ needle: needle });
              }
              this.$search.set(options);
              if (!options.start)
                  this.$search.set({ start: range });
              var newRange = this.$search.find(this.session);
              if (options.preventScroll)
                  return newRange;
              if (newRange) {
                  this.revealRange(newRange, animate);
                  return newRange;
              }
              if (options.backwards)
                  range.start = range.end;
              else
                  range.end = range.start;
              this.selection.setRange(range);
          };
          this.findNext = function (options, animate) {
              this.find({ skipCurrent: true, backwards: false }, options, animate);
          };
          this.findPrevious = function (options, animate) {
              this.find(options, { skipCurrent: true, backwards: true }, animate);
          };
          this.revealRange = function (range, animate) {
              this.$blockScrolling += 1;
              this.session.unfold(range);
              this.selection.setSelectionRange(range);
              this.$blockScrolling -= 1;
              var scrollTop = this.renderer.scrollTop;
              this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
              if (animate !== false)
                  this.renderer.animateScrolling(scrollTop);
          };
          this.undo = function () {
              this.$blockScrolling++;
              this.session.getUndoManager().undo();
              this.$blockScrolling--;
              this.renderer.scrollCursorIntoView(null, 0.5);
          };
          this.redo = function () {
              this.$blockScrolling++;
              this.session.getUndoManager().redo();
              this.$blockScrolling--;
              this.renderer.scrollCursorIntoView(null, 0.5);
          };
          this.destroy = function () {
              this.renderer.destroy();
              this._signal("destroy", this);
              if (this.session) {
                  this.session.destroy();
              }
          };
          this.setAutoScrollEditorIntoView = function (enable) {
              if (!enable)
                  return;
              var rect;
              var self = this;
              var shouldScroll = false;
              if (!this.$scrollAnchor)
                  this.$scrollAnchor = document.createElement("div");
              var scrollAnchor = this.$scrollAnchor;
              scrollAnchor.style.cssText = "position:absolute";
              this.container.insertBefore(scrollAnchor, this.container.firstChild);
              var onChangeSelection = this.on("changeSelection", function () {
                  shouldScroll = true;
              });
              var onBeforeRender = this.renderer.on("beforeRender", function () {
                  if (shouldScroll)
                      rect = self.renderer.container.getBoundingClientRect();
              });
              var onAfterRender = this.renderer.on("afterRender", function () {
                  if (shouldScroll && rect && (self.isFocused()
                      || self.searchBox && self.searchBox.isFocused())) {
                      var renderer = self.renderer;
                      var pos = renderer.$cursorLayer.$pixelPos;
                      var config = renderer.layerConfig;
                      var top = pos.top - config.offset;
                      if (pos.top >= 0 && top + rect.top < 0) {
                          shouldScroll = true;
                      }
                      else if (pos.top < config.height &&
                          pos.top + rect.top + config.lineHeight > window.innerHeight) {
                          shouldScroll = false;
                      }
                      else {
                          shouldScroll = null;
                      }
                      if (shouldScroll != null) {
                          scrollAnchor.style.top = top + "px";
                          scrollAnchor.style.left = pos.left + "px";
                          scrollAnchor.style.height = config.lineHeight + "px";
                          scrollAnchor.scrollIntoView(shouldScroll);
                      }
                      shouldScroll = rect = null;
                  }
              });
              this.setAutoScrollEditorIntoView = function (enable) {
                  if (enable)
                      return;
                  delete this.setAutoScrollEditorIntoView;
                  this.off("changeSelection", onChangeSelection);
                  this.renderer.off("afterRender", onAfterRender);
                  this.renderer.off("beforeRender", onBeforeRender);
              };
          };
          this.$resetCursorStyle = function () {
              var style = this.$cursorStyle || "ace";
              var cursorLayer = this.renderer.$cursorLayer;
              if (!cursorLayer)
                  return;
              cursorLayer.setSmoothBlinking(/smooth/.test(style));
              cursorLayer.isBlinking = !this.$readOnly && style != "wide";
              dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
          };
      }).call(Editor.prototype);
      config.defineOptions(Editor.prototype, "editor", {
          selectionStyle: {
              set: function (style) {
                  this.onSelectionChange();
                  this._signal("changeSelectionStyle", { data: style });
              },
              initialValue: "line"
          },
          highlightActiveLine: {
              set: function () { this.$updateHighlightActiveLine(); },
              initialValue: true
          },
          highlightSelectedWord: {
              set: function (shouldHighlight) { this.$onSelectionChange(); },
              initialValue: true
          },
          readOnly: {
              set: function (readOnly) {
                  this.$resetCursorStyle();
              },
              initialValue: false
          },
          cursorStyle: {
              set: function (val) { this.$resetCursorStyle(); },
              values: ["ace", "slim", "smooth", "wide"],
              initialValue: "ace"
          },
          mergeUndoDeltas: {
              values: [false, true, "always"],
              initialValue: true
          },
          behavioursEnabled: { initialValue: true },
          wrapBehavioursEnabled: { initialValue: true },
          autoScrollEditorIntoView: {
              set: function (val) { this.setAutoScrollEditorIntoView(val); }
          },
          keyboardHandler: {
              set: function (val) { this.setKeyboardHandler(val); },
              get: function () { return this.keybindingId; },
              handlesSet: true
          },
          hScrollBarAlwaysVisible: "renderer",
          vScrollBarAlwaysVisible: "renderer",
          highlightGutterLine: "renderer",
          animatedScroll: "renderer",
          showInvisibles: "renderer",
          showPrintMargin: "renderer",
          printMarginColumn: "renderer",
          printMargin: "renderer",
          fadeFoldWidgets: "renderer",
          showFoldWidgets: "renderer",
          showLineNumbers: "renderer",
          showGutter: "renderer",
          displayIndentGuides: "renderer",
          fontSize: "renderer",
          fontFamily: "renderer",
          maxLines: "renderer",
          minLines: "renderer",
          scrollPastEnd: "renderer",
          fixedWidthGutter: "renderer",
          theme: "renderer",
          scrollSpeed: "$mouseHandler",
          dragDelay: "$mouseHandler",
          dragEnabled: "$mouseHandler",
          focusTimout: "$mouseHandler",
          tooltipFollowsMouse: "$mouseHandler",
          firstLineNumber: "session",
          overwrite: "session",
          newLineMode: "session",
          useWorker: "session",
          useSoftTabs: "session",
          tabSize: "session",
          wrap: "session",
          indentedSoftWrap: "session",
          foldStyle: "session",
          mode: "session"
      });
      exports.Editor = Editor;
  });
  ace.define("ace/undomanager", ["require", "exports", "module"], function (acequire, exports, module) {
      var UndoManager = function () {
          this.reset();
      };
      (function () {
          this.execute = function (options) {
              var deltaSets = options.args[0];
              this.$doc = options.args[1];
              if (options.merge && this.hasUndo()) {
                  this.dirtyCounter--;
                  deltaSets = this.$undoStack.pop().concat(deltaSets);
              }
              this.$undoStack.push(deltaSets);
              this.$redoStack = [];
              if (this.dirtyCounter < 0) {
                  this.dirtyCounter = NaN;
              }
              this.dirtyCounter++;
          };
          this.undo = function (dontSelect) {
              var deltaSets = this.$undoStack.pop();
              var undoSelectionRange = null;
              if (deltaSets) {
                  undoSelectionRange = this.$doc.undoChanges(deltaSets, dontSelect);
                  this.$redoStack.push(deltaSets);
                  this.dirtyCounter--;
              }
              return undoSelectionRange;
          };
          this.redo = function (dontSelect) {
              var deltaSets = this.$redoStack.pop();
              var redoSelectionRange = null;
              if (deltaSets) {
                  redoSelectionRange =
                      this.$doc.redoChanges(this.$deserializeDeltas(deltaSets), dontSelect);
                  this.$undoStack.push(deltaSets);
                  this.dirtyCounter++;
              }
              return redoSelectionRange;
          };
          this.reset = function () {
              this.$undoStack = [];
              this.$redoStack = [];
              this.dirtyCounter = 0;
          };
          this.hasUndo = function () {
              return this.$undoStack.length > 0;
          };
          this.hasRedo = function () {
              return this.$redoStack.length > 0;
          };
          this.markClean = function () {
              this.dirtyCounter = 0;
          };
          this.isClean = function () {
              return this.dirtyCounter === 0;
          };
          this.$serializeDeltas = function (deltaSets) {
              return cloneDeltaSetsObj(deltaSets, $serializeDelta);
          };
          this.$deserializeDeltas = function (deltaSets) {
              return cloneDeltaSetsObj(deltaSets, $deserializeDelta);
          };
          function $serializeDelta(delta) {
              return {
                  action: delta.action,
                  start: delta.start,
                  end: delta.end,
                  lines: delta.lines.length == 1 ? null : delta.lines,
                  text: delta.lines.length == 1 ? delta.lines[0] : null
              };
          }
          function $deserializeDelta(delta) {
              return {
                  action: delta.action,
                  start: delta.start,
                  end: delta.end,
                  lines: delta.lines || [delta.text]
              };
          }
          function cloneDeltaSetsObj(deltaSets_old, fnGetModifiedDelta) {
              var deltaSets_new = new Array(deltaSets_old.length);
              for (var i = 0; i < deltaSets_old.length; i++) {
                  var deltaSet_old = deltaSets_old[i];
                  var deltaSet_new = { group: deltaSet_old.group, deltas: new Array(deltaSet_old.length) };
                  for (var j = 0; j < deltaSet_old.deltas.length; j++) {
                      var delta_old = deltaSet_old.deltas[j];
                      deltaSet_new.deltas[j] = fnGetModifiedDelta(delta_old);
                  }
                  deltaSets_new[i] = deltaSet_new;
              }
              return deltaSets_new;
          }
      }).call(UndoManager.prototype);
      exports.UndoManager = UndoManager;
  });
  ace.define("ace/layer/gutter", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter"], function (acequire, exports, module) {
      var dom = acequire("../lib/dom");
      var oop = acequire("../lib/oop");
      var lang = acequire("../lib/lang");
      var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
      var Gutter = function (parentEl) {
          this.element = dom.createElement("div");
          this.element.className = "ace_layer ace_gutter-layer";
          parentEl.appendChild(this.element);
          this.setShowFoldWidgets(this.$showFoldWidgets);
          this.gutterWidth = 0;
          this.$annotations = [];
          this.$updateAnnotations = this.$updateAnnotations.bind(this);
          this.$cells = [];
      };
      (function () {
          oop.implement(this, EventEmitter);
          this.setSession = function (session) {
              if (this.session)
                  this.session.removeEventListener("change", this.$updateAnnotations);
              this.session = session;
              if (session)
                  session.on("change", this.$updateAnnotations);
          };
          this.addGutterDecoration = function (row, className) {
              if (window.console)
                  console.warn && console.warn("deprecated use session.addGutterDecoration");
              this.session.addGutterDecoration(row, className);
          };
          this.removeGutterDecoration = function (row, className) {
              if (window.console)
                  console.warn && console.warn("deprecated use session.removeGutterDecoration");
              this.session.removeGutterDecoration(row, className);
          };
          this.setAnnotations = function (annotations) {
              this.$annotations = [];
              for (var i = 0; i < annotations.length; i++) {
                  var annotation = annotations[i];
                  var row = annotation.row;
                  var rowInfo = this.$annotations[row];
                  if (!rowInfo)
                      rowInfo = this.$annotations[row] = { text: [] };
                  var annoText = annotation.text;
                  annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";
                  if (rowInfo.text.indexOf(annoText) === -1)
                      rowInfo.text.push(annoText);
                  var type = annotation.type;
                  if (type == "error")
                      rowInfo.className = " ace_error";
                  else if (type == "warning" && rowInfo.className != " ace_error")
                      rowInfo.className = " ace_warning";
                  else if (type == "info" && (!rowInfo.className))
                      rowInfo.className = " ace_info";
              }
          };
          this.$updateAnnotations = function (delta) {
              if (!this.$annotations.length)
                  return;
              var firstRow = delta.start.row;
              var len = delta.end.row - firstRow;
              if (len === 0) ;
              else if (delta.action == 'remove') {
                  this.$annotations.splice(firstRow, len + 1, null);
              }
              else {
                  var args = new Array(len + 1);
                  args.unshift(firstRow, 1);
                  this.$annotations.splice.apply(this.$annotations, args);
              }
          };
          this.update = function (config) {
              var session = this.session;
              var firstRow = config.firstRow;
              var lastRow = Math.min(config.lastRow + config.gutterOffset, // needed to compensate for hor scollbar
              session.getLength() - 1);
              var fold = session.getNextFoldLine(firstRow);
              var foldStart = fold ? fold.start.row : Infinity;
              var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
              var breakpoints = session.$breakpoints;
              var decorations = session.$decorations;
              var firstLineNumber = session.$firstLineNumber;
              var lastLineNumber = 0;
              var gutterRenderer = session.gutterRenderer || this.$renderer;
              var cell = null;
              var index = -1;
              var row = firstRow;
              while (true) {
                  if (row > foldStart) {
                      row = fold.end.row + 1;
                      fold = session.getNextFoldLine(row, fold);
                      foldStart = fold ? fold.start.row : Infinity;
                  }
                  if (row > lastRow) {
                      while (this.$cells.length > index + 1) {
                          cell = this.$cells.pop();
                          this.element.removeChild(cell.element);
                      }
                      break;
                  }
                  cell = this.$cells[++index];
                  if (!cell) {
                      cell = { element: null, textNode: null, foldWidget: null };
                      cell.element = dom.createElement("div");
                      cell.textNode = document.createTextNode('');
                      cell.element.appendChild(cell.textNode);
                      this.element.appendChild(cell.element);
                      this.$cells[index] = cell;
                  }
                  var className = "ace_gutter-cell ";
                  if (breakpoints[row])
                      className += breakpoints[row];
                  if (decorations[row])
                      className += decorations[row];
                  if (this.$annotations[row])
                      className += this.$annotations[row].className;
                  if (cell.element.className != className)
                      cell.element.className = className;
                  var height = session.getRowLength(row) * config.lineHeight + "px";
                  if (height != cell.element.style.height)
                      cell.element.style.height = height;
                  if (foldWidgets) {
                      var c = foldWidgets[row];
                      if (c == null)
                          c = foldWidgets[row] = session.getFoldWidget(row);
                  }
                  if (c) {
                      if (!cell.foldWidget) {
                          cell.foldWidget = dom.createElement("span");
                          cell.element.appendChild(cell.foldWidget);
                      }
                      var className = "ace_fold-widget ace_" + c;
                      if (c == "start" && row == foldStart && row < fold.end.row)
                          className += " ace_closed";
                      else
                          className += " ace_open";
                      if (cell.foldWidget.className != className)
                          cell.foldWidget.className = className;
                      var height = config.lineHeight + "px";
                      if (cell.foldWidget.style.height != height)
                          cell.foldWidget.style.height = height;
                  }
                  else {
                      if (cell.foldWidget) {
                          cell.element.removeChild(cell.foldWidget);
                          cell.foldWidget = null;
                      }
                  }
                  var text = lastLineNumber = gutterRenderer
                      ? gutterRenderer.getText(session, row)
                      : row + firstLineNumber;
                  if (text !== cell.textNode.data)
                      cell.textNode.data = text;
                  row++;
              }
              this.element.style.height = config.minHeight + "px";
              if (this.$fixedWidth || session.$useWrapMode)
                  lastLineNumber = session.getLength() + firstLineNumber;
              var gutterWidth = gutterRenderer
                  ? gutterRenderer.getWidth(session, lastLineNumber, config)
                  : lastLineNumber.toString().length * config.characterWidth;
              var padding = this.$padding || this.$computePadding();
              gutterWidth += padding.left + padding.right;
              if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
                  this.gutterWidth = gutterWidth;
                  this.element.style.width = Math.ceil(this.gutterWidth) + "px";
                  this._emit("changeGutterWidth", gutterWidth);
              }
          };
          this.$fixedWidth = false;
          this.$showLineNumbers = true;
          this.$renderer = "";
          this.setShowLineNumbers = function (show) {
              this.$renderer = !show && {
                  getWidth: function () { return ""; },
                  getText: function () { return ""; }
              };
          };
          this.getShowLineNumbers = function () {
              return this.$showLineNumbers;
          };
          this.$showFoldWidgets = true;
          this.setShowFoldWidgets = function (show) {
              if (show)
                  dom.addCssClass(this.element, "ace_folding-enabled");
              else
                  dom.removeCssClass(this.element, "ace_folding-enabled");
              this.$showFoldWidgets = show;
              this.$padding = null;
          };
          this.getShowFoldWidgets = function () {
              return this.$showFoldWidgets;
          };
          this.$computePadding = function () {
              if (!this.element.firstChild)
                  return { left: 0, right: 0 };
              var style = dom.computedStyle(this.element.firstChild);
              this.$padding = {};
              this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
              this.$padding.right = parseInt(style.paddingRight) || 0;
              return this.$padding;
          };
          this.getRegion = function (point) {
              var padding = this.$padding || this.$computePadding();
              var rect = this.element.getBoundingClientRect();
              if (point.x < padding.left + rect.left)
                  return "markers";
              if (this.$showFoldWidgets && point.x > rect.right - padding.right)
                  return "foldWidgets";
          };
      }).call(Gutter.prototype);
      exports.Gutter = Gutter;
  });
  ace.define("ace/layer/marker", ["require", "exports", "module", "ace/range", "ace/lib/dom"], function (acequire, exports, module) {
      var Range = acequire("../range").Range;
      var dom = acequire("../lib/dom");
      var Marker = function (parentEl) {
          this.element = dom.createElement("div");
          this.element.className = "ace_layer ace_marker-layer";
          parentEl.appendChild(this.element);
      };
      (function () {
          this.$padding = 0;
          this.setPadding = function (padding) {
              this.$padding = padding;
          };
          this.setSession = function (session) {
              this.session = session;
          };
          this.setMarkers = function (markers) {
              this.markers = markers;
          };
          this.update = function (config) {
              if (!config)
                  return;
              this.config = config;
              var html = [];
              for (var key in this.markers) {
                  var marker = this.markers[key];
                  if (!marker.range) {
                      marker.update(html, this, this.session, config);
                      continue;
                  }
                  var range = marker.range.clipRows(config.firstRow, config.lastRow);
                  if (range.isEmpty())
                      continue;
                  range = range.toScreenRange(this.session);
                  if (marker.renderer) {
                      var top = this.$getTop(range.start.row, config);
                      var left = this.$padding + (this.session.$bidiHandler.isBidiRow(range.start.row)
                          ? this.session.$bidiHandler.getPosLeft(range.start.column)
                          : range.start.column * config.characterWidth);
                      marker.renderer(html, range, left, top, config);
                  }
                  else if (marker.type == "fullLine") {
                      this.drawFullLineMarker(html, range, marker.clazz, config);
                  }
                  else if (marker.type == "screenLine") {
                      this.drawScreenLineMarker(html, range, marker.clazz, config);
                  }
                  else if (range.isMultiLine()) {
                      if (marker.type == "text")
                          this.drawTextMarker(html, range, marker.clazz, config);
                      else
                          this.drawMultiLineMarker(html, range, marker.clazz, config);
                  }
                  else {
                      if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
                          this.drawBidiSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
                      }
                      else {
                          this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
                      }
                  }
              }
              this.element.innerHTML = html.join("");
          };
          this.$getTop = function (row, layerConfig) {
              return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
          };
          function getBorderClass(tl, tr, br, bl) {
              return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
          }
          this.drawTextMarker = function (stringBuilder, range, clazz, layerConfig, extraStyle) {
              var session = this.session;
              var start = range.start.row;
              var end = range.end.row;
              var row = start;
              var prev = 0;
              var curr = 0;
              var next = session.getScreenLastRowColumn(row);
              var clazzModified = null;
              var lineRange = new Range(row, range.start.column, row, curr);
              for (; row <= end; row++) {
                  lineRange.start.row = lineRange.end.row = row;
                  lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
                  lineRange.end.column = next;
                  prev = curr;
                  curr = next;
                  next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
                  clazzModified = clazz + (row == start ? " ace_start" : "") + " ace_br"
                      + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end);
                  if (this.session.$bidiHandler.isBidiRow(row)) {
                      this.drawBidiSingleLineMarker(stringBuilder, lineRange, clazzModified, layerConfig, row == end ? 0 : 1, extraStyle);
                  }
                  else {
                      this.drawSingleLineMarker(stringBuilder, lineRange, clazzModified, layerConfig, row == end ? 0 : 1, extraStyle);
                  }
              }
          };
          this.drawMultiLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
              var padding = this.$padding;
              var height, top, left;
              extraStyle = extraStyle || "";
              if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
                  var range1 = range.clone();
                  range1.end.row = range1.start.row;
                  range1.end.column = this.session.getLine(range1.start.row).length;
                  this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config, null, extraStyle);
              }
              else {
                  height = config.lineHeight;
                  top = this.$getTop(range.start.row, config);
                  left = padding + range.start.column * config.characterWidth;
                  stringBuilder.push("<div class='", clazz, " ace_br1 ace_start' style='", "height:", height, "px;", "right:0;", "top:", top, "px;", "left:", left, "px;", extraStyle, "'></div>");
              }
              if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
                  var range1 = range.clone();
                  range1.start.row = range1.end.row;
                  range1.start.column = 0;
                  this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config, null, extraStyle);
              }
              else {
                  var width = range.end.column * config.characterWidth;
                  height = config.lineHeight;
                  top = this.$getTop(range.end.row, config);
                  stringBuilder.push("<div class='", clazz, " ace_br12' style='", "height:", height, "px;", "width:", width, "px;", "top:", top, "px;", "left:", padding, "px;", extraStyle, "'></div>");
              }
              height = (range.end.row - range.start.row - 1) * config.lineHeight;
              if (height <= 0)
                  return;
              top = this.$getTop(range.start.row + 1, config);
              var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);
              stringBuilder.push("<div class='", clazz, (radiusClass ? " ace_br" + radiusClass : ""), "' style='", "height:", height, "px;", "right:0;", "top:", top, "px;", "left:", padding, "px;", extraStyle, "'></div>");
          };
          this.drawSingleLineMarker = function (stringBuilder, range, clazz, config, extraLength, extraStyle) {
              var height = config.lineHeight;
              var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
              var top = this.$getTop(range.start.row, config);
              var left = this.$padding + range.start.column * config.characterWidth;
              stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "width:", width, "px;", "top:", top, "px;", "left:", left, "px;", extraStyle || "", "'></div>");
          };
          this.drawBidiSingleLineMarker = function (stringBuilder, range, clazz, config, extraLength, extraStyle) {
              var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;
              var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);
              selections.forEach(function (selection) {
                  stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "width:", selection.width + (extraLength || 0), "px;", "top:", top, "px;", "left:", padding + selection.left, "px;", extraStyle || "", "'></div>");
              });
          };
          this.drawFullLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
              var top = this.$getTop(range.start.row, config);
              var height = config.lineHeight;
              if (range.start.row != range.end.row)
                  height += this.$getTop(range.end.row, config) - top;
              stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "top:", top, "px;", "left:0;right:0;", extraStyle || "", "'></div>");
          };
          this.drawScreenLineMarker = function (stringBuilder, range, clazz, config, extraStyle) {
              var top = this.$getTop(range.start.row, config);
              var height = config.lineHeight;
              stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "top:", top, "px;", "left:0;right:0;", extraStyle || "", "'></div>");
          };
      }).call(Marker.prototype);
      exports.Marker = Marker;
  });
  ace.define("ace/layer/text", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/lib/event_emitter"], function (acequire, exports, module) {
      var oop = acequire("../lib/oop");
      var dom = acequire("../lib/dom");
      var lang = acequire("../lib/lang");
      var useragent = acequire("../lib/useragent");
      var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
      var Text = function (parentEl) {
          this.element = dom.createElement("div");
          this.element.className = "ace_layer ace_text-layer";
          parentEl.appendChild(this.element);
          this.$updateEolChar = this.$updateEolChar.bind(this);
      };
      (function () {
          oop.implement(this, EventEmitter);
          this.EOF_CHAR = "\xB6";
          this.EOL_CHAR_LF = "\xAC";
          this.EOL_CHAR_CRLF = "\xa4";
          this.EOL_CHAR = this.EOL_CHAR_LF;
          this.TAB_CHAR = "\u2014"; //"\u21E5";
          this.SPACE_CHAR = "\xB7";
          this.$padding = 0;
          this.$updateEolChar = function () {
              var EOL_CHAR = this.session.doc.getNewLineCharacter() == "\n"
                  ? this.EOL_CHAR_LF
                  : this.EOL_CHAR_CRLF;
              if (this.EOL_CHAR != EOL_CHAR) {
                  this.EOL_CHAR = EOL_CHAR;
                  return true;
              }
          };
          this.setPadding = function (padding) {
              this.$padding = padding;
              this.element.style.padding = "0 " + padding + "px";
          };
          this.getLineHeight = function () {
              return this.$fontMetrics.$characterSize.height || 0;
          };
          this.getCharacterWidth = function () {
              return this.$fontMetrics.$characterSize.width || 0;
          };
          this.$setFontMetrics = function (measure) {
              this.$fontMetrics = measure;
              this.$fontMetrics.on("changeCharacterSize", function (e) {
                  this._signal("changeCharacterSize", e);
              }.bind(this));
              this.$pollSizeChanges();
          };
          this.checkForSizeChanges = function () {
              this.$fontMetrics.checkForSizeChanges();
          };
          this.$pollSizeChanges = function () {
              return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
          };
          this.setSession = function (session) {
              this.session = session;
              if (session)
                  this.$computeTabString();
          };
          this.showInvisibles = false;
          this.setShowInvisibles = function (showInvisibles) {
              if (this.showInvisibles == showInvisibles)
                  return false;
              this.showInvisibles = showInvisibles;
              this.$computeTabString();
              return true;
          };
          this.displayIndentGuides = true;
          this.setDisplayIndentGuides = function (display) {
              if (this.displayIndentGuides == display)
                  return false;
              this.displayIndentGuides = display;
              this.$computeTabString();
              return true;
          };
          this.$tabStrings = [];
          this.onChangeTabSize =
              this.$computeTabString = function () {
                  var tabSize = this.session.getTabSize();
                  this.tabSize = tabSize;
                  var tabStr = this.$tabStrings = [0];
                  for (var i = 1; i < tabSize + 1; i++) {
                      if (this.showInvisibles) {
                          tabStr.push("<span class='ace_invisible ace_invisible_tab'>"
                              + lang.stringRepeat(this.TAB_CHAR, i)
                              + "</span>");
                      }
                      else {
                          tabStr.push(lang.stringRepeat(" ", i));
                      }
                  }
                  if (this.displayIndentGuides) {
                      this.$indentGuideRe = /\s\S| \t|\t |\s$/;
                      var className = "ace_indent-guide";
                      var spaceClass = "";
                      var tabClass = "";
                      if (this.showInvisibles) {
                          className += " ace_invisible";
                          spaceClass = " ace_invisible_space";
                          tabClass = " ace_invisible_tab";
                          var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
                          var tabContent = lang.stringRepeat(this.TAB_CHAR, this.tabSize);
                      }
                      else {
                          var spaceContent = lang.stringRepeat(" ", this.tabSize);
                          var tabContent = spaceContent;
                      }
                      this.$tabStrings[" "] = "<span class='" + className + spaceClass + "'>" + spaceContent + "</span>";
                      this.$tabStrings["\t"] = "<span class='" + className + tabClass + "'>" + tabContent + "</span>";
                  }
              };
          this.updateLines = function (config, firstRow, lastRow) {
              if (this.config.lastRow != config.lastRow ||
                  this.config.firstRow != config.firstRow) {
                  this.scrollLines(config);
              }
              this.config = config;
              var first = Math.max(firstRow, config.firstRow);
              var last = Math.min(lastRow, config.lastRow);
              var lineElements = this.element.childNodes;
              var lineElementsIdx = 0;
              for (var row = config.firstRow; row < first; row++) {
                  var foldLine = this.session.getFoldLine(row);
                  if (foldLine) {
                      if (foldLine.containsRow(first)) {
                          first = foldLine.start.row;
                          break;
                      }
                      else {
                          row = foldLine.end.row;
                      }
                  }
                  lineElementsIdx++;
              }
              var row = first;
              var foldLine = this.session.getNextFoldLine(row);
              var foldStart = foldLine ? foldLine.start.row : Infinity;
              while (true) {
                  if (row > foldStart) {
                      row = foldLine.end.row + 1;
                      foldLine = this.session.getNextFoldLine(row, foldLine);
                      foldStart = foldLine ? foldLine.start.row : Infinity;
                  }
                  if (row > last)
                      break;
                  var lineElement = lineElements[lineElementsIdx++];
                  if (lineElement) {
                      var html = [];
                      this.$renderLine(html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false);
                      lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
                      lineElement.innerHTML = html.join("");
                  }
                  row++;
              }
          };
          this.scrollLines = function (config) {
              var oldConfig = this.config;
              this.config = config;
              if (!oldConfig || oldConfig.lastRow < config.firstRow)
                  return this.update(config);
              if (config.lastRow < oldConfig.firstRow)
                  return this.update(config);
              var el = this.element;
              if (oldConfig.firstRow < config.firstRow)
                  for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
                      el.removeChild(el.firstChild);
              if (oldConfig.lastRow > config.lastRow)
                  for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--)
                      el.removeChild(el.lastChild);
              if (config.firstRow < oldConfig.firstRow) {
                  var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
                  if (el.firstChild)
                      el.insertBefore(fragment, el.firstChild);
                  else
                      el.appendChild(fragment);
              }
              if (config.lastRow > oldConfig.lastRow) {
                  var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
                  el.appendChild(fragment);
              }
          };
          this.$renderLinesFragment = function (config, firstRow, lastRow) {
              var fragment = this.element.ownerDocument.createDocumentFragment();
              var row = firstRow;
              var foldLine = this.session.getNextFoldLine(row);
              var foldStart = foldLine ? foldLine.start.row : Infinity;
              while (true) {
                  if (row > foldStart) {
                      row = foldLine.end.row + 1;
                      foldLine = this.session.getNextFoldLine(row, foldLine);
                      foldStart = foldLine ? foldLine.start.row : Infinity;
                  }
                  if (row > lastRow)
                      break;
                  var container = dom.createElement("div");
                  var html = [];
                  this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
                  container.innerHTML = html.join("");
                  if (this.$useLineGroups()) {
                      container.className = 'ace_line_group';
                      fragment.appendChild(container);
                      container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
                  }
                  else {
                      while (container.firstChild)
                          fragment.appendChild(container.firstChild);
                  }
                  row++;
              }
              return fragment;
          };
          this.update = function (config) {
              this.config = config;
              var html = [];
              var firstRow = config.firstRow, lastRow = config.lastRow;
              var row = firstRow;
              var foldLine = this.session.getNextFoldLine(row);
              var foldStart = foldLine ? foldLine.start.row : Infinity;
              while (true) {
                  if (row > foldStart) {
                      row = foldLine.end.row + 1;
                      foldLine = this.session.getNextFoldLine(row, foldLine);
                      foldStart = foldLine ? foldLine.start.row : Infinity;
                  }
                  if (row > lastRow)
                      break;
                  if (this.$useLineGroups())
                      html.push("<div class='ace_line_group' style='height:", config.lineHeight * this.session.getRowLength(row), "px'>");
                  this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
                  if (this.$useLineGroups())
                      html.push("</div>"); // end the line group
                  row++;
              }
              this.element.innerHTML = html.join("");
          };
          this.$textToken = {
              "text": true,
              "rparen": true,
              "lparen": true
          };
          this.$renderToken = function (stringBuilder, screenColumn, token, value) {
              var self = this;
              var replaceReg = /\t|&|<|>|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF\uFFF9-\uFFFC])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
              var replaceFunc = function (c, a, b, tabIdx, idx4) {
                  if (a) {
                      return self.showInvisibles
                          ? "<span class='ace_invisible ace_invisible_space'>" + lang.stringRepeat(self.SPACE_CHAR, c.length) + "</span>"
                          : c;
                  }
                  else if (c == "&") {
                      return "&#38;";
                  }
                  else if (c == "<") {
                      return "&#60;";
                  }
                  else if (c == ">") {
                      return "&#62;";
                  }
                  else if (c == "\t") {
                      var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
                      screenColumn += tabSize - 1;
                      return self.$tabStrings[tabSize];
                  }
                  else if (c == "\u3000") {
                      var classToUse = self.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                      var space = self.showInvisibles ? self.SPACE_CHAR : "";
                      screenColumn += 1;
                      return "<span class='" + classToUse + "' style='width:" +
                          (self.config.characterWidth * 2) +
                          "px'>" + space + "</span>";
                  }
                  else if (b) {
                      return "<span class='ace_invisible ace_invisible_space ace_invalid'>" + self.SPACE_CHAR + "</span>";
                  }
                  else {
                      screenColumn += 1;
                      return "<span class='ace_cjk' style='width:" +
                          (self.config.characterWidth * 2) +
                          "px'>" + c + "</span>";
                  }
              };
              var output = value.replace(replaceReg, replaceFunc);
              if (!this.$textToken[token.type]) {
                  var classes = "ace_" + token.type.replace(/\./g, " ace_");
                  var style = "";
                  if (token.type == "fold")
                      style = " style='width:" + (token.value.length * this.config.characterWidth) + "px;' ";
                  stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
              }
              else {
                  stringBuilder.push(output);
              }
              return screenColumn + value.length;
          };
          this.renderIndentGuide = function (stringBuilder, value, max) {
              var cols = value.search(this.$indentGuideRe);
              if (cols <= 0 || cols >= max)
                  return value;
              if (value[0] == " ") {
                  cols -= cols % this.tabSize;
                  stringBuilder.push(lang.stringRepeat(this.$tabStrings[" "], cols / this.tabSize));
                  return value.substr(cols);
              }
              else if (value[0] == "\t") {
                  stringBuilder.push(lang.stringRepeat(this.$tabStrings["\t"], cols));
                  return value.substr(cols);
              }
              return value;
          };
          this.$renderWrappedLine = function (stringBuilder, tokens, splits, onlyContents) {
              var chars = 0;
              var split = 0;
              var splitChars = splits[0];
              var screenColumn = 0;
              for (var i = 0; i < tokens.length; i++) {
                  var token = tokens[i];
                  var value = token.value;
                  if (i == 0 && this.displayIndentGuides) {
                      chars = value.length;
                      value = this.renderIndentGuide(stringBuilder, value, splitChars);
                      if (!value)
                          continue;
                      chars -= value.length;
                  }
                  if (chars + value.length < splitChars) {
                      screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                      chars += value.length;
                  }
                  else {
                      while (chars + value.length >= splitChars) {
                          screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value.substring(0, splitChars - chars));
                          value = value.substring(splitChars - chars);
                          chars = splitChars;
                          if (!onlyContents) {
                              stringBuilder.push("</div>", "<div class='ace_line' style='height:", this.config.lineHeight, "px'>");
                          }
                          stringBuilder.push(lang.stringRepeat("\xa0", splits.indent));
                          split++;
                          screenColumn = 0;
                          splitChars = splits[split] || Number.MAX_VALUE;
                      }
                      if (value.length != 0) {
                          chars += value.length;
                          screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                      }
                  }
              }
          };
          this.$renderSimpleLine = function (stringBuilder, tokens) {
              var screenColumn = 0;
              var token = tokens[0];
              var value = token.value;
              if (this.displayIndentGuides)
                  value = this.renderIndentGuide(stringBuilder, value);
              if (value)
                  screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
              for (var i = 1; i < tokens.length; i++) {
                  token = tokens[i];
                  value = token.value;
                  screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
              }
          };
          this.$renderLine = function (stringBuilder, row, onlyContents, foldLine) {
              if (!foldLine && foldLine != false)
                  foldLine = this.session.getFoldLine(row);
              if (foldLine)
                  var tokens = this.$getFoldLineTokens(row, foldLine);
              else
                  var tokens = this.session.getTokens(row);
              if (!onlyContents) {
                  stringBuilder.push("<div class='ace_line' style='height:", this.config.lineHeight * (this.$useLineGroups() ? 1 : this.session.getRowLength(row)), "px'>");
              }
              if (tokens.length) {
                  var splits = this.session.getRowSplitData(row);
                  if (splits && splits.length)
                      this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);
                  else
                      this.$renderSimpleLine(stringBuilder, tokens);
              }
              if (this.showInvisibles) {
                  if (foldLine)
                      row = foldLine.end.row;
                  stringBuilder.push("<span class='ace_invisible ace_invisible_eol'>", row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR, "</span>");
              }
              if (!onlyContents)
                  stringBuilder.push("</div>");
          };
          this.$getFoldLineTokens = function (row, foldLine) {
              var session = this.session;
              var renderTokens = [];
              function addTokens(tokens, from, to) {
                  var idx = 0, col = 0;
                  while ((col + tokens[idx].value.length) < from) {
                      col += tokens[idx].value.length;
                      idx++;
                      if (idx == tokens.length)
                          return;
                  }
                  if (col != from) {
                      var value = tokens[idx].value.substring(from - col);
                      if (value.length > (to - from))
                          value = value.substring(0, to - from);
                      renderTokens.push({
                          type: tokens[idx].type,
                          value: value
                      });
                      col = from + value.length;
                      idx += 1;
                  }
                  while (col < to && idx < tokens.length) {
                      var value = tokens[idx].value;
                      if (value.length + col > to) {
                          renderTokens.push({
                              type: tokens[idx].type,
                              value: value.substring(0, to - col)
                          });
                      }
                      else
                          renderTokens.push(tokens[idx]);
                      col += value.length;
                      idx += 1;
                  }
              }
              var tokens = session.getTokens(row);
              foldLine.walk(function (placeholder, row, column, lastColumn, isNewRow) {
                  if (placeholder != null) {
                      renderTokens.push({
                          type: "fold",
                          value: placeholder
                      });
                  }
                  else {
                      if (isNewRow)
                          tokens = session.getTokens(row);
                      if (tokens.length)
                          addTokens(tokens, lastColumn, column);
                  }
              }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
              return renderTokens;
          };
          this.$useLineGroups = function () {
              return this.session.getUseWrapMode();
          };
          this.destroy = function () {
              clearInterval(this.$pollSizeChangesTimer);
              if (this.$measureNode)
                  this.$measureNode.parentNode.removeChild(this.$measureNode);
              delete this.$measureNode;
          };
      }).call(Text.prototype);
      exports.Text = Text;
  });
  ace.define("ace/layer/cursor", ["require", "exports", "module", "ace/lib/dom"], function (acequire, exports, module) {
      var dom = acequire("../lib/dom");
      var isIE8;
      var Cursor = function (parentEl) {
          this.element = dom.createElement("div");
          this.element.className = "ace_layer ace_cursor-layer";
          parentEl.appendChild(this.element);
          if (isIE8 === undefined)
              isIE8 = !("opacity" in this.element.style);
          this.isVisible = false;
          this.isBlinking = true;
          this.blinkInterval = 1000;
          this.smoothBlinking = false;
          this.cursors = [];
          this.cursor = this.addCursor();
          dom.addCssClass(this.element, "ace_hidden-cursors");
          this.$updateCursors = (isIE8
              ? this.$updateVisibility
              : this.$updateOpacity).bind(this);
      };
      (function () {
          this.$updateVisibility = function (val) {
              var cursors = this.cursors;
              for (var i = cursors.length; i--;)
                  cursors[i].style.visibility = val ? "" : "hidden";
          };
          this.$updateOpacity = function (val) {
              var cursors = this.cursors;
              for (var i = cursors.length; i--;)
                  cursors[i].style.opacity = val ? "" : "0";
          };
          this.$padding = 0;
          this.setPadding = function (padding) {
              this.$padding = padding;
          };
          this.setSession = function (session) {
              this.session = session;
          };
          this.setBlinking = function (blinking) {
              if (blinking != this.isBlinking) {
                  this.isBlinking = blinking;
                  this.restartTimer();
              }
          };
          this.setBlinkInterval = function (blinkInterval) {
              if (blinkInterval != this.blinkInterval) {
                  this.blinkInterval = blinkInterval;
                  this.restartTimer();
              }
          };
          this.setSmoothBlinking = function (smoothBlinking) {
              if (smoothBlinking != this.smoothBlinking && !isIE8) {
                  this.smoothBlinking = smoothBlinking;
                  dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
                  this.$updateCursors(true);
                  this.$updateCursors = (this.$updateOpacity).bind(this);
                  this.restartTimer();
              }
          };
          this.addCursor = function () {
              var el = dom.createElement("div");
              el.className = "ace_cursor";
              this.element.appendChild(el);
              this.cursors.push(el);
              return el;
          };
          this.removeCursor = function () {
              if (this.cursors.length > 1) {
                  var el = this.cursors.pop();
                  el.parentNode.removeChild(el);
                  return el;
              }
          };
          this.hideCursor = function () {
              this.isVisible = false;
              dom.addCssClass(this.element, "ace_hidden-cursors");
              this.restartTimer();
          };
          this.showCursor = function () {
              this.isVisible = true;
              dom.removeCssClass(this.element, "ace_hidden-cursors");
              this.restartTimer();
          };
          this.restartTimer = function () {
              var update = this.$updateCursors;
              clearInterval(this.intervalId);
              clearTimeout(this.timeoutId);
              if (this.smoothBlinking) {
                  dom.removeCssClass(this.element, "ace_smooth-blinking");
              }
              update(true);
              if (!this.isBlinking || !this.blinkInterval || !this.isVisible)
                  return;
              if (this.smoothBlinking) {
                  setTimeout(function () {
                      dom.addCssClass(this.element, "ace_smooth-blinking");
                  }.bind(this));
              }
              var blink = function () {
                  this.timeoutId = setTimeout(function () {
                      update(false);
                  }, 0.6 * this.blinkInterval);
              }.bind(this);
              this.intervalId = setInterval(function () {
                  update(true);
                  blink();
              }, this.blinkInterval);
              blink();
          };
          this.getPixelPosition = function (position, onScreen) {
              if (!this.config || !this.session)
                  return { left: 0, top: 0 };
              if (!position)
                  position = this.session.selection.getCursor();
              var pos = this.session.documentToScreenPosition(position);
              var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row)
                  ? this.session.$bidiHandler.getPosLeft(pos.column)
                  : pos.column * this.config.characterWidth);
              var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) *
                  this.config.lineHeight;
              return { left: cursorLeft, top: cursorTop };
          };
          this.update = function (config) {
              this.config = config;
              var selections = this.session.$selectionMarkers;
              var i = 0, cursorIndex = 0;
              if (selections === undefined || selections.length === 0) {
                  selections = [{ cursor: null }];
              }
              for (var i = 0, n = selections.length; i < n; i++) {
                  var pixelPos = this.getPixelPosition(selections[i].cursor, true);
                  if ((pixelPos.top > config.height + config.offset ||
                      pixelPos.top < 0) && i > 1) {
                      continue;
                  }
                  var style = (this.cursors[cursorIndex++] || this.addCursor()).style;
                  if (!this.drawCursor) {
                      style.left = pixelPos.left + "px";
                      style.top = pixelPos.top + "px";
                      style.width = config.characterWidth + "px";
                      style.height = config.lineHeight + "px";
                  }
                  else {
                      this.drawCursor(style, pixelPos, config, selections[i], this.session);
                  }
              }
              while (this.cursors.length > cursorIndex)
                  this.removeCursor();
              var overwrite = this.session.getOverwrite();
              this.$setOverwrite(overwrite);
              this.$pixelPos = pixelPos;
              this.restartTimer();
          };
          this.drawCursor = null;
          this.$setOverwrite = function (overwrite) {
              if (overwrite != this.overwrite) {
                  this.overwrite = overwrite;
                  if (overwrite)
                      dom.addCssClass(this.element, "ace_overwrite-cursors");
                  else
                      dom.removeCssClass(this.element, "ace_overwrite-cursors");
              }
          };
          this.destroy = function () {
              clearInterval(this.intervalId);
              clearTimeout(this.timeoutId);
          };
      }).call(Cursor.prototype);
      exports.Cursor = Cursor;
  });
  ace.define("ace/scrollbar", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function (acequire, exports, module) {
      var oop = acequire("./lib/oop");
      var dom = acequire("./lib/dom");
      var event = acequire("./lib/event");
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var MAX_SCROLL_H = 0x8000;
      var ScrollBar = function (parent) {
          this.element = dom.createElement("div");
          this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;
          this.inner = dom.createElement("div");
          this.inner.className = "ace_scrollbar-inner";
          this.element.appendChild(this.inner);
          parent.appendChild(this.element);
          this.setVisible(false);
          this.skipEvent = false;
          event.addListener(this.element, "scroll", this.onScroll.bind(this));
          event.addListener(this.element, "mousedown", event.preventDefault);
      };
      (function () {
          oop.implement(this, EventEmitter);
          this.setVisible = function (isVisible) {
              this.element.style.display = isVisible ? "" : "none";
              this.isVisible = isVisible;
              this.coeff = 1;
          };
      }).call(ScrollBar.prototype);
      var VScrollBar = function (parent, renderer) {
          ScrollBar.call(this, parent);
          this.scrollTop = 0;
          this.scrollHeight = 0;
          renderer.$scrollbarWidth =
              this.width = dom.scrollbarWidth(parent.ownerDocument);
          this.inner.style.width =
              this.element.style.width = (this.width || 15) + 5 + "px";
          this.$minWidth = 0;
      };
      oop.inherits(VScrollBar, ScrollBar);
      (function () {
          this.classSuffix = '-v';
          this.onScroll = function () {
              if (!this.skipEvent) {
                  this.scrollTop = this.element.scrollTop;
                  if (this.coeff != 1) {
                      var h = this.element.clientHeight / this.scrollHeight;
                      this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
                  }
                  this._emit("scroll", { data: this.scrollTop });
              }
              this.skipEvent = false;
          };
          this.getWidth = function () {
              return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
          };
          this.setHeight = function (height) {
              this.element.style.height = height + "px";
          };
          this.setInnerHeight =
              this.setScrollHeight = function (height) {
                  this.scrollHeight = height;
                  if (height > MAX_SCROLL_H) {
                      this.coeff = MAX_SCROLL_H / height;
                      height = MAX_SCROLL_H;
                  }
                  else if (this.coeff != 1) {
                      this.coeff = 1;
                  }
                  this.inner.style.height = height + "px";
              };
          this.setScrollTop = function (scrollTop) {
              if (this.scrollTop != scrollTop) {
                  this.skipEvent = true;
                  this.scrollTop = scrollTop;
                  this.element.scrollTop = scrollTop * this.coeff;
              }
          };
      }).call(VScrollBar.prototype);
      var HScrollBar = function (parent, renderer) {
          ScrollBar.call(this, parent);
          this.scrollLeft = 0;
          this.height = renderer.$scrollbarWidth;
          this.inner.style.height =
              this.element.style.height = (this.height || 15) + 5 + "px";
      };
      oop.inherits(HScrollBar, ScrollBar);
      (function () {
          this.classSuffix = '-h';
          this.onScroll = function () {
              if (!this.skipEvent) {
                  this.scrollLeft = this.element.scrollLeft;
                  this._emit("scroll", { data: this.scrollLeft });
              }
              this.skipEvent = false;
          };
          this.getHeight = function () {
              return this.isVisible ? this.height : 0;
          };
          this.setWidth = function (width) {
              this.element.style.width = width + "px";
          };
          this.setInnerWidth = function (width) {
              this.inner.style.width = width + "px";
          };
          this.setScrollWidth = function (width) {
              this.inner.style.width = width + "px";
          };
          this.setScrollLeft = function (scrollLeft) {
              if (this.scrollLeft != scrollLeft) {
                  this.skipEvent = true;
                  this.scrollLeft = this.element.scrollLeft = scrollLeft;
              }
          };
      }).call(HScrollBar.prototype);
      exports.ScrollBar = VScrollBar; // backward compatibility
      exports.ScrollBarV = VScrollBar; // backward compatibility
      exports.ScrollBarH = HScrollBar; // backward compatibility
      exports.VScrollBar = VScrollBar;
      exports.HScrollBar = HScrollBar;
  });
  ace.define("ace/renderloop", ["require", "exports", "module", "ace/lib/event"], function (acequire, exports, module) {
      var event = acequire("./lib/event");
      var RenderLoop = function (onRender, win) {
          this.onRender = onRender;
          this.pending = false;
          this.changes = 0;
          this.window = win || window;
      };
      (function () {
          this.schedule = function (change) {
              this.changes = this.changes | change;
              if (!this.pending && this.changes) {
                  this.pending = true;
                  var _self = this;
                  event.nextFrame(function () {
                      _self.pending = false;
                      var changes;
                      while (changes = _self.changes) {
                          _self.changes = 0;
                          _self.onRender(changes);
                      }
                  }, this.window);
              }
          };
      }).call(RenderLoop.prototype);
      exports.RenderLoop = RenderLoop;
  });
  ace.define("ace/layer/font_metrics", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/lib/event_emitter"], function (acequire, exports, module) {
      var oop = acequire("../lib/oop");
      var dom = acequire("../lib/dom");
      var lang = acequire("../lib/lang");
      var useragent = acequire("../lib/useragent");
      var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
      var CHAR_COUNT = 0;
      var FontMetrics = exports.FontMetrics = function (parentEl) {
          this.el = dom.createElement("div");
          this.$setMeasureNodeStyles(this.el.style, true);
          this.$main = dom.createElement("div");
          this.$setMeasureNodeStyles(this.$main.style);
          this.$measureNode = dom.createElement("div");
          this.$setMeasureNodeStyles(this.$measureNode.style);
          this.el.appendChild(this.$main);
          this.el.appendChild(this.$measureNode);
          parentEl.appendChild(this.el);
          if (!CHAR_COUNT)
              this.$testFractionalRect();
          this.$measureNode.innerHTML = lang.stringRepeat("X", CHAR_COUNT);
          this.$characterSize = { width: 0, height: 0 };
          this.checkForSizeChanges();
      };
      (function () {
          oop.implement(this, EventEmitter);
          this.$characterSize = { width: 0, height: 0 };
          this.$testFractionalRect = function () {
              var el = dom.createElement("div");
              this.$setMeasureNodeStyles(el.style);
              el.style.width = "0.2px";
              document.documentElement.appendChild(el);
              var w = el.getBoundingClientRect().width;
              if (w > 0 && w < 1)
                  CHAR_COUNT = 50;
              else
                  CHAR_COUNT = 100;
              el.parentNode.removeChild(el);
          };
          this.$setMeasureNodeStyles = function (style, isRoot) {
              style.width = style.height = "auto";
              style.left = style.top = "0px";
              style.visibility = "hidden";
              style.position = "absolute";
              style.whiteSpace = "pre";
              if (useragent.isIE < 8) {
                  style["font-family"] = "inherit";
              }
              else {
                  style.font = "inherit";
              }
              style.overflow = isRoot ? "hidden" : "visible";
          };
          this.checkForSizeChanges = function () {
              var size = this.$measureSizes();
              if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
                  this.$measureNode.style.fontWeight = "bold";
                  var boldSize = this.$measureSizes();
                  this.$measureNode.style.fontWeight = "";
                  this.$characterSize = size;
                  this.charSizes = Object.create(null);
                  this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
                  this._emit("changeCharacterSize", { data: size });
              }
          };
          this.$pollSizeChanges = function () {
              if (this.$pollSizeChangesTimer)
                  return this.$pollSizeChangesTimer;
              var self = this;
              return this.$pollSizeChangesTimer = setInterval(function () {
                  self.checkForSizeChanges();
              }, 500);
          };
          this.setPolling = function (val) {
              if (val) {
                  this.$pollSizeChanges();
              }
              else if (this.$pollSizeChangesTimer) {
                  clearInterval(this.$pollSizeChangesTimer);
                  this.$pollSizeChangesTimer = 0;
              }
          };
          this.$measureSizes = function () {
              if (CHAR_COUNT === 50) {
                  var rect = null;
                  try {
                      rect = this.$measureNode.getBoundingClientRect();
                  }
                  catch (e) {
                      rect = { width: 0, height: 0 };
                  }
                  var size = {
                      height: rect.height,
                      width: rect.width / CHAR_COUNT
                  };
              }
              else {
                  var size = {
                      height: this.$measureNode.clientHeight,
                      width: this.$measureNode.clientWidth / CHAR_COUNT
                  };
              }
              if (size.width === 0 || size.height === 0)
                  return null;
              return size;
          };
          this.$measureCharWidth = function (ch) {
              this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);
              var rect = this.$main.getBoundingClientRect();
              return rect.width / CHAR_COUNT;
          };
          this.getCharacterWidth = function (ch) {
              var w = this.charSizes[ch];
              if (w === undefined) {
                  w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
              }
              return w;
          };
          this.destroy = function () {
              clearInterval(this.$pollSizeChangesTimer);
              if (this.el && this.el.parentNode)
                  this.el.parentNode.removeChild(this.el);
          };
      }).call(FontMetrics.prototype);
  });
  ace.define("ace/virtual_renderer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/config", "ace/lib/useragent", "ace/layer/gutter", "ace/layer/marker", "ace/layer/text", "ace/layer/cursor", "ace/scrollbar", "ace/scrollbar", "ace/renderloop", "ace/layer/font_metrics", "ace/lib/event_emitter"], function (acequire, exports, module) {
      var oop = acequire("./lib/oop");
      var dom = acequire("./lib/dom");
      var config = acequire("./config");
      var useragent = acequire("./lib/useragent");
      var GutterLayer = acequire("./layer/gutter").Gutter;
      var MarkerLayer = acequire("./layer/marker").Marker;
      var TextLayer = acequire("./layer/text").Text;
      var CursorLayer = acequire("./layer/cursor").Cursor;
      var HScrollBar = acequire("./scrollbar").HScrollBar;
      var VScrollBar = acequire("./scrollbar").VScrollBar;
      var RenderLoop = acequire("./renderloop").RenderLoop;
      var FontMetrics = acequire("./layer/font_metrics").FontMetrics;
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var editorCss = ".ace_editor {\
position: relative;\
overflow: hidden;\
font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\
direction: ltr;\
text-align: left;\
-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\
}\
.ace_scroller {\
position: absolute;\
overflow: hidden;\
top: 0;\
bottom: 0;\
background-color: inherit;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
cursor: text;\
}\
.ace_content {\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
min-width: 100%;\
}\
.ace_dragging .ace_scroller:before{\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
bottom: 0;\
content: '';\
background: rgba(250, 250, 250, 0.01);\
z-index: 1000;\
}\
.ace_dragging.ace_dark .ace_scroller:before{\
background: rgba(0, 0, 0, 0.01);\
}\
.ace_selecting, .ace_selecting * {\
cursor: text !important;\
}\
.ace_gutter {\
position: absolute;\
overflow : hidden;\
width: auto;\
top: 0;\
bottom: 0;\
left: 0;\
cursor: default;\
z-index: 4;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
}\
.ace_gutter-active-line {\
position: absolute;\
left: 0;\
right: 0;\
}\
.ace_scroller.ace_scroll-left {\
box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\
}\
.ace_gutter-cell {\
padding-left: 19px;\
padding-right: 6px;\
background-repeat: no-repeat;\
}\
.ace_gutter-cell.ace_error {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_warning {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\");\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\");\
background-position: 2px center;\
}\
.ace_dark .ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\");\
}\
.ace_scrollbar {\
position: absolute;\
right: 0;\
bottom: 0;\
z-index: 6;\
}\
.ace_scrollbar-inner {\
position: absolute;\
cursor: text;\
left: 0;\
top: 0;\
}\
.ace_scrollbar-v{\
overflow-x: hidden;\
overflow-y: scroll;\
top: 0;\
}\
.ace_scrollbar-h {\
overflow-x: scroll;\
overflow-y: hidden;\
left: 0;\
}\
.ace_print-margin {\
position: absolute;\
height: 100%;\
}\
.ace_text-input {\
position: absolute;\
z-index: 0;\
width: 0.5em;\
height: 1em;\
opacity: 0;\
background: transparent;\
-moz-appearance: none;\
appearance: none;\
border: none;\
resize: none;\
outline: none;\
overflow: hidden;\
font: inherit;\
padding: 0 1px;\
margin: 0 -1px;\
text-indent: -1em;\
-ms-user-select: text;\
-moz-user-select: text;\
-webkit-user-select: text;\
user-select: text;\
white-space: pre!important;\
}\
.ace_text-input.ace_composition {\
background: inherit;\
color: inherit;\
z-index: 1000;\
opacity: 1;\
text-indent: 0;\
}\
.ace_layer {\
z-index: 1;\
position: absolute;\
overflow: hidden;\
word-wrap: normal;\
white-space: pre;\
height: 100%;\
width: 100%;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
pointer-events: none;\
}\
.ace_gutter-layer {\
position: relative;\
width: auto;\
text-align: right;\
pointer-events: auto;\
}\
.ace_text-layer {\
font: inherit !important;\
}\
.ace_cjk {\
display: inline-block;\
text-align: center;\
}\
.ace_cursor-layer {\
z-index: 4;\
}\
.ace_cursor {\
z-index: 4;\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
border-left: 2px solid;\
transform: translatez(0);\
}\
.ace_multiselect .ace_cursor {\
border-left-width: 1px;\
}\
.ace_slim-cursors .ace_cursor {\
border-left-width: 1px;\
}\
.ace_overwrite-cursors .ace_cursor {\
border-left-width: 0;\
border-bottom: 1px solid;\
}\
.ace_hidden-cursors .ace_cursor {\
opacity: 0.2;\
}\
.ace_smooth-blinking .ace_cursor {\
-webkit-transition: opacity 0.18s;\
transition: opacity 0.18s;\
}\
.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\
position: absolute;\
z-index: 3;\
}\
.ace_marker-layer .ace_selection {\
position: absolute;\
z-index: 5;\
}\
.ace_marker-layer .ace_bracket {\
position: absolute;\
z-index: 6;\
}\
.ace_marker-layer .ace_active-line {\
position: absolute;\
z-index: 2;\
}\
.ace_marker-layer .ace_selected-word {\
position: absolute;\
z-index: 4;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
}\
.ace_line .ace_fold {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
display: inline-block;\
height: 11px;\
margin-top: -2px;\
vertical-align: middle;\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\");\
background-repeat: no-repeat, repeat-x;\
background-position: center center, top left;\
color: transparent;\
border: 1px solid black;\
border-radius: 2px;\
cursor: pointer;\
pointer-events: auto;\
}\
.ace_dark .ace_fold {\
}\
.ace_fold:hover{\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\");\
}\
.ace_tooltip {\
background-color: #FFF;\
background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));\
background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\
border: 1px solid gray;\
border-radius: 1px;\
box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\
color: black;\
max-width: 100%;\
padding: 3px 4px;\
position: fixed;\
z-index: 999999;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
cursor: default;\
white-space: pre;\
word-wrap: break-word;\
line-height: normal;\
font-style: normal;\
font-weight: normal;\
letter-spacing: normal;\
pointer-events: none;\
}\
.ace_folding-enabled > .ace_gutter-cell {\
padding-right: 13px;\
}\
.ace_fold-widget {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
margin: 0 -12px 0 1px;\
display: none;\
width: 11px;\
vertical-align: top;\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: center;\
border-radius: 3px;\
border: 1px solid transparent;\
cursor: pointer;\
}\
.ace_folding-enabled .ace_fold-widget {\
display: inline-block;   \
}\
.ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\");\
}\
.ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\");\
}\
.ace_fold-widget:hover {\
border: 1px solid rgba(0, 0, 0, 0.3);\
background-color: rgba(255, 255, 255, 0.2);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
}\
.ace_fold-widget:active {\
border: 1px solid rgba(0, 0, 0, 0.4);\
background-color: rgba(0, 0, 0, 0.05);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
}\
.ace_dark .ace_fold-widget {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\
}\
.ace_dark .ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget:hover {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
background-color: rgba(255, 255, 255, 0.1);\
}\
.ace_dark .ace_fold-widget:active {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
}\
.ace_fold-widget.ace_invalid {\
background-color: #FFB4B4;\
border-color: #DE5555;\
}\
.ace_fade-fold-widgets .ace_fold-widget {\
-webkit-transition: opacity 0.4s ease 0.05s;\
transition: opacity 0.4s ease 0.05s;\
opacity: 0;\
}\
.ace_fade-fold-widgets:hover .ace_fold-widget {\
-webkit-transition: opacity 0.05s ease 0.05s;\
transition: opacity 0.05s ease 0.05s;\
opacity:1;\
}\
.ace_underline {\
text-decoration: underline;\
}\
.ace_bold {\
font-weight: bold;\
}\
.ace_nobold .ace_bold {\
font-weight: normal;\
}\
.ace_italic {\
font-style: italic;\
}\
.ace_error-marker {\
background-color: rgba(255, 0, 0,0.2);\
position: absolute;\
z-index: 9;\
}\
.ace_highlight-marker {\
background-color: rgba(255, 255, 0,0.2);\
position: absolute;\
z-index: 8;\
}\
.ace_br1 {border-top-left-radius    : 3px;}\
.ace_br2 {border-top-right-radius   : 3px;}\
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\
.ace_br4 {border-bottom-right-radius: 3px;}\
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\
.ace_br8 {border-bottom-left-radius : 3px;}\
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\
.ace_text-input-ios {\
position: absolute !important;\
top: -100000px !important;\
left: -100000px !important;\
}\
";
      dom.importCssString(editorCss, "ace_editor.css");
      var VirtualRenderer = function (container, theme) {
          var _self = this;
          this.container = container || dom.createElement("div");
          this.$keepTextAreaAtCursor = !useragent.isOldIE;
          dom.addCssClass(this.container, "ace_editor");
          this.setTheme(theme);
          this.$gutter = dom.createElement("div");
          this.$gutter.className = "ace_gutter";
          this.container.appendChild(this.$gutter);
          this.$gutter.setAttribute("aria-hidden", true);
          this.scroller = dom.createElement("div");
          this.scroller.className = "ace_scroller";
          this.container.appendChild(this.scroller);
          this.content = dom.createElement("div");
          this.content.className = "ace_content";
          this.scroller.appendChild(this.content);
          this.$gutterLayer = new GutterLayer(this.$gutter);
          this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));
          this.$markerBack = new MarkerLayer(this.content);
          var textLayer = this.$textLayer = new TextLayer(this.content);
          this.canvas = textLayer.element;
          this.$markerFront = new MarkerLayer(this.content);
          this.$cursorLayer = new CursorLayer(this.content);
          this.$horizScroll = false;
          this.$vScroll = false;
          this.scrollBar =
              this.scrollBarV = new VScrollBar(this.container, this);
          this.scrollBarH = new HScrollBar(this.container, this);
          this.scrollBarV.addEventListener("scroll", function (e) {
              if (!_self.$scrollAnimation)
                  _self.session.setScrollTop(e.data - _self.scrollMargin.top);
          });
          this.scrollBarH.addEventListener("scroll", function (e) {
              if (!_self.$scrollAnimation)
                  _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
          });
          this.scrollTop = 0;
          this.scrollLeft = 0;
          this.cursorPos = {
              row: 0,
              column: 0
          };
          this.$fontMetrics = new FontMetrics(this.container);
          this.$textLayer.$setFontMetrics(this.$fontMetrics);
          this.$textLayer.addEventListener("changeCharacterSize", function (e) {
              _self.updateCharacterSize();
              _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
              _self._signal("changeCharacterSize", e);
          });
          this.$size = {
              width: 0,
              height: 0,
              scrollerHeight: 0,
              scrollerWidth: 0,
              $dirty: true
          };
          this.layerConfig = {
              width: 1,
              padding: 0,
              firstRow: 0,
              firstRowScreen: 0,
              lastRow: 0,
              lineHeight: 0,
              characterWidth: 0,
              minHeight: 1,
              maxHeight: 1,
              offset: 0,
              height: 1,
              gutterOffset: 1
          };
          this.scrollMargin = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0,
              v: 0,
              h: 0
          };
          this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
          this.$loop.schedule(this.CHANGE_FULL);
          this.updateCharacterSize();
          this.setPadding(4);
          config.resetOptions(this);
          config._emit("renderer", this);
      };
      (function () {
          this.CHANGE_CURSOR = 1;
          this.CHANGE_MARKER = 2;
          this.CHANGE_GUTTER = 4;
          this.CHANGE_SCROLL = 8;
          this.CHANGE_LINES = 16;
          this.CHANGE_TEXT = 32;
          this.CHANGE_SIZE = 64;
          this.CHANGE_MARKER_BACK = 128;
          this.CHANGE_MARKER_FRONT = 256;
          this.CHANGE_FULL = 512;
          this.CHANGE_H_SCROLL = 1024;
          oop.implement(this, EventEmitter);
          this.updateCharacterSize = function () {
              if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
                  this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
                  this.setStyle("ace_nobold", !this.$allowBoldFonts);
              }
              this.layerConfig.characterWidth =
                  this.characterWidth = this.$textLayer.getCharacterWidth();
              this.layerConfig.lineHeight =
                  this.lineHeight = this.$textLayer.getLineHeight();
              this.$updatePrintMargin();
          };
          this.setSession = function (session) {
              if (this.session)
                  this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
              this.session = session;
              if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
                  session.setScrollTop(-this.scrollMargin.top);
              this.$cursorLayer.setSession(session);
              this.$markerBack.setSession(session);
              this.$markerFront.setSession(session);
              this.$gutterLayer.setSession(session);
              this.$textLayer.setSession(session);
              if (!session)
                  return;
              this.$loop.schedule(this.CHANGE_FULL);
              this.session.$setFontMetrics(this.$fontMetrics);
              this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
              this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
              this.onChangeNewLineMode();
              this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
          };
          this.updateLines = function (firstRow, lastRow, force) {
              if (lastRow === undefined)
                  lastRow = Infinity;
              if (!this.$changedLines) {
                  this.$changedLines = {
                      firstRow: firstRow,
                      lastRow: lastRow
                  };
              }
              else {
                  if (this.$changedLines.firstRow > firstRow)
                      this.$changedLines.firstRow = firstRow;
                  if (this.$changedLines.lastRow < lastRow)
                      this.$changedLines.lastRow = lastRow;
              }
              if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
                  if (force)
                      this.$changedLines.lastRow = this.layerConfig.lastRow;
                  else
                      return;
              }
              if (this.$changedLines.firstRow > this.layerConfig.lastRow)
                  return;
              this.$loop.schedule(this.CHANGE_LINES);
          };
          this.onChangeNewLineMode = function () {
              this.$loop.schedule(this.CHANGE_TEXT);
              this.$textLayer.$updateEolChar();
              this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
          };
          this.onChangeTabSize = function () {
              this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
              this.$textLayer.onChangeTabSize();
          };
          this.updateText = function () {
              this.$loop.schedule(this.CHANGE_TEXT);
          };
          this.updateFull = function (force) {
              if (force)
                  this.$renderChanges(this.CHANGE_FULL, true);
              else
                  this.$loop.schedule(this.CHANGE_FULL);
          };
          this.updateFontSize = function () {
              this.$textLayer.checkForSizeChanges();
          };
          this.$changes = 0;
          this.$updateSizeAsync = function () {
              if (this.$loop.pending)
                  this.$size.$dirty = true;
              else
                  this.onResize();
          };
          this.onResize = function (force, gutterWidth, width, height) {
              if (this.resizing > 2)
                  return;
              else if (this.resizing > 0)
                  this.resizing++;
              else
                  this.resizing = force ? 1 : 0;
              var el = this.container;
              if (!height)
                  height = el.clientHeight || el.scrollHeight;
              if (!width)
                  width = el.clientWidth || el.scrollWidth;
              var changes = this.$updateCachedSize(force, gutterWidth, width, height);
              if (!this.$size.scrollerHeight || (!width && !height))
                  return this.resizing = 0;
              if (force)
                  this.$gutterLayer.$padding = null;
              if (force)
                  this.$renderChanges(changes | this.$changes, true);
              else
                  this.$loop.schedule(changes | this.$changes);
              if (this.resizing)
                  this.resizing = 0;
              this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
          };
          this.$updateCachedSize = function (force, gutterWidth, width, height) {
              height -= (this.$extraHeight || 0);
              var changes = 0;
              var size = this.$size;
              var oldSize = {
                  width: size.width,
                  height: size.height,
                  scrollerHeight: size.scrollerHeight,
                  scrollerWidth: size.scrollerWidth
              };
              if (height && (force || size.height != height)) {
                  size.height = height;
                  changes |= this.CHANGE_SIZE;
                  size.scrollerHeight = size.height;
                  if (this.$horizScroll)
                      size.scrollerHeight -= this.scrollBarH.getHeight();
                  this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
                  changes = changes | this.CHANGE_SCROLL;
              }
              if (width && (force || size.width != width)) {
                  changes |= this.CHANGE_SIZE;
                  size.width = width;
                  if (gutterWidth == null)
                      gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
                  this.gutterWidth = gutterWidth;
                  this.scrollBarH.element.style.left =
                      this.scroller.style.left = gutterWidth + "px";
                  size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());
                  this.scrollBarH.element.style.right =
                      this.scroller.style.right = this.scrollBarV.getWidth() + "px";
                  this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";
                  if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force)
                      changes |= this.CHANGE_FULL;
              }
              size.$dirty = !width || !height;
              if (changes)
                  this._signal("resize", oldSize);
              return changes;
          };
          this.onGutterResize = function () {
              var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
              if (gutterWidth != this.gutterWidth)
                  this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
              if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
                  this.$loop.schedule(this.CHANGE_FULL);
              }
              else if (this.$size.$dirty) {
                  this.$loop.schedule(this.CHANGE_FULL);
              }
              else {
                  this.$computeLayerConfig();
                  this.$loop.schedule(this.CHANGE_MARKER);
              }
          };
          this.adjustWrapLimit = function () {
              var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
              var limit = Math.floor(availableWidth / this.characterWidth);
              return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
          };
          this.setAnimatedScroll = function (shouldAnimate) {
              this.setOption("animatedScroll", shouldAnimate);
          };
          this.getAnimatedScroll = function () {
              return this.$animatedScroll;
          };
          this.setShowInvisibles = function (showInvisibles) {
              this.setOption("showInvisibles", showInvisibles);
              this.session.$bidiHandler.setShowInvisibles(showInvisibles);
          };
          this.getShowInvisibles = function () {
              return this.getOption("showInvisibles");
          };
          this.getDisplayIndentGuides = function () {
              return this.getOption("displayIndentGuides");
          };
          this.setDisplayIndentGuides = function (display) {
              this.setOption("displayIndentGuides", display);
          };
          this.setShowPrintMargin = function (showPrintMargin) {
              this.setOption("showPrintMargin", showPrintMargin);
          };
          this.getShowPrintMargin = function () {
              return this.getOption("showPrintMargin");
          };
          this.setPrintMarginColumn = function (showPrintMargin) {
              this.setOption("printMarginColumn", showPrintMargin);
          };
          this.getPrintMarginColumn = function () {
              return this.getOption("printMarginColumn");
          };
          this.getShowGutter = function () {
              return this.getOption("showGutter");
          };
          this.setShowGutter = function (show) {
              return this.setOption("showGutter", show);
          };
          this.getFadeFoldWidgets = function () {
              return this.getOption("fadeFoldWidgets");
          };
          this.setFadeFoldWidgets = function (show) {
              this.setOption("fadeFoldWidgets", show);
          };
          this.setHighlightGutterLine = function (shouldHighlight) {
              this.setOption("highlightGutterLine", shouldHighlight);
          };
          this.getHighlightGutterLine = function () {
              return this.getOption("highlightGutterLine");
          };
          this.$updateGutterLineHighlight = function () {
              var pos = this.$cursorLayer.$pixelPos;
              var height = this.layerConfig.lineHeight;
              if (this.session.getUseWrapMode()) {
                  var cursor = this.session.selection.getCursor();
                  cursor.column = 0;
                  pos = this.$cursorLayer.getPixelPosition(cursor, true);
                  height *= this.session.getRowLength(cursor.row);
              }
              this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
              this.$gutterLineHighlight.style.height = height + "px";
          };
          this.$updatePrintMargin = function () {
              if (!this.$showPrintMargin && !this.$printMarginEl)
                  return;
              if (!this.$printMarginEl) {
                  var containerEl = dom.createElement("div");
                  containerEl.className = "ace_layer ace_print-margin-layer";
                  this.$printMarginEl = dom.createElement("div");
                  this.$printMarginEl.className = "ace_print-margin";
                  containerEl.appendChild(this.$printMarginEl);
                  this.content.insertBefore(containerEl, this.content.firstChild);
              }
              var style = this.$printMarginEl.style;
              style.left = ((this.characterWidth * this.$printMarginColumn) + this.$padding) + "px";
              style.visibility = this.$showPrintMargin ? "visible" : "hidden";
              if (this.session && this.session.$wrap == -1)
                  this.adjustWrapLimit();
          };
          this.getContainerElement = function () {
              return this.container;
          };
          this.getMouseEventTarget = function () {
              return this.scroller;
          };
          this.getTextAreaContainer = function () {
              return this.container;
          };
          this.$moveTextAreaToCursor = function () {
              if (!this.$keepTextAreaAtCursor)
                  return;
              var config = this.layerConfig;
              var posTop = this.$cursorLayer.$pixelPos.top;
              var posLeft = this.$cursorLayer.$pixelPos.left;
              posTop -= config.offset;
              var style = this.textarea.style;
              var h = this.lineHeight;
              if (posTop < 0 || posTop > config.height - h) {
                  style.top = style.left = "0";
                  return;
              }
              var w = this.characterWidth;
              if (this.$composition) {
                  var val = this.textarea.value.replace(/^\x01+/, "");
                  w *= (this.session.$getStringScreenWidth(val)[0] + 2);
                  h += 2;
              }
              posLeft -= this.scrollLeft;
              if (posLeft > this.$size.scrollerWidth - w)
                  posLeft = this.$size.scrollerWidth - w;
              posLeft += this.gutterWidth;
              style.height = h + "px";
              style.width = w + "px";
              style.left = Math.min(posLeft, this.$size.scrollerWidth - w) + "px";
              style.top = Math.min(posTop, this.$size.height - h) + "px";
          };
          this.getFirstVisibleRow = function () {
              return this.layerConfig.firstRow;
          };
          this.getFirstFullyVisibleRow = function () {
              return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
          };
          this.getLastFullyVisibleRow = function () {
              var config = this.layerConfig;
              var lastRow = config.lastRow;
              var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
              if (top - this.session.getScrollTop() > config.height - config.lineHeight)
                  return lastRow - 1;
              return lastRow;
          };
          this.getLastVisibleRow = function () {
              return this.layerConfig.lastRow;
          };
          this.$padding = null;
          this.setPadding = function (padding) {
              this.$padding = padding;
              this.$textLayer.setPadding(padding);
              this.$cursorLayer.setPadding(padding);
              this.$markerFront.setPadding(padding);
              this.$markerBack.setPadding(padding);
              this.$loop.schedule(this.CHANGE_FULL);
              this.$updatePrintMargin();
          };
          this.setScrollMargin = function (top, bottom, left, right) {
              var sm = this.scrollMargin;
              sm.top = top | 0;
              sm.bottom = bottom | 0;
              sm.right = right | 0;
              sm.left = left | 0;
              sm.v = sm.top + sm.bottom;
              sm.h = sm.left + sm.right;
              if (sm.top && this.scrollTop <= 0 && this.session)
                  this.session.setScrollTop(-sm.top);
              this.updateFull();
          };
          this.getHScrollBarAlwaysVisible = function () {
              return this.$hScrollBarAlwaysVisible;
          };
          this.setHScrollBarAlwaysVisible = function (alwaysVisible) {
              this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
          };
          this.getVScrollBarAlwaysVisible = function () {
              return this.$vScrollBarAlwaysVisible;
          };
          this.setVScrollBarAlwaysVisible = function (alwaysVisible) {
              this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
          };
          this.$updateScrollBarV = function () {
              var scrollHeight = this.layerConfig.maxHeight;
              var scrollerHeight = this.$size.scrollerHeight;
              if (!this.$maxLines && this.$scrollPastEnd) {
                  scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
                  if (this.scrollTop > scrollHeight - scrollerHeight) {
                      scrollHeight = this.scrollTop + scrollerHeight;
                      this.scrollBarV.scrollTop = null;
                  }
              }
              this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
              this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
          };
          this.$updateScrollBarH = function () {
              this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
              this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
          };
          this.$frozen = false;
          this.freeze = function () {
              this.$frozen = true;
          };
          this.unfreeze = function () {
              this.$frozen = false;
          };
          this.$renderChanges = function (changes, force) {
              if (this.$changes) {
                  changes |= this.$changes;
                  this.$changes = 0;
              }
              if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
                  this.$changes |= changes;
                  return;
              }
              if (this.$size.$dirty) {
                  this.$changes |= changes;
                  return this.onResize(true);
              }
              if (!this.lineHeight) {
                  this.$textLayer.checkForSizeChanges();
              }
              this._signal("beforeRender");
              if (this.session && this.session.$bidiHandler)
                  this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);
              var config = this.layerConfig;
              if (changes & this.CHANGE_FULL ||
                  changes & this.CHANGE_SIZE ||
                  changes & this.CHANGE_TEXT ||
                  changes & this.CHANGE_LINES ||
                  changes & this.CHANGE_SCROLL ||
                  changes & this.CHANGE_H_SCROLL) {
                  changes |= this.$computeLayerConfig();
                  if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
                      var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
                      if (st > 0) {
                          this.scrollTop = st;
                          changes = changes | this.CHANGE_SCROLL;
                          changes |= this.$computeLayerConfig();
                      }
                  }
                  config = this.layerConfig;
                  this.$updateScrollBarV();
                  if (changes & this.CHANGE_H_SCROLL)
                      this.$updateScrollBarH();
                  this.$gutterLayer.element.style.marginTop = (-config.offset) + "px";
                  this.content.style.marginTop = (-config.offset) + "px";
                  this.content.style.width = config.width + 2 * this.$padding + "px";
                  this.content.style.height = config.minHeight + "px";
              }
              if (changes & this.CHANGE_H_SCROLL) {
                  this.content.style.marginLeft = -this.scrollLeft + "px";
                  this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
              }
              if (changes & this.CHANGE_FULL) {
                  this.$textLayer.update(config);
                  if (this.$showGutter)
                      this.$gutterLayer.update(config);
                  this.$markerBack.update(config);
                  this.$markerFront.update(config);
                  this.$cursorLayer.update(config);
                  this.$moveTextAreaToCursor();
                  this.$highlightGutterLine && this.$updateGutterLineHighlight();
                  this._signal("afterRender");
                  return;
              }
              if (changes & this.CHANGE_SCROLL) {
                  if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
                      this.$textLayer.update(config);
                  else
                      this.$textLayer.scrollLines(config);
                  if (this.$showGutter)
                      this.$gutterLayer.update(config);
                  this.$markerBack.update(config);
                  this.$markerFront.update(config);
                  this.$cursorLayer.update(config);
                  this.$highlightGutterLine && this.$updateGutterLineHighlight();
                  this.$moveTextAreaToCursor();
                  this._signal("afterRender");
                  return;
              }
              if (changes & this.CHANGE_TEXT) {
                  this.$textLayer.update(config);
                  if (this.$showGutter)
                      this.$gutterLayer.update(config);
              }
              else if (changes & this.CHANGE_LINES) {
                  if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
                      this.$gutterLayer.update(config);
              }
              else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
                  if (this.$showGutter)
                      this.$gutterLayer.update(config);
              }
              if (changes & this.CHANGE_CURSOR) {
                  this.$cursorLayer.update(config);
                  this.$moveTextAreaToCursor();
                  this.$highlightGutterLine && this.$updateGutterLineHighlight();
              }
              if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
                  this.$markerFront.update(config);
              }
              if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
                  this.$markerBack.update(config);
              }
              this._signal("afterRender");
          };
          this.$autosize = function () {
              var height = this.session.getScreenLength() * this.lineHeight;
              var maxHeight = this.$maxLines * this.lineHeight;
              var desiredHeight = Math.min(maxHeight, Math.max((this.$minLines || 1) * this.lineHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
              if (this.$horizScroll)
                  desiredHeight += this.scrollBarH.getHeight();
              if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
                  desiredHeight = this.$maxPixelHeight;
              var vScroll = height > maxHeight;
              if (desiredHeight != this.desiredHeight ||
                  this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
                  if (vScroll != this.$vScroll) {
                      this.$vScroll = vScroll;
                      this.scrollBarV.setVisible(vScroll);
                  }
                  var w = this.container.clientWidth;
                  this.container.style.height = desiredHeight + "px";
                  this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
                  this.desiredHeight = desiredHeight;
                  this._signal("autosize");
              }
          };
          this.$computeLayerConfig = function () {
              var session = this.session;
              var size = this.$size;
              var hideScrollbars = size.height <= 2 * this.lineHeight;
              var screenLines = this.session.getScreenLength();
              var maxHeight = screenLines * this.lineHeight;
              var longestLine = this.$getLongestLine();
              var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible ||
                  size.scrollerWidth - longestLine - 2 * this.$padding < 0);
              var hScrollChanged = this.$horizScroll !== horizScroll;
              if (hScrollChanged) {
                  this.$horizScroll = horizScroll;
                  this.scrollBarH.setVisible(horizScroll);
              }
              var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
              if (this.$maxLines && this.lineHeight > 1)
                  this.$autosize();
              var offset = this.scrollTop % this.lineHeight;
              var minHeight = size.scrollerHeight + this.lineHeight;
              var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd
                  ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd
                  : 0;
              maxHeight += scrollPastEnd;
              var sm = this.scrollMargin;
              this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));
              this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
              var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible ||
                  size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
              var vScrollChanged = vScrollBefore !== vScroll;
              if (vScrollChanged) {
                  this.$vScroll = vScroll;
                  this.scrollBarV.setVisible(vScroll);
              }
              var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
              var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
              var lastRow = firstRow + lineCount;
              var firstRowScreen, firstRowHeight;
              var lineHeight = this.lineHeight;
              firstRow = session.screenToDocumentRow(firstRow, 0);
              var foldLine = session.getFoldLine(firstRow);
              if (foldLine) {
                  firstRow = foldLine.start.row;
              }
              firstRowScreen = session.documentToScreenRow(firstRow, 0);
              firstRowHeight = session.getRowLength(firstRow) * lineHeight;
              lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
              minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight +
                  firstRowHeight;
              offset = this.scrollTop - firstRowScreen * lineHeight;
              var changes = 0;
              if (this.layerConfig.width != longestLine)
                  changes = this.CHANGE_H_SCROLL;
              if (hScrollChanged || vScrollChanged) {
                  changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
                  this._signal("scrollbarVisibilityChanged");
                  if (vScrollChanged)
                      longestLine = this.$getLongestLine();
              }
              this.layerConfig = {
                  width: longestLine,
                  padding: this.$padding,
                  firstRow: firstRow,
                  firstRowScreen: firstRowScreen,
                  lastRow: lastRow,
                  lineHeight: lineHeight,
                  characterWidth: this.characterWidth,
                  minHeight: minHeight,
                  maxHeight: maxHeight,
                  offset: offset,
                  gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
                  height: this.$size.scrollerHeight
              };
              return changes;
          };
          this.$updateLines = function () {
              if (!this.$changedLines)
                  return;
              var firstRow = this.$changedLines.firstRow;
              var lastRow = this.$changedLines.lastRow;
              this.$changedLines = null;
              var layerConfig = this.layerConfig;
              if (firstRow > layerConfig.lastRow + 1) {
                  return;
              }
              if (lastRow < layerConfig.firstRow) {
                  return;
              }
              if (lastRow === Infinity) {
                  if (this.$showGutter)
                      this.$gutterLayer.update(layerConfig);
                  this.$textLayer.update(layerConfig);
                  return;
              }
              this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
              return true;
          };
          this.$getLongestLine = function () {
              var charCount = this.session.getScreenWidth();
              if (this.showInvisibles && !this.session.$useWrapMode)
                  charCount += 1;
              return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
          };
          this.updateFrontMarkers = function () {
              this.$markerFront.setMarkers(this.session.getMarkers(true));
              this.$loop.schedule(this.CHANGE_MARKER_FRONT);
          };
          this.updateBackMarkers = function () {
              this.$markerBack.setMarkers(this.session.getMarkers());
              this.$loop.schedule(this.CHANGE_MARKER_BACK);
          };
          this.addGutterDecoration = function (row, className) {
              this.$gutterLayer.addGutterDecoration(row, className);
          };
          this.removeGutterDecoration = function (row, className) {
              this.$gutterLayer.removeGutterDecoration(row, className);
          };
          this.updateBreakpoints = function (rows) {
              this.$loop.schedule(this.CHANGE_GUTTER);
          };
          this.setAnnotations = function (annotations) {
              this.$gutterLayer.setAnnotations(annotations);
              this.$loop.schedule(this.CHANGE_GUTTER);
          };
          this.updateCursor = function () {
              this.$loop.schedule(this.CHANGE_CURSOR);
          };
          this.hideCursor = function () {
              this.$cursorLayer.hideCursor();
          };
          this.showCursor = function () {
              this.$cursorLayer.showCursor();
          };
          this.scrollSelectionIntoView = function (anchor, lead, offset) {
              this.scrollCursorIntoView(anchor, offset);
              this.scrollCursorIntoView(lead, offset);
          };
          this.scrollCursorIntoView = function (cursor, offset, $viewMargin) {
              if (this.$size.scrollerHeight === 0)
                  return;
              var pos = this.$cursorLayer.getPixelPosition(cursor);
              var left = pos.left;
              var top = pos.top;
              var topMargin = $viewMargin && $viewMargin.top || 0;
              var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
              var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
              if (scrollTop + topMargin > top) {
                  if (offset && scrollTop + topMargin > top + this.lineHeight)
                      top -= offset * this.$size.scrollerHeight;
                  if (top === 0)
                      top = -this.scrollMargin.top;
                  this.session.setScrollTop(top);
              }
              else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
                  if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top - this.lineHeight)
                      top += offset * this.$size.scrollerHeight;
                  this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
              }
              var scrollLeft = this.scrollLeft;
              if (scrollLeft > left) {
                  if (left < this.$padding + 2 * this.layerConfig.characterWidth)
                      left = -this.scrollMargin.left;
                  this.session.setScrollLeft(left);
              }
              else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
                  this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
              }
              else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
                  this.session.setScrollLeft(0);
              }
          };
          this.getScrollTop = function () {
              return this.session.getScrollTop();
          };
          this.getScrollLeft = function () {
              return this.session.getScrollLeft();
          };
          this.getScrollTopRow = function () {
              return this.scrollTop / this.lineHeight;
          };
          this.getScrollBottomRow = function () {
              return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
          };
          this.scrollToRow = function (row) {
              this.session.setScrollTop(row * this.lineHeight);
          };
          this.alignCursor = function (cursor, alignment) {
              if (typeof cursor == "number")
                  cursor = { row: cursor, column: 0 };
              var pos = this.$cursorLayer.getPixelPosition(cursor);
              var h = this.$size.scrollerHeight - this.lineHeight;
              var offset = pos.top - h * (alignment || 0);
              this.session.setScrollTop(offset);
              return offset;
          };
          this.STEPS = 8;
          this.$calcSteps = function (fromValue, toValue) {
              var i = 0;
              var l = this.STEPS;
              var steps = [];
              var func = function (t, x_min, dx) {
                  return dx * (Math.pow(t - 1, 3) + 1) + x_min;
              };
              for (i = 0; i < l; ++i)
                  steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
              return steps;
          };
          this.scrollToLine = function (line, center, animate, callback) {
              var pos = this.$cursorLayer.getPixelPosition({ row: line, column: 0 });
              var offset = pos.top;
              if (center)
                  offset -= this.$size.scrollerHeight / 2;
              var initialScroll = this.scrollTop;
              this.session.setScrollTop(offset);
              if (animate !== false)
                  this.animateScrolling(initialScroll, callback);
          };
          this.animateScrolling = function (fromValue, callback) {
              var toValue = this.scrollTop;
              if (!this.$animatedScroll)
                  return;
              var _self = this;
              if (fromValue == toValue)
                  return;
              if (this.$scrollAnimation) {
                  var oldSteps = this.$scrollAnimation.steps;
                  if (oldSteps.length) {
                      fromValue = oldSteps[0];
                      if (fromValue == toValue)
                          return;
                  }
              }
              var steps = _self.$calcSteps(fromValue, toValue);
              this.$scrollAnimation = { from: fromValue, to: toValue, steps: steps };
              clearInterval(this.$timer);
              _self.session.setScrollTop(steps.shift());
              _self.session.$scrollTop = toValue;
              this.$timer = setInterval(function () {
                  if (steps.length) {
                      _self.session.setScrollTop(steps.shift());
                      _self.session.$scrollTop = toValue;
                  }
                  else if (toValue != null) {
                      _self.session.$scrollTop = -1;
                      _self.session.setScrollTop(toValue);
                      toValue = null;
                  }
                  else {
                      _self.$timer = clearInterval(_self.$timer);
                      _self.$scrollAnimation = null;
                      callback && callback();
                  }
              }, 10);
          };
          this.scrollToY = function (scrollTop) {
              if (this.scrollTop !== scrollTop) {
                  this.$loop.schedule(this.CHANGE_SCROLL);
                  this.scrollTop = scrollTop;
              }
          };
          this.scrollToX = function (scrollLeft) {
              if (this.scrollLeft !== scrollLeft)
                  this.scrollLeft = scrollLeft;
              this.$loop.schedule(this.CHANGE_H_SCROLL);
          };
          this.scrollTo = function (x, y) {
              this.session.setScrollTop(y);
              this.session.setScrollLeft(y);
          };
          this.scrollBy = function (deltaX, deltaY) {
              deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
              deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
          };
          this.isScrollableBy = function (deltaX, deltaY) {
              if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
                  return true;
              if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight
                  - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
                  return true;
              if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
                  return true;
              if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth
                  - this.layerConfig.width < -1 + this.scrollMargin.right)
                  return true;
          };
          this.pixelToScreenCoordinates = function (x, y) {
              var canvasPos = this.scroller.getBoundingClientRect();
              var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
              var offset = offsetX / this.characterWidth;
              var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
              var col = Math.round(offset);
              return { row: row, column: col, side: offset - col > 0 ? 1 : -1, offsetX: offsetX };
          };
          this.screenToTextCoordinates = function (x, y) {
              var canvasPos = this.scroller.getBoundingClientRect();
              var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
              var col = Math.round(offsetX / this.characterWidth);
              var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;
              return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
          };
          this.textToScreenCoordinates = function (row, column) {
              var canvasPos = this.scroller.getBoundingClientRect();
              var pos = this.session.documentToScreenPosition(row, column);
              var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row)
                  ? this.session.$bidiHandler.getPosLeft(pos.column)
                  : Math.round(pos.column * this.characterWidth));
              var y = pos.row * this.lineHeight;
              return {
                  pageX: canvasPos.left + x - this.scrollLeft,
                  pageY: canvasPos.top + y - this.scrollTop
              };
          };
          this.visualizeFocus = function () {
              dom.addCssClass(this.container, "ace_focus");
          };
          this.visualizeBlur = function () {
              dom.removeCssClass(this.container, "ace_focus");
          };
          this.showComposition = function (position) {
              if (!this.$composition)
                  this.$composition = {
                      keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
                      cssText: this.textarea.style.cssText
                  };
              this.$keepTextAreaAtCursor = true;
              dom.addCssClass(this.textarea, "ace_composition");
              this.textarea.style.cssText = "";
              this.$moveTextAreaToCursor();
          };
          this.setCompositionText = function (text) {
              this.$moveTextAreaToCursor();
          };
          this.hideComposition = function () {
              if (!this.$composition)
                  return;
              dom.removeCssClass(this.textarea, "ace_composition");
              this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
              this.textarea.style.cssText = this.$composition.cssText;
              this.$composition = null;
          };
          this.setTheme = function (theme, cb) {
              var _self = this;
              this.$themeId = theme;
              _self._dispatchEvent('themeChange', { theme: theme });
              if (!theme || typeof theme == "string") {
                  var moduleName = theme || this.$options.theme.initialValue;
                  config.loadModule(["theme", moduleName], afterLoad);
              }
              else {
                  afterLoad(theme);
              }
              function afterLoad(module) {
                  if (_self.$themeId != theme)
                      return cb && cb();
                  if (!module || !module.cssClass)
                      throw new Error("couldn't load module " + theme + " or it didn't call define");
                  dom.importCssString(module.cssText, module.cssClass, _self.container.ownerDocument);
                  if (_self.theme)
                      dom.removeCssClass(_self.container, _self.theme.cssClass);
                  var padding = "padding" in module ? module.padding
                      : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
                  if (_self.$padding && padding != _self.$padding)
                      _self.setPadding(padding);
                  _self.$theme = module.cssClass;
                  _self.theme = module;
                  dom.addCssClass(_self.container, module.cssClass);
                  dom.setCssClass(_self.container, "ace_dark", module.isDark);
                  if (_self.$size) {
                      _self.$size.width = 0;
                      _self.$updateSizeAsync();
                  }
                  _self._dispatchEvent('themeLoaded', { theme: module });
                  cb && cb();
              }
          };
          this.getTheme = function () {
              return this.$themeId;
          };
          this.setStyle = function (style, include) {
              dom.setCssClass(this.container, style, include !== false);
          };
          this.unsetStyle = function (style) {
              dom.removeCssClass(this.container, style);
          };
          this.setCursorStyle = function (style) {
              if (this.scroller.style.cursor != style)
                  this.scroller.style.cursor = style;
          };
          this.setMouseCursor = function (cursorStyle) {
              this.scroller.style.cursor = cursorStyle;
          };
          this.destroy = function () {
              this.$textLayer.destroy();
              this.$cursorLayer.destroy();
          };
      }).call(VirtualRenderer.prototype);
      config.defineOptions(VirtualRenderer.prototype, "renderer", {
          animatedScroll: { initialValue: false },
          showInvisibles: {
              set: function (value) {
                  if (this.$textLayer.setShowInvisibles(value))
                      this.$loop.schedule(this.CHANGE_TEXT);
              },
              initialValue: false
          },
          showPrintMargin: {
              set: function () { this.$updatePrintMargin(); },
              initialValue: true
          },
          printMarginColumn: {
              set: function () { this.$updatePrintMargin(); },
              initialValue: 80
          },
          printMargin: {
              set: function (val) {
                  if (typeof val == "number")
                      this.$printMarginColumn = val;
                  this.$showPrintMargin = !!val;
                  this.$updatePrintMargin();
              },
              get: function () {
                  return this.$showPrintMargin && this.$printMarginColumn;
              }
          },
          showGutter: {
              set: function (show) {
                  this.$gutter.style.display = show ? "block" : "none";
                  this.$loop.schedule(this.CHANGE_FULL);
                  this.onGutterResize();
              },
              initialValue: true
          },
          fadeFoldWidgets: {
              set: function (show) {
                  dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
              },
              initialValue: false
          },
          showFoldWidgets: {
              set: function (show) { this.$gutterLayer.setShowFoldWidgets(show); },
              initialValue: true
          },
          showLineNumbers: {
              set: function (show) {
                  this.$gutterLayer.setShowLineNumbers(show);
                  this.$loop.schedule(this.CHANGE_GUTTER);
              },
              initialValue: true
          },
          displayIndentGuides: {
              set: function (show) {
                  if (this.$textLayer.setDisplayIndentGuides(show))
                      this.$loop.schedule(this.CHANGE_TEXT);
              },
              initialValue: true
          },
          highlightGutterLine: {
              set: function (shouldHighlight) {
                  if (!this.$gutterLineHighlight) {
                      this.$gutterLineHighlight = dom.createElement("div");
                      this.$gutterLineHighlight.className = "ace_gutter-active-line";
                      this.$gutter.appendChild(this.$gutterLineHighlight);
                      return;
                  }
                  this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
                  if (this.$cursorLayer.$pixelPos)
                      this.$updateGutterLineHighlight();
              },
              initialValue: false,
              value: true
          },
          hScrollBarAlwaysVisible: {
              set: function (val) {
                  if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
                      this.$loop.schedule(this.CHANGE_SCROLL);
              },
              initialValue: false
          },
          vScrollBarAlwaysVisible: {
              set: function (val) {
                  if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
                      this.$loop.schedule(this.CHANGE_SCROLL);
              },
              initialValue: false
          },
          fontSize: {
              set: function (size) {
                  if (typeof size == "number")
                      size = size + "px";
                  this.container.style.fontSize = size;
                  this.updateFontSize();
              },
              initialValue: 12
          },
          fontFamily: {
              set: function (name) {
                  this.container.style.fontFamily = name;
                  this.updateFontSize();
              }
          },
          maxLines: {
              set: function (val) {
                  this.updateFull();
              }
          },
          minLines: {
              set: function (val) {
                  this.updateFull();
              }
          },
          maxPixelHeight: {
              set: function (val) {
                  this.updateFull();
              },
              initialValue: 0
          },
          scrollPastEnd: {
              set: function (val) {
                  val = +val || 0;
                  if (this.$scrollPastEnd == val)
                      return;
                  this.$scrollPastEnd = val;
                  this.$loop.schedule(this.CHANGE_SCROLL);
              },
              initialValue: 0,
              handlesSet: true
          },
          fixedWidthGutter: {
              set: function (val) {
                  this.$gutterLayer.$fixedWidth = !!val;
                  this.$loop.schedule(this.CHANGE_GUTTER);
              }
          },
          theme: {
              set: function (val) { this.setTheme(val); },
              get: function () { return this.$themeId || this.theme; },
              initialValue: "./theme/textmate",
              handlesSet: true
          }
      });
      exports.VirtualRenderer = VirtualRenderer;
  });
  ace.define("ace/worker/worker_client", ["require", "exports", "module", "ace/lib/oop", "ace/lib/net", "ace/lib/event_emitter", "ace/config"], function (acequire, exports, module) {
      var oop = acequire("../lib/oop");
      var net = acequire("../lib/net");
      var EventEmitter = acequire("../lib/event_emitter").EventEmitter;
      var config = acequire("../config");
      function $workerBlob(workerUrl, mod) {
          var script = mod.src;
          "importScripts('" + net.qualifyURL(workerUrl) + "');";
          try {
              return new Blob([script], { "type": "application/javascript" });
          }
          catch (e) { // Backwards-compatibility
              var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
              var blobBuilder = new BlobBuilder();
              blobBuilder.append(script);
              return blobBuilder.getBlob("application/javascript");
          }
      }
      function createWorker(workerUrl, mod) {
          var blob = $workerBlob(workerUrl, mod);
          var URL = window.URL || window.webkitURL;
          var blobURL = URL.createObjectURL(blob);
          return new Worker(blobURL);
      }
      var WorkerClient = function (topLevelNamespaces, mod, classname, workerUrl, importScripts) {
          this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
          this.changeListener = this.changeListener.bind(this);
          this.onMessage = this.onMessage.bind(this);
          if (acequire.nameToUrl && !acequire.toUrl)
              acequire.toUrl = acequire.nameToUrl;
          if (config.get("packaged") || !acequire.toUrl) {
              workerUrl = workerUrl || config.moduleUrl(mod.id, "worker");
          }
          else {
              var normalizePath = this.$normalizePath;
              workerUrl = workerUrl || normalizePath(acequire.toUrl("ace/worker/worker.js", null, "_"));
              var tlns = {};
              topLevelNamespaces.forEach(function (ns) {
                  tlns[ns] = normalizePath(acequire.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
              });
          }
          this.$worker = createWorker(workerUrl, mod);
          if (importScripts) {
              this.send("importScripts", importScripts);
          }
          this.$worker.postMessage({
              init: true,
              tlns: tlns,
              module: mod.id,
              classname: classname
          });
          this.callbackId = 1;
          this.callbacks = {};
          this.$worker.onmessage = this.onMessage;
      };
      (function () {
          oop.implement(this, EventEmitter);
          this.onMessage = function (e) {
              var msg = e.data;
              switch (msg.type) {
                  case "event":
                      this._signal(msg.name, { data: msg.data });
                      break;
                  case "call":
                      var callback = this.callbacks[msg.id];
                      if (callback) {
                          callback(msg.data);
                          delete this.callbacks[msg.id];
                      }
                      break;
                  case "error":
                      this.reportError(msg.data);
                      break;
                  case "log":
                      window.console && console.log && console.log.apply(console, msg.data);
                      break;
              }
          };
          this.reportError = function (err) {
              window.console && console.error && console.error(err);
          };
          this.$normalizePath = function (path) {
              return net.qualifyURL(path);
          };
          this.terminate = function () {
              this._signal("terminate", {});
              this.deltaQueue = null;
              this.$worker.terminate();
              this.$worker = null;
              if (this.$doc)
                  this.$doc.off("change", this.changeListener);
              this.$doc = null;
          };
          this.send = function (cmd, args) {
              this.$worker.postMessage({ command: cmd, args: args });
          };
          this.call = function (cmd, args, callback) {
              if (callback) {
                  var id = this.callbackId++;
                  this.callbacks[id] = callback;
                  args.push(id);
              }
              this.send(cmd, args);
          };
          this.emit = function (event, data) {
              try {
                  this.$worker.postMessage({ event: event, data: { data: data.data } });
              }
              catch (ex) {
                  console.error(ex.stack);
              }
          };
          this.attachToDocument = function (doc) {
              if (this.$doc)
                  this.terminate();
              this.$doc = doc;
              this.call("setValue", [doc.getValue()]);
              doc.on("change", this.changeListener);
          };
          this.changeListener = function (delta) {
              if (!this.deltaQueue) {
                  this.deltaQueue = [];
                  setTimeout(this.$sendDeltaQueue, 0);
              }
              if (delta.action == "insert")
                  this.deltaQueue.push(delta.start, delta.lines);
              else
                  this.deltaQueue.push(delta.start, delta.end);
          };
          this.$sendDeltaQueue = function () {
              var q = this.deltaQueue;
              if (!q)
                  return;
              this.deltaQueue = null;
              if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
                  this.call("setValue", [this.$doc.getValue()]);
              }
              else
                  this.emit("change", { data: q });
          };
      }).call(WorkerClient.prototype);
      var UIWorkerClient = function (topLevelNamespaces, mod, classname) {
          this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
          this.changeListener = this.changeListener.bind(this);
          this.callbackId = 1;
          this.callbacks = {};
          this.messageBuffer = [];
          var main = null;
          var emitSync = false;
          var sender = Object.create(EventEmitter);
          var _self = this;
          this.$worker = {};
          this.$worker.terminate = function () { };
          this.$worker.postMessage = function (e) {
              _self.messageBuffer.push(e);
              if (main) {
                  if (emitSync)
                      setTimeout(processNext);
                  else
                      processNext();
              }
          };
          this.setEmitSync = function (val) { emitSync = val; };
          var processNext = function () {
              var msg = _self.messageBuffer.shift();
              if (msg.command)
                  main[msg.command].apply(main, msg.args);
              else if (msg.event)
                  sender._signal(msg.event, msg.data);
          };
          sender.postMessage = function (msg) {
              _self.onMessage({ data: msg });
          };
          sender.callback = function (data, callbackId) {
              this.postMessage({ type: "call", id: callbackId, data: data });
          };
          sender.emit = function (name, data) {
              this.postMessage({ type: "event", name: name, data: data });
          };
          config.loadModule(["worker", mod], function (Main) {
              main = new Main[classname](sender);
              while (_self.messageBuffer.length)
                  processNext();
          });
      };
      UIWorkerClient.prototype = WorkerClient.prototype;
      exports.UIWorkerClient = UIWorkerClient;
      exports.WorkerClient = WorkerClient;
      exports.createWorker = createWorker;
  });
  ace.define("ace/placeholder", ["require", "exports", "module", "ace/range", "ace/lib/event_emitter", "ace/lib/oop"], function (acequire, exports, module) {
      var Range = acequire("./range").Range;
      var EventEmitter = acequire("./lib/event_emitter").EventEmitter;
      var oop = acequire("./lib/oop");
      var PlaceHolder = function (session, length, pos, others, mainClass, othersClass) {
          var _self = this;
          this.length = length;
          this.session = session;
          this.doc = session.getDocument();
          this.mainClass = mainClass;
          this.othersClass = othersClass;
          this.$onUpdate = this.onUpdate.bind(this);
          this.doc.on("change", this.$onUpdate);
          this.$others = others;
          this.$onCursorChange = function () {
              setTimeout(function () {
                  _self.onCursorChange();
              });
          };
          this.$pos = pos;
          var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || { length: -1 };
          this.$undoStackDepth = undoStack.length;
          this.setup();
          session.selection.on("changeCursor", this.$onCursorChange);
      };
      (function () {
          oop.implement(this, EventEmitter);
          this.setup = function () {
              var _self = this;
              var doc = this.doc;
              var session = this.session;
              this.selectionBefore = session.selection.toJSON();
              if (session.selection.inMultiSelectMode)
                  session.selection.toSingleRange();
              this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
              var pos = this.pos;
              pos.$insertRight = true;
              pos.detach();
              pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
              this.others = [];
              this.$others.forEach(function (other) {
                  var anchor = doc.createAnchor(other.row, other.column);
                  anchor.$insertRight = true;
                  anchor.detach();
                  _self.others.push(anchor);
              });
              session.setUndoSelect(false);
          };
          this.showOtherMarkers = function () {
              if (this.othersActive)
                  return;
              var session = this.session;
              var _self = this;
              this.othersActive = true;
              this.others.forEach(function (anchor) {
                  anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
              });
          };
          this.hideOtherMarkers = function () {
              if (!this.othersActive)
                  return;
              this.othersActive = false;
              for (var i = 0; i < this.others.length; i++) {
                  this.session.removeMarker(this.others[i].markerId);
              }
          };
          this.onUpdate = function (delta) {
              if (this.$updating)
                  return this.updateAnchors(delta);
              var range = delta;
              if (range.start.row !== range.end.row)
                  return;
              if (range.start.row !== this.pos.row)
                  return;
              this.$updating = true;
              var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
              var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
              var distanceFromStart = range.start.column - this.pos.column;
              this.updateAnchors(delta);
              if (inMainRange)
                  this.length += lengthDiff;
              if (inMainRange && !this.session.$fromUndo) {
                  if (delta.action === 'insert') {
                      for (var i = this.others.length - 1; i >= 0; i--) {
                          var otherPos = this.others[i];
                          var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                          this.doc.insertMergedLines(newPos, delta.lines);
                      }
                  }
                  else if (delta.action === 'remove') {
                      for (var i = this.others.length - 1; i >= 0; i--) {
                          var otherPos = this.others[i];
                          var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                          this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                      }
                  }
              }
              this.$updating = false;
              this.updateMarkers();
          };
          this.updateAnchors = function (delta) {
              this.pos.onChange(delta);
              for (var i = this.others.length; i--;)
                  this.others[i].onChange(delta);
              this.updateMarkers();
          };
          this.updateMarkers = function () {
              if (this.$updating)
                  return;
              var _self = this;
              var session = this.session;
              var updateMarker = function (pos, className) {
                  session.removeMarker(pos.markerId);
                  pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);
              };
              updateMarker(this.pos, this.mainClass);
              for (var i = this.others.length; i--;)
                  updateMarker(this.others[i], this.othersClass);
          };
          this.onCursorChange = function (event) {
              if (this.$updating || !this.session)
                  return;
              var pos = this.session.selection.getCursor();
              if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
                  this.showOtherMarkers();
                  this._emit("cursorEnter", event);
              }
              else {
                  this.hideOtherMarkers();
                  this._emit("cursorLeave", event);
              }
          };
          this.detach = function () {
              this.session.removeMarker(this.pos && this.pos.markerId);
              this.hideOtherMarkers();
              this.doc.removeEventListener("change", this.$onUpdate);
              this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
              this.session.setUndoSelect(true);
              this.session = null;
          };
          this.cancel = function () {
              if (this.$undoStackDepth === -1)
                  return;
              var undoManager = this.session.getUndoManager();
              var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
              for (var i = 0; i < undosRequired; i++) {
                  undoManager.undo(true);
              }
              if (this.selectionBefore)
                  this.session.selection.fromJSON(this.selectionBefore);
          };
      }).call(PlaceHolder.prototype);
      exports.PlaceHolder = PlaceHolder;
  });
  ace.define("ace/mouse/multi_select_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function (acequire, exports, module) {
      var event = acequire("../lib/event");
      var useragent = acequire("../lib/useragent");
      function isSamePoint(p1, p2) {
          return p1.row == p2.row && p1.column == p2.column;
      }
      function onMouseDown(e) {
          var ev = e.domEvent;
          var alt = ev.altKey;
          var shift = ev.shiftKey;
          var ctrl = ev.ctrlKey;
          var accel = e.getAccelKey();
          var button = e.getButton();
          if (ctrl && useragent.isMac)
              button = ev.button;
          if (e.editor.inMultiSelectMode && button == 2) {
              e.editor.textInput.onContextMenu(e.domEvent);
              return;
          }
          if (!ctrl && !alt && !accel) {
              if (button === 0 && e.editor.inMultiSelectMode)
                  e.editor.exitMultiSelectMode();
              return;
          }
          if (button !== 0)
              return;
          var editor = e.editor;
          var selection = editor.selection;
          var isMultiSelect = editor.inMultiSelectMode;
          var pos = e.getDocumentPosition();
          var cursor = selection.getCursor();
          var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));
          var mouseX = e.x, mouseY = e.y;
          var onMouseSelection = function (e) {
              mouseX = e.clientX;
              mouseY = e.clientY;
          };
          var session = editor.session;
          var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
          var screenCursor = screenAnchor;
          var selectionMode;
          if (editor.$mouseHandler.$enableJumpToDef) {
              if (ctrl && alt || accel && alt)
                  selectionMode = shift ? "block" : "add";
              else if (alt && editor.$blockSelectEnabled)
                  selectionMode = "block";
          }
          else {
              if (accel && !alt) {
                  selectionMode = "add";
                  if (!isMultiSelect && shift)
                      return;
              }
              else if (alt && editor.$blockSelectEnabled) {
                  selectionMode = "block";
              }
          }
          if (selectionMode && useragent.isMac && ev.ctrlKey) {
              editor.$mouseHandler.cancelContextMenu();
          }
          if (selectionMode == "add") {
              if (!isMultiSelect && inSelection)
                  return; // dragging
              if (!isMultiSelect) {
                  var range = selection.toOrientedRange();
                  editor.addSelectionMarker(range);
              }
              var oldRange = selection.rangeList.rangeAtPoint(pos);
              editor.$blockScrolling++;
              editor.inVirtualSelectionMode = true;
              if (shift) {
                  oldRange = null;
                  range = selection.ranges[0] || range;
                  editor.removeSelectionMarker(range);
              }
              editor.once("mouseup", function () {
                  var tmpSel = selection.toOrientedRange();
                  if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
                      selection.substractPoint(tmpSel.cursor);
                  else {
                      if (shift) {
                          selection.substractPoint(range.cursor);
                      }
                      else if (range) {
                          editor.removeSelectionMarker(range);
                          selection.addRange(range);
                      }
                      selection.addRange(tmpSel);
                  }
                  editor.$blockScrolling--;
                  editor.inVirtualSelectionMode = false;
              });
          }
          else if (selectionMode == "block") {
              e.stop();
              editor.inVirtualSelectionMode = true;
              var initialRange;
              var rectSel = [];
              var blockSelect = function () {
                  var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
                  var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);
                  if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
                      return;
                  screenCursor = newCursor;
                  editor.$blockScrolling++;
                  editor.selection.moveToPosition(cursor);
                  editor.renderer.scrollCursorIntoView();
                  editor.removeSelectionMarkers(rectSel);
                  rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
                  if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
                      rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
                  rectSel.forEach(editor.addSelectionMarker, editor);
                  editor.updateSelectionMarkers();
                  editor.$blockScrolling--;
              };
              editor.$blockScrolling++;
              if (isMultiSelect && !accel) {
                  selection.toSingleRange();
              }
              else if (!isMultiSelect && accel) {
                  initialRange = selection.toOrientedRange();
                  editor.addSelectionMarker(initialRange);
              }
              if (shift)
                  screenAnchor = session.documentToScreenPosition(selection.lead);
              else
                  selection.moveToPosition(pos);
              editor.$blockScrolling--;
              screenCursor = { row: -1, column: -1 };
              var onMouseSelectionEnd = function (e) {
                  clearInterval(timerId);
                  editor.removeSelectionMarkers(rectSel);
                  if (!rectSel.length)
                      rectSel = [selection.toOrientedRange()];
                  editor.$blockScrolling++;
                  if (initialRange) {
                      editor.removeSelectionMarker(initialRange);
                      selection.toSingleRange(initialRange);
                  }
                  for (var i = 0; i < rectSel.length; i++)
                      selection.addRange(rectSel[i]);
                  editor.inVirtualSelectionMode = false;
                  editor.$mouseHandler.$clickSelection = null;
                  editor.$blockScrolling--;
              };
              var onSelectionInterval = blockSelect;
              event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
              var timerId = setInterval(function () { onSelectionInterval(); }, 20);
              return e.preventDefault();
          }
      }
      exports.onMouseDown = onMouseDown;
  });
  ace.define("ace/commands/multi_select_commands", ["require", "exports", "module", "ace/keyboard/hash_handler"], function (acequire, exports, module) {
      exports.defaultCommands = [{
              name: "addCursorAbove",
              exec: function (editor) { editor.selectMoreLines(-1); },
              bindKey: { win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up" },
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "addCursorBelow",
              exec: function (editor) { editor.selectMoreLines(1); },
              bindKey: { win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down" },
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "addCursorAboveSkipCurrent",
              exec: function (editor) { editor.selectMoreLines(-1, true); },
              bindKey: { win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up" },
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "addCursorBelowSkipCurrent",
              exec: function (editor) { editor.selectMoreLines(1, true); },
              bindKey: { win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down" },
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "selectMoreBefore",
              exec: function (editor) { editor.selectMore(-1); },
              bindKey: { win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left" },
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "selectMoreAfter",
              exec: function (editor) { editor.selectMore(1); },
              bindKey: { win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right" },
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "selectNextBefore",
              exec: function (editor) { editor.selectMore(-1, true); },
              bindKey: { win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left" },
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "selectNextAfter",
              exec: function (editor) { editor.selectMore(1, true); },
              bindKey: { win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right" },
              scrollIntoView: "cursor",
              readOnly: true
          }, {
              name: "splitIntoLines",
              exec: function (editor) { editor.multiSelect.splitIntoLines(); },
              bindKey: { win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L" },
              readOnly: true
          }, {
              name: "alignCursors",
              exec: function (editor) { editor.alignCursors(); },
              bindKey: { win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A" },
              scrollIntoView: "cursor"
          }, {
              name: "findAll",
              exec: function (editor) { editor.findAll(); },
              bindKey: { win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G" },
              scrollIntoView: "cursor",
              readOnly: true
          }];
      exports.multiSelectCommands = [{
              name: "singleSelection",
              bindKey: "esc",
              exec: function (editor) { editor.exitMultiSelectMode(); },
              scrollIntoView: "cursor",
              readOnly: true,
              isAvailable: function (editor) { return editor && editor.inMultiSelectMode; }
          }];
      var HashHandler = acequire("../keyboard/hash_handler").HashHandler;
      exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);
  });
  ace.define("ace/multi_select", ["require", "exports", "module", "ace/range_list", "ace/range", "ace/selection", "ace/mouse/multi_select_handler", "ace/lib/event", "ace/lib/lang", "ace/commands/multi_select_commands", "ace/search", "ace/edit_session", "ace/editor", "ace/config"], function (acequire, exports, module) {
      var RangeList = acequire("./range_list").RangeList;
      var Range = acequire("./range").Range;
      var Selection = acequire("./selection").Selection;
      var onMouseDown = acequire("./mouse/multi_select_handler").onMouseDown;
      var event = acequire("./lib/event");
      var lang = acequire("./lib/lang");
      var commands = acequire("./commands/multi_select_commands");
      exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
      var Search = acequire("./search").Search;
      var search = new Search();
      function find(session, needle, dir) {
          search.$options.wrap = true;
          search.$options.needle = needle;
          search.$options.backwards = dir == -1;
          return search.find(session);
      }
      var EditSession = acequire("./edit_session").EditSession;
      (function () {
          this.getSelectionMarkers = function () {
              return this.$selectionMarkers;
          };
      }).call(EditSession.prototype);
      (function () {
          this.ranges = null;
          this.rangeList = null;
          this.addRange = function (range, $blockChangeEvents) {
              if (!range)
                  return;
              if (!this.inMultiSelectMode && this.rangeCount === 0) {
                  var oldRange = this.toOrientedRange();
                  this.rangeList.add(oldRange);
                  this.rangeList.add(range);
                  if (this.rangeList.ranges.length != 2) {
                      this.rangeList.removeAll();
                      return $blockChangeEvents || this.fromOrientedRange(range);
                  }
                  this.rangeList.removeAll();
                  this.rangeList.add(oldRange);
                  this.$onAddRange(oldRange);
              }
              if (!range.cursor)
                  range.cursor = range.end;
              var removed = this.rangeList.add(range);
              this.$onAddRange(range);
              if (removed.length)
                  this.$onRemoveRange(removed);
              if (this.rangeCount > 1 && !this.inMultiSelectMode) {
                  this._signal("multiSelect");
                  this.inMultiSelectMode = true;
                  this.session.$undoSelect = false;
                  this.rangeList.attach(this.session);
              }
              return $blockChangeEvents || this.fromOrientedRange(range);
          };
          this.toSingleRange = function (range) {
              range = range || this.ranges[0];
              var removed = this.rangeList.removeAll();
              if (removed.length)
                  this.$onRemoveRange(removed);
              range && this.fromOrientedRange(range);
          };
          this.substractPoint = function (pos) {
              var removed = this.rangeList.substractPoint(pos);
              if (removed) {
                  this.$onRemoveRange(removed);
                  return removed[0];
              }
          };
          this.mergeOverlappingRanges = function () {
              var removed = this.rangeList.merge();
              if (removed.length)
                  this.$onRemoveRange(removed);
              else if (this.ranges[0])
                  this.fromOrientedRange(this.ranges[0]);
          };
          this.$onAddRange = function (range) {
              this.rangeCount = this.rangeList.ranges.length;
              this.ranges.unshift(range);
              this._signal("addRange", { range: range });
          };
          this.$onRemoveRange = function (removed) {
              this.rangeCount = this.rangeList.ranges.length;
              if (this.rangeCount == 1 && this.inMultiSelectMode) {
                  var lastRange = this.rangeList.ranges.pop();
                  removed.push(lastRange);
                  this.rangeCount = 0;
              }
              for (var i = removed.length; i--;) {
                  var index = this.ranges.indexOf(removed[i]);
                  this.ranges.splice(index, 1);
              }
              this._signal("removeRange", { ranges: removed });
              if (this.rangeCount === 0 && this.inMultiSelectMode) {
                  this.inMultiSelectMode = false;
                  this._signal("singleSelect");
                  this.session.$undoSelect = true;
                  this.rangeList.detach(this.session);
              }
              lastRange = lastRange || this.ranges[0];
              if (lastRange && !lastRange.isEqual(this.getRange()))
                  this.fromOrientedRange(lastRange);
          };
          this.$initRangeList = function () {
              if (this.rangeList)
                  return;
              this.rangeList = new RangeList();
              this.ranges = [];
              this.rangeCount = 0;
          };
          this.getAllRanges = function () {
              return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
          };
          this.splitIntoLines = function () {
              if (this.rangeCount > 1) {
                  var ranges = this.rangeList.ranges;
                  var lastRange = ranges[ranges.length - 1];
                  var range = Range.fromPoints(ranges[0].start, lastRange.end);
                  this.toSingleRange();
                  this.setSelectionRange(range, lastRange.cursor == lastRange.start);
              }
              else {
                  var range = this.getRange();
                  var isBackwards = this.isBackwards();
                  var startRow = range.start.row;
                  var endRow = range.end.row;
                  if (startRow == endRow) {
                      if (isBackwards)
                          var start = range.end, end = range.start;
                      else
                          var start = range.start, end = range.end;
                      this.addRange(Range.fromPoints(end, end));
                      this.addRange(Range.fromPoints(start, start));
                      return;
                  }
                  var rectSel = [];
                  var r = this.getLineRange(startRow, true);
                  r.start.column = range.start.column;
                  rectSel.push(r);
                  for (var i = startRow + 1; i < endRow; i++)
                      rectSel.push(this.getLineRange(i, true));
                  r = this.getLineRange(endRow, true);
                  r.end.column = range.end.column;
                  rectSel.push(r);
                  rectSel.forEach(this.addRange, this);
              }
          };
          this.toggleBlockSelection = function () {
              if (this.rangeCount > 1) {
                  var ranges = this.rangeList.ranges;
                  var lastRange = ranges[ranges.length - 1];
                  var range = Range.fromPoints(ranges[0].start, lastRange.end);
                  this.toSingleRange();
                  this.setSelectionRange(range, lastRange.cursor == lastRange.start);
              }
              else {
                  var cursor = this.session.documentToScreenPosition(this.selectionLead);
                  var anchor = this.session.documentToScreenPosition(this.selectionAnchor);
                  var rectSel = this.rectangularRangeBlock(cursor, anchor);
                  rectSel.forEach(this.addRange, this);
              }
          };
          this.rectangularRangeBlock = function (screenCursor, screenAnchor, includeEmptyLines) {
              var rectSel = [];
              var xBackwards = screenCursor.column < screenAnchor.column;
              if (xBackwards) {
                  var startColumn = screenCursor.column;
                  var endColumn = screenAnchor.column;
                  var startOffsetX = screenCursor.offsetX;
                  var endOffsetX = screenAnchor.offsetX;
              }
              else {
                  var startColumn = screenAnchor.column;
                  var endColumn = screenCursor.column;
                  var startOffsetX = screenAnchor.offsetX;
                  var endOffsetX = screenCursor.offsetX;
              }
              var yBackwards = screenCursor.row < screenAnchor.row;
              if (yBackwards) {
                  var startRow = screenCursor.row;
                  var endRow = screenAnchor.row;
              }
              else {
                  var startRow = screenAnchor.row;
                  var endRow = screenCursor.row;
              }
              if (startColumn < 0)
                  startColumn = 0;
              if (startRow < 0)
                  startRow = 0;
              if (startRow == endRow)
                  includeEmptyLines = true;
              for (var row = startRow; row <= endRow; row++) {
                  var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn, startOffsetX), this.session.screenToDocumentPosition(row, endColumn, endOffsetX));
                  if (range.isEmpty()) {
                      if (docEnd && isSamePoint(range.end, docEnd))
                          break;
                      var docEnd = range.end;
                  }
                  range.cursor = xBackwards ? range.start : range.end;
                  rectSel.push(range);
              }
              if (yBackwards)
                  rectSel.reverse();
              if (!includeEmptyLines) {
                  var end = rectSel.length - 1;
                  while (rectSel[end].isEmpty() && end > 0)
                      end--;
                  if (end > 0) {
                      var start = 0;
                      while (rectSel[start].isEmpty())
                          start++;
                  }
                  for (var i = end; i >= start; i--) {
                      if (rectSel[i].isEmpty())
                          rectSel.splice(i, 1);
                  }
              }
              return rectSel;
          };
      }).call(Selection.prototype);
      var Editor = acequire("./editor").Editor;
      (function () {
          this.updateSelectionMarkers = function () {
              this.renderer.updateCursor();
              this.renderer.updateBackMarkers();
          };
          this.addSelectionMarker = function (orientedRange) {
              if (!orientedRange.cursor)
                  orientedRange.cursor = orientedRange.end;
              var style = this.getSelectionStyle();
              orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);
              this.session.$selectionMarkers.push(orientedRange);
              this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
              return orientedRange;
          };
          this.removeSelectionMarker = function (range) {
              if (!range.marker)
                  return;
              this.session.removeMarker(range.marker);
              var index = this.session.$selectionMarkers.indexOf(range);
              if (index != -1)
                  this.session.$selectionMarkers.splice(index, 1);
              this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
          };
          this.removeSelectionMarkers = function (ranges) {
              var markerList = this.session.$selectionMarkers;
              for (var i = ranges.length; i--;) {
                  var range = ranges[i];
                  if (!range.marker)
                      continue;
                  this.session.removeMarker(range.marker);
                  var index = markerList.indexOf(range);
                  if (index != -1)
                      markerList.splice(index, 1);
              }
              this.session.selectionMarkerCount = markerList.length;
          };
          this.$onAddRange = function (e) {
              this.addSelectionMarker(e.range);
              this.renderer.updateCursor();
              this.renderer.updateBackMarkers();
          };
          this.$onRemoveRange = function (e) {
              this.removeSelectionMarkers(e.ranges);
              this.renderer.updateCursor();
              this.renderer.updateBackMarkers();
          };
          this.$onMultiSelect = function (e) {
              if (this.inMultiSelectMode)
                  return;
              this.inMultiSelectMode = true;
              this.setStyle("ace_multiselect");
              this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
              this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);
              this.renderer.updateCursor();
              this.renderer.updateBackMarkers();
          };
          this.$onSingleSelect = function (e) {
              if (this.session.multiSelect.inVirtualMode)
                  return;
              this.inMultiSelectMode = false;
              this.unsetStyle("ace_multiselect");
              this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
              this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
              this.renderer.updateCursor();
              this.renderer.updateBackMarkers();
              this._emit("changeSelection");
          };
          this.$onMultiSelectExec = function (e) {
              var command = e.command;
              var editor = e.editor;
              if (!editor.multiSelect)
                  return;
              if (!command.multiSelectAction) {
                  var result = command.exec(editor, e.args || {});
                  editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
                  editor.multiSelect.mergeOverlappingRanges();
              }
              else if (command.multiSelectAction == "forEach") {
                  result = editor.forEachSelection(command, e.args);
              }
              else if (command.multiSelectAction == "forEachLine") {
                  result = editor.forEachSelection(command, e.args, true);
              }
              else if (command.multiSelectAction == "single") {
                  editor.exitMultiSelectMode();
                  result = command.exec(editor, e.args || {});
              }
              else {
                  result = command.multiSelectAction(editor, e.args || {});
              }
              return result;
          };
          this.forEachSelection = function (cmd, args, options) {
              if (this.inVirtualSelectionMode)
                  return;
              var keepOrder = options && options.keepOrder;
              var $byLines = options == true || options && options.$byLines;
              var session = this.session;
              var selection = this.selection;
              var rangeList = selection.rangeList;
              var ranges = (keepOrder ? selection : rangeList).ranges;
              var result;
              if (!ranges.length)
                  return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
              var reg = selection._eventRegistry;
              selection._eventRegistry = {};
              var tmpSel = new Selection(session);
              this.inVirtualSelectionMode = true;
              for (var i = ranges.length; i--;) {
                  if ($byLines) {
                      while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
                          i--;
                  }
                  tmpSel.fromOrientedRange(ranges[i]);
                  tmpSel.index = i;
                  this.selection = session.selection = tmpSel;
                  var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
                  if (!result && cmdResult !== undefined)
                      result = cmdResult;
                  tmpSel.toOrientedRange(ranges[i]);
              }
              tmpSel.detach();
              this.selection = session.selection = selection;
              this.inVirtualSelectionMode = false;
              selection._eventRegistry = reg;
              selection.mergeOverlappingRanges();
              var anim = this.renderer.$scrollAnimation;
              this.onCursorChange();
              this.onSelectionChange();
              if (anim && anim.from == anim.to)
                  this.renderer.animateScrolling(anim.from);
              return result;
          };
          this.exitMultiSelectMode = function () {
              if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
                  return;
              this.multiSelect.toSingleRange();
          };
          this.getSelectedText = function () {
              var text = "";
              if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
                  var ranges = this.multiSelect.rangeList.ranges;
                  var buf = [];
                  for (var i = 0; i < ranges.length; i++) {
                      buf.push(this.session.getTextRange(ranges[i]));
                  }
                  var nl = this.session.getDocument().getNewLineCharacter();
                  text = buf.join(nl);
                  if (text.length == (buf.length - 1) * nl.length)
                      text = "";
              }
              else if (!this.selection.isEmpty()) {
                  text = this.session.getTextRange(this.getSelectionRange());
              }
              return text;
          };
          this.$checkMultiselectChange = function (e, anchor) {
              if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
                  var range = this.multiSelect.ranges[0];
                  if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
                      return;
                  var pos = anchor == this.multiSelect.anchor
                      ? range.cursor == range.start ? range.end : range.start
                      : range.cursor;
                  if (pos.row != anchor.row
                      || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
                      this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
              }
          };
          this.findAll = function (needle, options, additive) {
              options = options || {};
              options.needle = needle || options.needle;
              if (options.needle == undefined) {
                  var range = this.selection.isEmpty()
                      ? this.selection.getWordRange()
                      : this.selection.getRange();
                  options.needle = this.session.getTextRange(range);
              }
              this.$search.set(options);
              var ranges = this.$search.findAll(this.session);
              if (!ranges.length)
                  return 0;
              this.$blockScrolling += 1;
              var selection = this.multiSelect;
              if (!additive)
                  selection.toSingleRange(ranges[0]);
              for (var i = ranges.length; i--;)
                  selection.addRange(ranges[i], true);
              if (range && selection.rangeList.rangeAtPoint(range.start))
                  selection.addRange(range, true);
              this.$blockScrolling -= 1;
              return ranges.length;
          };
          this.selectMoreLines = function (dir, skip) {
              var range = this.selection.toOrientedRange();
              var isBackwards = range.cursor == range.end;
              var screenLead = this.session.documentToScreenPosition(range.cursor);
              if (this.selection.$desiredColumn)
                  screenLead.column = this.selection.$desiredColumn;
              var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
              if (!range.isEmpty()) {
                  var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
                  var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
              }
              else {
                  var anchor = lead;
              }
              if (isBackwards) {
                  var newRange = Range.fromPoints(lead, anchor);
                  newRange.cursor = newRange.start;
              }
              else {
                  var newRange = Range.fromPoints(anchor, lead);
                  newRange.cursor = newRange.end;
              }
              newRange.desiredColumn = screenLead.column;
              if (!this.selection.inMultiSelectMode) {
                  this.selection.addRange(range);
              }
              else {
                  if (skip)
                      var toRemove = range.cursor;
              }
              this.selection.addRange(newRange);
              if (toRemove)
                  this.selection.substractPoint(toRemove);
          };
          this.transposeSelections = function (dir) {
              var session = this.session;
              var sel = session.multiSelect;
              var all = sel.ranges;
              for (var i = all.length; i--;) {
                  var range = all[i];
                  if (range.isEmpty()) {
                      var tmp = session.getWordRange(range.start.row, range.start.column);
                      range.start.row = tmp.start.row;
                      range.start.column = tmp.start.column;
                      range.end.row = tmp.end.row;
                      range.end.column = tmp.end.column;
                  }
              }
              sel.mergeOverlappingRanges();
              var words = [];
              for (var i = all.length; i--;) {
                  var range = all[i];
                  words.unshift(session.getTextRange(range));
              }
              if (dir < 0)
                  words.unshift(words.pop());
              else
                  words.push(words.shift());
              for (var i = all.length; i--;) {
                  var range = all[i];
                  var tmp = range.clone();
                  session.replace(range, words[i]);
                  range.start.row = tmp.start.row;
                  range.start.column = tmp.start.column;
              }
          };
          this.selectMore = function (dir, skip, stopAtFirst) {
              var session = this.session;
              var sel = session.multiSelect;
              var range = sel.toOrientedRange();
              if (range.isEmpty()) {
                  range = session.getWordRange(range.start.row, range.start.column);
                  range.cursor = dir == -1 ? range.start : range.end;
                  this.multiSelect.addRange(range);
                  if (stopAtFirst)
                      return;
              }
              var needle = session.getTextRange(range);
              var newRange = find(session, needle, dir);
              if (newRange) {
                  newRange.cursor = dir == -1 ? newRange.start : newRange.end;
                  this.$blockScrolling += 1;
                  this.session.unfold(newRange);
                  this.multiSelect.addRange(newRange);
                  this.$blockScrolling -= 1;
                  this.renderer.scrollCursorIntoView(null, 0.5);
              }
              if (skip)
                  this.multiSelect.substractPoint(range.cursor);
          };
          this.alignCursors = function () {
              var session = this.session;
              var sel = session.multiSelect;
              var ranges = sel.ranges;
              var row = -1;
              var sameRowRanges = ranges.filter(function (r) {
                  if (r.cursor.row == row)
                      return true;
                  row = r.cursor.row;
              });
              if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
                  var range = this.selection.getRange();
                  var fr = range.start.row, lr = range.end.row;
                  var guessRange = fr == lr;
                  if (guessRange) {
                      var max = this.session.getLength();
                      var line;
                      do {
                          line = this.session.getLine(lr);
                      } while (/[=:]/.test(line) && ++lr < max);
                      do {
                          line = this.session.getLine(fr);
                      } while (/[=:]/.test(line) && --fr > 0);
                      if (fr < 0)
                          fr = 0;
                      if (lr >= max)
                          lr = max - 1;
                  }
                  var lines = this.session.removeFullLines(fr, lr);
                  lines = this.$reAlignText(lines, guessRange);
                  this.session.insert({ row: fr, column: 0 }, lines.join("\n") + "\n");
                  if (!guessRange) {
                      range.start.column = 0;
                      range.end.column = lines[lines.length - 1].length;
                  }
                  this.selection.setRange(range);
              }
              else {
                  sameRowRanges.forEach(function (r) {
                      sel.substractPoint(r.cursor);
                  });
                  var maxCol = 0;
                  var minSpace = Infinity;
                  var spaceOffsets = ranges.map(function (r) {
                      var p = r.cursor;
                      var line = session.getLine(p.row);
                      var spaceOffset = line.substr(p.column).search(/\S/g);
                      if (spaceOffset == -1)
                          spaceOffset = 0;
                      if (p.column > maxCol)
                          maxCol = p.column;
                      if (spaceOffset < minSpace)
                          minSpace = spaceOffset;
                      return spaceOffset;
                  });
                  ranges.forEach(function (r, i) {
                      var p = r.cursor;
                      var l = maxCol - p.column;
                      var d = spaceOffsets[i] - minSpace;
                      if (l > d)
                          session.insert(p, lang.stringRepeat(" ", l - d));
                      else
                          session.remove(new Range(p.row, p.column, p.row, p.column - l + d));
                      r.start.column = r.end.column = maxCol;
                      r.start.row = r.end.row = p.row;
                      r.cursor = r.end;
                  });
                  sel.fromOrientedRange(ranges[0]);
                  this.renderer.updateCursor();
                  this.renderer.updateBackMarkers();
              }
          };
          this.$reAlignText = function (lines, forceLeft) {
              var isLeftAligned = true, isRightAligned = true;
              var startW, textW, endW;
              return lines.map(function (line) {
                  var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
                  if (!m)
                      return [line];
                  if (startW == null) {
                      startW = m[1].length;
                      textW = m[2].length;
                      endW = m[3].length;
                      return m;
                  }
                  if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
                      isRightAligned = false;
                  if (startW != m[1].length)
                      isLeftAligned = false;
                  if (startW > m[1].length)
                      startW = m[1].length;
                  if (textW < m[2].length)
                      textW = m[2].length;
                  if (endW > m[3].length)
                      endW = m[3].length;
                  return m;
              }).map(forceLeft ? alignLeft :
                  isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
              function spaces(n) {
                  return lang.stringRepeat(" ", n);
              }
              function alignLeft(m) {
                  return !m[2] ? m[0] : spaces(startW) + m[2]
                      + spaces(textW - m[2].length + endW)
                      + m[4].replace(/^([=:])\s+/, "$1 ");
              }
              function alignRight(m) {
                  return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2]
                      + spaces(endW, " ")
                      + m[4].replace(/^([=:])\s+/, "$1 ");
              }
              function unAlign(m) {
                  return !m[2] ? m[0] : spaces(startW) + m[2]
                      + spaces(endW)
                      + m[4].replace(/^([=:])\s+/, "$1 ");
              }
          };
      }).call(Editor.prototype);
      function isSamePoint(p1, p2) {
          return p1.row == p2.row && p1.column == p2.column;
      }
      exports.onSessionChange = function (e) {
          var session = e.session;
          if (session && !session.multiSelect) {
              session.$selectionMarkers = [];
              session.selection.$initRangeList();
              session.multiSelect = session.selection;
          }
          this.multiSelect = session && session.multiSelect;
          var oldSession = e.oldSession;
          if (oldSession) {
              oldSession.multiSelect.off("addRange", this.$onAddRange);
              oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
              oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
              oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
              oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
              oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
          }
          if (session) {
              session.multiSelect.on("addRange", this.$onAddRange);
              session.multiSelect.on("removeRange", this.$onRemoveRange);
              session.multiSelect.on("multiSelect", this.$onMultiSelect);
              session.multiSelect.on("singleSelect", this.$onSingleSelect);
              session.multiSelect.lead.on("change", this.$checkMultiselectChange);
              session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
          }
          if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
              if (session.selection.inMultiSelectMode)
                  this.$onMultiSelect();
              else
                  this.$onSingleSelect();
          }
      };
      function MultiSelect(editor) {
          if (editor.$multiselectOnSessionChange)
              return;
          editor.$onAddRange = editor.$onAddRange.bind(editor);
          editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
          editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
          editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
          editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
          editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);
          editor.$multiselectOnSessionChange(editor);
          editor.on("changeSession", editor.$multiselectOnSessionChange);
          editor.on("mousedown", onMouseDown);
          editor.commands.addCommands(commands.defaultCommands);
          addAltCursorListeners(editor);
      }
      function addAltCursorListeners(editor) {
          var el = editor.textInput.getElement();
          var altCursor = false;
          event.addListener(el, "keydown", function (e) {
              var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
              if (editor.$blockSelectEnabled && altDown) {
                  if (!altCursor) {
                      editor.renderer.setMouseCursor("crosshair");
                      altCursor = true;
                  }
              }
              else if (altCursor) {
                  reset();
              }
          });
          event.addListener(el, "keyup", reset);
          event.addListener(el, "blur", reset);
          function reset(e) {
              if (altCursor) {
                  editor.renderer.setMouseCursor("");
                  altCursor = false;
              }
          }
      }
      exports.MultiSelect = MultiSelect;
      acequire("./config").defineOptions(Editor.prototype, "editor", {
          enableMultiselect: {
              set: function (val) {
                  MultiSelect(this);
                  if (val) {
                      this.on("changeSession", this.$multiselectOnSessionChange);
                      this.on("mousedown", onMouseDown);
                  }
                  else {
                      this.off("changeSession", this.$multiselectOnSessionChange);
                      this.off("mousedown", onMouseDown);
                  }
              },
              value: true
          },
          enableBlockSelect: {
              set: function (val) {
                  this.$blockSelectEnabled = val;
              },
              value: true
          }
      });
  });
  ace.define("ace/mode/folding/fold_mode", ["require", "exports", "module", "ace/range"], function (acequire, exports, module) {
      var Range = acequire("../../range").Range;
      var FoldMode = exports.FoldMode = function () { };
      (function () {
          this.foldingStartMarker = null;
          this.foldingStopMarker = null;
          this.getFoldWidget = function (session, foldStyle, row) {
              var line = session.getLine(row);
              if (this.foldingStartMarker.test(line))
                  return "start";
              if (foldStyle == "markbeginend"
                  && this.foldingStopMarker
                  && this.foldingStopMarker.test(line))
                  return "end";
              return "";
          };
          this.getFoldWidgetRange = function (session, foldStyle, row) {
              return null;
          };
          this.indentationBlock = function (session, row, column) {
              var re = /\S/;
              var line = session.getLine(row);
              var startLevel = line.search(re);
              if (startLevel == -1)
                  return;
              var startColumn = column || line.length;
              var maxRow = session.getLength();
              var startRow = row;
              var endRow = row;
              while (++row < maxRow) {
                  var level = session.getLine(row).search(re);
                  if (level == -1)
                      continue;
                  if (level <= startLevel)
                      break;
                  endRow = row;
              }
              if (endRow > startRow) {
                  var endColumn = session.getLine(endRow).length;
                  return new Range(startRow, startColumn, endRow, endColumn);
              }
          };
          this.openingBracketBlock = function (session, bracket, row, column, typeRe) {
              var start = { row: row, column: column + 1 };
              var end = session.$findClosingBracket(bracket, start, typeRe);
              if (!end)
                  return;
              var fw = session.foldWidgets[end.row];
              if (fw == null)
                  fw = session.getFoldWidget(end.row);
              if (fw == "start" && end.row > start.row) {
                  end.row--;
                  end.column = session.getLine(end.row).length;
              }
              return Range.fromPoints(start, end);
          };
          this.closingBracketBlock = function (session, bracket, row, column, typeRe) {
              var end = { row: row, column: column };
              var start = session.$findOpeningBracket(bracket, end);
              if (!start)
                  return;
              start.column++;
              end.column--;
              return Range.fromPoints(start, end);
          };
      }).call(FoldMode.prototype);
  });
  ace.define("ace/theme/textmate", ["require", "exports", "module", "ace/lib/dom"], function (acequire, exports, module) {
      exports.isDark = false;
      exports.cssClass = "ace-tm";
      exports.cssText = ".ace-tm .ace_gutter {\
background: #f0f0f0;\
color: #333;\
}\
.ace-tm .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-tm .ace_fold {\
background-color: #6B72E6;\
}\
.ace-tm {\
background-color: #FFFFFF;\
color: black;\
}\
.ace-tm .ace_cursor {\
color: black;\
}\
.ace-tm .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-tm .ace_storage,\
.ace-tm .ace_keyword {\
color: blue;\
}\
.ace-tm .ace_constant {\
color: rgb(197, 6, 11);\
}\
.ace-tm .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-tm .ace_constant.ace_language {\
color: rgb(88, 92, 246);\
}\
.ace-tm .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_invalid {\
background-color: rgba(255, 0, 0, 0.1);\
color: red;\
}\
.ace-tm .ace_support.ace_function {\
color: rgb(60, 76, 114);\
}\
.ace-tm .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_support.ace_type,\
.ace-tm .ace_support.ace_class {\
color: rgb(109, 121, 222);\
}\
.ace-tm .ace_keyword.ace_operator {\
color: rgb(104, 118, 135);\
}\
.ace-tm .ace_string {\
color: rgb(3, 106, 7);\
}\
.ace-tm .ace_comment {\
color: rgb(76, 136, 107);\
}\
.ace-tm .ace_comment.ace_doc {\
color: rgb(0, 102, 255);\
}\
.ace-tm .ace_comment.ace_doc.ace_tag {\
color: rgb(128, 159, 191);\
}\
.ace-tm .ace_constant.ace_numeric {\
color: rgb(0, 0, 205);\
}\
.ace-tm .ace_variable {\
color: rgb(49, 132, 149);\
}\
.ace-tm .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-tm .ace_entity.ace_name.ace_function {\
color: #0000A2;\
}\
.ace-tm .ace_heading {\
color: rgb(12, 7, 255);\
}\
.ace-tm .ace_list {\
color:rgb(185, 6, 144);\
}\
.ace-tm .ace_meta.ace_tag {\
color:rgb(0, 22, 142);\
}\
.ace-tm .ace_string.ace_regex {\
color: rgb(255, 0, 0)\
}\
.ace-tm .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-tm.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px white;\
}\
.ace-tm .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-tm .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-tm .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-tm .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.07);\
}\
.ace-tm .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-tm .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-tm .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}\
";
      var dom = acequire("../lib/dom");
      dom.importCssString(exports.cssText, exports.cssClass);
  });
  ace.define("ace/line_widgets", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/range"], function (acequire, exports, module) {
      var oop = acequire("./lib/oop");
      var dom = acequire("./lib/dom");
      var Range = acequire("./range").Range;
      function LineWidgets(session) {
          this.session = session;
          this.session.widgetManager = this;
          this.session.getRowLength = this.getRowLength;
          this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
          this.updateOnChange = this.updateOnChange.bind(this);
          this.renderWidgets = this.renderWidgets.bind(this);
          this.measureWidgets = this.measureWidgets.bind(this);
          this.session._changedWidgets = [];
          this.$onChangeEditor = this.$onChangeEditor.bind(this);
          this.session.on("change", this.updateOnChange);
          this.session.on("changeFold", this.updateOnFold);
          this.session.on("changeEditor", this.$onChangeEditor);
      }
      (function () {
          this.getRowLength = function (row) {
              var h;
              if (this.lineWidgets)
                  h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
              else
                  h = 0;
              if (!this.$useWrapMode || !this.$wrapData[row]) {
                  return 1 + h;
              }
              else {
                  return this.$wrapData[row].length + 1 + h;
              }
          };
          this.$getWidgetScreenLength = function () {
              var screenRows = 0;
              this.lineWidgets.forEach(function (w) {
                  if (w && w.rowCount && !w.hidden)
                      screenRows += w.rowCount;
              });
              return screenRows;
          };
          this.$onChangeEditor = function (e) {
              this.attach(e.editor);
          };
          this.attach = function (editor) {
              if (editor && editor.widgetManager && editor.widgetManager != this)
                  editor.widgetManager.detach();
              if (this.editor == editor)
                  return;
              this.detach();
              this.editor = editor;
              if (editor) {
                  editor.widgetManager = this;
                  editor.renderer.on("beforeRender", this.measureWidgets);
                  editor.renderer.on("afterRender", this.renderWidgets);
              }
          };
          this.detach = function (e) {
              var editor = this.editor;
              if (!editor)
                  return;
              this.editor = null;
              editor.widgetManager = null;
              editor.renderer.off("beforeRender", this.measureWidgets);
              editor.renderer.off("afterRender", this.renderWidgets);
              var lineWidgets = this.session.lineWidgets;
              lineWidgets && lineWidgets.forEach(function (w) {
                  if (w && w.el && w.el.parentNode) {
                      w._inDocument = false;
                      w.el.parentNode.removeChild(w.el);
                  }
              });
          };
          this.updateOnFold = function (e, session) {
              var lineWidgets = session.lineWidgets;
              if (!lineWidgets || !e.action)
                  return;
              var fold = e.data;
              var start = fold.start.row;
              var end = fold.end.row;
              var hide = e.action == "add";
              for (var i = start + 1; i < end; i++) {
                  if (lineWidgets[i])
                      lineWidgets[i].hidden = hide;
              }
              if (lineWidgets[end]) {
                  if (hide) {
                      if (!lineWidgets[start])
                          lineWidgets[start] = lineWidgets[end];
                      else
                          lineWidgets[end].hidden = hide;
                  }
                  else {
                      if (lineWidgets[start] == lineWidgets[end])
                          lineWidgets[start] = undefined;
                      lineWidgets[end].hidden = hide;
                  }
              }
          };
          this.updateOnChange = function (delta) {
              var lineWidgets = this.session.lineWidgets;
              if (!lineWidgets)
                  return;
              var startRow = delta.start.row;
              var len = delta.end.row - startRow;
              if (len === 0) ;
              else if (delta.action == 'remove') {
                  var removed = lineWidgets.splice(startRow + 1, len);
                  removed.forEach(function (w) {
                      w && this.removeLineWidget(w);
                  }, this);
                  this.$updateRows();
              }
              else {
                  var args = new Array(len);
                  args.unshift(startRow, 0);
                  lineWidgets.splice.apply(lineWidgets, args);
                  this.$updateRows();
              }
          };
          this.$updateRows = function () {
              var lineWidgets = this.session.lineWidgets;
              if (!lineWidgets)
                  return;
              var noWidgets = true;
              lineWidgets.forEach(function (w, i) {
                  if (w) {
                      noWidgets = false;
                      w.row = i;
                      while (w.$oldWidget) {
                          w.$oldWidget.row = i;
                          w = w.$oldWidget;
                      }
                  }
              });
              if (noWidgets)
                  this.session.lineWidgets = null;
          };
          this.addLineWidget = function (w) {
              if (!this.session.lineWidgets)
                  this.session.lineWidgets = new Array(this.session.getLength());
              var old = this.session.lineWidgets[w.row];
              if (old) {
                  w.$oldWidget = old;
                  if (old.el && old.el.parentNode) {
                      old.el.parentNode.removeChild(old.el);
                      old._inDocument = false;
                  }
              }
              this.session.lineWidgets[w.row] = w;
              w.session = this.session;
              var renderer = this.editor.renderer;
              if (w.html && !w.el) {
                  w.el = dom.createElement("div");
                  w.el.innerHTML = w.html;
              }
              if (w.el) {
                  dom.addCssClass(w.el, "ace_lineWidgetContainer");
                  w.el.style.position = "absolute";
                  w.el.style.zIndex = 5;
                  renderer.container.appendChild(w.el);
                  w._inDocument = true;
              }
              if (!w.coverGutter) {
                  w.el.style.zIndex = 3;
              }
              if (w.pixelHeight == null) {
                  w.pixelHeight = w.el.offsetHeight;
              }
              if (w.rowCount == null) {
                  w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
              }
              var fold = this.session.getFoldAt(w.row, 0);
              w.$fold = fold;
              if (fold) {
                  var lineWidgets = this.session.lineWidgets;
                  if (w.row == fold.end.row && !lineWidgets[fold.start.row])
                      lineWidgets[fold.start.row] = w;
                  else
                      w.hidden = true;
              }
              this.session._emit("changeFold", { data: { start: { row: w.row } } });
              this.$updateRows();
              this.renderWidgets(null, renderer);
              this.onWidgetChanged(w);
              return w;
          };
          this.removeLineWidget = function (w) {
              w._inDocument = false;
              w.session = null;
              if (w.el && w.el.parentNode)
                  w.el.parentNode.removeChild(w.el);
              if (w.editor && w.editor.destroy)
                  try {
                      w.editor.destroy();
                  }
                  catch (e) { }
              if (this.session.lineWidgets) {
                  var w1 = this.session.lineWidgets[w.row];
                  if (w1 == w) {
                      this.session.lineWidgets[w.row] = w.$oldWidget;
                      if (w.$oldWidget)
                          this.onWidgetChanged(w.$oldWidget);
                  }
                  else {
                      while (w1) {
                          if (w1.$oldWidget == w) {
                              w1.$oldWidget = w.$oldWidget;
                              break;
                          }
                          w1 = w1.$oldWidget;
                      }
                  }
              }
              this.session._emit("changeFold", { data: { start: { row: w.row } } });
              this.$updateRows();
          };
          this.getWidgetsAtRow = function (row) {
              var lineWidgets = this.session.lineWidgets;
              var w = lineWidgets && lineWidgets[row];
              var list = [];
              while (w) {
                  list.push(w);
                  w = w.$oldWidget;
              }
              return list;
          };
          this.onWidgetChanged = function (w) {
              this.session._changedWidgets.push(w);
              this.editor && this.editor.renderer.updateFull();
          };
          this.measureWidgets = function (e, renderer) {
              var changedWidgets = this.session._changedWidgets;
              var config = renderer.layerConfig;
              if (!changedWidgets || !changedWidgets.length)
                  return;
              var min = Infinity;
              for (var i = 0; i < changedWidgets.length; i++) {
                  var w = changedWidgets[i];
                  if (!w || !w.el)
                      continue;
                  if (w.session != this.session)
                      continue;
                  if (!w._inDocument) {
                      if (this.session.lineWidgets[w.row] != w)
                          continue;
                      w._inDocument = true;
                      renderer.container.appendChild(w.el);
                  }
                  w.h = w.el.offsetHeight;
                  if (!w.fixedWidth) {
                      w.w = w.el.offsetWidth;
                      w.screenWidth = Math.ceil(w.w / config.characterWidth);
                  }
                  var rowCount = w.h / config.lineHeight;
                  if (w.coverLine) {
                      rowCount -= this.session.getRowLineCount(w.row);
                      if (rowCount < 0)
                          rowCount = 0;
                  }
                  if (w.rowCount != rowCount) {
                      w.rowCount = rowCount;
                      if (w.row < min)
                          min = w.row;
                  }
              }
              if (min != Infinity) {
                  this.session._emit("changeFold", { data: { start: { row: min } } });
                  this.session.lineWidgetWidth = null;
              }
              this.session._changedWidgets = [];
          };
          this.renderWidgets = function (e, renderer) {
              var config = renderer.layerConfig;
              var lineWidgets = this.session.lineWidgets;
              if (!lineWidgets)
                  return;
              var first = Math.min(this.firstRow, config.firstRow);
              var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
              while (first > 0 && !lineWidgets[first])
                  first--;
              this.firstRow = config.firstRow;
              this.lastRow = config.lastRow;
              renderer.$cursorLayer.config = config;
              for (var i = first; i <= last; i++) {
                  var w = lineWidgets[i];
                  if (!w || !w.el)
                      continue;
                  if (w.hidden) {
                      w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
                      continue;
                  }
                  if (!w._inDocument) {
                      w._inDocument = true;
                      renderer.container.appendChild(w.el);
                  }
                  var top = renderer.$cursorLayer.getPixelPosition({ row: i, column: 0 }, true).top;
                  if (!w.coverLine)
                      top += config.lineHeight * this.session.getRowLineCount(w.row);
                  w.el.style.top = top - config.offset + "px";
                  var left = w.coverGutter ? 0 : renderer.gutterWidth;
                  if (!w.fixedWidth)
                      left -= renderer.scrollLeft;
                  w.el.style.left = left + "px";
                  if (w.fullWidth && w.screenWidth) {
                      w.el.style.minWidth = config.width + 2 * config.padding + "px";
                  }
                  if (w.fixedWidth) {
                      w.el.style.right = renderer.scrollBar.getWidth() + "px";
                  }
                  else {
                      w.el.style.right = "";
                  }
              }
          };
      }).call(LineWidgets.prototype);
      exports.LineWidgets = LineWidgets;
  });
  ace.define("ace/ext/error_marker", ["require", "exports", "module", "ace/line_widgets", "ace/lib/dom", "ace/range"], function (acequire, exports, module) {
      var LineWidgets = acequire("../line_widgets").LineWidgets;
      var dom = acequire("../lib/dom");
      var Range = acequire("../range").Range;
      function binarySearch(array, needle, comparator) {
          var first = 0;
          var last = array.length - 1;
          while (first <= last) {
              var mid = (first + last) >> 1;
              var c = comparator(needle, array[mid]);
              if (c > 0)
                  first = mid + 1;
              else if (c < 0)
                  last = mid - 1;
              else
                  return mid;
          }
          return -(first + 1);
      }
      function findAnnotations(session, row, dir) {
          var annotations = session.getAnnotations().sort(Range.comparePoints);
          if (!annotations.length)
              return;
          var i = binarySearch(annotations, { row: row, column: -1 }, Range.comparePoints);
          if (i < 0)
              i = -i - 1;
          if (i >= annotations.length)
              i = dir > 0 ? 0 : annotations.length - 1;
          else if (i === 0 && dir < 0)
              i = annotations.length - 1;
          var annotation = annotations[i];
          if (!annotation || !dir)
              return;
          if (annotation.row === row) {
              do {
                  annotation = annotations[i += dir];
              } while (annotation && annotation.row === row);
              if (!annotation)
                  return annotations.slice();
          }
          var matched = [];
          row = annotation.row;
          do {
              matched[dir < 0 ? "unshift" : "push"](annotation);
              annotation = annotations[i += dir];
          } while (annotation && annotation.row == row);
          return matched.length && matched;
      }
      exports.showErrorMarker = function (editor, dir) {
          var session = editor.session;
          if (!session.widgetManager) {
              session.widgetManager = new LineWidgets(session);
              session.widgetManager.attach(editor);
          }
          var pos = editor.getCursorPosition();
          var row = pos.row;
          var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function (w) {
              return w.type == "errorMarker";
          })[0];
          if (oldWidget) {
              oldWidget.destroy();
          }
          else {
              row -= dir;
          }
          var annotations = findAnnotations(session, row, dir);
          var gutterAnno;
          if (annotations) {
              var annotation = annotations[0];
              pos.column = (annotation.pos && typeof annotation.column != "number"
                  ? annotation.pos.sc
                  : annotation.column) || 0;
              pos.row = annotation.row;
              gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
          }
          else if (oldWidget) {
              return;
          }
          else {
              gutterAnno = {
                  text: ["Looks good!"],
                  className: "ace_ok"
              };
          }
          editor.session.unfold(pos.row);
          editor.selection.moveToPosition(pos);
          var w = {
              row: pos.row,
              fixedWidth: true,
              coverGutter: true,
              el: dom.createElement("div"),
              type: "errorMarker"
          };
          var el = w.el.appendChild(dom.createElement("div"));
          var arrow = w.el.appendChild(dom.createElement("div"));
          arrow.className = "error_widget_arrow " + gutterAnno.className;
          var left = editor.renderer.$cursorLayer
              .getPixelPosition(pos).left;
          arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
          w.el.className = "error_widget_wrapper";
          el.className = "error_widget " + gutterAnno.className;
          el.innerHTML = gutterAnno.text.join("<br>");
          el.appendChild(dom.createElement("div"));
          var kb = function (_, hashId, keyString) {
              if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
                  w.destroy();
                  return { command: "null" };
              }
          };
          w.destroy = function () {
              if (editor.$mouseHandler.isMousePressed)
                  return;
              editor.keyBinding.removeKeyboardHandler(kb);
              session.widgetManager.removeLineWidget(w);
              editor.off("changeSelection", w.destroy);
              editor.off("changeSession", w.destroy);
              editor.off("mouseup", w.destroy);
              editor.off("change", w.destroy);
          };
          editor.keyBinding.addKeyboardHandler(kb);
          editor.on("changeSelection", w.destroy);
          editor.on("changeSession", w.destroy);
          editor.on("mouseup", w.destroy);
          editor.on("change", w.destroy);
          editor.session.widgetManager.addLineWidget(w);
          w.el.onmousedown = editor.focus.bind(editor);
          editor.renderer.scrollCursorIntoView(null, 0.5, { bottom: w.el.offsetHeight });
      };
      dom.importCssString("\
    .error_widget_wrapper {\
        background: inherit;\
        color: inherit;\
        border:none\
    }\
    .error_widget {\
        border-top: solid 2px;\
        border-bottom: solid 2px;\
        margin: 5px 0;\
        padding: 10px 40px;\
        white-space: pre-wrap;\
    }\
    .error_widget.ace_error, .error_widget_arrow.ace_error{\
        border-color: #ff5a5a\
    }\
    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
        border-color: #F1D817\
    }\
    .error_widget.ace_info, .error_widget_arrow.ace_info{\
        border-color: #5a5a5a\
    }\
    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
        border-color: #5aaa5a\
    }\
    .error_widget_arrow {\
        position: absolute;\
        border: solid 5px;\
        border-top-color: transparent!important;\
        border-right-color: transparent!important;\
        border-left-color: transparent!important;\
        top: -5px;\
    }\
", "");
  });
  ace.define("ace/ace", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/dom", "ace/lib/event", "ace/editor", "ace/edit_session", "ace/undomanager", "ace/virtual_renderer", "ace/worker/worker_client", "ace/keyboard/hash_handler", "ace/placeholder", "ace/multi_select", "ace/mode/folding/fold_mode", "ace/theme/textmate", "ace/ext/error_marker", "ace/config"], function (acequire, exports, module) {
      acequire("./lib/fixoldbrowsers");
      var dom = acequire("./lib/dom");
      var event = acequire("./lib/event");
      var Editor = acequire("./editor").Editor;
      var EditSession = acequire("./edit_session").EditSession;
      var UndoManager = acequire("./undomanager").UndoManager;
      var Renderer = acequire("./virtual_renderer").VirtualRenderer;
      acequire("./worker/worker_client");
      acequire("./keyboard/hash_handler");
      acequire("./placeholder");
      acequire("./multi_select");
      acequire("./mode/folding/fold_mode");
      acequire("./theme/textmate");
      acequire("./ext/error_marker");
      exports.config = acequire("./config");
      exports.acequire = acequire;
      exports.edit = function (el) {
          if (typeof el == "string") {
              var _id = el;
              el = document.getElementById(_id);
              if (!el)
                  throw new Error("ace.edit can't find div #" + _id);
          }
          if (el && el.env && el.env.editor instanceof Editor)
              return el.env.editor;
          var value = "";
          if (el && /input|textarea/i.test(el.tagName)) {
              var oldNode = el;
              value = oldNode.value;
              el = dom.createElement("pre");
              oldNode.parentNode.replaceChild(el, oldNode);
          }
          else if (el) {
              value = dom.getInnerText(el);
              el.innerHTML = "";
          }
          var doc = exports.createEditSession(value);
          var editor = new Editor(new Renderer(el));
          editor.setSession(doc);
          var env = {
              document: doc,
              editor: editor,
              onResize: editor.resize.bind(editor, null)
          };
          if (oldNode)
              env.textarea = oldNode;
          event.addListener(window, "resize", env.onResize);
          editor.on("destroy", function () {
              event.removeListener(window, "resize", env.onResize);
              env.editor.container.env = null; // prevent memory leak on old ie
          });
          editor.container.env = editor.env = env;
          return editor;
      };
      exports.createEditSession = function (text, mode) {
          var doc = new EditSession(text, mode);
          doc.setUndoManager(new UndoManager());
          return doc;
      };
      exports.EditSession = EditSession;
      exports.UndoManager = UndoManager;
      exports.version = "1.2.9";
  });
  (function () {
      ace.acequire(["ace/ace"], function (a) {
          if (a) {
              a.config.init(true);
              a.define = ace.define;
          }
          if (!window.ace)
              window.ace = a;
          for (var key in a)
              if (a.hasOwnProperty(key))
                  window.ace[key] = a[key];
      });
  })();
  var brace = window.ace.acequire("ace/ace");

  ace.define("ace/theme/monokai", ["require", "exports", "module", "ace/lib/dom"], function (acequire, exports, module) {
      exports.isDark = true;
      exports.cssClass = "ace-monokai";
      exports.cssText = ".ace-monokai .ace_gutter {\
background: #2F3129;\
color: #8F908A\
}\
.ace-monokai .ace_print-margin {\
width: 1px;\
background: #555651\
}\
.ace-monokai {\
background-color: #272822;\
color: #F8F8F2\
}\
.ace-monokai .ace_cursor {\
color: #F8F8F0\
}\
.ace-monokai .ace_marker-layer .ace_selection {\
background: #49483E\
}\
.ace-monokai.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px #272822;\
}\
.ace-monokai .ace_marker-layer .ace_step {\
background: rgb(102, 82, 0)\
}\
.ace-monokai .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid #49483E\
}\
.ace-monokai .ace_marker-layer .ace_active-line {\
background: #202020\
}\
.ace-monokai .ace_gutter-active-line {\
background-color: #272727\
}\
.ace-monokai .ace_marker-layer .ace_selected-word {\
border: 1px solid #49483E\
}\
.ace-monokai .ace_invisible {\
color: #52524d\
}\
.ace-monokai .ace_entity.ace_name.ace_tag,\
.ace-monokai .ace_keyword,\
.ace-monokai .ace_meta.ace_tag,\
.ace-monokai .ace_storage {\
color: #F92672\
}\
.ace-monokai .ace_punctuation,\
.ace-monokai .ace_punctuation.ace_tag {\
color: #fff\
}\
.ace-monokai .ace_constant.ace_character,\
.ace-monokai .ace_constant.ace_language,\
.ace-monokai .ace_constant.ace_numeric,\
.ace-monokai .ace_constant.ace_other {\
color: #AE81FF\
}\
.ace-monokai .ace_invalid {\
color: #F8F8F0;\
background-color: #F92672\
}\
.ace-monokai .ace_invalid.ace_deprecated {\
color: #F8F8F0;\
background-color: #AE81FF\
}\
.ace-monokai .ace_support.ace_constant,\
.ace-monokai .ace_support.ace_function {\
color: #66D9EF\
}\
.ace-monokai .ace_fold {\
background-color: #A6E22E;\
border-color: #F8F8F2\
}\
.ace-monokai .ace_storage.ace_type,\
.ace-monokai .ace_support.ace_class,\
.ace-monokai .ace_support.ace_type {\
font-style: italic;\
color: #66D9EF\
}\
.ace-monokai .ace_entity.ace_name.ace_function,\
.ace-monokai .ace_entity.ace_other,\
.ace-monokai .ace_entity.ace_other.ace_attribute-name,\
.ace-monokai .ace_variable {\
color: #A6E22E\
}\
.ace-monokai .ace_variable.ace_parameter {\
font-style: italic;\
color: #FD971F\
}\
.ace-monokai .ace_string {\
color: #E6DB74\
}\
.ace-monokai .ace_comment {\
color: #75715E\
}\
.ace-monokai .ace_indent-guide {\
background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWPQ0FD0ZXBzd/wPAAjVAoxeSgNeAAAAAElFTkSuQmCC) right repeat-y\
}";
      var dom = acequire("../lib/dom");
      dom.importCssString(exports.cssText, exports.cssClass);
  });

  var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
      else
          for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                  r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __metadata = (this && this.__metadata) || function (k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
  };
  var AceEditorDirective = /** @class */ (function () {
      function AceEditorDirective(elementRef, zone) {
          var _this = this;
          this.zone = zone;
          this.textChanged = new core.EventEmitter();
          this.textChange = new core.EventEmitter();
          this._options = {};
          this._readOnly = false;
          this._theme = "monokai";
          this._mode = "html";
          this._autoUpdateContent = true;
          this._durationBeforeCallback = 0;
          this._text = "";
          var el = elementRef.nativeElement;
          this.zone.runOutsideAngular(function () {
              _this.editor = ace["edit"](el);
          });
          this.editor.$blockScrolling = Infinity;
      }
      AceEditorDirective.prototype.ngOnInit = function () {
          this.init();
          this.initEvents();
      };
      AceEditorDirective.prototype.ngOnDestroy = function () {
          this.editor.destroy();
      };
      AceEditorDirective.prototype.init = function () {
          this.editor.setOptions(this._options || {});
          this.editor.setTheme("ace/theme/" + this._theme);
          this.setMode(this._mode);
          this.editor.setReadOnly(this._readOnly);
      };
      AceEditorDirective.prototype.initEvents = function () {
          var _this = this;
          this.editor.on('change', function () { return _this.updateText(); });
          this.editor.on('paste', function () { return _this.updateText(); });
      };
      AceEditorDirective.prototype.updateText = function () {
          var _this = this;
          var newVal = this.editor.getValue();
          if (newVal === this.oldText) {
              return;
          }
          if (!this._durationBeforeCallback) {
              this._text = newVal;
              this.zone.run(function () {
                  _this.textChange.emit(newVal);
                  _this.textChanged.emit(newVal);
              });
          }
          else {
              if (this.timeoutSaving != null) {
                  clearTimeout(this.timeoutSaving);
              }
              this.timeoutSaving = setTimeout(function () {
                  _this._text = newVal;
                  _this.zone.run(function () {
                      _this.textChange.emit(newVal);
                      _this.textChanged.emit(newVal);
                  });
                  _this.timeoutSaving = null;
              }, this._durationBeforeCallback);
          }
          this.oldText = newVal;
      };
      Object.defineProperty(AceEditorDirective.prototype, "options", {
          set: function (options) {
              this._options = options;
              this.editor.setOptions(options || {});
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(AceEditorDirective.prototype, "readOnly", {
          set: function (readOnly) {
              this._readOnly = readOnly;
              this.editor.setReadOnly(readOnly);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(AceEditorDirective.prototype, "theme", {
          set: function (theme) {
              this._theme = theme;
              this.editor.setTheme("ace/theme/" + theme);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(AceEditorDirective.prototype, "mode", {
          set: function (mode) {
              this.setMode(mode);
          },
          enumerable: true,
          configurable: true
      });
      AceEditorDirective.prototype.setMode = function (mode) {
          this._mode = mode;
          if (typeof this._mode === 'object') {
              this.editor.getSession().setMode(this._mode);
          }
          else {
              this.editor.getSession().setMode("ace/mode/" + this._mode);
          }
      };
      Object.defineProperty(AceEditorDirective.prototype, "text", {
          get: function () {
              return this._text;
          },
          set: function (text) {
              this.setText(text);
          },
          enumerable: true,
          configurable: true
      });
      AceEditorDirective.prototype.setText = function (text) {
          if (this._text !== text) {
              if (text === null || text === undefined) {
                  text = "";
              }
              if (this._autoUpdateContent === true) {
                  this._text = text;
                  this.editor.setValue(text);
                  this.editor.clearSelection();
              }
          }
      };
      Object.defineProperty(AceEditorDirective.prototype, "autoUpdateContent", {
          set: function (status) {
              this._autoUpdateContent = status;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(AceEditorDirective.prototype, "durationBeforeCallback", {
          set: function (num) {
              this.setDurationBeforeCallback(num);
          },
          enumerable: true,
          configurable: true
      });
      AceEditorDirective.prototype.setDurationBeforeCallback = function (num) {
          this._durationBeforeCallback = num;
      };
      Object.defineProperty(AceEditorDirective.prototype, "aceEditor", {
          get: function () {
              return this.editor;
          },
          enumerable: true,
          configurable: true
      });
      __decorate([
          core.Output(),
          __metadata("design:type", Object)
      ], AceEditorDirective.prototype, "textChanged", void 0);
      __decorate([
          core.Output(),
          __metadata("design:type", Object)
      ], AceEditorDirective.prototype, "textChange", void 0);
      __decorate([
          core.Input(),
          __metadata("design:type", Object),
          __metadata("design:paramtypes", [Object])
      ], AceEditorDirective.prototype, "options", null);
      __decorate([
          core.Input(),
          __metadata("design:type", Object),
          __metadata("design:paramtypes", [Object])
      ], AceEditorDirective.prototype, "readOnly", null);
      __decorate([
          core.Input(),
          __metadata("design:type", Object),
          __metadata("design:paramtypes", [Object])
      ], AceEditorDirective.prototype, "theme", null);
      __decorate([
          core.Input(),
          __metadata("design:type", Object),
          __metadata("design:paramtypes", [Object])
      ], AceEditorDirective.prototype, "mode", null);
      __decorate([
          core.Input(),
          __metadata("design:type", String),
          __metadata("design:paramtypes", [String])
      ], AceEditorDirective.prototype, "text", null);
      __decorate([
          core.Input(),
          __metadata("design:type", Object),
          __metadata("design:paramtypes", [Object])
      ], AceEditorDirective.prototype, "autoUpdateContent", null);
      __decorate([
          core.Input(),
          __metadata("design:type", Number),
          __metadata("design:paramtypes", [Number])
      ], AceEditorDirective.prototype, "durationBeforeCallback", null);
      AceEditorDirective = __decorate([
          core.Directive({
              selector: '[ace-editor]'
          }),
          __metadata("design:paramtypes", [core.ElementRef, core.NgZone])
      ], AceEditorDirective);
      return AceEditorDirective;
  }());

  var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
      else
          for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                  r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __metadata$1 = (this && this.__metadata) || function (k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
  };
  var AceEditorComponent = /** @class */ (function () {
      function AceEditorComponent(elementRef, zone) {
          var _this = this;
          this.zone = zone;
          this.textChanged = new core.EventEmitter();
          this.textChange = new core.EventEmitter();
          this.style = {};
          this._options = {};
          this._readOnly = false;
          this._theme = "monokai";
          this._mode = "html";
          this._autoUpdateContent = true;
          this._durationBeforeCallback = 0;
          this._text = "";
          this._onChange = function (_) {
          };
          this._onTouched = function () {
          };
          var el = elementRef.nativeElement;
          this.zone.runOutsideAngular(function () {
              _this._editor = ace['edit'](el);
          });
          this._editor.$blockScrolling = Infinity;
      }
      AceEditorComponent_1 = AceEditorComponent;
      AceEditorComponent.prototype.ngOnInit = function () {
          this.init();
          this.initEvents();
      };
      AceEditorComponent.prototype.ngOnDestroy = function () {
          this._editor.destroy();
      };
      AceEditorComponent.prototype.init = function () {
          this.setOptions(this._options || {});
          this.setTheme(this._theme);
          this.setMode(this._mode);
          this.setReadOnly(this._readOnly);
      };
      AceEditorComponent.prototype.initEvents = function () {
          var _this = this;
          this._editor.on('change', function () { return _this.updateText(); });
          this._editor.on('paste', function () { return _this.updateText(); });
      };
      AceEditorComponent.prototype.updateText = function () {
          var _this = this;
          var newVal = this._editor.getValue();
          if (newVal === this.oldText) {
              return;
          }
          if (!this._durationBeforeCallback) {
              this._text = newVal;
              this.zone.run(function () {
                  _this.textChange.emit(newVal);
                  _this.textChanged.emit(newVal);
              });
              this._onChange(newVal);
          }
          else {
              if (this.timeoutSaving) {
                  clearTimeout(this.timeoutSaving);
              }
              this.timeoutSaving = setTimeout(function () {
                  _this._text = newVal;
                  _this.zone.run(function () {
                      _this.textChange.emit(newVal);
                      _this.textChanged.emit(newVal);
                  });
                  _this.timeoutSaving = null;
              }, this._durationBeforeCallback);
          }
          this.oldText = newVal;
      };
      Object.defineProperty(AceEditorComponent.prototype, "options", {
          set: function (options) {
              this.setOptions(options);
          },
          enumerable: true,
          configurable: true
      });
      AceEditorComponent.prototype.setOptions = function (options) {
          this._options = options;
          this._editor.setOptions(options || {});
      };
      Object.defineProperty(AceEditorComponent.prototype, "readOnly", {
          set: function (readOnly) {
              this.setReadOnly(readOnly);
          },
          enumerable: true,
          configurable: true
      });
      AceEditorComponent.prototype.setReadOnly = function (readOnly) {
          this._readOnly = readOnly;
          this._editor.setReadOnly(readOnly);
      };
      Object.defineProperty(AceEditorComponent.prototype, "theme", {
          set: function (theme) {
              this.setTheme(theme);
          },
          enumerable: true,
          configurable: true
      });
      AceEditorComponent.prototype.setTheme = function (theme) {
          this._theme = theme;
          this._editor.setTheme("ace/theme/" + theme);
      };
      Object.defineProperty(AceEditorComponent.prototype, "mode", {
          set: function (mode) {
              this.setMode(mode);
          },
          enumerable: true,
          configurable: true
      });
      AceEditorComponent.prototype.setMode = function (mode) {
          this._mode = mode;
          if (typeof this._mode === 'object') {
              this._editor.getSession().setMode(this._mode);
          }
          else {
              this._editor.getSession().setMode("ace/mode/" + this._mode);
          }
      };
      Object.defineProperty(AceEditorComponent.prototype, "value", {
          get: function () {
              return this.text;
          },
          set: function (value) {
              this.setText(value);
          },
          enumerable: true,
          configurable: true
      });
      AceEditorComponent.prototype.writeValue = function (value) {
          this.setText(value);
      };
      AceEditorComponent.prototype.registerOnChange = function (fn) {
          this._onChange = fn;
      };
      AceEditorComponent.prototype.registerOnTouched = function (fn) {
          this._onTouched = fn;
      };
      Object.defineProperty(AceEditorComponent.prototype, "text", {
          get: function () {
              return this._text;
          },
          set: function (text) {
              this.setText(text);
          },
          enumerable: true,
          configurable: true
      });
      AceEditorComponent.prototype.setText = function (text) {
          if (text === null || text === undefined) {
              text = "";
          }
          if (this._text !== text && this._autoUpdateContent === true) {
              this._text = text;
              this._editor.setValue(text);
              this._onChange(text);
              this._editor.clearSelection();
          }
      };
      Object.defineProperty(AceEditorComponent.prototype, "autoUpdateContent", {
          set: function (status) {
              this.setAutoUpdateContent(status);
          },
          enumerable: true,
          configurable: true
      });
      AceEditorComponent.prototype.setAutoUpdateContent = function (status) {
          this._autoUpdateContent = status;
      };
      Object.defineProperty(AceEditorComponent.prototype, "durationBeforeCallback", {
          set: function (num) {
              this.setDurationBeforeCallback(num);
          },
          enumerable: true,
          configurable: true
      });
      AceEditorComponent.prototype.setDurationBeforeCallback = function (num) {
          this._durationBeforeCallback = num;
      };
      AceEditorComponent.prototype.getEditor = function () {
          return this._editor;
      };
      var AceEditorComponent_1;
      __decorate$1([
          core.Output(),
          __metadata$1("design:type", Object)
      ], AceEditorComponent.prototype, "textChanged", void 0);
      __decorate$1([
          core.Output(),
          __metadata$1("design:type", Object)
      ], AceEditorComponent.prototype, "textChange", void 0);
      __decorate$1([
          core.Input(),
          __metadata$1("design:type", Object)
      ], AceEditorComponent.prototype, "style", void 0);
      __decorate$1([
          core.Input(),
          __metadata$1("design:type", Object),
          __metadata$1("design:paramtypes", [Object])
      ], AceEditorComponent.prototype, "options", null);
      __decorate$1([
          core.Input(),
          __metadata$1("design:type", Object),
          __metadata$1("design:paramtypes", [Object])
      ], AceEditorComponent.prototype, "readOnly", null);
      __decorate$1([
          core.Input(),
          __metadata$1("design:type", Object),
          __metadata$1("design:paramtypes", [Object])
      ], AceEditorComponent.prototype, "theme", null);
      __decorate$1([
          core.Input(),
          __metadata$1("design:type", Object),
          __metadata$1("design:paramtypes", [Object])
      ], AceEditorComponent.prototype, "mode", null);
      __decorate$1([
          core.Input(),
          __metadata$1("design:type", String),
          __metadata$1("design:paramtypes", [String])
      ], AceEditorComponent.prototype, "value", null);
      __decorate$1([
          core.Input(),
          __metadata$1("design:type", String),
          __metadata$1("design:paramtypes", [String])
      ], AceEditorComponent.prototype, "text", null);
      __decorate$1([
          core.Input(),
          __metadata$1("design:type", Object),
          __metadata$1("design:paramtypes", [Object])
      ], AceEditorComponent.prototype, "autoUpdateContent", null);
      __decorate$1([
          core.Input(),
          __metadata$1("design:type", Number),
          __metadata$1("design:paramtypes", [Number])
      ], AceEditorComponent.prototype, "durationBeforeCallback", null);
      AceEditorComponent = AceEditorComponent_1 = __decorate$1([
          core.Component({
              selector: 'ace-editor',
              template: '',
              styles: [':host { display:block;width:100%; }'],
              providers: [{
                      provide: forms.NG_VALUE_ACCESSOR,
                      useExisting: core.forwardRef(function () { return AceEditorComponent_1; }),
                      multi: true
                  }]
          }),
          __metadata$1("design:paramtypes", [core.ElementRef, core.NgZone])
      ], AceEditorComponent);
      return AceEditorComponent;
  }());

  var __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
      else
          for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                  r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var list = [
      AceEditorComponent,
      AceEditorDirective
  ];
  var AceEditorModule = /** @class */ (function () {
      function AceEditorModule() {
      }
      AceEditorModule = __decorate$2([
          core.NgModule({
              declarations: list.slice(),
              imports: [],
              providers: [],
              exports: list
          })
      ], AceEditorModule);
      return AceEditorModule;
  }());

  var __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
      else
          for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                  r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __metadata$2 = (this && this.__metadata) || function (k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
  };
  var FroalaEditorDirective = /** @class */ (function () {
      function FroalaEditorDirective(el, zone) {
          this.zone = zone;
          // editor options
          this._opts = {
              immediateAngularModelUpdate: false,
              angularIgnoreAttrs: null
          };
          this.SPECIAL_TAGS = ['img', 'button', 'input', 'a'];
          this.INNER_HTML_ATTR = 'innerHTML';
          this._hasSpecialTag = false;
          this._listeningEvents = [];
          this._editorInitialized = false;
          this._oldModel = null;
          // Begin ControlValueAccesor methods.
          this.onChange = function (_) { };
          this.onTouched = function () { };
          // froalaModel directive as output: update model if editor contentChanged
          this.froalaModelChange = new core.EventEmitter();
          // froalaInit directive as output: send manual editor initialization
          this.froalaInit = new core.EventEmitter();
          var element = el.nativeElement;
          // check if the element is a special tag
          if (this.SPECIAL_TAGS.indexOf(element.tagName.toLowerCase()) != -1) {
              this._hasSpecialTag = true;
          }
          // jquery wrap and store element
          this._$element = $(element);
          this.zone = zone;
      }
      FroalaEditorDirective_1 = FroalaEditorDirective;
      // Form model content changed.
      FroalaEditorDirective.prototype.writeValue = function (content) {
          this.updateEditor(content);
      };
      FroalaEditorDirective.prototype.registerOnChange = function (fn) { this.onChange = fn; };
      FroalaEditorDirective.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
      Object.defineProperty(FroalaEditorDirective.prototype, "froalaEditor", {
          // End ControlValueAccesor methods.
          // froalaEditor directive as input: store the editor options
          set: function (opts) {
              this._opts = opts || this._opts;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(FroalaEditorDirective.prototype, "froalaModel", {
          // froalaModel directive as input: store initial editor content
          set: function (content) {
              this.updateEditor(content);
          },
          enumerable: true,
          configurable: true
      });
      // Update editor with model contents.
      FroalaEditorDirective.prototype.updateEditor = function (content) {
          if (JSON.stringify(this._oldModel) == JSON.stringify(content)) {
              return;
          }
          if (!this._hasSpecialTag) {
              this._oldModel = content;
          }
          else {
              this._model = content;
          }
          if (this._editorInitialized) {
              if (!this._hasSpecialTag) {
                  this._$element.froalaEditor('html.set', content);
              }
              else {
                  this.setContent();
              }
          }
          else {
              if (!this._hasSpecialTag) {
                  this._$element.html(content);
              }
              else {
                  this.setContent();
              }
          }
      };
      // update model if editor contentChanged
      FroalaEditorDirective.prototype.updateModel = function () {
          var _this = this;
          this.zone.run(function () {
              var modelContent = null;
              if (_this._hasSpecialTag) {
                  var attributeNodes = _this._$element[0].attributes;
                  var attrs = {};
                  for (var i = 0; i < attributeNodes.length; i++) {
                      var attrName = attributeNodes[i].name;
                      if (_this._opts.angularIgnoreAttrs && _this._opts.angularIgnoreAttrs.indexOf(attrName) != -1) {
                          continue;
                      }
                      attrs[attrName] = attributeNodes[i].value;
                  }
                  if (_this._$element[0].innerHTML) {
                      attrs[_this.INNER_HTML_ATTR] = _this._$element[0].innerHTML;
                  }
                  modelContent = attrs;
              }
              else {
                  var returnedHtml = _this._$element.froalaEditor('html.get');
                  if (typeof returnedHtml === 'string') {
                      modelContent = returnedHtml;
                  }
              }
              _this._oldModel = modelContent;
              // Update froalaModel.
              _this.froalaModelChange.emit(modelContent);
              // Update form model.
              _this.onChange(modelContent);
          });
      };
      // register event on jquery element
      FroalaEditorDirective.prototype.registerEvent = function (element, eventName, callback) {
          if (!element || !eventName || !callback) {
              return;
          }
          this._listeningEvents.push(eventName);
          element.on(eventName, callback);
      };
      FroalaEditorDirective.prototype.initListeners = function () {
          var self = this;
          // bind contentChange and keyup event to froalaModel
          this.registerEvent(this._$element, 'froalaEditor.contentChanged', function () {
              setTimeout(function () {
                  self.updateModel();
              }, 0);
          });
          if (this._opts.immediateAngularModelUpdate) {
              this.registerEvent(this._editor, 'keyup', function () {
                  setTimeout(function () {
                      self.updateModel();
                  }, 0);
              });
          }
      };
      // register events from editor options
      FroalaEditorDirective.prototype.registerFroalaEvents = function () {
          if (!this._opts.events) {
              return;
          }
          for (var eventName in this._opts.events) {
              if (this._opts.events.hasOwnProperty(eventName)) {
                  this.registerEvent(this._$element, eventName, this._opts.events[eventName]);
              }
          }
      };
      FroalaEditorDirective.prototype.createEditor = function () {
          var _this = this;
          if (this._editorInitialized) {
              return;
          }
          this.setContent(true);
          // Registering events before initializing the editor will bind the initialized event correctly.
          this.registerFroalaEvents();
          this.initListeners();
          // init editor
          this.zone.runOutsideAngular(function () {
              _this._$element.on('froalaEditor.initialized', function () {
                  _this._editorInitialized = true;
              });
              _this._editor = _this._$element.froalaEditor(_this._opts).data('froala.editor').$el;
          });
      };
      FroalaEditorDirective.prototype.setHtml = function () {
          this._$element.froalaEditor('html.set', this._model || '', true);
          // This will reset the undo stack everytime the model changes externally. Can we fix this?
          this._$element.froalaEditor('undo.reset');
          this._$element.froalaEditor('undo.saveStep');
      };
      FroalaEditorDirective.prototype.setContent = function (firstTime) {
          if (firstTime === void 0) {
              firstTime = false;
          }
          var self = this;
          // Set initial content
          if (this._model || this._model == '') {
              this._oldModel = this._model;
              if (this._hasSpecialTag) {
                  var tags = this._model;
                  // add tags on element
                  if (tags) {
                      for (var attr in tags) {
                          if (tags.hasOwnProperty(attr) && attr != this.INNER_HTML_ATTR) {
                              this._$element.attr(attr, tags[attr]);
                          }
                      }
                      if (tags.hasOwnProperty(this.INNER_HTML_ATTR)) {
                          this._$element[0].innerHTML = tags[this.INNER_HTML_ATTR];
                      }
                  }
              }
              else {
                  if (firstTime) {
                      this.registerEvent(this._$element, 'froalaEditor.initialized', function () {
                          self.setHtml();
                      });
                  }
                  else {
                      self.setHtml();
                  }
              }
          }
      };
      FroalaEditorDirective.prototype.destroyEditor = function () {
          if (this._editorInitialized) {
              this._$element.off(this._listeningEvents.join(" "));
              this._editor.off('keyup');
              this._$element.froalaEditor('destroy');
              this._listeningEvents.length = 0;
              this._editorInitialized = false;
          }
      };
      FroalaEditorDirective.prototype.getEditor = function () {
          if (this._$element) {
              return this._$element.froalaEditor.bind(this._$element);
          }
          return null;
      };
      // send manual editor initialization
      FroalaEditorDirective.prototype.generateManualController = function () {
          var controls = {
              initialize: this.createEditor.bind(this),
              destroy: this.destroyEditor.bind(this),
              getEditor: this.getEditor.bind(this),
          };
          this.froalaInit.emit(controls);
      };
      // TODO not sure if ngOnInit is executed after @inputs
      FroalaEditorDirective.prototype.ngOnInit = function () {
          // check if output froalaInit is present. Maybe observers is private and should not be used?? TODO how to better test that an output directive is present.
          if (!this.froalaInit.observers.length) {
              this.createEditor();
          }
          else {
              this.generateManualController();
          }
      };
      FroalaEditorDirective.prototype.ngOnDestroy = function () {
          this.destroyEditor();
      };
      var FroalaEditorDirective_1;
      __decorate$3([
          core.Input(),
          __metadata$2("design:type", Object),
          __metadata$2("design:paramtypes", [Object])
      ], FroalaEditorDirective.prototype, "froalaEditor", null);
      __decorate$3([
          core.Input(),
          __metadata$2("design:type", Object),
          __metadata$2("design:paramtypes", [Object])
      ], FroalaEditorDirective.prototype, "froalaModel", null);
      __decorate$3([
          core.Output(),
          __metadata$2("design:type", core.EventEmitter)
      ], FroalaEditorDirective.prototype, "froalaModelChange", void 0);
      __decorate$3([
          core.Output(),
          __metadata$2("design:type", core.EventEmitter)
      ], FroalaEditorDirective.prototype, "froalaInit", void 0);
      FroalaEditorDirective = FroalaEditorDirective_1 = __decorate$3([
          core.Directive({
              selector: '[froalaEditor]',
              exportAs: 'froalaEditor',
              providers: [{
                      provide: forms.NG_VALUE_ACCESSOR, useExisting: core.forwardRef(function () { return FroalaEditorDirective_1; }),
                      multi: true
                  }]
          }),
          __metadata$2("design:paramtypes", [core.ElementRef, core.NgZone])
      ], FroalaEditorDirective);
      return FroalaEditorDirective;
  }());

  var __decorate$4 = (this && this.__decorate) || function (decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
      else
          for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                  r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var FroalaEditorModule = /** @class */ (function () {
      function FroalaEditorModule() {
      }
      FroalaEditorModule_1 = FroalaEditorModule;
      FroalaEditorModule.forRoot = function () {
          return { ngModule: FroalaEditorModule_1, providers: [] };
      };
      var FroalaEditorModule_1;
      FroalaEditorModule = FroalaEditorModule_1 = __decorate$4([
          core.NgModule({
              declarations: [FroalaEditorDirective],
              exports: [FroalaEditorDirective]
          })
      ], FroalaEditorModule);
      return FroalaEditorModule;
  }());

  var __decorate$5 = (this && this.__decorate) || function (decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
      else
          for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                  r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __metadata$3 = (this && this.__metadata) || function (k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
  };
  var FroalaViewDirective = /** @class */ (function () {
      function FroalaViewDirective(renderer, element) {
          this.renderer = renderer;
          this._element = element.nativeElement;
      }
      Object.defineProperty(FroalaViewDirective.prototype, "froalaView", {
          // update content model as it comes
          set: function (content) {
              this._element.innerHTML = content;
          },
          enumerable: true,
          configurable: true
      });
      FroalaViewDirective.prototype.ngAfterViewInit = function () {
          this.renderer.setElementClass(this._element, "fr-view", true);
      };
      __decorate$5([
          core.Input(),
          __metadata$3("design:type", String),
          __metadata$3("design:paramtypes", [String])
      ], FroalaViewDirective.prototype, "froalaView", null);
      FroalaViewDirective = __decorate$5([
          core.Directive({
              selector: '[froalaView]'
          }),
          __metadata$3("design:paramtypes", [core.Renderer, core.ElementRef])
      ], FroalaViewDirective);
      return FroalaViewDirective;
  }());

  var __decorate$6 = (this && this.__decorate) || function (decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
      else
          for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                  r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var FroalaViewModule = /** @class */ (function () {
      function FroalaViewModule() {
      }
      FroalaViewModule_1 = FroalaViewModule;
      FroalaViewModule.forRoot = function () {
          return { ngModule: FroalaViewModule_1, providers: [] };
      };
      var FroalaViewModule_1;
      FroalaViewModule = FroalaViewModule_1 = __decorate$6([
          core.NgModule({
              declarations: [FroalaViewDirective],
              exports: [FroalaViewDirective]
          })
      ], FroalaViewModule);
      return FroalaViewModule;
  }());

  var __decorate$7 = (this && this.__decorate) || function (decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
      else
          for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                  r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var MODULES = [
      FroalaEditorModule,
      FroalaViewModule
  ];
  var FERootModule = /** @class */ (function () {
      function FERootModule() {
      }
      FERootModule = __decorate$7([
          core.NgModule({
              imports: [
                  FroalaEditorModule.forRoot(),
                  FroalaViewModule.forRoot()
              ],
              exports: MODULES
          })
      ], FERootModule);
      return FERootModule;
  }());

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /** @type {?} */
  var BACKSPACE = 8;
  /** @type {?} */
  var TAB = 9;
  /** @type {?} */
  var ENTER = 13;
  /** @type {?} */
  var ESCAPE = 27;
  /** @type {?} */
  var SPACE = 32;
  /** @type {?} */
  var PAGE_UP = 33;
  /** @type {?} */
  var PAGE_DOWN = 34;
  /** @type {?} */
  var END = 35;
  /** @type {?} */
  var HOME = 36;
  /** @type {?} */
  var LEFT_ARROW = 37;
  /** @type {?} */
  var UP_ARROW = 38;
  /** @type {?} */
  var RIGHT_ARROW = 39;
  /** @type {?} */
  var DOWN_ARROW = 40;
  /** @type {?} */
  var DELETE = 46;
  /** @type {?} */
  var ZERO = 48;
  /** @type {?} */
  var NINE = 57;
  /** @type {?} */
  var A = 65;
  /** @type {?} */
  var Z = 90;
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Checks whether a modifier key is pressed.
   * @param {?} event Event to be checked.
   * @param {...?} modifiers
   * @return {?}
   */
  function hasModifierKey(event) {
      var modifiers = [];
      for (var _i = 1; _i < arguments.length; _i++) {
          modifiers[_i - 1] = arguments[_i];
      }
      if (modifiers.length) {
          return modifiers.some(function (modifier) { return event[modifier]; });
      }
      return event.altKey || event.shiftKey || event.ctrlKey || event.metaKey;
  }

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Whether the current platform supports the V8 Break Iterator. The V8 check
  // is necessary to detect all Blink based browsers.
  /** @type {?} */
  var hasV8BreakIterator = (typeof Intl !== 'undefined' && (( /** @type {?} */(Intl))).v8BreakIterator);
  /**
   * Service to detect the current platform by comparing the userAgent strings and
   * checking browser-specific global properties.
   */
  var Platform = /** @class */ (function () {
      /**
       * @breaking-change 8.0.0 remove optional decorator
       */
      function Platform(_platformId) {
          this._platformId = _platformId;
          /**
           * Whether the Angular application is being rendered in the browser.
           * We want to use the Angular platform check because if the Document is shimmed
           * without the navigator, the following checks will fail. This is preferred because
           * sometimes the Document may be shimmed without the user's knowledge or intention
           */
          this.isBrowser = this._platformId ?
              common.isPlatformBrowser(this._platformId) : typeof document === 'object' && !!document;
          /**
           * Whether the current browser is Microsoft Edge.
           */
          this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);
          /**
           * Whether the current rendering engine is Microsoft Trident.
           */
          this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);
          /**
           * Whether the current rendering engine is Blink.
           */
          // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.
          this.BLINK = this.isBrowser && (!!((( /** @type {?} */(window))).chrome || hasV8BreakIterator) &&
              typeof CSS !== 'undefined' && !this.EDGE && !this.TRIDENT);
          /**
           * Whether the current rendering engine is WebKit.
           */
          // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to
          // ensure that Webkit runs standalone and is not used as another engine's base.
          this.WEBKIT = this.isBrowser &&
              /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
          /**
           * Whether the current platform is Apple iOS.
           */
          this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&
              !('MSStream' in window);
          /**
           * Whether the current browser is Firefox.
           */
          // It's difficult to detect the plain Gecko engine, because most of the browsers identify
          // them self as Gecko-like browsers and modify the userAgent's according to that.
          // Since we only cover one explicit Firefox case, we can simply check for Firefox
          // instead of having an unstable check for Gecko.
          this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);
          /**
           * Whether the current platform is Android.
           */
          // Trident on mobile adds the android platform to the userAgent to trick detections.
          this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;
          /**
           * Whether the current browser is Safari.
           */
          // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake
          // this and just place the Safari keyword in the userAgent. To be more safe about Safari every
          // Safari browser should also use Webkit as its layout engine.
          this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
      }
      Platform.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */
      Platform.ctorParameters = function () {
          return [
              { type: Object, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.PLATFORM_ID,] }] }
          ];
      };
      /** @nocollapse */ Platform.ngInjectableDef = core.defineInjectable({ factory: function Platform_Factory() { return new Platform(core.inject(core.PLATFORM_ID, 8)); }, token: Platform, providedIn: "root" });
      return Platform;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var PlatformModule = /** @class */ (function () {
      function PlatformModule() {
      }
      PlatformModule.decorators = [
          { type: core.NgModule, args: [{},] },
      ];
      return PlatformModule;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Cached result Set of input types support by the current browser.
   * @type {?}
   */
  var supportedInputTypes;
  /**
   * Types of `<input>` that *might* be supported.
   * @type {?}
   */
  var candidateInputTypes = [
      // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after
      // first changing it to something else:
      // The specified value "" does not conform to the required format.
      // The format is "#rrggbb" where rr, gg, bb are two-digit hexadecimal numbers.
      'color',
      'button',
      'checkbox',
      'date',
      'datetime-local',
      'email',
      'file',
      'hidden',
      'image',
      'month',
      'number',
      'password',
      'radio',
      'range',
      'reset',
      'search',
      'submit',
      'tel',
      'text',
      'time',
      'url',
      'week',
  ];
  /**
   * @return {?} The input types supported by this browser.
   */
  function getSupportedInputTypes() {
      // Result is cached.
      if (supportedInputTypes) {
          return supportedInputTypes;
      }
      // We can't check if an input type is not supported until we're on the browser, so say that
      // everything is supported when not on the browser. We don't use `Platform` here since it's
      // just a helper function and can't inject it.
      if (typeof document !== 'object' || !document) {
          supportedInputTypes = new Set(candidateInputTypes);
          return supportedInputTypes;
      }
      /** @type {?} */
      var featureTestInput = document.createElement('input');
      supportedInputTypes = new Set(candidateInputTypes.filter(function (value) {
          featureTestInput.setAttribute('type', value);
          return featureTestInput.type === value;
      }));
      return supportedInputTypes;
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Cached result of whether the user's browser supports passive event listeners.
   * @type {?}
   */
  var supportsPassiveEvents;
  /**
   * Checks whether the user's browser supports passive event listeners.
   * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
   * @return {?}
   */
  function supportsPassiveEventListeners() {
      if (supportsPassiveEvents == null && typeof window !== 'undefined') {
          try {
              window.addEventListener('test', ( /** @type {?} */(null)), Object.defineProperty({}, 'passive', {
                  get: function () { return supportsPassiveEvents = true; }
              }));
          }
          finally {
              supportsPassiveEvents = supportsPassiveEvents || false;
          }
      }
      return supportsPassiveEvents;
  }
  /**
   * Normalizes an `AddEventListener` object to something that can be passed
   * to `addEventListener` on any browser, no matter whether it supports the
   * `options` parameter.
   * @param {?} options Object to be normalized.
   * @return {?}
   */
  function normalizePassiveListenerOptions(options) {
      return supportsPassiveEventListeners() ? options : !!options.capture;
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @enum {number} */
  var RtlScrollAxisType = {
      /**
       * scrollLeft is 0 when scrolled all the way left and (scrollWidth - clientWidth) when scrolled
       * all the way right.
       */
      NORMAL: 0,
      /**
       * scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and 0 when scrolled
       * all the way right.
       */
      NEGATED: 1,
      /**
       * scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and 0 when scrolled
       * all the way right.
       */
      INVERTED: 2,
  };
  RtlScrollAxisType[RtlScrollAxisType.NORMAL] = 'NORMAL';
  RtlScrollAxisType[RtlScrollAxisType.NEGATED] = 'NEGATED';
  RtlScrollAxisType[RtlScrollAxisType.INVERTED] = 'INVERTED';
  /**
   * Cached result of the way the browser handles the horizontal scroll axis in RTL mode.
   * @type {?}
   */
  var rtlScrollAxisType;
  /**
   * Check whether the browser supports scroll behaviors.
   * @return {?}
   */
  function supportsScrollBehavior() {
      return !!(typeof document == 'object' && 'scrollBehavior' in ( /** @type {?} */(document.documentElement)).style);
  }
  /**
   * Checks the type of RTL scroll axis used by this browser. As of time of writing, Chrome is NORMAL,
   * Firefox & Safari are NEGATED, and IE & Edge are INVERTED.
   * @return {?}
   */
  function getRtlScrollAxisType() {
      // We can't check unless we're on the browser. Just assume 'normal' if we're not.
      if (typeof document !== 'object' || !document) {
          return RtlScrollAxisType.NORMAL;
      }
      if (!rtlScrollAxisType) {
          // Create a 1px wide scrolling container and a 2px wide content element.
          /** @type {?} */
          var scrollContainer = document.createElement('div');
          /** @type {?} */
          var containerStyle = scrollContainer.style;
          scrollContainer.dir = 'rtl';
          containerStyle.height = '1px';
          containerStyle.width = '1px';
          containerStyle.overflow = 'auto';
          containerStyle.visibility = 'hidden';
          containerStyle.pointerEvents = 'none';
          containerStyle.position = 'absolute';
          /** @type {?} */
          var content = document.createElement('div');
          /** @type {?} */
          var contentStyle = content.style;
          contentStyle.width = '2px';
          contentStyle.height = '1px';
          scrollContainer.appendChild(content);
          document.body.appendChild(scrollContainer);
          rtlScrollAxisType = RtlScrollAxisType.NORMAL;
          // The viewport starts scrolled all the way to the right in RTL mode. If we are in a NORMAL
          // browser this would mean that the scrollLeft should be 1. If it's zero instead we know we're
          // dealing with one of the other two types of browsers.
          if (scrollContainer.scrollLeft === 0) {
              // In a NEGATED browser the scrollLeft is always somewhere in [-maxScrollAmount, 0]. For an
              // INVERTED browser it is always somewhere in [0, maxScrollAmount]. We can determine which by
              // setting to the scrollLeft to 1. This is past the max for a NEGATED browser, so it will
              // return 0 when we read it again.
              scrollContainer.scrollLeft = 1;
              rtlScrollAxisType =
                  scrollContainer.scrollLeft === 0 ? RtlScrollAxisType.NEGATED : RtlScrollAxisType.INVERTED;
          }
          ( /** @type {?} */(scrollContainer.parentNode)).removeChild(scrollContainer);
      }
      return rtlScrollAxisType;
  }

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Coerces a data-bound value (typically a string) to a boolean.
   * @param {?} value
   * @return {?}
   */
  function coerceBooleanProperty(value) {
      return value != null && "" + value !== 'false';
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @param {?} value
   * @param {?=} fallbackValue
   * @return {?}
   */
  function coerceNumberProperty(value, fallbackValue) {
      if (fallbackValue === void 0) {
          fallbackValue = 0;
      }
      return _isNumberValue(value) ? Number(value) : fallbackValue;
  }
  /**
   * Whether the provided value is considered a number.
   * \@docs-private
   * @param {?} value
   * @return {?}
   */
  function _isNumberValue(value) {
      // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,
      // and other non-number values as NaN, where Number just uses 0) but it considers the string
      // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.
      return !isNaN(parseFloat(( /** @type {?} */(value)))) && !isNaN(Number(value));
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Wraps the provided value in an array, unless the provided value is an array.
   * @template T
   * @param {?} value
   * @return {?}
   */
  function coerceArray(value) {
      return Array.isArray(value) ? value : [value];
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Coerces a value to a CSS pixel value.
   * @param {?} value
   * @return {?}
   */
  function coerceCssPixelValue(value) {
      if (value == null) {
          return '';
      }
      return typeof value === 'string' ? value : value + "px";
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Coerces an ElementRef or an Element into an element.
   * Useful for APIs that can accept either a ref or the native element itself.
   * @template T
   * @param {?} elementOrRef
   * @return {?}
   */
  function coerceElement(elementOrRef) {
      return elementOrRef instanceof core.ElementRef ? elementOrRef.nativeElement : elementOrRef;
  }

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.
   * \@docs-private
   */
  var MutationObserverFactory = /** @class */ (function () {
      function MutationObserverFactory() {
      }
      /**
       * @param {?} callback
       * @return {?}
       */
      MutationObserverFactory.prototype.create = /**
       * @param {?} callback
       * @return {?}
       */
          function (callback) {
              return typeof MutationObserver === 'undefined' ? null : new MutationObserver(callback);
          };
      MutationObserverFactory.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */ MutationObserverFactory.ngInjectableDef = core.defineInjectable({ factory: function MutationObserverFactory_Factory() { return new MutationObserverFactory(); }, token: MutationObserverFactory, providedIn: "root" });
      return MutationObserverFactory;
  }());
  /**
   * An injectable service that allows watching elements for changes to their content.
   */
  var ContentObserver = /** @class */ (function () {
      function ContentObserver(_mutationObserverFactory) {
          this._mutationObserverFactory = _mutationObserverFactory;
          /**
           * Keeps track of the existing MutationObservers so they can be reused.
           */
          this._observedElements = new Map();
      }
      /**
       * @return {?}
       */
      ContentObserver.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._observedElements.forEach(function (_, element) { return _this._cleanupObserver(element); });
          };
      /**
       * @param {?} elementOrRef
       * @return {?}
       */
      ContentObserver.prototype.observe = /**
       * @param {?} elementOrRef
       * @return {?}
       */
          function (elementOrRef) {
              var _this = this;
              /** @type {?} */
              var element = coerceElement(elementOrRef);
              return new rxjs.Observable(function (observer) {
                  /** @type {?} */
                  var stream = _this._observeElement(element);
                  /** @type {?} */
                  var subscription = stream.subscribe(observer);
                  return function () {
                      subscription.unsubscribe();
                      _this._unobserveElement(element);
                  };
              });
          };
      /**
       * Observes the given element by using the existing MutationObserver if available, or creating a
       * new one if not.
       */
      /**
       * Observes the given element by using the existing MutationObserver if available, or creating a
       * new one if not.
       * @private
       * @param {?} element
       * @return {?}
       */
      ContentObserver.prototype._observeElement = /**
       * Observes the given element by using the existing MutationObserver if available, or creating a
       * new one if not.
       * @private
       * @param {?} element
       * @return {?}
       */
          function (element) {
              if (!this._observedElements.has(element)) {
                  /** @type {?} */
                  var stream_1 = new rxjs.Subject();
                  /** @type {?} */
                  var observer = this._mutationObserverFactory.create(function (mutations) { return stream_1.next(mutations); });
                  if (observer) {
                      observer.observe(element, {
                          characterData: true,
                          childList: true,
                          subtree: true
                      });
                  }
                  this._observedElements.set(element, { observer: observer, stream: stream_1, count: 1 });
              }
              else {
                  ( /** @type {?} */(this._observedElements.get(element))).count++;
              }
              return ( /** @type {?} */(this._observedElements.get(element))).stream;
          };
      /**
       * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is
       * observing this element.
       */
      /**
       * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is
       * observing this element.
       * @private
       * @param {?} element
       * @return {?}
       */
      ContentObserver.prototype._unobserveElement = /**
       * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is
       * observing this element.
       * @private
       * @param {?} element
       * @return {?}
       */
          function (element) {
              if (this._observedElements.has(element)) {
                  ( /** @type {?} */(this._observedElements.get(element))).count--;
                  if (!( /** @type {?} */(this._observedElements.get(element))).count) {
                      this._cleanupObserver(element);
                  }
              }
          };
      /** Clean up the underlying MutationObserver for the specified element. */
      /**
       * Clean up the underlying MutationObserver for the specified element.
       * @private
       * @param {?} element
       * @return {?}
       */
      ContentObserver.prototype._cleanupObserver = /**
       * Clean up the underlying MutationObserver for the specified element.
       * @private
       * @param {?} element
       * @return {?}
       */
          function (element) {
              if (this._observedElements.has(element)) {
                  var _a = ( /** @type {?} */(this._observedElements.get(element))), observer = _a.observer, stream = _a.stream;
                  if (observer) {
                      observer.disconnect();
                  }
                  stream.complete();
                  this._observedElements.delete(element);
              }
          };
      ContentObserver.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */
      ContentObserver.ctorParameters = function () {
          return [
              { type: MutationObserverFactory }
          ];
      };
      /** @nocollapse */ ContentObserver.ngInjectableDef = core.defineInjectable({ factory: function ContentObserver_Factory() { return new ContentObserver(core.inject(MutationObserverFactory)); }, token: ContentObserver, providedIn: "root" });
      return ContentObserver;
  }());
  /**
   * Directive that triggers a callback whenever the content of
   * its associated element has changed.
   */
  var CdkObserveContent = /** @class */ (function () {
      function CdkObserveContent(_contentObserver, _elementRef, _ngZone) {
          this._contentObserver = _contentObserver;
          this._elementRef = _elementRef;
          this._ngZone = _ngZone;
          /**
           * Event emitted for each change in the element's content.
           */
          this.event = new core.EventEmitter();
          this._disabled = false;
          this._currentSubscription = null;
      }
      Object.defineProperty(CdkObserveContent.prototype, "disabled", {
          /**
           * Whether observing content is disabled. This option can be used
           * to disconnect the underlying MutationObserver until it is needed.
           */
          get: /**
           * Whether observing content is disabled. This option can be used
           * to disconnect the underlying MutationObserver until it is needed.
           * @return {?}
           */ function () { return this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._disabled = coerceBooleanProperty(value);
              this._disabled ? this._unsubscribe() : this._subscribe();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkObserveContent.prototype, "debounce", {
          /** Debounce interval for emitting the changes. */
          get: /**
           * Debounce interval for emitting the changes.
           * @return {?}
           */ function () { return this._debounce; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._debounce = coerceNumberProperty(value);
              this._subscribe();
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      CdkObserveContent.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              if (!this._currentSubscription && !this.disabled) {
                  this._subscribe();
              }
          };
      /**
       * @return {?}
       */
      CdkObserveContent.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._unsubscribe();
          };
      /**
       * @private
       * @return {?}
       */
      CdkObserveContent.prototype._subscribe = /**
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              this._unsubscribe();
              /** @type {?} */
              var stream = this._contentObserver.observe(this._elementRef);
              // TODO(mmalerba): We shouldn't be emitting on this @Output() outside the zone.
              // Consider brining it back inside the zone next time we're making breaking changes.
              // Bringing it back inside can cause things like infinite change detection loops and changed
              // after checked errors if people's code isn't handling it properly.
              this._ngZone.runOutsideAngular(function () {
                  _this._currentSubscription =
                      (_this.debounce ? stream.pipe(operators.debounceTime(_this.debounce)) : stream).subscribe(_this.event);
              });
          };
      /**
       * @private
       * @return {?}
       */
      CdkObserveContent.prototype._unsubscribe = /**
       * @private
       * @return {?}
       */
          function () {
              if (this._currentSubscription) {
                  this._currentSubscription.unsubscribe();
              }
          };
      CdkObserveContent.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkObserveContent]',
                      exportAs: 'cdkObserveContent',
                  },] },
      ];
      /** @nocollapse */
      CdkObserveContent.ctorParameters = function () {
          return [
              { type: ContentObserver },
              { type: core.ElementRef },
              { type: core.NgZone }
          ];
      };
      CdkObserveContent.propDecorators = {
          event: [{ type: core.Output, args: ['cdkObserveContent',] }],
          disabled: [{ type: core.Input, args: ['cdkObserveContentDisabled',] }],
          debounce: [{ type: core.Input }]
      };
      return CdkObserveContent;
  }());

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * IDs are deliminated by an empty space, as per the spec.
   * @type {?}
   */
  var ID_DELIMINATOR = ' ';
  /**
   * Adds the given ID to the specified ARIA attribute on an element.
   * Used for attributes such as aria-labelledby, aria-owns, etc.
   * @param {?} el
   * @param {?} attr
   * @param {?} id
   * @return {?}
   */
  function addAriaReferencedId(el, attr, id) {
      /** @type {?} */
      var ids = getAriaReferenceIds(el, attr);
      if (ids.some(function (existingId) { return existingId.trim() == id.trim(); })) {
          return;
      }
      ids.push(id.trim());
      el.setAttribute(attr, ids.join(ID_DELIMINATOR));
  }
  /**
   * Removes the given ID from the specified ARIA attribute on an element.
   * Used for attributes such as aria-labelledby, aria-owns, etc.
   * @param {?} el
   * @param {?} attr
   * @param {?} id
   * @return {?}
   */
  function removeAriaReferencedId(el, attr, id) {
      /** @type {?} */
      var ids = getAriaReferenceIds(el, attr);
      /** @type {?} */
      var filteredIds = ids.filter(function (val) { return val != id.trim(); });
      el.setAttribute(attr, filteredIds.join(ID_DELIMINATOR));
  }
  /**
   * Gets the list of IDs referenced by the given ARIA attribute on an element.
   * Used for attributes such as aria-labelledby, aria-owns, etc.
   * @param {?} el
   * @param {?} attr
   * @return {?}
   */
  function getAriaReferenceIds(el, attr) {
      // Get string array of all individual ids (whitespace deliminated) in the attribute value
      return (el.getAttribute(attr) || '').match(/\S+/g) || [];
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * ID used for the body container where all messages are appended.
   * @type {?}
   */
  var MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';
  /**
   * ID prefix used for each created message element.
   * @type {?}
   */
  var CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';
  /**
   * Attribute given to each host element that is described by a message element.
   * @type {?}
   */
  var CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';
  /**
   * Global incremental identifier for each registered message element.
   * @type {?}
   */
  var nextId = 0;
  /**
   * Global map of all registered message elements that have been placed into the document.
   * @type {?}
   */
  var messageRegistry = new Map();
  /**
   * Container for all registered messages.
   * @type {?}
   */
  var messagesContainer = null;
  /**
   * Utility that creates visually hidden elements with a message content. Useful for elements that
   * want to use aria-describedby to further describe themselves without adding additional visual
   * content.
   * \@docs-private
   */
  var AriaDescriber = /** @class */ (function () {
      function AriaDescriber(_document) {
          this._document = _document;
      }
      /**
       * Adds to the host element an aria-describedby reference to a hidden element that contains
       * the message. If the same message has already been registered, then it will reuse the created
       * message element.
       */
      /**
       * Adds to the host element an aria-describedby reference to a hidden element that contains
       * the message. If the same message has already been registered, then it will reuse the created
       * message element.
       * @param {?} hostElement
       * @param {?} message
       * @return {?}
       */
      AriaDescriber.prototype.describe = /**
       * Adds to the host element an aria-describedby reference to a hidden element that contains
       * the message. If the same message has already been registered, then it will reuse the created
       * message element.
       * @param {?} hostElement
       * @param {?} message
       * @return {?}
       */
          function (hostElement, message) {
              if (!this._canBeDescribed(hostElement, message)) {
                  return;
              }
              if (!messageRegistry.has(message)) {
                  this._createMessageElement(message);
              }
              if (!this._isElementDescribedByMessage(hostElement, message)) {
                  this._addMessageReference(hostElement, message);
              }
          };
      /** Removes the host element's aria-describedby reference to the message element. */
      /**
       * Removes the host element's aria-describedby reference to the message element.
       * @param {?} hostElement
       * @param {?} message
       * @return {?}
       */
      AriaDescriber.prototype.removeDescription = /**
       * Removes the host element's aria-describedby reference to the message element.
       * @param {?} hostElement
       * @param {?} message
       * @return {?}
       */
          function (hostElement, message) {
              if (!this._canBeDescribed(hostElement, message)) {
                  return;
              }
              if (this._isElementDescribedByMessage(hostElement, message)) {
                  this._removeMessageReference(hostElement, message);
              }
              /** @type {?} */
              var registeredMessage = messageRegistry.get(message);
              if (registeredMessage && registeredMessage.referenceCount === 0) {
                  this._deleteMessageElement(message);
              }
              if (messagesContainer && messagesContainer.childNodes.length === 0) {
                  this._deleteMessagesContainer();
              }
          };
      /** Unregisters all created message elements and removes the message container. */
      /**
       * Unregisters all created message elements and removes the message container.
       * @return {?}
       */
      AriaDescriber.prototype.ngOnDestroy = /**
       * Unregisters all created message elements and removes the message container.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var describedElements = this._document.querySelectorAll("[" + CDK_DESCRIBEDBY_HOST_ATTRIBUTE + "]");
              for (var i = 0; i < describedElements.length; i++) {
                  this._removeCdkDescribedByReferenceIds(describedElements[i]);
                  describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
              }
              if (messagesContainer) {
                  this._deleteMessagesContainer();
              }
              messageRegistry.clear();
          };
      /**
       * Creates a new element in the visually hidden message container element with the message
       * as its content and adds it to the message registry.
       */
      /**
       * Creates a new element in the visually hidden message container element with the message
       * as its content and adds it to the message registry.
       * @private
       * @param {?} message
       * @return {?}
       */
      AriaDescriber.prototype._createMessageElement = /**
       * Creates a new element in the visually hidden message container element with the message
       * as its content and adds it to the message registry.
       * @private
       * @param {?} message
       * @return {?}
       */
          function (message) {
              /** @type {?} */
              var messageElement = this._document.createElement('div');
              messageElement.setAttribute('id', CDK_DESCRIBEDBY_ID_PREFIX + "-" + nextId++);
              messageElement.appendChild(( /** @type {?} */(this._document.createTextNode(message))));
              this._createMessagesContainer();
              ( /** @type {?} */(messagesContainer)).appendChild(messageElement);
              messageRegistry.set(message, { messageElement: messageElement, referenceCount: 0 });
          };
      /** Deletes the message element from the global messages container. */
      /**
       * Deletes the message element from the global messages container.
       * @private
       * @param {?} message
       * @return {?}
       */
      AriaDescriber.prototype._deleteMessageElement = /**
       * Deletes the message element from the global messages container.
       * @private
       * @param {?} message
       * @return {?}
       */
          function (message) {
              /** @type {?} */
              var registeredMessage = messageRegistry.get(message);
              /** @type {?} */
              var messageElement = registeredMessage && registeredMessage.messageElement;
              if (messagesContainer && messageElement) {
                  messagesContainer.removeChild(messageElement);
              }
              messageRegistry.delete(message);
          };
      /** Creates the global container for all aria-describedby messages. */
      /**
       * Creates the global container for all aria-describedby messages.
       * @private
       * @return {?}
       */
      AriaDescriber.prototype._createMessagesContainer = /**
       * Creates the global container for all aria-describedby messages.
       * @private
       * @return {?}
       */
          function () {
              if (!messagesContainer) {
                  /** @type {?} */
                  var preExistingContainer = this._document.getElementById(MESSAGES_CONTAINER_ID);
                  // When going from the server to the client, we may end up in a situation where there's
                  // already a container on the page, but we don't have a reference to it. Clear the
                  // old container so we don't get duplicates. Doing this, instead of emptying the previous
                  // container, should be slightly faster.
                  if (preExistingContainer) {
                      ( /** @type {?} */(preExistingContainer.parentNode)).removeChild(preExistingContainer);
                  }
                  messagesContainer = this._document.createElement('div');
                  messagesContainer.id = MESSAGES_CONTAINER_ID;
                  messagesContainer.setAttribute('aria-hidden', 'true');
                  messagesContainer.style.display = 'none';
                  this._document.body.appendChild(messagesContainer);
              }
          };
      /** Deletes the global messages container. */
      /**
       * Deletes the global messages container.
       * @private
       * @return {?}
       */
      AriaDescriber.prototype._deleteMessagesContainer = /**
       * Deletes the global messages container.
       * @private
       * @return {?}
       */
          function () {
              if (messagesContainer && messagesContainer.parentNode) {
                  messagesContainer.parentNode.removeChild(messagesContainer);
                  messagesContainer = null;
              }
          };
      /** Removes all cdk-describedby messages that are hosted through the element. */
      /**
       * Removes all cdk-describedby messages that are hosted through the element.
       * @private
       * @param {?} element
       * @return {?}
       */
      AriaDescriber.prototype._removeCdkDescribedByReferenceIds = /**
       * Removes all cdk-describedby messages that are hosted through the element.
       * @private
       * @param {?} element
       * @return {?}
       */
          function (element) {
              // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX
              /** @type {?} */
              var originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')
                  .filter(function (id) { return id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0; });
              element.setAttribute('aria-describedby', originalReferenceIds.join(' '));
          };
      /**
       * Adds a message reference to the element using aria-describedby and increments the registered
       * message's reference count.
       */
      /**
       * Adds a message reference to the element using aria-describedby and increments the registered
       * message's reference count.
       * @private
       * @param {?} element
       * @param {?} message
       * @return {?}
       */
      AriaDescriber.prototype._addMessageReference = /**
       * Adds a message reference to the element using aria-describedby and increments the registered
       * message's reference count.
       * @private
       * @param {?} element
       * @param {?} message
       * @return {?}
       */
          function (element, message) {
              /** @type {?} */
              var registeredMessage = ( /** @type {?} */(messageRegistry.get(message)));
              // Add the aria-describedby reference and set the
              // describedby_host attribute to mark the element.
              addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);
              element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');
              registeredMessage.referenceCount++;
          };
      /**
       * Removes a message reference from the element using aria-describedby
       * and decrements the registered message's reference count.
       */
      /**
       * Removes a message reference from the element using aria-describedby
       * and decrements the registered message's reference count.
       * @private
       * @param {?} element
       * @param {?} message
       * @return {?}
       */
      AriaDescriber.prototype._removeMessageReference = /**
       * Removes a message reference from the element using aria-describedby
       * and decrements the registered message's reference count.
       * @private
       * @param {?} element
       * @param {?} message
       * @return {?}
       */
          function (element, message) {
              /** @type {?} */
              var registeredMessage = ( /** @type {?} */(messageRegistry.get(message)));
              registeredMessage.referenceCount--;
              removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);
              element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
          };
      /** Returns true if the element has been described by the provided message ID. */
      /**
       * Returns true if the element has been described by the provided message ID.
       * @private
       * @param {?} element
       * @param {?} message
       * @return {?}
       */
      AriaDescriber.prototype._isElementDescribedByMessage = /**
       * Returns true if the element has been described by the provided message ID.
       * @private
       * @param {?} element
       * @param {?} message
       * @return {?}
       */
          function (element, message) {
              /** @type {?} */
              var referenceIds = getAriaReferenceIds(element, 'aria-describedby');
              /** @type {?} */
              var registeredMessage = messageRegistry.get(message);
              /** @type {?} */
              var messageId = registeredMessage && registeredMessage.messageElement.id;
              return !!messageId && referenceIds.indexOf(messageId) != -1;
          };
      /** Determines whether a message can be described on a particular element. */
      /**
       * Determines whether a message can be described on a particular element.
       * @private
       * @param {?} element
       * @param {?} message
       * @return {?}
       */
      AriaDescriber.prototype._canBeDescribed = /**
       * Determines whether a message can be described on a particular element.
       * @private
       * @param {?} element
       * @param {?} message
       * @return {?}
       */
          function (element, message) {
              return element.nodeType === this._document.ELEMENT_NODE && message != null &&
                  !!("" + message).trim();
          };
      AriaDescriber.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */
      AriaDescriber.ctorParameters = function () {
          return [
              { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
          ];
      };
      /** @nocollapse */ AriaDescriber.ngInjectableDef = core.defineInjectable({ factory: function AriaDescriber_Factory() { return new AriaDescriber(core.inject(common.DOCUMENT)); }, token: AriaDescriber, providedIn: "root" });
      return AriaDescriber;
  }());
  /**
   * \@docs-private \@deprecated \@breaking-change 8.0.0
   * @param {?} parentDispatcher
   * @param {?} _document
   * @return {?}
   */
  function ARIA_DESCRIBER_PROVIDER_FACTORY(parentDispatcher, _document) {
      return parentDispatcher || new AriaDescriber(_document);
  }
  /**
   * \@docs-private \@deprecated \@breaking-change 8.0.0
   * @type {?}
   */
  var ARIA_DESCRIBER_PROVIDER = {
      // If there is already an AriaDescriber available, use that. Otherwise, provide a new one.
      provide: AriaDescriber,
      deps: [
          [new core.Optional(), new core.SkipSelf(), AriaDescriber],
          ( /** @type {?} */(common.DOCUMENT))
      ],
      useFactory: ARIA_DESCRIBER_PROVIDER_FACTORY
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * This class manages keyboard events for selectable lists. If you pass it a query list
   * of items, it will set the active item correctly when arrow events occur.
   * @template T
   */
  var /**
   * This class manages keyboard events for selectable lists. If you pass it a query list
   * of items, it will set the active item correctly when arrow events occur.
   * @template T
   */ ListKeyManager = /** @class */ (function () {
      function ListKeyManager(_items) {
          var _this = this;
          this._items = _items;
          this._activeItemIndex = -1;
          this._activeItem = null;
          this._wrap = false;
          this._letterKeyStream = new rxjs.Subject();
          this._typeaheadSubscription = rxjs.Subscription.EMPTY;
          this._vertical = true;
          this._allowedModifierKeys = [];
          /**
           * Predicate function that can be used to check whether an item should be skipped
           * by the key manager. By default, disabled items are skipped.
           */
          this._skipPredicateFn = function (item) { return item.disabled; };
          // Buffer for the letters that the user has pressed when the typeahead option is turned on.
          this._pressedLetters = [];
          /**
           * Stream that emits any time the TAB key is pressed, so components can react
           * when focus is shifted off of the list.
           */
          this.tabOut = new rxjs.Subject();
          /**
           * Stream that emits whenever the active item of the list manager changes.
           */
          this.change = new rxjs.Subject();
          // We allow for the items to be an array because, in some cases, the consumer may
          // not have access to a QueryList of the items they want to manage (e.g. when the
          // items aren't being collected via `ViewChildren` or `ContentChildren`).
          if (_items instanceof core.QueryList) {
              _items.changes.subscribe(function (newItems) {
                  if (_this._activeItem) {
                      /** @type {?} */
                      var itemArray = newItems.toArray();
                      /** @type {?} */
                      var newIndex = itemArray.indexOf(_this._activeItem);
                      if (newIndex > -1 && newIndex !== _this._activeItemIndex) {
                          _this._activeItemIndex = newIndex;
                      }
                  }
              });
          }
      }
      /**
       * Sets the predicate function that determines which items should be skipped by the
       * list key manager.
       * @param predicate Function that determines whether the given item should be skipped.
       */
      /**
       * Sets the predicate function that determines which items should be skipped by the
       * list key manager.
       * @template THIS
       * @this {THIS}
       * @param {?} predicate Function that determines whether the given item should be skipped.
       * @return {THIS}
       */
      ListKeyManager.prototype.skipPredicate = /**
       * Sets the predicate function that determines which items should be skipped by the
       * list key manager.
       * @template THIS
       * @this {THIS}
       * @param {?} predicate Function that determines whether the given item should be skipped.
       * @return {THIS}
       */
          function (predicate) {
              ( /** @type {?} */(this))._skipPredicateFn = predicate;
              return ( /** @type {?} */(this));
          };
      /**
       * Configures wrapping mode, which determines whether the active item will wrap to
       * the other end of list when there are no more items in the given direction.
       * @param shouldWrap Whether the list should wrap when reaching the end.
       */
      /**
       * Configures wrapping mode, which determines whether the active item will wrap to
       * the other end of list when there are no more items in the given direction.
       * @template THIS
       * @this {THIS}
       * @param {?=} shouldWrap Whether the list should wrap when reaching the end.
       * @return {THIS}
       */
      ListKeyManager.prototype.withWrap = /**
       * Configures wrapping mode, which determines whether the active item will wrap to
       * the other end of list when there are no more items in the given direction.
       * @template THIS
       * @this {THIS}
       * @param {?=} shouldWrap Whether the list should wrap when reaching the end.
       * @return {THIS}
       */
          function (shouldWrap) {
              if (shouldWrap === void 0) {
                  shouldWrap = true;
              }
              ( /** @type {?} */(this))._wrap = shouldWrap;
              return ( /** @type {?} */(this));
          };
      /**
       * Configures whether the key manager should be able to move the selection vertically.
       * @param enabled Whether vertical selection should be enabled.
       */
      /**
       * Configures whether the key manager should be able to move the selection vertically.
       * @template THIS
       * @this {THIS}
       * @param {?=} enabled Whether vertical selection should be enabled.
       * @return {THIS}
       */
      ListKeyManager.prototype.withVerticalOrientation = /**
       * Configures whether the key manager should be able to move the selection vertically.
       * @template THIS
       * @this {THIS}
       * @param {?=} enabled Whether vertical selection should be enabled.
       * @return {THIS}
       */
          function (enabled) {
              if (enabled === void 0) {
                  enabled = true;
              }
              ( /** @type {?} */(this))._vertical = enabled;
              return ( /** @type {?} */(this));
          };
      /**
       * Configures the key manager to move the selection horizontally.
       * Passing in `null` will disable horizontal movement.
       * @param direction Direction in which the selection can be moved.
       */
      /**
       * Configures the key manager to move the selection horizontally.
       * Passing in `null` will disable horizontal movement.
       * @template THIS
       * @this {THIS}
       * @param {?} direction Direction in which the selection can be moved.
       * @return {THIS}
       */
      ListKeyManager.prototype.withHorizontalOrientation = /**
       * Configures the key manager to move the selection horizontally.
       * Passing in `null` will disable horizontal movement.
       * @template THIS
       * @this {THIS}
       * @param {?} direction Direction in which the selection can be moved.
       * @return {THIS}
       */
          function (direction) {
              ( /** @type {?} */(this))._horizontal = direction;
              return ( /** @type {?} */(this));
          };
      /**
       * Modifier keys which are allowed to be held down and whose default actions will be prevented
       * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.
       */
      /**
       * Modifier keys which are allowed to be held down and whose default actions will be prevented
       * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.
       * @template THIS
       * @this {THIS}
       * @param {?} keys
       * @return {THIS}
       */
      ListKeyManager.prototype.withAllowedModifierKeys = /**
       * Modifier keys which are allowed to be held down and whose default actions will be prevented
       * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.
       * @template THIS
       * @this {THIS}
       * @param {?} keys
       * @return {THIS}
       */
          function (keys) {
              ( /** @type {?} */(this))._allowedModifierKeys = keys;
              return ( /** @type {?} */(this));
          };
      /**
       * Turns on typeahead mode which allows users to set the active item by typing.
       * @param debounceInterval Time to wait after the last keystroke before setting the active item.
       */
      /**
       * Turns on typeahead mode which allows users to set the active item by typing.
       * @template THIS
       * @this {THIS}
       * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.
       * @return {THIS}
       */
      ListKeyManager.prototype.withTypeAhead = /**
       * Turns on typeahead mode which allows users to set the active item by typing.
       * @template THIS
       * @this {THIS}
       * @param {?=} debounceInterval Time to wait after the last keystroke before setting the active item.
       * @return {THIS}
       */
          function (debounceInterval) {
              var _this = this;
              if (debounceInterval === void 0) {
                  debounceInterval = 200;
              }
              if (( /** @type {?} */(this))._items.length && ( /** @type {?} */(this))._items.some(function (item) { return typeof item.getLabel !== 'function'; })) {
                  throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');
              }
              ( /** @type {?} */(this))._typeaheadSubscription.unsubscribe();
              // Debounce the presses of non-navigational keys, collect the ones that correspond to letters
              // and convert those letters back into a string. Afterwards find the first item that starts
              // with that string and select it.
              ( /** @type {?} */(this))._typeaheadSubscription = ( /** @type {?} */(this))._letterKeyStream.pipe(operators.tap(function (keyCode) { return ( /** @type {?} */(_this))._pressedLetters.push(keyCode); }), operators.debounceTime(debounceInterval), operators.filter(function () { return ( /** @type {?} */(_this))._pressedLetters.length > 0; }), operators.map(function () { return ( /** @type {?} */(_this))._pressedLetters.join(''); })).subscribe(function (inputString) {
                  /** @type {?} */
                  var items = ( /** @type {?} */(_this))._getItemsArray();
                  // Start at 1 because we want to start searching at the item immediately
                  // following the current active item.
                  for (var i = 1; i < items.length + 1; i++) {
                      /** @type {?} */
                      var index = (( /** @type {?} */(_this))._activeItemIndex + i) % items.length;
                      /** @type {?} */
                      var item = items[index];
                      if (!( /** @type {?} */(_this))._skipPredicateFn(item) &&
                          ( /** @type {?} */(item.getLabel))().toUpperCase().trim().indexOf(inputString) === 0) {
                          ( /** @type {?} */(_this)).setActiveItem(index);
                          break;
                      }
                  }
                  ( /** @type {?} */(_this))._pressedLetters = [];
              });
              return ( /** @type {?} */(this));
          };
      /**
       * @param {?} item
       * @return {?}
       */
      ListKeyManager.prototype.setActiveItem = /**
       * @param {?} item
       * @return {?}
       */
          function (item) {
              /** @type {?} */
              var previousIndex = this._activeItemIndex;
              this.updateActiveItem(item);
              if (this._activeItemIndex !== previousIndex) {
                  this.change.next(this._activeItemIndex);
              }
          };
      /**
       * Sets the active item depending on the key event passed in.
       * @param event Keyboard event to be used for determining which element should be active.
       */
      /**
       * Sets the active item depending on the key event passed in.
       * @param {?} event Keyboard event to be used for determining which element should be active.
       * @return {?}
       */
      ListKeyManager.prototype.onKeydown = /**
       * Sets the active item depending on the key event passed in.
       * @param {?} event Keyboard event to be used for determining which element should be active.
       * @return {?}
       */
          function (event) {
              var _this = this;
              /** @type {?} */
              var keyCode = event.keyCode;
              /** @type {?} */
              var modifiers = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];
              /** @type {?} */
              var isModifierAllowed = modifiers.every(function (modifier) {
                  return !event[modifier] || _this._allowedModifierKeys.indexOf(modifier) > -1;
              });
              switch (keyCode) {
                  case TAB:
                      this.tabOut.next();
                      return;
                  case DOWN_ARROW:
                      if (this._vertical && isModifierAllowed) {
                          this.setNextItemActive();
                          break;
                      }
                      else {
                          return;
                      }
                  case UP_ARROW:
                      if (this._vertical && isModifierAllowed) {
                          this.setPreviousItemActive();
                          break;
                      }
                      else {
                          return;
                      }
                  case RIGHT_ARROW:
                      if (this._horizontal && isModifierAllowed) {
                          this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();
                          break;
                      }
                      else {
                          return;
                      }
                  case LEFT_ARROW:
                      if (this._horizontal && isModifierAllowed) {
                          this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();
                          break;
                      }
                      else {
                          return;
                      }
                  default:
                      if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {
                          // Attempt to use the `event.key` which also maps it to the user's keyboard language,
                          // otherwise fall back to resolving alphanumeric characters via the keyCode.
                          if (event.key && event.key.length === 1) {
                              this._letterKeyStream.next(event.key.toLocaleUpperCase());
                          }
                          else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {
                              this._letterKeyStream.next(String.fromCharCode(keyCode));
                          }
                      }
                      // Note that we return here, in order to avoid preventing
                      // the default action of non-navigational keys.
                      return;
              }
              this._pressedLetters = [];
              event.preventDefault();
          };
      Object.defineProperty(ListKeyManager.prototype, "activeItemIndex", {
          /** Index of the currently active item. */
          get: /**
           * Index of the currently active item.
           * @return {?}
           */ function () {
              return this._activeItemIndex;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(ListKeyManager.prototype, "activeItem", {
          /** The active item. */
          get: /**
           * The active item.
           * @return {?}
           */ function () {
              return this._activeItem;
          },
          enumerable: true,
          configurable: true
      });
      /** Sets the active item to the first enabled item in the list. */
      /**
       * Sets the active item to the first enabled item in the list.
       * @return {?}
       */
      ListKeyManager.prototype.setFirstItemActive = /**
       * Sets the active item to the first enabled item in the list.
       * @return {?}
       */
          function () {
              this._setActiveItemByIndex(0, 1);
          };
      /** Sets the active item to the last enabled item in the list. */
      /**
       * Sets the active item to the last enabled item in the list.
       * @return {?}
       */
      ListKeyManager.prototype.setLastItemActive = /**
       * Sets the active item to the last enabled item in the list.
       * @return {?}
       */
          function () {
              this._setActiveItemByIndex(this._items.length - 1, -1);
          };
      /** Sets the active item to the next enabled item in the list. */
      /**
       * Sets the active item to the next enabled item in the list.
       * @return {?}
       */
      ListKeyManager.prototype.setNextItemActive = /**
       * Sets the active item to the next enabled item in the list.
       * @return {?}
       */
          function () {
              this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);
          };
      /** Sets the active item to a previous enabled item in the list. */
      /**
       * Sets the active item to a previous enabled item in the list.
       * @return {?}
       */
      ListKeyManager.prototype.setPreviousItemActive = /**
       * Sets the active item to a previous enabled item in the list.
       * @return {?}
       */
          function () {
              this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()
                  : this._setActiveItemByDelta(-1);
          };
      /**
       * @param {?} item
       * @return {?}
       */
      ListKeyManager.prototype.updateActiveItem = /**
       * @param {?} item
       * @return {?}
       */
          function (item) {
              /** @type {?} */
              var itemArray = this._getItemsArray();
              /** @type {?} */
              var index = typeof item === 'number' ? item : itemArray.indexOf(item);
              /** @type {?} */
              var activeItem = itemArray[index];
              // Explicitly check for `null` and `undefined` because other falsy values are valid.
              this._activeItem = activeItem == null ? null : activeItem;
              this._activeItemIndex = index;
          };
      /**
       * Allows setting of the activeItemIndex without any other effects.
       * @param index The new activeItemIndex.
       * @deprecated Use `updateActiveItem` instead.
       * @breaking-change 8.0.0
       */
      /**
       * Allows setting of the activeItemIndex without any other effects.
       * @deprecated Use `updateActiveItem` instead.
       * \@breaking-change 8.0.0
       * @param {?} index The new activeItemIndex.
       * @return {?}
       */
      ListKeyManager.prototype.updateActiveItemIndex = /**
       * Allows setting of the activeItemIndex without any other effects.
       * @deprecated Use `updateActiveItem` instead.
       * \@breaking-change 8.0.0
       * @param {?} index The new activeItemIndex.
       * @return {?}
       */
          function (index) {
              this.updateActiveItem(index);
          };
      /**
       * This method sets the active item, given a list of items and the delta between the
       * currently active item and the new active item. It will calculate differently
       * depending on whether wrap mode is turned on.
       */
      /**
       * This method sets the active item, given a list of items and the delta between the
       * currently active item and the new active item. It will calculate differently
       * depending on whether wrap mode is turned on.
       * @private
       * @param {?} delta
       * @return {?}
       */
      ListKeyManager.prototype._setActiveItemByDelta = /**
       * This method sets the active item, given a list of items and the delta between the
       * currently active item and the new active item. It will calculate differently
       * depending on whether wrap mode is turned on.
       * @private
       * @param {?} delta
       * @return {?}
       */
          function (delta) {
              this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);
          };
      /**
       * Sets the active item properly given "wrap" mode. In other words, it will continue to move
       * down the list until it finds an item that is not disabled, and it will wrap if it
       * encounters either end of the list.
       */
      /**
       * Sets the active item properly given "wrap" mode. In other words, it will continue to move
       * down the list until it finds an item that is not disabled, and it will wrap if it
       * encounters either end of the list.
       * @private
       * @param {?} delta
       * @return {?}
       */
      ListKeyManager.prototype._setActiveInWrapMode = /**
       * Sets the active item properly given "wrap" mode. In other words, it will continue to move
       * down the list until it finds an item that is not disabled, and it will wrap if it
       * encounters either end of the list.
       * @private
       * @param {?} delta
       * @return {?}
       */
          function (delta) {
              /** @type {?} */
              var items = this._getItemsArray();
              for (var i = 1; i <= items.length; i++) {
                  /** @type {?} */
                  var index = (this._activeItemIndex + (delta * i) + items.length) % items.length;
                  /** @type {?} */
                  var item = items[index];
                  if (!this._skipPredicateFn(item)) {
                      this.setActiveItem(index);
                      return;
                  }
              }
          };
      /**
       * Sets the active item properly given the default mode. In other words, it will
       * continue to move down the list until it finds an item that is not disabled. If
       * it encounters either end of the list, it will stop and not wrap.
       */
      /**
       * Sets the active item properly given the default mode. In other words, it will
       * continue to move down the list until it finds an item that is not disabled. If
       * it encounters either end of the list, it will stop and not wrap.
       * @private
       * @param {?} delta
       * @return {?}
       */
      ListKeyManager.prototype._setActiveInDefaultMode = /**
       * Sets the active item properly given the default mode. In other words, it will
       * continue to move down the list until it finds an item that is not disabled. If
       * it encounters either end of the list, it will stop and not wrap.
       * @private
       * @param {?} delta
       * @return {?}
       */
          function (delta) {
              this._setActiveItemByIndex(this._activeItemIndex + delta, delta);
          };
      /**
       * Sets the active item to the first enabled item starting at the index specified. If the
       * item is disabled, it will move in the fallbackDelta direction until it either
       * finds an enabled item or encounters the end of the list.
       */
      /**
       * Sets the active item to the first enabled item starting at the index specified. If the
       * item is disabled, it will move in the fallbackDelta direction until it either
       * finds an enabled item or encounters the end of the list.
       * @private
       * @param {?} index
       * @param {?} fallbackDelta
       * @return {?}
       */
      ListKeyManager.prototype._setActiveItemByIndex = /**
       * Sets the active item to the first enabled item starting at the index specified. If the
       * item is disabled, it will move in the fallbackDelta direction until it either
       * finds an enabled item or encounters the end of the list.
       * @private
       * @param {?} index
       * @param {?} fallbackDelta
       * @return {?}
       */
          function (index, fallbackDelta) {
              /** @type {?} */
              var items = this._getItemsArray();
              if (!items[index]) {
                  return;
              }
              while (this._skipPredicateFn(items[index])) {
                  index += fallbackDelta;
                  if (!items[index]) {
                      return;
                  }
              }
              this.setActiveItem(index);
          };
      /** Returns the items as an array. */
      /**
       * Returns the items as an array.
       * @private
       * @return {?}
       */
      ListKeyManager.prototype._getItemsArray = /**
       * Returns the items as an array.
       * @private
       * @return {?}
       */
          function () {
              return this._items instanceof core.QueryList ? this._items.toArray() : this._items;
          };
      return ListKeyManager;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @template T
   */
  var /**
   * @template T
   */ ActiveDescendantKeyManager = /** @class */ (function (_super) {
      tslib_1.__extends(ActiveDescendantKeyManager, _super);
      function ActiveDescendantKeyManager() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * @param {?} index
       * @return {?}
       */
      ActiveDescendantKeyManager.prototype.setActiveItem = /**
       * @param {?} index
       * @return {?}
       */
          function (index) {
              if (this.activeItem) {
                  this.activeItem.setInactiveStyles();
              }
              _super.prototype.setActiveItem.call(this, index);
              if (this.activeItem) {
                  this.activeItem.setActiveStyles();
              }
          };
      return ActiveDescendantKeyManager;
  }(ListKeyManager));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @template T
   */
  var /**
   * @template T
   */ FocusKeyManager = /** @class */ (function (_super) {
      tslib_1.__extends(FocusKeyManager, _super);
      function FocusKeyManager() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this._origin = 'program';
          return _this;
      }
      /**
       * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.
       * @param origin Focus origin to be used when focusing items.
       */
      /**
       * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.
       * @template THIS
       * @this {THIS}
       * @param {?} origin Focus origin to be used when focusing items.
       * @return {THIS}
       */
      FocusKeyManager.prototype.setFocusOrigin = /**
       * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.
       * @template THIS
       * @this {THIS}
       * @param {?} origin Focus origin to be used when focusing items.
       * @return {THIS}
       */
          function (origin) {
              ( /** @type {?} */(this))._origin = origin;
              return ( /** @type {?} */(this));
          };
      /**
       * @param {?} item
       * @return {?}
       */
      FocusKeyManager.prototype.setActiveItem = /**
       * @param {?} item
       * @return {?}
       */
          function (item) {
              _super.prototype.setActiveItem.call(this, item);
              if (this.activeItem) {
                  this.activeItem.focus(this._origin);
              }
          };
      return FocusKeyManager;
  }(ListKeyManager));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // The InteractivityChecker leans heavily on the ally.js accessibility utilities.
  // Methods like `isTabbable` are only covering specific edge-cases for the browsers which are
  // supported.
  /**
   * Utility for checking the interactivity of an element, such as whether is is focusable or
   * tabbable.
   */
  var InteractivityChecker = /** @class */ (function () {
      function InteractivityChecker(_platform) {
          this._platform = _platform;
      }
      /**
       * Gets whether an element is disabled.
       *
       * @param element Element to be checked.
       * @returns Whether the element is disabled.
       */
      /**
       * Gets whether an element is disabled.
       *
       * @param {?} element Element to be checked.
       * @return {?} Whether the element is disabled.
       */
      InteractivityChecker.prototype.isDisabled = /**
       * Gets whether an element is disabled.
       *
       * @param {?} element Element to be checked.
       * @return {?} Whether the element is disabled.
       */
          function (element) {
              // This does not capture some cases, such as a non-form control with a disabled attribute or
              // a form control inside of a disabled form, but should capture the most common cases.
              return element.hasAttribute('disabled');
          };
      /**
       * Gets whether an element is visible for the purposes of interactivity.
       *
       * This will capture states like `display: none` and `visibility: hidden`, but not things like
       * being clipped by an `overflow: hidden` parent or being outside the viewport.
       *
       * @returns Whether the element is visible.
       */
      /**
       * Gets whether an element is visible for the purposes of interactivity.
       *
       * This will capture states like `display: none` and `visibility: hidden`, but not things like
       * being clipped by an `overflow: hidden` parent or being outside the viewport.
       *
       * @param {?} element
       * @return {?} Whether the element is visible.
       */
      InteractivityChecker.prototype.isVisible = /**
       * Gets whether an element is visible for the purposes of interactivity.
       *
       * This will capture states like `display: none` and `visibility: hidden`, but not things like
       * being clipped by an `overflow: hidden` parent or being outside the viewport.
       *
       * @param {?} element
       * @return {?} Whether the element is visible.
       */
          function (element) {
              return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';
          };
      /**
       * Gets whether an element can be reached via Tab key.
       * Assumes that the element has already been checked with isFocusable.
       *
       * @param element Element to be checked.
       * @returns Whether the element is tabbable.
       */
      /**
       * Gets whether an element can be reached via Tab key.
       * Assumes that the element has already been checked with isFocusable.
       *
       * @param {?} element Element to be checked.
       * @return {?} Whether the element is tabbable.
       */
      InteractivityChecker.prototype.isTabbable = /**
       * Gets whether an element can be reached via Tab key.
       * Assumes that the element has already been checked with isFocusable.
       *
       * @param {?} element Element to be checked.
       * @return {?} Whether the element is tabbable.
       */
          function (element) {
              // Nothing is tabbable on the server 😎
              if (!this._platform.isBrowser) {
                  return false;
              }
              /** @type {?} */
              var frameElement = getFrameElement(getWindow(element));
              if (frameElement) {
                  /** @type {?} */
                  var frameType = frameElement && frameElement.nodeName.toLowerCase();
                  // Frame elements inherit their tabindex onto all child elements.
                  if (getTabIndexValue(frameElement) === -1) {
                      return false;
                  }
                  // Webkit and Blink consider anything inside of an <object> element as non-tabbable.
                  if ((this._platform.BLINK || this._platform.WEBKIT) && frameType === 'object') {
                      return false;
                  }
                  // Webkit and Blink disable tabbing to an element inside of an invisible frame.
                  if ((this._platform.BLINK || this._platform.WEBKIT) && !this.isVisible(frameElement)) {
                      return false;
                  }
              }
              /** @type {?} */
              var nodeName = element.nodeName.toLowerCase();
              /** @type {?} */
              var tabIndexValue = getTabIndexValue(element);
              if (element.hasAttribute('contenteditable')) {
                  return tabIndexValue !== -1;
              }
              if (nodeName === 'iframe') {
                  // The frames may be tabbable depending on content, but it's not possibly to reliably
                  // investigate the content of the frames.
                  return false;
              }
              if (nodeName === 'audio') {
                  if (!element.hasAttribute('controls')) {
                      // By default an <audio> element without the controls enabled is not tabbable.
                      return false;
                  }
                  else if (this._platform.BLINK) {
                      // In Blink <audio controls> elements are always tabbable.
                      return true;
                  }
              }
              if (nodeName === 'video') {
                  if (!element.hasAttribute('controls') && this._platform.TRIDENT) {
                      // In Trident a <video> element without the controls enabled is not tabbable.
                      return false;
                  }
                  else if (this._platform.BLINK || this._platform.FIREFOX) {
                      // In Chrome and Firefox <video controls> elements are always tabbable.
                      return true;
                  }
              }
              if (nodeName === 'object' && (this._platform.BLINK || this._platform.WEBKIT)) {
                  // In all Blink and WebKit based browsers <object> elements are never tabbable.
                  return false;
              }
              // In iOS the browser only considers some specific elements as tabbable.
              if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {
                  return false;
              }
              return element.tabIndex >= 0;
          };
      /**
       * Gets whether an element can be focused by the user.
       *
       * @param element Element to be checked.
       * @returns Whether the element is focusable.
       */
      /**
       * Gets whether an element can be focused by the user.
       *
       * @param {?} element Element to be checked.
       * @return {?} Whether the element is focusable.
       */
      InteractivityChecker.prototype.isFocusable = /**
       * Gets whether an element can be focused by the user.
       *
       * @param {?} element Element to be checked.
       * @return {?} Whether the element is focusable.
       */
          function (element) {
              // Perform checks in order of left to most expensive.
              // Again, naive approach that does not capture many edge cases and browser quirks.
              return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);
          };
      InteractivityChecker.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */
      InteractivityChecker.ctorParameters = function () {
          return [
              { type: Platform }
          ];
      };
      /** @nocollapse */ InteractivityChecker.ngInjectableDef = core.defineInjectable({ factory: function InteractivityChecker_Factory() { return new InteractivityChecker(core.inject(Platform)); }, token: InteractivityChecker, providedIn: "root" });
      return InteractivityChecker;
  }());
  /**
   * Returns the frame element from a window object. Since browsers like MS Edge throw errors if
   * the frameElement property is being accessed from a different host address, this property
   * should be accessed carefully.
   * @param {?} window
   * @return {?}
   */
  function getFrameElement(window) {
      try {
          return ( /** @type {?} */(window.frameElement));
      }
      catch (_a) {
          return null;
      }
  }
  /**
   * Checks whether the specified element has any geometry / rectangles.
   * @param {?} element
   * @return {?}
   */
  function hasGeometry(element) {
      // Use logic from jQuery to check for an invisible element.
      // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12
      return !!(element.offsetWidth || element.offsetHeight ||
          (typeof element.getClientRects === 'function' && element.getClientRects().length));
  }
  /**
   * Gets whether an element's
   * @param {?} element
   * @return {?}
   */
  function isNativeFormElement(element) {
      /** @type {?} */
      var nodeName = element.nodeName.toLowerCase();
      return nodeName === 'input' ||
          nodeName === 'select' ||
          nodeName === 'button' ||
          nodeName === 'textarea';
  }
  /**
   * Gets whether an element is an `<input type="hidden">`.
   * @param {?} element
   * @return {?}
   */
  function isHiddenInput(element) {
      return isInputElement(element) && element.type == 'hidden';
  }
  /**
   * Gets whether an element is an anchor that has an href attribute.
   * @param {?} element
   * @return {?}
   */
  function isAnchorWithHref(element) {
      return isAnchorElement(element) && element.hasAttribute('href');
  }
  /**
   * Gets whether an element is an input element.
   * @param {?} element
   * @return {?}
   */
  function isInputElement(element) {
      return element.nodeName.toLowerCase() == 'input';
  }
  /**
   * Gets whether an element is an anchor element.
   * @param {?} element
   * @return {?}
   */
  function isAnchorElement(element) {
      return element.nodeName.toLowerCase() == 'a';
  }
  /**
   * Gets whether an element has a valid tabindex.
   * @param {?} element
   * @return {?}
   */
  function hasValidTabIndex(element) {
      if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {
          return false;
      }
      /** @type {?} */
      var tabIndex = element.getAttribute('tabindex');
      // IE11 parses tabindex="" as the value "-32768"
      if (tabIndex == '-32768') {
          return false;
      }
      return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));
  }
  /**
   * Returns the parsed tabindex from the element attributes instead of returning the
   * evaluated tabindex from the browsers defaults.
   * @param {?} element
   * @return {?}
   */
  function getTabIndexValue(element) {
      if (!hasValidTabIndex(element)) {
          return null;
      }
      // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
      /** @type {?} */
      var tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);
      return isNaN(tabIndex) ? -1 : tabIndex;
  }
  /**
   * Checks whether the specified element is potentially tabbable on iOS
   * @param {?} element
   * @return {?}
   */
  function isPotentiallyTabbableIOS(element) {
      /** @type {?} */
      var nodeName = element.nodeName.toLowerCase();
      /** @type {?} */
      var inputType = nodeName === 'input' && (( /** @type {?} */(element))).type;
      return inputType === 'text'
          || inputType === 'password'
          || nodeName === 'select'
          || nodeName === 'textarea';
  }
  /**
   * Gets whether an element is potentially focusable without taking current visible/disabled state
   * into account.
   * @param {?} element
   * @return {?}
   */
  function isPotentiallyFocusable(element) {
      // Inputs are potentially focusable *unless* they're type="hidden".
      if (isHiddenInput(element)) {
          return false;
      }
      return isNativeFormElement(element) ||
          isAnchorWithHref(element) ||
          element.hasAttribute('contenteditable') ||
          hasValidTabIndex(element);
  }
  /**
   * Gets the parent window of a DOM node with regards of being inside of an iframe.
   * @param {?} node
   * @return {?}
   */
  function getWindow(node) {
      // ownerDocument is null if `node` itself *is* a document.
      return node.ownerDocument && node.ownerDocument.defaultView || window;
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Class that allows for trapping focus within a DOM element.
   *
   * This class currently uses a relatively simple approach to focus trapping.
   * It assumes that the tab order is the same as DOM order, which is not necessarily true.
   * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause to two to misalign.
   */
  var /**
   * Class that allows for trapping focus within a DOM element.
   *
   * This class currently uses a relatively simple approach to focus trapping.
   * It assumes that the tab order is the same as DOM order, which is not necessarily true.
   * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause to two to misalign.
   */ FocusTrap = /** @class */ (function () {
      function FocusTrap(_element, _checker, _ngZone, _document, deferAnchors) {
          if (deferAnchors === void 0) {
              deferAnchors = false;
          }
          var _this = this;
          this._element = _element;
          this._checker = _checker;
          this._ngZone = _ngZone;
          this._document = _document;
          this._hasAttached = false;
          // Event listeners for the anchors. Need to be regular functions so that we can unbind them later.
          this._startAnchorListener = function () { return _this.focusLastTabbableElement(); };
          this._endAnchorListener = function () { return _this.focusFirstTabbableElement(); };
          this._enabled = true;
          if (!deferAnchors) {
              this.attachAnchors();
          }
      }
      Object.defineProperty(FocusTrap.prototype, "enabled", {
          /** Whether the focus trap is active. */
          get: /**
           * Whether the focus trap is active.
           * @return {?}
           */ function () { return this._enabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._enabled = value;
              if (this._startAnchor && this._endAnchor) {
                  this._toggleAnchorTabIndex(value, this._startAnchor);
                  this._toggleAnchorTabIndex(value, this._endAnchor);
              }
          },
          enumerable: true,
          configurable: true
      });
      /** Destroys the focus trap by cleaning up the anchors. */
      /**
       * Destroys the focus trap by cleaning up the anchors.
       * @return {?}
       */
      FocusTrap.prototype.destroy = /**
       * Destroys the focus trap by cleaning up the anchors.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var startAnchor = this._startAnchor;
              /** @type {?} */
              var endAnchor = this._endAnchor;
              if (startAnchor) {
                  startAnchor.removeEventListener('focus', this._startAnchorListener);
                  if (startAnchor.parentNode) {
                      startAnchor.parentNode.removeChild(startAnchor);
                  }
              }
              if (endAnchor) {
                  endAnchor.removeEventListener('focus', this._endAnchorListener);
                  if (endAnchor.parentNode) {
                      endAnchor.parentNode.removeChild(endAnchor);
                  }
              }
              this._startAnchor = this._endAnchor = null;
          };
      /**
       * Inserts the anchors into the DOM. This is usually done automatically
       * in the constructor, but can be deferred for cases like directives with `*ngIf`.
       * @returns Whether the focus trap managed to attach successfuly. This may not be the case
       * if the target element isn't currently in the DOM.
       */
      /**
       * Inserts the anchors into the DOM. This is usually done automatically
       * in the constructor, but can be deferred for cases like directives with `*ngIf`.
       * @return {?} Whether the focus trap managed to attach successfuly. This may not be the case
       * if the target element isn't currently in the DOM.
       */
      FocusTrap.prototype.attachAnchors = /**
       * Inserts the anchors into the DOM. This is usually done automatically
       * in the constructor, but can be deferred for cases like directives with `*ngIf`.
       * @return {?} Whether the focus trap managed to attach successfuly. This may not be the case
       * if the target element isn't currently in the DOM.
       */
          function () {
              var _this = this;
              // If we're not on the browser, there can be no focus to trap.
              if (this._hasAttached) {
                  return true;
              }
              this._ngZone.runOutsideAngular(function () {
                  if (!_this._startAnchor) {
                      _this._startAnchor = _this._createAnchor();
                      ( /** @type {?} */(_this._startAnchor)).addEventListener('focus', _this._startAnchorListener);
                  }
                  if (!_this._endAnchor) {
                      _this._endAnchor = _this._createAnchor();
                      ( /** @type {?} */(_this._endAnchor)).addEventListener('focus', _this._endAnchorListener);
                  }
              });
              if (this._element.parentNode) {
                  this._element.parentNode.insertBefore(( /** @type {?} */(this._startAnchor)), this._element);
                  this._element.parentNode.insertBefore(( /** @type {?} */(this._endAnchor)), this._element.nextSibling);
                  this._hasAttached = true;
              }
              return this._hasAttached;
          };
      /**
       * Waits for the zone to stabilize, then either focuses the first element that the
       * user specified, or the first tabbable element.
       * @returns Returns a promise that resolves with a boolean, depending
       * on whether focus was moved successfuly.
       */
      /**
       * Waits for the zone to stabilize, then either focuses the first element that the
       * user specified, or the first tabbable element.
       * @return {?} Returns a promise that resolves with a boolean, depending
       * on whether focus was moved successfuly.
       */
      FocusTrap.prototype.focusInitialElementWhenReady = /**
       * Waits for the zone to stabilize, then either focuses the first element that the
       * user specified, or the first tabbable element.
       * @return {?} Returns a promise that resolves with a boolean, depending
       * on whether focus was moved successfuly.
       */
          function () {
              var _this = this;
              return new Promise(function (resolve) {
                  _this._executeOnStable(function () { return resolve(_this.focusInitialElement()); });
              });
          };
      /**
       * Waits for the zone to stabilize, then focuses
       * the first tabbable element within the focus trap region.
       * @returns Returns a promise that resolves with a boolean, depending
       * on whether focus was moved successfuly.
       */
      /**
       * Waits for the zone to stabilize, then focuses
       * the first tabbable element within the focus trap region.
       * @return {?} Returns a promise that resolves with a boolean, depending
       * on whether focus was moved successfuly.
       */
      FocusTrap.prototype.focusFirstTabbableElementWhenReady = /**
       * Waits for the zone to stabilize, then focuses
       * the first tabbable element within the focus trap region.
       * @return {?} Returns a promise that resolves with a boolean, depending
       * on whether focus was moved successfuly.
       */
          function () {
              var _this = this;
              return new Promise(function (resolve) {
                  _this._executeOnStable(function () { return resolve(_this.focusFirstTabbableElement()); });
              });
          };
      /**
       * Waits for the zone to stabilize, then focuses
       * the last tabbable element within the focus trap region.
       * @returns Returns a promise that resolves with a boolean, depending
       * on whether focus was moved successfuly.
       */
      /**
       * Waits for the zone to stabilize, then focuses
       * the last tabbable element within the focus trap region.
       * @return {?} Returns a promise that resolves with a boolean, depending
       * on whether focus was moved successfuly.
       */
      FocusTrap.prototype.focusLastTabbableElementWhenReady = /**
       * Waits for the zone to stabilize, then focuses
       * the last tabbable element within the focus trap region.
       * @return {?} Returns a promise that resolves with a boolean, depending
       * on whether focus was moved successfuly.
       */
          function () {
              var _this = this;
              return new Promise(function (resolve) {
                  _this._executeOnStable(function () { return resolve(_this.focusLastTabbableElement()); });
              });
          };
      /**
       * Get the specified boundary element of the trapped region.
       * @param bound The boundary to get (start or end of trapped region).
       * @returns The boundary element.
       */
      /**
       * Get the specified boundary element of the trapped region.
       * @private
       * @param {?} bound The boundary to get (start or end of trapped region).
       * @return {?} The boundary element.
       */
      FocusTrap.prototype._getRegionBoundary = /**
       * Get the specified boundary element of the trapped region.
       * @private
       * @param {?} bound The boundary to get (start or end of trapped region).
       * @return {?} The boundary element.
       */
          function (bound) {
              // Contains the deprecated version of selector, for temporary backwards comparability.
              /** @type {?} */
              var markers = ( /** @type {?} */(this._element.querySelectorAll("[cdk-focus-region-" + bound + "], " +
                  ("[cdkFocusRegion" + bound + "], ") +
                  ("[cdk-focus-" + bound + "]"))));
              for (var i = 0; i < markers.length; i++) {
                  // @breaking-change 8.0.0
                  if (markers[i].hasAttribute("cdk-focus-" + bound)) {
                      console.warn("Found use of deprecated attribute 'cdk-focus-" + bound + "', " +
                          ("use 'cdkFocusRegion" + bound + "' instead. The deprecated ") +
                          "attribute will be removed in 8.0.0.", markers[i]);
                  }
                  else if (markers[i].hasAttribute("cdk-focus-region-" + bound)) {
                      console.warn("Found use of deprecated attribute 'cdk-focus-region-" + bound + "', " +
                          ("use 'cdkFocusRegion" + bound + "' instead. The deprecated attribute ") +
                          "will be removed in 8.0.0.", markers[i]);
                  }
              }
              if (bound == 'start') {
                  return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);
              }
              return markers.length ?
                  markers[markers.length - 1] : this._getLastTabbableElement(this._element);
          };
      /**
       * Focuses the element that should be focused when the focus trap is initialized.
       * @returns Whether focus was moved successfuly.
       */
      /**
       * Focuses the element that should be focused when the focus trap is initialized.
       * @return {?} Whether focus was moved successfuly.
       */
      FocusTrap.prototype.focusInitialElement = /**
       * Focuses the element that should be focused when the focus trap is initialized.
       * @return {?} Whether focus was moved successfuly.
       */
          function () {
              // Contains the deprecated version of selector, for temporary backwards comparability.
              /** @type {?} */
              var redirectToElement = ( /** @type {?} */(this._element.querySelector("[cdk-focus-initial], " +
                  "[cdkFocusInitial]")));
              if (redirectToElement) {
                  // @breaking-change 8.0.0
                  if (redirectToElement.hasAttribute("cdk-focus-initial")) {
                      console.warn("Found use of deprecated attribute 'cdk-focus-initial', " +
                          "use 'cdkFocusInitial' instead. The deprecated attribute " +
                          "will be removed in 8.0.0", redirectToElement);
                  }
                  // Warn the consumer if the element they've pointed to
                  // isn't focusable, when not in production mode.
                  if (core.isDevMode() && !this._checker.isFocusable(redirectToElement)) {
                      console.warn("Element matching '[cdkFocusInitial]' is not focusable.", redirectToElement);
                  }
                  redirectToElement.focus();
                  return true;
              }
              return this.focusFirstTabbableElement();
          };
      /**
       * Focuses the first tabbable element within the focus trap region.
       * @returns Whether focus was moved successfuly.
       */
      /**
       * Focuses the first tabbable element within the focus trap region.
       * @return {?} Whether focus was moved successfuly.
       */
      FocusTrap.prototype.focusFirstTabbableElement = /**
       * Focuses the first tabbable element within the focus trap region.
       * @return {?} Whether focus was moved successfuly.
       */
          function () {
              /** @type {?} */
              var redirectToElement = this._getRegionBoundary('start');
              if (redirectToElement) {
                  redirectToElement.focus();
              }
              return !!redirectToElement;
          };
      /**
       * Focuses the last tabbable element within the focus trap region.
       * @returns Whether focus was moved successfuly.
       */
      /**
       * Focuses the last tabbable element within the focus trap region.
       * @return {?} Whether focus was moved successfuly.
       */
      FocusTrap.prototype.focusLastTabbableElement = /**
       * Focuses the last tabbable element within the focus trap region.
       * @return {?} Whether focus was moved successfuly.
       */
          function () {
              /** @type {?} */
              var redirectToElement = this._getRegionBoundary('end');
              if (redirectToElement) {
                  redirectToElement.focus();
              }
              return !!redirectToElement;
          };
      /**
       * Checks whether the focus trap has successfuly been attached.
       */
      /**
       * Checks whether the focus trap has successfuly been attached.
       * @return {?}
       */
      FocusTrap.prototype.hasAttached = /**
       * Checks whether the focus trap has successfuly been attached.
       * @return {?}
       */
          function () {
              return this._hasAttached;
          };
      /** Get the first tabbable element from a DOM subtree (inclusive). */
      /**
       * Get the first tabbable element from a DOM subtree (inclusive).
       * @private
       * @param {?} root
       * @return {?}
       */
      FocusTrap.prototype._getFirstTabbableElement = /**
       * Get the first tabbable element from a DOM subtree (inclusive).
       * @private
       * @param {?} root
       * @return {?}
       */
          function (root) {
              if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
                  return root;
              }
              // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall
              // back to `childNodes` which includes text nodes, comments etc.
              /** @type {?} */
              var children = root.children || root.childNodes;
              for (var i = 0; i < children.length; i++) {
                  /** @type {?} */
                  var tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?
                      this._getFirstTabbableElement(( /** @type {?} */(children[i]))) :
                      null;
                  if (tabbableChild) {
                      return tabbableChild;
                  }
              }
              return null;
          };
      /** Get the last tabbable element from a DOM subtree (inclusive). */
      /**
       * Get the last tabbable element from a DOM subtree (inclusive).
       * @private
       * @param {?} root
       * @return {?}
       */
      FocusTrap.prototype._getLastTabbableElement = /**
       * Get the last tabbable element from a DOM subtree (inclusive).
       * @private
       * @param {?} root
       * @return {?}
       */
          function (root) {
              if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
                  return root;
              }
              // Iterate in reverse DOM order.
              /** @type {?} */
              var children = root.children || root.childNodes;
              for (var i = children.length - 1; i >= 0; i--) {
                  /** @type {?} */
                  var tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?
                      this._getLastTabbableElement(( /** @type {?} */(children[i]))) :
                      null;
                  if (tabbableChild) {
                      return tabbableChild;
                  }
              }
              return null;
          };
      /** Creates an anchor element. */
      /**
       * Creates an anchor element.
       * @private
       * @return {?}
       */
      FocusTrap.prototype._createAnchor = /**
       * Creates an anchor element.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var anchor = this._document.createElement('div');
              this._toggleAnchorTabIndex(this._enabled, anchor);
              anchor.classList.add('cdk-visually-hidden');
              anchor.classList.add('cdk-focus-trap-anchor');
              anchor.setAttribute('aria-hidden', 'true');
              return anchor;
          };
      /**
       * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.
       * @param isEnabled Whether the focus trap is enabled.
       * @param anchor Anchor on which to toggle the tabindex.
       */
      /**
       * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.
       * @private
       * @param {?} isEnabled Whether the focus trap is enabled.
       * @param {?} anchor Anchor on which to toggle the tabindex.
       * @return {?}
       */
      FocusTrap.prototype._toggleAnchorTabIndex = /**
       * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.
       * @private
       * @param {?} isEnabled Whether the focus trap is enabled.
       * @param {?} anchor Anchor on which to toggle the tabindex.
       * @return {?}
       */
          function (isEnabled, anchor) {
              // Remove the tabindex completely, rather than setting it to -1, because if the
              // element has a tabindex, the user might still hit it when navigating with the arrow keys.
              isEnabled ? anchor.setAttribute('tabindex', '0') : anchor.removeAttribute('tabindex');
          };
      /** Executes a function when the zone is stable. */
      /**
       * Executes a function when the zone is stable.
       * @private
       * @param {?} fn
       * @return {?}
       */
      FocusTrap.prototype._executeOnStable = /**
       * Executes a function when the zone is stable.
       * @private
       * @param {?} fn
       * @return {?}
       */
          function (fn) {
              if (this._ngZone.isStable) {
                  fn();
              }
              else {
                  this._ngZone.onStable.asObservable().pipe(operators.take(1)).subscribe(fn);
              }
          };
      return FocusTrap;
  }());
  /**
   * Factory that allows easy instantiation of focus traps.
   */
  var FocusTrapFactory = /** @class */ (function () {
      function FocusTrapFactory(_checker, _ngZone, _document) {
          this._checker = _checker;
          this._ngZone = _ngZone;
          this._document = _document;
      }
      /**
       * Creates a focus-trapped region around the given element.
       * @param element The element around which focus will be trapped.
       * @param deferCaptureElements Defers the creation of focus-capturing elements to be done
       *     manually by the user.
       * @returns The created focus trap instance.
       */
      /**
       * Creates a focus-trapped region around the given element.
       * @param {?} element The element around which focus will be trapped.
       * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done
       *     manually by the user.
       * @return {?} The created focus trap instance.
       */
      FocusTrapFactory.prototype.create = /**
       * Creates a focus-trapped region around the given element.
       * @param {?} element The element around which focus will be trapped.
       * @param {?=} deferCaptureElements Defers the creation of focus-capturing elements to be done
       *     manually by the user.
       * @return {?} The created focus trap instance.
       */
          function (element, deferCaptureElements) {
              if (deferCaptureElements === void 0) {
                  deferCaptureElements = false;
              }
              return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);
          };
      FocusTrapFactory.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */
      FocusTrapFactory.ctorParameters = function () {
          return [
              { type: InteractivityChecker },
              { type: core.NgZone },
              { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
          ];
      };
      /** @nocollapse */ FocusTrapFactory.ngInjectableDef = core.defineInjectable({ factory: function FocusTrapFactory_Factory() { return new FocusTrapFactory(core.inject(InteractivityChecker), core.inject(core.NgZone), core.inject(common.DOCUMENT)); }, token: FocusTrapFactory, providedIn: "root" });
      return FocusTrapFactory;
  }());
  /**
   * Directive for trapping focus within a region.
   */
  var CdkTrapFocus = /** @class */ (function () {
      function CdkTrapFocus(_elementRef, _focusTrapFactory, _document) {
          this._elementRef = _elementRef;
          this._focusTrapFactory = _focusTrapFactory;
          /**
           * Previously focused element to restore focus to upon destroy when using autoCapture.
           */
          this._previouslyFocusedElement = null;
          this._document = _document;
          this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);
      }
      Object.defineProperty(CdkTrapFocus.prototype, "enabled", {
          /** Whether the focus trap is active. */
          get: /**
           * Whether the focus trap is active.
           * @return {?}
           */ function () { return this.focusTrap.enabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this.focusTrap.enabled = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkTrapFocus.prototype, "autoCapture", {
          /**
           * Whether the directive should automatially move focus into the trapped region upon
           * initialization and return focus to the previous activeElement upon destruction.
           */
          get: /**
           * Whether the directive should automatially move focus into the trapped region upon
           * initialization and return focus to the previous activeElement upon destruction.
           * @return {?}
           */ function () { return this._autoCapture; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._autoCapture = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      CdkTrapFocus.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this.focusTrap.destroy();
              // If we stored a previously focused element when using autoCapture, return focus to that
              // element now that the trapped region is being destroyed.
              if (this._previouslyFocusedElement) {
                  this._previouslyFocusedElement.focus();
                  this._previouslyFocusedElement = null;
              }
          };
      /**
       * @return {?}
       */
      CdkTrapFocus.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this.focusTrap.attachAnchors();
              if (this.autoCapture) {
                  this._previouslyFocusedElement = ( /** @type {?} */(this._document.activeElement));
                  this.focusTrap.focusInitialElementWhenReady();
              }
          };
      /**
       * @return {?}
       */
      CdkTrapFocus.prototype.ngDoCheck = /**
       * @return {?}
       */
          function () {
              if (!this.focusTrap.hasAttached()) {
                  this.focusTrap.attachAnchors();
              }
          };
      CdkTrapFocus.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkTrapFocus]',
                      exportAs: 'cdkTrapFocus',
                  },] },
      ];
      /** @nocollapse */
      CdkTrapFocus.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: FocusTrapFactory },
              { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
          ];
      };
      CdkTrapFocus.propDecorators = {
          enabled: [{ type: core.Input, args: ['cdkTrapFocus',] }],
          autoCapture: [{ type: core.Input, args: ['cdkTrapFocusAutoCapture',] }]
      };
      return CdkTrapFocus;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // The token for the live announcer element is defined in a separate file from LiveAnnouncer
  // as a workaround for https://github.com/angular/angular/issues/22559
  /** @type {?} */
  var LIVE_ANNOUNCER_ELEMENT_TOKEN = new core.InjectionToken('liveAnnouncerElement', {
      providedIn: 'root',
      factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,
  });
  /**
   * \@docs-private
   * @return {?}
   */
  function LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {
      return null;
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var LiveAnnouncer = /** @class */ (function () {
      function LiveAnnouncer(elementToken, _ngZone, _document) {
          this._ngZone = _ngZone;
          // We inject the live element and document as `any` because the constructor signature cannot
          // reference browser globals (HTMLElement, Document) on non-browser environments, since having
          // a class decorator causes TypeScript to preserve the constructor signature types.
          this._document = _document;
          this._liveElement = elementToken || this._createLiveElement();
      }
      /**
       * @param {?} message
       * @param {...?} args
       * @return {?}
       */
      LiveAnnouncer.prototype.announce = /**
       * @param {?} message
       * @param {...?} args
       * @return {?}
       */
          function (message) {
              var _this = this;
              var args = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                  args[_i - 1] = arguments[_i];
              }
              /** @type {?} */
              var politeness;
              /** @type {?} */
              var duration;
              if (args.length === 1 && typeof args[0] === 'number') {
                  duration = args[0];
              }
              else {
                  politeness = args[0], duration = args[1];
              }
              this.clear();
              clearTimeout(this._previousTimeout);
              // TODO: ensure changing the politeness works on all environments we support.
              this._liveElement.setAttribute('aria-live', ( /** @type {?} */(politeness)) || 'polite');
              // This 100ms timeout is necessary for some browser + screen-reader combinations:
              // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.
              // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a
              //   second time without clearing and then using a non-zero delay.
              // (using JAWS 17 at time of this writing).
              return this._ngZone.runOutsideAngular(function () {
                  return new Promise(function (resolve) {
                      clearTimeout(_this._previousTimeout);
                      _this._previousTimeout = setTimeout(function () {
                          _this._liveElement.textContent = message;
                          resolve();
                          if (typeof duration === 'number') {
                              _this._previousTimeout = setTimeout(function () { return _this.clear(); }, duration);
                          }
                      }, 100);
                  });
              });
          };
      /**
       * Clears the current text from the announcer element. Can be used to prevent
       * screen readers from reading the text out again while the user is going
       * through the page landmarks.
       */
      /**
       * Clears the current text from the announcer element. Can be used to prevent
       * screen readers from reading the text out again while the user is going
       * through the page landmarks.
       * @return {?}
       */
      LiveAnnouncer.prototype.clear = /**
       * Clears the current text from the announcer element. Can be used to prevent
       * screen readers from reading the text out again while the user is going
       * through the page landmarks.
       * @return {?}
       */
          function () {
              if (this._liveElement) {
                  this._liveElement.textContent = '';
              }
          };
      /**
       * @return {?}
       */
      LiveAnnouncer.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              clearTimeout(this._previousTimeout);
              if (this._liveElement && this._liveElement.parentNode) {
                  this._liveElement.parentNode.removeChild(this._liveElement);
                  this._liveElement = ( /** @type {?} */(null));
              }
          };
      /**
       * @private
       * @return {?}
       */
      LiveAnnouncer.prototype._createLiveElement = /**
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var elementClass = 'cdk-live-announcer-element';
              /** @type {?} */
              var previousElements = this._document.getElementsByClassName(elementClass);
              /** @type {?} */
              var liveEl = this._document.createElement('div');
              // Remove any old containers. This can happen when coming in from a server-side-rendered page.
              for (var i = 0; i < previousElements.length; i++) {
                  ( /** @type {?} */(previousElements[i].parentNode)).removeChild(previousElements[i]);
              }
              liveEl.classList.add(elementClass);
              liveEl.classList.add('cdk-visually-hidden');
              liveEl.setAttribute('aria-atomic', 'true');
              liveEl.setAttribute('aria-live', 'polite');
              this._document.body.appendChild(liveEl);
              return liveEl;
          };
      LiveAnnouncer.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */
      LiveAnnouncer.ctorParameters = function () {
          return [
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [LIVE_ANNOUNCER_ELEMENT_TOKEN,] }] },
              { type: core.NgZone },
              { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
          ];
      };
      /** @nocollapse */ LiveAnnouncer.ngInjectableDef = core.defineInjectable({ factory: function LiveAnnouncer_Factory() { return new LiveAnnouncer(core.inject(LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), core.inject(core.NgZone), core.inject(common.DOCUMENT)); }, token: LiveAnnouncer, providedIn: "root" });
      return LiveAnnouncer;
  }());
  /**
   * A directive that works similarly to aria-live, but uses the LiveAnnouncer to ensure compatibility
   * with a wider range of browsers and screen readers.
   */
  var CdkAriaLive = /** @class */ (function () {
      function CdkAriaLive(_elementRef, _liveAnnouncer, _contentObserver, _ngZone) {
          this._elementRef = _elementRef;
          this._liveAnnouncer = _liveAnnouncer;
          this._contentObserver = _contentObserver;
          this._ngZone = _ngZone;
          this._politeness = 'off';
      }
      Object.defineProperty(CdkAriaLive.prototype, "politeness", {
          /** The aria-live politeness level to use when announcing messages. */
          get: /**
           * The aria-live politeness level to use when announcing messages.
           * @return {?}
           */ function () { return this._politeness; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              var _this = this;
              this._politeness = value === 'polite' || value === 'assertive' ? value : 'off';
              if (this._politeness === 'off') {
                  if (this._subscription) {
                      this._subscription.unsubscribe();
                      this._subscription = null;
                  }
              }
              else if (!this._subscription) {
                  this._subscription = this._ngZone.runOutsideAngular(function () {
                      return _this._contentObserver
                          .observe(_this._elementRef)
                          .subscribe(function () {
                          // Note that we use textContent here, rather than innerText, in order to avoid a reflow.
                          /** @type {?} */
                          var elementText = _this._elementRef.nativeElement.textContent;
                          // The `MutationObserver` fires also for attribute
                          // changes which we don't want to announce.
                          if (elementText !== _this._previousAnnouncedText) {
                              _this._liveAnnouncer.announce(elementText, _this._politeness);
                              _this._previousAnnouncedText = elementText;
                          }
                      });
                  });
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      CdkAriaLive.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              if (this._subscription) {
                  this._subscription.unsubscribe();
              }
          };
      CdkAriaLive.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkAriaLive]',
                      exportAs: 'cdkAriaLive',
                  },] },
      ];
      /** @nocollapse */
      CdkAriaLive.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: LiveAnnouncer },
              { type: ContentObserver },
              { type: core.NgZone }
          ];
      };
      CdkAriaLive.propDecorators = {
          politeness: [{ type: core.Input, args: ['cdkAriaLive',] }]
      };
      return CdkAriaLive;
  }());
  /**
   * \@docs-private \@deprecated \@breaking-change 8.0.0
   * @param {?} parentAnnouncer
   * @param {?} liveElement
   * @param {?} _document
   * @param {?} ngZone
   * @return {?}
   */
  function LIVE_ANNOUNCER_PROVIDER_FACTORY(parentAnnouncer, liveElement, _document, ngZone) {
      return parentAnnouncer || new LiveAnnouncer(liveElement, ngZone, _document);
  }
  /**
   * \@docs-private \@deprecated \@breaking-change 8.0.0
   * @type {?}
   */
  var LIVE_ANNOUNCER_PROVIDER = {
      // If there is already a LiveAnnouncer available, use that. Otherwise, provide a new one.
      provide: LiveAnnouncer,
      deps: [
          [new core.Optional(), new core.SkipSelf(), LiveAnnouncer],
          [new core.Optional(), new core.Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)],
          common.DOCUMENT,
          core.NgZone,
      ],
      useFactory: LIVE_ANNOUNCER_PROVIDER_FACTORY
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found
  // that a value of around 650ms seems appropriate.
  /** @type {?} */
  var TOUCH_BUFFER_MS = 650;
  /**
   * Event listener options that enable capturing and also
   * mark the the listener as passive if the browser supports it.
   * @type {?}
   */
  var captureEventListenerOptions = normalizePassiveListenerOptions({
      passive: true,
      capture: true
  });
  /**
   * Monitors mouse and keyboard events to determine the cause of focus events.
   */
  var FocusMonitor = /** @class */ (function () {
      function FocusMonitor(_ngZone, _platform) {
          var _this = this;
          this._ngZone = _ngZone;
          this._platform = _platform;
          /**
           * The focus origin that the next focus event is a result of.
           */
          this._origin = null;
          /**
           * Whether the window has just been focused.
           */
          this._windowFocused = false;
          /**
           * Map of elements being monitored to their info.
           */
          this._elementInfo = new Map();
          /**
           * The number of elements currently being monitored.
           */
          this._monitoredElementCount = 0;
          /**
           * Event listener for `keydown` events on the document.
           * Needs to be an arrow function in order to preserve the context when it gets bound.
           */
          this._documentKeydownListener = function () {
              // On keydown record the origin and clear any touch event that may be in progress.
              _this._lastTouchTarget = null;
              _this._setOriginForCurrentEventQueue('keyboard');
          };
          /**
           * Event listener for `mousedown` events on the document.
           * Needs to be an arrow function in order to preserve the context when it gets bound.
           */
          this._documentMousedownListener = function () {
              // On mousedown record the origin only if there is not touch
              // target, since a mousedown can happen as a result of a touch event.
              if (!_this._lastTouchTarget) {
                  _this._setOriginForCurrentEventQueue('mouse');
              }
          };
          /**
           * Event listener for `touchstart` events on the document.
           * Needs to be an arrow function in order to preserve the context when it gets bound.
           */
          this._documentTouchstartListener = function (event) {
              // When the touchstart event fires the focus event is not yet in the event queue. This means
              // we can't rely on the trick used above (setting timeout of 1ms). Instead we wait 650ms to
              // see if a focus happens.
              if (_this._touchTimeoutId != null) {
                  clearTimeout(_this._touchTimeoutId);
              }
              _this._lastTouchTarget = event.target;
              _this._touchTimeoutId = setTimeout(function () { return _this._lastTouchTarget = null; }, TOUCH_BUFFER_MS);
          };
          /**
           * Event listener for `focus` events on the window.
           * Needs to be an arrow function in order to preserve the context when it gets bound.
           */
          this._windowFocusListener = function () {
              // Make a note of when the window regains focus, so we can
              // restore the origin info for the focused element.
              _this._windowFocused = true;
              _this._windowFocusTimeoutId = setTimeout(function () { return _this._windowFocused = false; });
          };
      }
      /**
       * @param {?} element
       * @param {?=} checkChildren
       * @return {?}
       */
      FocusMonitor.prototype.monitor = /**
       * @param {?} element
       * @param {?=} checkChildren
       * @return {?}
       */
          function (element, checkChildren) {
              var _this = this;
              if (checkChildren === void 0) {
                  checkChildren = false;
              }
              // Do nothing if we're not on the browser platform.
              if (!this._platform.isBrowser) {
                  return rxjs.of(null);
              }
              /** @type {?} */
              var nativeElement = coerceElement(element);
              // Check if we're already monitoring this element.
              if (this._elementInfo.has(nativeElement)) {
                  /** @type {?} */
                  var cachedInfo = this._elementInfo.get(nativeElement);
                  ( /** @type {?} */(cachedInfo)).checkChildren = checkChildren;
                  return ( /** @type {?} */(cachedInfo)).subject.asObservable();
              }
              // Create monitored element info.
              /** @type {?} */
              var info = {
                  unlisten: function () { },
                  checkChildren: checkChildren,
                  subject: new rxjs.Subject()
              };
              this._elementInfo.set(nativeElement, info);
              this._incrementMonitoredElementCount();
              // Start listening. We need to listen in capture phase since focus events don't bubble.
              /** @type {?} */
              var focusListener = function (event) { return _this._onFocus(event, nativeElement); };
              /** @type {?} */
              var blurListener = function (event) { return _this._onBlur(event, nativeElement); };
              this._ngZone.runOutsideAngular(function () {
                  nativeElement.addEventListener('focus', focusListener, true);
                  nativeElement.addEventListener('blur', blurListener, true);
              });
              // Create an unlisten function for later.
              info.unlisten = function () {
                  nativeElement.removeEventListener('focus', focusListener, true);
                  nativeElement.removeEventListener('blur', blurListener, true);
              };
              return info.subject.asObservable();
          };
      /**
       * @param {?} element
       * @return {?}
       */
      FocusMonitor.prototype.stopMonitoring = /**
       * @param {?} element
       * @return {?}
       */
          function (element) {
              /** @type {?} */
              var nativeElement = coerceElement(element);
              /** @type {?} */
              var elementInfo = this._elementInfo.get(nativeElement);
              if (elementInfo) {
                  elementInfo.unlisten();
                  elementInfo.subject.complete();
                  this._setClasses(nativeElement);
                  this._elementInfo.delete(nativeElement);
                  this._decrementMonitoredElementCount();
              }
          };
      /**
       * @param {?} element
       * @param {?} origin
       * @param {?=} options
       * @return {?}
       */
      FocusMonitor.prototype.focusVia = /**
       * @param {?} element
       * @param {?} origin
       * @param {?=} options
       * @return {?}
       */
          function (element, origin, options) {
              /** @type {?} */
              var nativeElement = coerceElement(element);
              this._setOriginForCurrentEventQueue(origin);
              // `focus` isn't available on the server
              if (typeof nativeElement.focus === 'function') {
                  // Cast the element to `any`, because the TS typings don't have the `options` parameter yet.
                  (( /** @type {?} */(nativeElement))).focus(options);
              }
          };
      /**
       * @return {?}
       */
      FocusMonitor.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._elementInfo.forEach(function (_info, element) { return _this.stopMonitoring(element); });
          };
      /**
       * @private
       * @param {?} element
       * @param {?} className
       * @param {?} shouldSet
       * @return {?}
       */
      FocusMonitor.prototype._toggleClass = /**
       * @private
       * @param {?} element
       * @param {?} className
       * @param {?} shouldSet
       * @return {?}
       */
          function (element, className, shouldSet) {
              if (shouldSet) {
                  element.classList.add(className);
              }
              else {
                  element.classList.remove(className);
              }
          };
      /**
       * Sets the focus classes on the element based on the given focus origin.
       * @param element The element to update the classes on.
       * @param origin The focus origin.
       */
      /**
       * Sets the focus classes on the element based on the given focus origin.
       * @private
       * @param {?} element The element to update the classes on.
       * @param {?=} origin The focus origin.
       * @return {?}
       */
      FocusMonitor.prototype._setClasses = /**
       * Sets the focus classes on the element based on the given focus origin.
       * @private
       * @param {?} element The element to update the classes on.
       * @param {?=} origin The focus origin.
       * @return {?}
       */
          function (element, origin) {
              /** @type {?} */
              var elementInfo = this._elementInfo.get(element);
              if (elementInfo) {
                  this._toggleClass(element, 'cdk-focused', !!origin);
                  this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');
                  this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');
                  this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');
                  this._toggleClass(element, 'cdk-program-focused', origin === 'program');
              }
          };
      /**
       * Sets the origin and schedules an async function to clear it at the end of the event queue.
       * @param origin The origin to set.
       */
      /**
       * Sets the origin and schedules an async function to clear it at the end of the event queue.
       * @private
       * @param {?} origin The origin to set.
       * @return {?}
       */
      FocusMonitor.prototype._setOriginForCurrentEventQueue = /**
       * Sets the origin and schedules an async function to clear it at the end of the event queue.
       * @private
       * @param {?} origin The origin to set.
       * @return {?}
       */
          function (origin) {
              var _this = this;
              this._ngZone.runOutsideAngular(function () {
                  _this._origin = origin;
                  // Sometimes the focus origin won't be valid in Firefox because Firefox seems to focus *one*
                  // tick after the interaction event fired. To ensure the focus origin is always correct,
                  // the focus origin will be determined at the beginning of the next tick.
                  _this._originTimeoutId = setTimeout(function () { return _this._origin = null; }, 1);
              });
          };
      /**
       * Checks whether the given focus event was caused by a touchstart event.
       * @param event The focus event to check.
       * @returns Whether the event was caused by a touch.
       */
      /**
       * Checks whether the given focus event was caused by a touchstart event.
       * @private
       * @param {?} event The focus event to check.
       * @return {?} Whether the event was caused by a touch.
       */
      FocusMonitor.prototype._wasCausedByTouch = /**
       * Checks whether the given focus event was caused by a touchstart event.
       * @private
       * @param {?} event The focus event to check.
       * @return {?} Whether the event was caused by a touch.
       */
          function (event) {
              // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.
              // Consider the following dom structure:
              //
              // <div #parent tabindex="0" cdkFocusClasses>
              //   <div #child (click)="#parent.focus()"></div>
              // </div>
              //
              // If the user touches the #child element and the #parent is programmatically focused as a
              // result, this code will still consider it to have been caused by the touch event and will
              // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a
              // relatively small edge-case that can be worked around by using
              // focusVia(parentEl, 'program') to focus the parent element.
              //
              // If we decide that we absolutely must handle this case correctly, we can do so by listening
              // for the first focus event after the touchstart, and then the first blur event after that
              // focus event. When that blur event fires we know that whatever follows is not a result of the
              // touchstart.
              /** @type {?} */
              var focusTarget = event.target;
              return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&
                  (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));
          };
      /**
       * Handles focus events on a registered element.
       * @param event The focus event.
       * @param element The monitored element.
       */
      /**
       * Handles focus events on a registered element.
       * @private
       * @param {?} event The focus event.
       * @param {?} element The monitored element.
       * @return {?}
       */
      FocusMonitor.prototype._onFocus = /**
       * Handles focus events on a registered element.
       * @private
       * @param {?} event The focus event.
       * @param {?} element The monitored element.
       * @return {?}
       */
          function (event, element) {
              // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent
              // focus event affecting the monitored element. If we want to use the origin of the first event
              // instead we should check for the cdk-focused class here and return if the element already has
              // it. (This only matters for elements that have includesChildren = true).
              // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent
              // focus event affecting the monitored element. If we want to use the origin of the first event
              // instead we should check for the cdk-focused class here and return if the element already has
              // it. (This only matters for elements that have includesChildren = true).
              // If we are not counting child-element-focus as focused, make sure that the event target is the
              // monitored element itself.
              /** @type {?} */
              var elementInfo = this._elementInfo.get(element);
              if (!elementInfo || (!elementInfo.checkChildren && element !== event.target)) {
                  return;
              }
              // If we couldn't detect a cause for the focus event, it's due to one of three reasons:
              // 1) The window has just regained focus, in which case we want to restore the focused state of
              //    the element from before the window blurred.
              // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.
              // 3) The element was programmatically focused, in which case we should mark the origin as
              //    'program'.
              /** @type {?} */
              var origin = this._origin;
              if (!origin) {
                  if (this._windowFocused && this._lastFocusOrigin) {
                      origin = this._lastFocusOrigin;
                  }
                  else if (this._wasCausedByTouch(event)) {
                      origin = 'touch';
                  }
                  else {
                      origin = 'program';
                  }
              }
              this._setClasses(element, origin);
              this._emitOrigin(elementInfo.subject, origin);
              this._lastFocusOrigin = origin;
          };
      /**
       * Handles blur events on a registered element.
       * @param event The blur event.
       * @param element The monitored element.
       */
      /**
       * Handles blur events on a registered element.
       * @param {?} event The blur event.
       * @param {?} element The monitored element.
       * @return {?}
       */
      FocusMonitor.prototype._onBlur = /**
       * Handles blur events on a registered element.
       * @param {?} event The blur event.
       * @param {?} element The monitored element.
       * @return {?}
       */
          function (event, element) {
              // If we are counting child-element-focus as focused, make sure that we aren't just blurring in
              // order to focus another child of the monitored element.
              /** @type {?} */
              var elementInfo = this._elementInfo.get(element);
              if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&
                  element.contains(event.relatedTarget))) {
                  return;
              }
              this._setClasses(element);
              this._emitOrigin(elementInfo.subject, null);
          };
      /**
       * @private
       * @param {?} subject
       * @param {?} origin
       * @return {?}
       */
      FocusMonitor.prototype._emitOrigin = /**
       * @private
       * @param {?} subject
       * @param {?} origin
       * @return {?}
       */
          function (subject, origin) {
              this._ngZone.run(function () { return subject.next(origin); });
          };
      /**
       * @private
       * @return {?}
       */
      FocusMonitor.prototype._incrementMonitoredElementCount = /**
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              // Register global listeners when first element is monitored.
              if (++this._monitoredElementCount == 1 && this._platform.isBrowser) {
                  // Note: we listen to events in the capture phase so we
                  // can detect them even if the user stops propagation.
                  this._ngZone.runOutsideAngular(function () {
                      document.addEventListener('keydown', _this._documentKeydownListener, captureEventListenerOptions);
                      document.addEventListener('mousedown', _this._documentMousedownListener, captureEventListenerOptions);
                      document.addEventListener('touchstart', _this._documentTouchstartListener, captureEventListenerOptions);
                      window.addEventListener('focus', _this._windowFocusListener);
                  });
              }
          };
      /**
       * @private
       * @return {?}
       */
      FocusMonitor.prototype._decrementMonitoredElementCount = /**
       * @private
       * @return {?}
       */
          function () {
              // Unregister global listeners when last element is unmonitored.
              if (!--this._monitoredElementCount) {
                  document.removeEventListener('keydown', this._documentKeydownListener, captureEventListenerOptions);
                  document.removeEventListener('mousedown', this._documentMousedownListener, captureEventListenerOptions);
                  document.removeEventListener('touchstart', this._documentTouchstartListener, captureEventListenerOptions);
                  window.removeEventListener('focus', this._windowFocusListener);
                  // Clear timeouts for all potentially pending timeouts to prevent the leaks.
                  clearTimeout(this._windowFocusTimeoutId);
                  clearTimeout(this._touchTimeoutId);
                  clearTimeout(this._originTimeoutId);
              }
          };
      FocusMonitor.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */
      FocusMonitor.ctorParameters = function () {
          return [
              { type: core.NgZone },
              { type: Platform }
          ];
      };
      /** @nocollapse */ FocusMonitor.ngInjectableDef = core.defineInjectable({ factory: function FocusMonitor_Factory() { return new FocusMonitor(core.inject(core.NgZone), core.inject(Platform)); }, token: FocusMonitor, providedIn: "root" });
      return FocusMonitor;
  }());
  /**
   * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or
   * programmatically) and adds corresponding classes to the element.
   *
   * There are two variants of this directive:
   * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is
   *    focused.
   * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.
   */
  var CdkMonitorFocus = /** @class */ (function () {
      function CdkMonitorFocus(_elementRef, _focusMonitor) {
          var _this = this;
          this._elementRef = _elementRef;
          this._focusMonitor = _focusMonitor;
          this.cdkFocusChange = new core.EventEmitter();
          this._monitorSubscription = this._focusMonitor.monitor(this._elementRef, this._elementRef.nativeElement.hasAttribute('cdkMonitorSubtreeFocus'))
              .subscribe(function (origin) { return _this.cdkFocusChange.emit(origin); });
      }
      /**
       * @return {?}
       */
      CdkMonitorFocus.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._focusMonitor.stopMonitoring(this._elementRef);
              this._monitorSubscription.unsubscribe();
          };
      CdkMonitorFocus.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',
                  },] },
      ];
      /** @nocollapse */
      CdkMonitorFocus.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: FocusMonitor }
          ];
      };
      CdkMonitorFocus.propDecorators = {
          cdkFocusChange: [{ type: core.Output }]
      };
      return CdkMonitorFocus;
  }());
  /**
   * \@docs-private \@deprecated \@breaking-change 8.0.0
   * @param {?} parentDispatcher
   * @param {?} ngZone
   * @param {?} platform
   * @return {?}
   */
  function FOCUS_MONITOR_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {
      return parentDispatcher || new FocusMonitor(ngZone, platform);
  }
  /**
   * \@docs-private \@deprecated \@breaking-change 8.0.0
   * @type {?}
   */
  var FOCUS_MONITOR_PROVIDER = {
      // If there is already a FocusMonitor available, use that. Otherwise, provide a new one.
      provide: FocusMonitor,
      deps: [[new core.Optional(), new core.SkipSelf(), FocusMonitor], core.NgZone, Platform],
      useFactory: FOCUS_MONITOR_PROVIDER_FACTORY
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Screenreaders will often fire fake mousedown events when a focusable element
   * is activated using the keyboard. We can typically distinguish between these faked
   * mousedown events and real mousedown events using the "buttons" property. While
   * real mousedowns will indicate the mouse button that was pressed (e.g. "1" for
   * the left mouse button), faked mousedowns will usually set the property value to 0.
   * @param {?} event
   * @return {?}
   */
  function isFakeMousedownFromScreenReader(event) {
      return event.buttons === 0;
  }

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token used to inject the document into Directionality.
   * This is used so that the value can be faked in tests.
   *
   * We can't use the real document in tests because changing the real `dir` causes geometry-based
   * tests in Safari to fail.
   *
   * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests
   * themselves use things like `querySelector` in test code.
   *
   * This token is defined in a separate file from Directionality as a workaround for
   * https://github.com/angular/angular/issues/22559
   *
   * \@docs-private
   * @type {?}
   */
  var DIR_DOCUMENT = new core.InjectionToken('cdk-dir-doc', {
      providedIn: 'root',
      factory: DIR_DOCUMENT_FACTORY,
  });
  /**
   * \@docs-private
   * @return {?}
   */
  function DIR_DOCUMENT_FACTORY() {
      return core.inject(common.DOCUMENT);
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * The directionality (LTR / RTL) context for the application (or a subtree of it).
   * Exposes the current direction and a stream of direction changes.
   */
  var Directionality = /** @class */ (function () {
      function Directionality(_document) {
          /**
           * The current 'ltr' or 'rtl' value.
           */
          this.value = 'ltr';
          /**
           * Stream that emits whenever the 'ltr' / 'rtl' state changes.
           */
          this.change = new core.EventEmitter();
          if (_document) {
              // TODO: handle 'auto' value -
              // We still need to account for dir="auto".
              // It looks like HTMLElemenet.dir is also "auto" when that's set to the attribute,
              // but getComputedStyle return either "ltr" or "rtl". avoiding getComputedStyle for now
              /** @type {?} */
              var bodyDir = _document.body ? _document.body.dir : null;
              /** @type {?} */
              var htmlDir = _document.documentElement ? _document.documentElement.dir : null;
              /** @type {?} */
              var value = bodyDir || htmlDir;
              this.value = (value === 'ltr' || value === 'rtl') ? value : 'ltr';
          }
      }
      /**
       * @return {?}
       */
      Directionality.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this.change.complete();
          };
      Directionality.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */
      Directionality.ctorParameters = function () {
          return [
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DIR_DOCUMENT,] }] }
          ];
      };
      /** @nocollapse */ Directionality.ngInjectableDef = core.defineInjectable({ factory: function Directionality_Factory() { return new Directionality(core.inject(DIR_DOCUMENT, 8)); }, token: Directionality, providedIn: "root" });
      return Directionality;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Directive to listen for changes of direction of part of the DOM.
   *
   * Provides itself as Directionality such that descendant directives only need to ever inject
   * Directionality to get the closest direction.
   */
  var Dir = /** @class */ (function () {
      function Dir() {
          /**
           * Normalized direction that accounts for invalid/unsupported values.
           */
          this._dir = 'ltr';
          /**
           * Whether the `value` has been set to its initial value.
           */
          this._isInitialized = false;
          /**
           * Event emitted when the direction changes.
           */
          this.change = new core.EventEmitter();
      }
      Object.defineProperty(Dir.prototype, "dir", {
          /** @docs-private */
          get: /**
           * \@docs-private
           * @return {?}
           */ function () { return this._dir; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var old = this._dir;
              this._rawDir = value;
              this._dir = (value === 'ltr' || value === 'rtl') ? value : 'ltr';
              if (old !== this._dir && this._isInitialized) {
                  this.change.emit(this._dir);
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(Dir.prototype, "value", {
          /** Current layout direction of the element. */
          get: /**
           * Current layout direction of the element.
           * @return {?}
           */ function () { return this.dir; },
          enumerable: true,
          configurable: true
      });
      /** Initialize once default value has been set. */
      /**
       * Initialize once default value has been set.
       * @return {?}
       */
      Dir.prototype.ngAfterContentInit = /**
       * Initialize once default value has been set.
       * @return {?}
       */
          function () {
              this._isInitialized = true;
          };
      /**
       * @return {?}
       */
      Dir.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this.change.complete();
          };
      Dir.decorators = [
          { type: core.Directive, args: [{
                      selector: '[dir]',
                      providers: [{ provide: Directionality, useExisting: Dir }],
                      host: { '[attr.dir]': '_rawDir' },
                      exportAs: 'dir',
                  },] },
      ];
      Dir.propDecorators = {
          change: [{ type: core.Output, args: ['dirChange',] }],
          dir: [{ type: core.Input }]
      };
      return Dir;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var BidiModule = /** @class */ (function () {
      function BidiModule() {
      }
      BidiModule.decorators = [
          { type: core.NgModule, args: [{
                      exports: [Dir],
                      declarations: [Dir],
                  },] },
      ];
      return BidiModule;
  }());

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@docs-private
   */
  var AnimationCurves = /** @class */ (function () {
      function AnimationCurves() {
      }
      AnimationCurves.STANDARD_CURVE = 'cubic-bezier(0.4,0.0,0.2,1)';
      AnimationCurves.DECELERATION_CURVE = 'cubic-bezier(0.0,0.0,0.2,1)';
      AnimationCurves.ACCELERATION_CURVE = 'cubic-bezier(0.4,0.0,1,1)';
      AnimationCurves.SHARP_CURVE = 'cubic-bezier(0.4,0.0,0.6,1)';
      return AnimationCurves;
  }());
  /**
   * \@docs-private
   */
  var AnimationDurations = /** @class */ (function () {
      function AnimationDurations() {
      }
      AnimationDurations.COMPLEX = '375ms';
      AnimationDurations.ENTERING = '225ms';
      AnimationDurations.EXITING = '195ms';
      return AnimationDurations;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token that configures whether the Material sanity checks are enabled.
   * @type {?}
   */
  var MATERIAL_SANITY_CHECKS = new core.InjectionToken('mat-sanity-checks', {
      providedIn: 'root',
      factory: MATERIAL_SANITY_CHECKS_FACTORY,
  });
  /**
   * \@docs-private
   * @return {?}
   */
  function MATERIAL_SANITY_CHECKS_FACTORY() {
      return true;
  }
  /**
   * Module that captures anything that should be loaded and/or run for *all* Angular Material
   * components. This includes Bidi, etc.
   *
   * This module should be imported to each top-level component module (e.g., MatTabsModule).
   */
  var MatCommonModule = /** @class */ (function () {
      function MatCommonModule(_sanityChecksEnabled, _hammerLoader) {
          this._sanityChecksEnabled = _sanityChecksEnabled;
          this._hammerLoader = _hammerLoader;
          /**
           * Whether we've done the global sanity checks (e.g. a theme is loaded, there is a doctype).
           */
          this._hasDoneGlobalChecks = false;
          /**
           * Whether we've already checked for HammerJs availability.
           */
          this._hasCheckedHammer = false;
          /**
           * Reference to the global `document` object.
           */
          this._document = typeof document === 'object' && document ? document : null;
          /**
           * Reference to the global 'window' object.
           */
          this._window = typeof window === 'object' && window ? window : null;
          if (this._areChecksEnabled() && !this._hasDoneGlobalChecks) {
              this._checkDoctypeIsDefined();
              this._checkThemeIsPresent();
              this._hasDoneGlobalChecks = true;
          }
      }
      /** Whether any sanity checks are enabled */
      /**
       * Whether any sanity checks are enabled
       * @private
       * @return {?}
       */
      MatCommonModule.prototype._areChecksEnabled = /**
       * Whether any sanity checks are enabled
       * @private
       * @return {?}
       */
          function () {
              return this._sanityChecksEnabled && core.isDevMode() && !this._isTestEnv();
          };
      /** Whether the code is running in tests. */
      /**
       * Whether the code is running in tests.
       * @private
       * @return {?}
       */
      MatCommonModule.prototype._isTestEnv = /**
       * Whether the code is running in tests.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var window = ( /** @type {?} */(this._window));
              return window && (window.__karma__ || window.jasmine);
          };
      /**
       * @private
       * @return {?}
       */
      MatCommonModule.prototype._checkDoctypeIsDefined = /**
       * @private
       * @return {?}
       */
          function () {
              if (this._document && !this._document.doctype) {
                  console.warn('Current document does not have a doctype. This may cause ' +
                      'some Angular Material components not to behave as expected.');
              }
          };
      /**
       * @private
       * @return {?}
       */
      MatCommonModule.prototype._checkThemeIsPresent = /**
       * @private
       * @return {?}
       */
          function () {
              // We need to assert that the `body` is defined, because these checks run very early
              // and the `body` won't be defined if the consumer put their scripts in the `head`.
              if (!this._document || !this._document.body || typeof getComputedStyle !== 'function') {
                  return;
              }
              /** @type {?} */
              var testElement = this._document.createElement('div');
              testElement.classList.add('mat-theme-loaded-marker');
              this._document.body.appendChild(testElement);
              /** @type {?} */
              var computedStyle = getComputedStyle(testElement);
              // In some situations the computed style of the test element can be null. For example in
              // Firefox, the computed style is null if an application is running inside of a hidden iframe.
              // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397
              if (computedStyle && computedStyle.display !== 'none') {
                  console.warn('Could not find Angular Material core theme. Most Material ' +
                      'components may not work as expected. For more info refer ' +
                      'to the theming guide: https://material.angular.io/guide/theming');
              }
              this._document.body.removeChild(testElement);
          };
      /** Checks whether HammerJS is available. */
      /**
       * Checks whether HammerJS is available.
       * @return {?}
       */
      MatCommonModule.prototype._checkHammerIsAvailable = /**
       * Checks whether HammerJS is available.
       * @return {?}
       */
          function () {
              if (this._hasCheckedHammer || !this._window) {
                  return;
              }
              if (this._areChecksEnabled() && !(( /** @type {?} */(this._window)))['Hammer'] && !this._hammerLoader) {
                  console.warn('Could not find HammerJS. Certain Angular Material components may not work correctly.');
              }
              this._hasCheckedHammer = true;
          };
      MatCommonModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [BidiModule],
                      exports: [BidiModule],
                  },] },
      ];
      /** @nocollapse */
      MatCommonModule.ctorParameters = function () {
          return [
              { type: Boolean, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MATERIAL_SANITY_CHECKS,] }] },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [platformBrowser.HAMMER_LOADER,] }] }
          ];
      };
      return MatCommonModule;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Mixin to augment a directive with a `disabled` property.
   * @template T
   * @param {?} base
   * @return {?}
   */
  function mixinDisabled(base) {
      return /** @class */ (function (_super) {
          tslib_1.__extends(class_1, _super);
          function class_1() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
              }
              var _this = _super.apply(this, args) || this;
              _this._disabled = false;
              return _this;
          }
          Object.defineProperty(class_1.prototype, "disabled", {
              get: /**
               * @return {?}
               */ function () { return this._disabled; },
              set: /**
               * @param {?} value
               * @return {?}
               */ function (value) { this._disabled = coerceBooleanProperty(value); },
              enumerable: true,
              configurable: true
          });
          return class_1;
      }(base));
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Mixin to augment a directive with a `color` property.
   * @template T
   * @param {?} base
   * @param {?=} defaultColor
   * @return {?}
   */
  function mixinColor(base, defaultColor) {
      return /** @class */ (function (_super) {
          tslib_1.__extends(class_1, _super);
          function class_1() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
              }
              var _this = _super.apply(this, args) || this;
              // Set the default color that can be specified from the mixin.
              _this.color = defaultColor;
              return _this;
          }
          Object.defineProperty(class_1.prototype, "color", {
              get: /**
               * @return {?}
               */ function () { return this._color; },
              set: /**
               * @param {?} value
               * @return {?}
               */ function (value) {
                  /** @type {?} */
                  var colorPalette = value || defaultColor;
                  if (colorPalette !== this._color) {
                      if (this._color) {
                          this._elementRef.nativeElement.classList.remove("mat-" + this._color);
                      }
                      if (colorPalette) {
                          this._elementRef.nativeElement.classList.add("mat-" + colorPalette);
                      }
                      this._color = colorPalette;
                  }
              },
              enumerable: true,
              configurable: true
          });
          return class_1;
      }(base));
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Mixin to augment a directive with a `disableRipple` property.
   * @template T
   * @param {?} base
   * @return {?}
   */
  function mixinDisableRipple(base) {
      return /** @class */ (function (_super) {
          tslib_1.__extends(class_1, _super);
          function class_1() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
              }
              var _this = _super.apply(this, args) || this;
              _this._disableRipple = false;
              return _this;
          }
          Object.defineProperty(class_1.prototype, "disableRipple", {
              /** Whether the ripple effect is disabled or not. */
              get: /**
               * Whether the ripple effect is disabled or not.
               * @return {?}
               */ function () { return this._disableRipple; },
              set: /**
               * @param {?} value
               * @return {?}
               */ function (value) { this._disableRipple = coerceBooleanProperty(value); },
              enumerable: true,
              configurable: true
          });
          return class_1;
      }(base));
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Mixin to augment a directive with a `tabIndex` property.
   * @template T
   * @param {?} base
   * @param {?=} defaultTabIndex
   * @return {?}
   */
  function mixinTabIndex(base, defaultTabIndex) {
      if (defaultTabIndex === void 0) {
          defaultTabIndex = 0;
      }
      return /** @class */ (function (_super) {
          tslib_1.__extends(class_1, _super);
          function class_1() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
              }
              var _this = _super.apply(this, args) || this;
              _this._tabIndex = defaultTabIndex;
              return _this;
          }
          Object.defineProperty(class_1.prototype, "tabIndex", {
              get: /**
               * @return {?}
               */ function () { return this.disabled ? -1 : this._tabIndex; },
              set: /**
               * @param {?} value
               * @return {?}
               */ function (value) {
                  // If the specified tabIndex value is null or undefined, fall back to the default value.
                  this._tabIndex = value != null ? value : defaultTabIndex;
              },
              enumerable: true,
              configurable: true
          });
          return class_1;
      }(base));
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Mixin to augment a directive with updateErrorState method.
   * For component with `errorState` and need to update `errorState`.
   * @template T
   * @param {?} base
   * @return {?}
   */
  function mixinErrorState(base) {
      return /** @class */ (function (_super) {
          tslib_1.__extends(class_1, _super);
          function class_1() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
              }
              var _this = _super.apply(this, args) || this;
              /**
               * Whether the component is in an error state.
               */
              _this.errorState = false;
              /**
               * Stream that emits whenever the state of the input changes such that the wrapping
               * `MatFormField` needs to run change detection.
               */
              _this.stateChanges = new rxjs.Subject();
              return _this;
          }
          /**
           * @return {?}
           */
          class_1.prototype.updateErrorState = /**
           * @return {?}
           */
              function () {
                  /** @type {?} */
                  var oldState = this.errorState;
                  /** @type {?} */
                  var parent = this._parentFormGroup || this._parentForm;
                  /** @type {?} */
                  var matcher = this.errorStateMatcher || this._defaultErrorStateMatcher;
                  /** @type {?} */
                  var control = this.ngControl ? ( /** @type {?} */(this.ngControl.control)) : null;
                  /** @type {?} */
                  var newState = matcher.isErrorState(control, parent);
                  if (newState !== oldState) {
                      this.errorState = newState;
                      this.stateChanges.next();
                  }
              };
          return class_1;
      }(base));
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Mixin to augment a directive with an initialized property that will emits when ngOnInit ends.
   * @template T
   * @param {?} base
   * @return {?}
   */
  function mixinInitialized(base) {
      return /** @class */ (function (_super) {
          tslib_1.__extends(class_1, _super);
          function class_1() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
              }
              var _this = _super.apply(this, args) || this;
              /**
               * Whether this directive has been marked as initialized.
               */
              _this._isInitialized = false;
              /**
               * List of subscribers that subscribed before the directive was initialized. Should be notified
               * during _markInitialized. Set to null after pending subscribers are notified, and should
               * not expect to be populated after.
               */
              _this._pendingSubscribers = [];
              /**
               * Observable stream that emits when the directive initializes. If already initialized, the
               * subscriber is stored to be notified once _markInitialized is called.
               */
              _this.initialized = new rxjs.Observable(function (subscriber) {
                  // If initialized, immediately notify the subscriber. Otherwise store the subscriber to notify
                  // when _markInitialized is called.
                  if (_this._isInitialized) {
                      _this._notifySubscriber(subscriber);
                  }
                  else {
                      ( /** @type {?} */(_this._pendingSubscribers)).push(subscriber);
                  }
              });
              return _this;
          }
          /**
           * Marks the state as initialized and notifies pending subscribers. Should be called at the end
           * of ngOnInit.
           * @docs-private
           */
          /**
           * Marks the state as initialized and notifies pending subscribers. Should be called at the end
           * of ngOnInit.
           * \@docs-private
           * @return {?}
           */
          class_1.prototype._markInitialized = /**
           * Marks the state as initialized and notifies pending subscribers. Should be called at the end
           * of ngOnInit.
           * \@docs-private
           * @return {?}
           */
              function () {
                  if (this._isInitialized) {
                      throw Error('This directive has already been marked as initialized and ' +
                          'should not be called twice.');
                  }
                  this._isInitialized = true;
                  ( /** @type {?} */(this._pendingSubscribers)).forEach(this._notifySubscriber);
                  this._pendingSubscribers = null;
              };
          /** Emits and completes the subscriber stream (should only emit once). */
          /**
           * Emits and completes the subscriber stream (should only emit once).
           * @param {?} subscriber
           * @return {?}
           */
          class_1.prototype._notifySubscriber = /**
           * Emits and completes the subscriber stream (should only emit once).
           * @param {?} subscriber
           * @return {?}
           */
              function (subscriber) {
                  subscriber.next();
                  subscriber.complete();
              };
          return class_1;
      }(base));
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * InjectionToken for datepicker that can be used to override default locale code.
   * @type {?}
   */
  var MAT_DATE_LOCALE = new core.InjectionToken('MAT_DATE_LOCALE', {
      providedIn: 'root',
      factory: MAT_DATE_LOCALE_FACTORY,
  });
  /**
   * \@docs-private
   * @return {?}
   */
  function MAT_DATE_LOCALE_FACTORY() {
      return core.inject(core.LOCALE_ID);
  }
  /**
   * Adapts type `D` to be usable as a date by cdk-based components that work with dates.
   * @abstract
   * @template D
   */
  var /**
   * Adapts type `D` to be usable as a date by cdk-based components that work with dates.
   * @abstract
   * @template D
   */ DateAdapter = /** @class */ (function () {
      function DateAdapter() {
          this._localeChanges = new rxjs.Subject();
      }
      Object.defineProperty(DateAdapter.prototype, "localeChanges", {
          /** A stream that emits when the locale changes. */
          get: /**
           * A stream that emits when the locale changes.
           * @return {?}
           */ function () { return this._localeChanges; },
          enumerable: true,
          configurable: true
      });
      /**
       * Attempts to deserialize a value to a valid date object. This is different from parsing in that
       * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601
       * string). The default implementation does not allow any deserialization, it simply checks that
       * the given value is already a valid date object or null. The `<mat-datepicker>` will call this
       * method on all of it's `@Input()` properties that accept dates. It is therefore possible to
       * support passing values from your backend directly to these properties by overriding this method
       * to also deserialize the format used by your backend.
       * @param value The value to be deserialized into a date object.
       * @returns The deserialized date object, either a valid date, null if the value can be
       *     deserialized into a null date (e.g. the empty string), or an invalid date.
       */
      /**
       * Attempts to deserialize a value to a valid date object. This is different from parsing in that
       * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601
       * string). The default implementation does not allow any deserialization, it simply checks that
       * the given value is already a valid date object or null. The `<mat-datepicker>` will call this
       * method on all of it's `\@Input()` properties that accept dates. It is therefore possible to
       * support passing values from your backend directly to these properties by overriding this method
       * to also deserialize the format used by your backend.
       * @param {?} value The value to be deserialized into a date object.
       * @return {?} The deserialized date object, either a valid date, null if the value can be
       *     deserialized into a null date (e.g. the empty string), or an invalid date.
       */
      DateAdapter.prototype.deserialize = /**
       * Attempts to deserialize a value to a valid date object. This is different from parsing in that
       * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601
       * string). The default implementation does not allow any deserialization, it simply checks that
       * the given value is already a valid date object or null. The `<mat-datepicker>` will call this
       * method on all of it's `\@Input()` properties that accept dates. It is therefore possible to
       * support passing values from your backend directly to these properties by overriding this method
       * to also deserialize the format used by your backend.
       * @param {?} value The value to be deserialized into a date object.
       * @return {?} The deserialized date object, either a valid date, null if the value can be
       *     deserialized into a null date (e.g. the empty string), or an invalid date.
       */
          function (value) {
              if (value == null || this.isDateInstance(value) && this.isValid(value)) {
                  return value;
              }
              return this.invalid();
          };
      /**
       * Sets the locale used for all dates.
       * @param locale The new locale.
       */
      /**
       * Sets the locale used for all dates.
       * @param {?} locale The new locale.
       * @return {?}
       */
      DateAdapter.prototype.setLocale = /**
       * Sets the locale used for all dates.
       * @param {?} locale The new locale.
       * @return {?}
       */
          function (locale) {
              this.locale = locale;
              this._localeChanges.next();
          };
      /**
       * Compares two dates.
       * @param first The first date to compare.
       * @param second The second date to compare.
       * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,
       *     a number greater than 0 if the first date is later.
       */
      /**
       * Compares two dates.
       * @param {?} first The first date to compare.
       * @param {?} second The second date to compare.
       * @return {?} 0 if the dates are equal, a number less than 0 if the first date is earlier,
       *     a number greater than 0 if the first date is later.
       */
      DateAdapter.prototype.compareDate = /**
       * Compares two dates.
       * @param {?} first The first date to compare.
       * @param {?} second The second date to compare.
       * @return {?} 0 if the dates are equal, a number less than 0 if the first date is earlier,
       *     a number greater than 0 if the first date is later.
       */
          function (first, second) {
              return this.getYear(first) - this.getYear(second) ||
                  this.getMonth(first) - this.getMonth(second) ||
                  this.getDate(first) - this.getDate(second);
          };
      /**
       * Checks if two dates are equal.
       * @param first The first date to check.
       * @param second The second date to check.
       * @returns Whether the two dates are equal.
       *     Null dates are considered equal to other null dates.
       */
      /**
       * Checks if two dates are equal.
       * @param {?} first The first date to check.
       * @param {?} second The second date to check.
       * @return {?} Whether the two dates are equal.
       *     Null dates are considered equal to other null dates.
       */
      DateAdapter.prototype.sameDate = /**
       * Checks if two dates are equal.
       * @param {?} first The first date to check.
       * @param {?} second The second date to check.
       * @return {?} Whether the two dates are equal.
       *     Null dates are considered equal to other null dates.
       */
          function (first, second) {
              if (first && second) {
                  /** @type {?} */
                  var firstValid = this.isValid(first);
                  /** @type {?} */
                  var secondValid = this.isValid(second);
                  if (firstValid && secondValid) {
                      return !this.compareDate(first, second);
                  }
                  return firstValid == secondValid;
              }
              return first == second;
          };
      /**
       * Clamp the given date between min and max dates.
       * @param date The date to clamp.
       * @param min The minimum value to allow. If null or omitted no min is enforced.
       * @param max The maximum value to allow. If null or omitted no max is enforced.
       * @returns `min` if `date` is less than `min`, `max` if date is greater than `max`,
       *     otherwise `date`.
       */
      /**
       * Clamp the given date between min and max dates.
       * @param {?} date The date to clamp.
       * @param {?=} min The minimum value to allow. If null or omitted no min is enforced.
       * @param {?=} max The maximum value to allow. If null or omitted no max is enforced.
       * @return {?} `min` if `date` is less than `min`, `max` if date is greater than `max`,
       *     otherwise `date`.
       */
      DateAdapter.prototype.clampDate = /**
       * Clamp the given date between min and max dates.
       * @param {?} date The date to clamp.
       * @param {?=} min The minimum value to allow. If null or omitted no min is enforced.
       * @param {?=} max The maximum value to allow. If null or omitted no max is enforced.
       * @return {?} `min` if `date` is less than `min`, `max` if date is greater than `max`,
       *     otherwise `date`.
       */
          function (date, min, max) {
              if (min && this.compareDate(date, min) < 0) {
                  return min;
              }
              if (max && this.compareDate(date, max) > 0) {
                  return max;
              }
              return date;
          };
      return DateAdapter;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var MAT_DATE_FORMATS = new core.InjectionToken('mat-date-formats');
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // TODO(mmalerba): Remove when we no longer support safari 9.
  /**
   * Whether the browser supports the Intl API.
   * @type {?}
   */
  var SUPPORTS_INTL_API = typeof Intl != 'undefined';
  /**
   * The default month names to use if Intl API is not available.
   * @type {?}
   */
  var DEFAULT_MONTH_NAMES = {
      'long': [
          'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',
          'October', 'November', 'December'
      ],
      'short': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      'narrow': ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D']
  };
  var ɵ0 = function (i) { return String(i + 1); };
  /**
   * The default date names to use if Intl API is not available.
   * @type {?}
   */
  var DEFAULT_DATE_NAMES = range(31, ɵ0);
  /**
   * The default day of the week names to use if Intl API is not available.
   * @type {?}
   */
  var DEFAULT_DAY_OF_WEEK_NAMES = {
      'long': ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
      'short': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      'narrow': ['S', 'M', 'T', 'W', 'T', 'F', 'S']
  };
  /**
   * Matches strings that have the form of a valid RFC 3339 string
   * (https://tools.ietf.org/html/rfc3339). Note that the string may not actually be a valid date
   * because the regex will match strings an with out of bounds month, date, etc.
   * @type {?}
   */
  var ISO_8601_REGEX = /^\d{4}-\d{2}-\d{2}(?:T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|(?:(?:\+|-)\d{2}:\d{2}))?)?$/;
  /**
   * Creates an array and fills it with values.
   * @template T
   * @param {?} length
   * @param {?} valueFunction
   * @return {?}
   */
  function range(length, valueFunction) {
      /** @type {?} */
      var valuesArray = Array(length);
      for (var i = 0; i < length; i++) {
          valuesArray[i] = valueFunction(i);
      }
      return valuesArray;
  }
  /**
   * Adapts the native JS Date for use with cdk-based components that work with dates.
   */
  var NativeDateAdapter = /** @class */ (function (_super) {
      tslib_1.__extends(NativeDateAdapter, _super);
      function NativeDateAdapter(matDateLocale, platform) {
          var _this = _super.call(this) || this;
          /**
           * Whether to use `timeZone: 'utc'` with `Intl.DateTimeFormat` when formatting dates.
           * Without this `Intl.DateTimeFormat` sometimes chooses the wrong timeZone, which can throw off
           * the result. (e.g. in the en-US locale `new Date(1800, 7, 14).toLocaleDateString()`
           * will produce `'8/13/1800'`.
           *
           * TODO(mmalerba): drop this variable. It's not being used in the code right now. We're now
           * getting the string representation of a Date object from it's utc representation. We're keeping
           * it here for sometime, just for precaution, in case we decide to revert some of these changes
           * though.
           */
          _this.useUtcForDisplay = true;
          _super.prototype.setLocale.call(_this, matDateLocale);
          // IE does its own time zone correction, so we disable this on IE.
          _this.useUtcForDisplay = !platform.TRIDENT;
          _this._clampDate = platform.TRIDENT || platform.EDGE;
          return _this;
      }
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.getYear = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date.getFullYear();
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.getMonth = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date.getMonth();
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.getDate = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date.getDate();
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.getDayOfWeek = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date.getDay();
          };
      /**
       * @param {?} style
       * @return {?}
       */
      NativeDateAdapter.prototype.getMonthNames = /**
       * @param {?} style
       * @return {?}
       */
          function (style) {
              var _this = this;
              if (SUPPORTS_INTL_API) {
                  /** @type {?} */
                  var dtf_1 = new Intl.DateTimeFormat(this.locale, { month: style, timeZone: 'utc' });
                  return range(12, function (i) {
                      return _this._stripDirectionalityCharacters(_this._format(dtf_1, new Date(2017, i, 1)));
                  });
              }
              return DEFAULT_MONTH_NAMES[style];
          };
      /**
       * @return {?}
       */
      NativeDateAdapter.prototype.getDateNames = /**
       * @return {?}
       */
          function () {
              var _this = this;
              if (SUPPORTS_INTL_API) {
                  /** @type {?} */
                  var dtf_2 = new Intl.DateTimeFormat(this.locale, { day: 'numeric', timeZone: 'utc' });
                  return range(31, function (i) { return _this._stripDirectionalityCharacters(_this._format(dtf_2, new Date(2017, 0, i + 1))); });
              }
              return DEFAULT_DATE_NAMES;
          };
      /**
       * @param {?} style
       * @return {?}
       */
      NativeDateAdapter.prototype.getDayOfWeekNames = /**
       * @param {?} style
       * @return {?}
       */
          function (style) {
              var _this = this;
              if (SUPPORTS_INTL_API) {
                  /** @type {?} */
                  var dtf_3 = new Intl.DateTimeFormat(this.locale, { weekday: style, timeZone: 'utc' });
                  return range(7, function (i) { return _this._stripDirectionalityCharacters(_this._format(dtf_3, new Date(2017, 0, i + 1))); });
              }
              return DEFAULT_DAY_OF_WEEK_NAMES[style];
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.getYearName = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              if (SUPPORTS_INTL_API) {
                  /** @type {?} */
                  var dtf = new Intl.DateTimeFormat(this.locale, { year: 'numeric', timeZone: 'utc' });
                  return this._stripDirectionalityCharacters(this._format(dtf, date));
              }
              return String(this.getYear(date));
          };
      /**
       * @return {?}
       */
      NativeDateAdapter.prototype.getFirstDayOfWeek = /**
       * @return {?}
       */
          function () {
              // We can't tell using native JS Date what the first day of the week is, we default to Sunday.
              return 0;
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.getNumDaysInMonth = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return this.getDate(this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + 1, 0));
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.clone = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return new Date(date.getTime());
          };
      /**
       * @param {?} year
       * @param {?} month
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.createDate = /**
       * @param {?} year
       * @param {?} month
       * @param {?} date
       * @return {?}
       */
          function (year, month, date) {
              // Check for invalid month and date (except upper bound on date which we have to check after
              // creating the Date).
              if (month < 0 || month > 11) {
                  throw Error("Invalid month index \"" + month + "\". Month index has to be between 0 and 11.");
              }
              if (date < 1) {
                  throw Error("Invalid date \"" + date + "\". Date has to be greater than 0.");
              }
              /** @type {?} */
              var result = this._createDateWithOverflow(year, month, date);
              // Check that the date wasn't above the upper bound for the month, causing the month to overflow
              if (result.getMonth() != month) {
                  throw Error("Invalid date \"" + date + "\" for month with index \"" + month + "\".");
              }
              return result;
          };
      /**
       * @return {?}
       */
      NativeDateAdapter.prototype.today = /**
       * @return {?}
       */
          function () {
              return new Date();
          };
      /**
       * @param {?} value
       * @return {?}
       */
      NativeDateAdapter.prototype.parse = /**
       * @param {?} value
       * @return {?}
       */
          function (value) {
              // We have no way using the native JS Date to set the parse format or locale, so we ignore these
              // parameters.
              if (typeof value == 'number') {
                  return new Date(value);
              }
              return value ? new Date(Date.parse(value)) : null;
          };
      /**
       * @param {?} date
       * @param {?} displayFormat
       * @return {?}
       */
      NativeDateAdapter.prototype.format = /**
       * @param {?} date
       * @param {?} displayFormat
       * @return {?}
       */
          function (date, displayFormat) {
              if (!this.isValid(date)) {
                  throw Error('NativeDateAdapter: Cannot format invalid date.');
              }
              if (SUPPORTS_INTL_API) {
                  // On IE and Edge the i18n API will throw a hard error that can crash the entire app
                  // if we attempt to format a date whose year is less than 1 or greater than 9999.
                  if (this._clampDate && (date.getFullYear() < 1 || date.getFullYear() > 9999)) {
                      date = this.clone(date);
                      date.setFullYear(Math.max(1, Math.min(9999, date.getFullYear())));
                  }
                  displayFormat = tslib_1.__assign({}, displayFormat, { timeZone: 'utc' });
                  /** @type {?} */
                  var dtf = new Intl.DateTimeFormat(this.locale, displayFormat);
                  return this._stripDirectionalityCharacters(this._format(dtf, date));
              }
              return this._stripDirectionalityCharacters(date.toDateString());
          };
      /**
       * @param {?} date
       * @param {?} years
       * @return {?}
       */
      NativeDateAdapter.prototype.addCalendarYears = /**
       * @param {?} date
       * @param {?} years
       * @return {?}
       */
          function (date, years) {
              return this.addCalendarMonths(date, years * 12);
          };
      /**
       * @param {?} date
       * @param {?} months
       * @return {?}
       */
      NativeDateAdapter.prototype.addCalendarMonths = /**
       * @param {?} date
       * @param {?} months
       * @return {?}
       */
          function (date, months) {
              /** @type {?} */
              var newDate = this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + months, this.getDate(date));
              // It's possible to wind up in the wrong month if the original month has more days than the new
              // month. In this case we want to go to the last day of the desired month.
              // Note: the additional + 12 % 12 ensures we end up with a positive number, since JS % doesn't
              // guarantee this.
              if (this.getMonth(newDate) != ((this.getMonth(date) + months) % 12 + 12) % 12) {
                  newDate = this._createDateWithOverflow(this.getYear(newDate), this.getMonth(newDate), 0);
              }
              return newDate;
          };
      /**
       * @param {?} date
       * @param {?} days
       * @return {?}
       */
      NativeDateAdapter.prototype.addCalendarDays = /**
       * @param {?} date
       * @param {?} days
       * @return {?}
       */
          function (date, days) {
              return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date) + days);
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.toIso8601 = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return [
                  date.getUTCFullYear(),
                  this._2digit(date.getUTCMonth() + 1),
                  this._2digit(date.getUTCDate())
              ].join('-');
          };
      /**
       * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings
       * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an
       * invalid date for all other values.
       */
      /**
       * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings
       * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an
       * invalid date for all other values.
       * @param {?} value
       * @return {?}
       */
      NativeDateAdapter.prototype.deserialize = /**
       * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings
       * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an
       * invalid date for all other values.
       * @param {?} value
       * @return {?}
       */
          function (value) {
              if (typeof value === 'string') {
                  if (!value) {
                      return null;
                  }
                  // The `Date` constructor accepts formats other than ISO 8601, so we need to make sure the
                  // string is the right format first.
                  if (ISO_8601_REGEX.test(value)) {
                      /** @type {?} */
                      var date = new Date(value);
                      if (this.isValid(date)) {
                          return date;
                      }
                  }
              }
              return _super.prototype.deserialize.call(this, value);
          };
      /**
       * @param {?} obj
       * @return {?}
       */
      NativeDateAdapter.prototype.isDateInstance = /**
       * @param {?} obj
       * @return {?}
       */
          function (obj) {
              return obj instanceof Date;
          };
      /**
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype.isValid = /**
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return !isNaN(date.getTime());
          };
      /**
       * @return {?}
       */
      NativeDateAdapter.prototype.invalid = /**
       * @return {?}
       */
          function () {
              return new Date(NaN);
          };
      /** Creates a date but allows the month and date to overflow. */
      /**
       * Creates a date but allows the month and date to overflow.
       * @private
       * @param {?} year
       * @param {?} month
       * @param {?} date
       * @return {?}
       */
      NativeDateAdapter.prototype._createDateWithOverflow = /**
       * Creates a date but allows the month and date to overflow.
       * @private
       * @param {?} year
       * @param {?} month
       * @param {?} date
       * @return {?}
       */
          function (year, month, date) {
              /** @type {?} */
              var result = new Date(year, month, date);
              // We need to correct for the fact that JS native Date treats years in range [0, 99] as
              // abbreviations for 19xx.
              if (year >= 0 && year < 100) {
                  result.setFullYear(this.getYear(result) - 1900);
              }
              return result;
          };
      /**
       * Pads a number to make it two digits.
       * @param n The number to pad.
       * @returns The padded number.
       */
      /**
       * Pads a number to make it two digits.
       * @private
       * @param {?} n The number to pad.
       * @return {?} The padded number.
       */
      NativeDateAdapter.prototype._2digit = /**
       * Pads a number to make it two digits.
       * @private
       * @param {?} n The number to pad.
       * @return {?} The padded number.
       */
          function (n) {
              return ('00' + n).slice(-2);
          };
      /**
       * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while
       * other browsers do not. We remove them to make output consistent and because they interfere with
       * date parsing.
       * @param str The string to strip direction characters from.
       * @returns The stripped string.
       */
      /**
       * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while
       * other browsers do not. We remove them to make output consistent and because they interfere with
       * date parsing.
       * @private
       * @param {?} str The string to strip direction characters from.
       * @return {?} The stripped string.
       */
      NativeDateAdapter.prototype._stripDirectionalityCharacters = /**
       * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while
       * other browsers do not. We remove them to make output consistent and because they interfere with
       * date parsing.
       * @private
       * @param {?} str The string to strip direction characters from.
       * @return {?} The stripped string.
       */
          function (str) {
              return str.replace(/[\u200e\u200f]/g, '');
          };
      /**
       * When converting Date object to string, javascript built-in functions may return wrong
       * results because it applies its internal DST rules. The DST rules around the world change
       * very frequently, and the current valid rule is not always valid in previous years though.
       * We work around this problem building a new Date object which has its internal UTC
       * representation with the local date and time.
       * @param dtf Intl.DateTimeFormat object, containg the desired string format. It must have
       *    timeZone set to 'utc' to work fine.
       * @param date Date from which we want to get the string representation according to dtf
       * @returns A Date object with its UTC representation based on the passed in date info
       */
      /**
       * When converting Date object to string, javascript built-in functions may return wrong
       * results because it applies its internal DST rules. The DST rules around the world change
       * very frequently, and the current valid rule is not always valid in previous years though.
       * We work around this problem building a new Date object which has its internal UTC
       * representation with the local date and time.
       * @private
       * @param {?} dtf Intl.DateTimeFormat object, containg the desired string format. It must have
       *    timeZone set to 'utc' to work fine.
       * @param {?} date Date from which we want to get the string representation according to dtf
       * @return {?} A Date object with its UTC representation based on the passed in date info
       */
      NativeDateAdapter.prototype._format = /**
       * When converting Date object to string, javascript built-in functions may return wrong
       * results because it applies its internal DST rules. The DST rules around the world change
       * very frequently, and the current valid rule is not always valid in previous years though.
       * We work around this problem building a new Date object which has its internal UTC
       * representation with the local date and time.
       * @private
       * @param {?} dtf Intl.DateTimeFormat object, containg the desired string format. It must have
       *    timeZone set to 'utc' to work fine.
       * @param {?} date Date from which we want to get the string representation according to dtf
       * @return {?} A Date object with its UTC representation based on the passed in date info
       */
          function (dtf, date) {
              /** @type {?} */
              var d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
              return dtf.format(d);
          };
      NativeDateAdapter.decorators = [
          { type: core.Injectable },
      ];
      /** @nocollapse */
      NativeDateAdapter.ctorParameters = function () {
          return [
              { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_DATE_LOCALE,] }] },
              { type: Platform }
          ];
      };
      return NativeDateAdapter;
  }(DateAdapter));
  /**
   * Provider that defines how form controls behave with regards to displaying error messages.
   */
  var ErrorStateMatcher = /** @class */ (function () {
      function ErrorStateMatcher() {
      }
      /**
       * @param {?} control
       * @param {?} form
       * @return {?}
       */
      ErrorStateMatcher.prototype.isErrorState = /**
       * @param {?} control
       * @param {?} form
       * @return {?}
       */
          function (control, form) {
              return !!(control && control.invalid && (control.touched || (form && form.submitted)));
          };
      ErrorStateMatcher.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */ ErrorStateMatcher.ngInjectableDef = core.defineInjectable({ factory: function ErrorStateMatcher_Factory() { return new ErrorStateMatcher(); }, token: ErrorStateMatcher, providedIn: "root" });
      return ErrorStateMatcher;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token that can be used to provide options to the Hammerjs instance.
   * More info at http://hammerjs.github.io/api/.
   * @type {?}
   */
  var MAT_HAMMER_OPTIONS = new core.InjectionToken('MAT_HAMMER_OPTIONS');
  /** @type {?} */
  var ANGULAR_MATERIAL_SUPPORTED_HAMMER_GESTURES = [
      'longpress',
      'slide',
      'slidestart',
      'slideend',
      'slideright',
      'slideleft'
  ];
  var ɵ0$2 = function () { }, ɵ1 = function () { };
  /**
   * Fake HammerInstance that is used when a Hammer instance is requested when HammerJS has not
   * been loaded on the page.
   * @type {?}
   */
  var noopHammerInstance = {
      on: ɵ0$2,
      off: ɵ1,
  };
  /**
   * Adjusts configuration of our gesture library, Hammer.
   */
  var GestureConfig = /** @class */ (function (_super) {
      tslib_1.__extends(GestureConfig, _super);
      function GestureConfig(_hammerOptions, commonModule) {
          var _this = _super.call(this) || this;
          _this._hammerOptions = _hammerOptions;
          /**
           * List of new event names to add to the gesture support list
           */
          _this.events = ANGULAR_MATERIAL_SUPPORTED_HAMMER_GESTURES;
          if (commonModule) {
              commonModule._checkHammerIsAvailable();
          }
          return _this;
      }
      /**
       * Builds Hammer instance manually to add custom recognizers that match the Material Design spec.
       *
       * Our gesture names come from the Material Design gestures spec:
       * https://material.io/design/#gestures-touch-mechanics
       *
       * More information on default recognizers can be found in Hammer docs:
       * http://hammerjs.github.io/recognizer-pan/
       * http://hammerjs.github.io/recognizer-press/
       *
       * @param element Element to which to assign the new HammerJS gestures.
       * @returns Newly-created HammerJS instance.
       */
      /**
       * Builds Hammer instance manually to add custom recognizers that match the Material Design spec.
       *
       * Our gesture names come from the Material Design gestures spec:
       * https://material.io/design/#gestures-touch-mechanics
       *
       * More information on default recognizers can be found in Hammer docs:
       * http://hammerjs.github.io/recognizer-pan/
       * http://hammerjs.github.io/recognizer-press/
       *
       * @param {?} element Element to which to assign the new HammerJS gestures.
       * @return {?} Newly-created HammerJS instance.
       */
      GestureConfig.prototype.buildHammer = /**
       * Builds Hammer instance manually to add custom recognizers that match the Material Design spec.
       *
       * Our gesture names come from the Material Design gestures spec:
       * https://material.io/design/#gestures-touch-mechanics
       *
       * More information on default recognizers can be found in Hammer docs:
       * http://hammerjs.github.io/recognizer-pan/
       * http://hammerjs.github.io/recognizer-press/
       *
       * @param {?} element Element to which to assign the new HammerJS gestures.
       * @return {?} Newly-created HammerJS instance.
       */
          function (element) {
              /** @type {?} */
              var hammer = typeof window !== 'undefined' ? (( /** @type {?} */(window))).Hammer : null;
              if (!hammer) {
                  // If HammerJS is not loaded here, return the noop HammerInstance. This is necessary to
                  // ensure that omitting HammerJS completely will not cause any errors while *also* supporting
                  // the lazy-loading of HammerJS via the HAMMER_LOADER token introduced in Angular 6.1.
                  // Because we can't depend on HAMMER_LOADER's existance until 7.0, we have to always set
                  // `this.events` to the set we support, instead of conditionally setting it to `[]` if
                  // `HAMMER_LOADER` is present (and then throwing an Error here if `window.Hammer` is
                  // undefined).
                  // @breaking-change 8.0.0
                  return noopHammerInstance;
              }
              /** @type {?} */
              var mc = new hammer(element, this._hammerOptions || undefined);
              // Default Hammer Recognizers.
              /** @type {?} */
              var pan = new hammer.Pan();
              /** @type {?} */
              var swipe = new hammer.Swipe();
              /** @type {?} */
              var press = new hammer.Press();
              // Notice that a HammerJS recognizer can only depend on one other recognizer once.
              // Otherwise the previous `recognizeWith` will be dropped.
              // TODO: Confirm threshold numbers with Material Design UX Team
              /** @type {?} */
              var slide = this._createRecognizer(pan, { event: 'slide', threshold: 0 }, swipe);
              /** @type {?} */
              var longpress = this._createRecognizer(press, { event: 'longpress', time: 500 });
              // Overwrite the default `pan` event to use the swipe event.
              pan.recognizeWith(swipe);
              // Since the slide event threshold is set to zero, the slide recognizer can fire and
              // accidentally reset the longpress recognizer. In order to make sure that the two
              // recognizers can run simultaneously but don't affect each other, we allow the slide
              // recognizer to recognize while a longpress is being processed.
              // See: https://github.com/hammerjs/hammer.js/blob/master/src/manager.js#L123-L124
              longpress.recognizeWith(slide);
              // Add customized gestures to Hammer manager
              mc.add([swipe, press, pan, slide, longpress]);
              return ( /** @type {?} */(mc));
          };
      /** Creates a new recognizer, without affecting the default recognizers of HammerJS */
      /**
       * Creates a new recognizer, without affecting the default recognizers of HammerJS
       * @private
       * @param {?} base
       * @param {?} options
       * @param {...?} inheritances
       * @return {?}
       */
      GestureConfig.prototype._createRecognizer = /**
       * Creates a new recognizer, without affecting the default recognizers of HammerJS
       * @private
       * @param {?} base
       * @param {?} options
       * @param {...?} inheritances
       * @return {?}
       */
          function (base, options) {
              var inheritances = [];
              for (var _i = 2; _i < arguments.length; _i++) {
                  inheritances[_i - 2] = arguments[_i];
              }
              /** @type {?} */
              var recognizer = new (( /** @type {?} */(base.constructor)))(options);
              inheritances.push(base);
              inheritances.forEach(function (item) { return recognizer.recognizeWith(item); });
              return recognizer;
          };
      GestureConfig.decorators = [
          { type: core.Injectable },
      ];
      /** @nocollapse */
      GestureConfig.ctorParameters = function () {
          return [
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_HAMMER_OPTIONS,] }] },
              { type: MatCommonModule, decorators: [{ type: core.Optional }] }
          ];
      };
      return GestureConfig;
  }(platformBrowser.HammerGestureConfig));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Shared directive to count lines inside a text area, such as a list item.
   * Line elements can be extracted with a \@ContentChildren(MatLine) query, then
   * counted by checking the query list's length.
   */
  var MatLine = /** @class */ (function () {
      function MatLine() {
      }
      MatLine.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mat-line], [matLine]',
                      host: { 'class': 'mat-line' }
                  },] },
      ];
      return MatLine;
  }());
  /**
   * Helper that takes a query list of lines and sets the correct class on the host.
   * \@docs-private
   * @param {?} lines
   * @param {?} element
   * @return {?}
   */
  function setLines(lines, element) {
      // Note: doesn't need to unsubscribe, because `changes`
      // gets completed by Angular when the view is destroyed.
      lines.changes.pipe(operators.startWith(lines)).subscribe(function (_a) {
          var length = _a.length;
          setClass(element, 'mat-2-line', false);
          setClass(element, 'mat-3-line', false);
          setClass(element, 'mat-multi-line', false);
          if (length === 2 || length === 3) {
              setClass(element, "mat-" + length + "-line", true);
          }
          else if (length > 3) {
              setClass(element, "mat-multi-line", true);
          }
      });
  }
  /**
   * Adds or removes a class from an element.
   * @param {?} element
   * @param {?} className
   * @param {?} isAdd
   * @return {?}
   */
  function setClass(element, className, isAdd) {
      /** @type {?} */
      var classList = element.nativeElement.classList;
      isAdd ? classList.add(className) : classList.remove(className);
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @enum {number} */
  var RippleState = {
      FADING_IN: 0, VISIBLE: 1, FADING_OUT: 2, HIDDEN: 3,
  };
  RippleState[RippleState.FADING_IN] = 'FADING_IN';
  RippleState[RippleState.VISIBLE] = 'VISIBLE';
  RippleState[RippleState.FADING_OUT] = 'FADING_OUT';
  RippleState[RippleState.HIDDEN] = 'HIDDEN';
  /**
   * Reference to a previously launched ripple element.
   */
  var /**
   * Reference to a previously launched ripple element.
   */ RippleRef = /** @class */ (function () {
      function RippleRef(_renderer, element, config) {
          this._renderer = _renderer;
          this.element = element;
          this.config = config;
          /**
           * Current state of the ripple.
           */
          this.state = RippleState.HIDDEN;
      }
      /** Fades out the ripple element. */
      /**
       * Fades out the ripple element.
       * @return {?}
       */
      RippleRef.prototype.fadeOut = /**
       * Fades out the ripple element.
       * @return {?}
       */
          function () {
              this._renderer.fadeOutRipple(this);
          };
      return RippleRef;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Default ripple animation configuration for ripples without an explicit
   * animation config specified.
   * @type {?}
   */
  var defaultRippleAnimationConfig = {
      enterDuration: 450,
      exitDuration: 400
  };
  /**
   * Timeout for ignoring mouse events. Mouse events will be temporary ignored after touch
   * events to avoid synthetic mouse events.
   * @type {?}
   */
  var ignoreMouseEventsTimeout = 800;
  /**
   * Options that apply to all the event listeners that are bound by the ripple renderer.
   * @type {?}
   */
  var passiveEventOptions = normalizePassiveListenerOptions({ passive: true });
  /**
   * Helper service that performs DOM manipulations. Not intended to be used outside this module.
   * The constructor takes a reference to the ripple directive's host element and a map of DOM
   * event handlers to be installed on the element that triggers ripple animations.
   * This will eventually become a custom renderer once Angular support exists.
   * \@docs-private
   */
  var /**
   * Helper service that performs DOM manipulations. Not intended to be used outside this module.
   * The constructor takes a reference to the ripple directive's host element and a map of DOM
   * event handlers to be installed on the element that triggers ripple animations.
   * This will eventually become a custom renderer once Angular support exists.
   * \@docs-private
   */ RippleRenderer = /** @class */ (function () {
      function RippleRenderer(_target, _ngZone, elementRef, platform) {
          var _this = this;
          this._target = _target;
          this._ngZone = _ngZone;
          /**
           * Whether the pointer is currently down or not.
           */
          this._isPointerDown = false;
          /**
           * Events to be registered on the trigger element.
           */
          this._triggerEvents = new Map();
          /**
           * Set of currently active ripple references.
           */
          this._activeRipples = new Set();
          /**
           * Function being called whenever the trigger is being pressed using mouse.
           */
          this.onMousedown = function (event) {
              // Screen readers will fire fake mouse events for space/enter. Skip launching a
              // ripple in this case for consistency with the non-screen-reader experience.
              /** @type {?} */
              var isFakeMousedown = isFakeMousedownFromScreenReader(event);
              /** @type {?} */
              var isSyntheticEvent = _this._lastTouchStartEvent &&
                  Date.now() < _this._lastTouchStartEvent + ignoreMouseEventsTimeout;
              if (!_this._target.rippleDisabled && !isFakeMousedown && !isSyntheticEvent) {
                  _this._isPointerDown = true;
                  _this.fadeInRipple(event.clientX, event.clientY, _this._target.rippleConfig);
              }
          };
          /**
           * Function being called whenever the trigger is being pressed using touch.
           */
          this.onTouchStart = function (event) {
              if (!_this._target.rippleDisabled) {
                  // Some browsers fire mouse events after a `touchstart` event. Those synthetic mouse
                  // events will launch a second ripple if we don't ignore mouse events for a specific
                  // time after a touchstart event.
                  _this._lastTouchStartEvent = Date.now();
                  _this._isPointerDown = true;
                  // Use `changedTouches` so we skip any touches where the user put
                  // their finger down, but used another finger to tap the element again.
                  /** @type {?} */
                  var touches = event.changedTouches;
                  for (var i = 0; i < touches.length; i++) {
                      _this.fadeInRipple(touches[i].clientX, touches[i].clientY, _this._target.rippleConfig);
                  }
              }
          };
          /**
           * Function being called whenever the trigger is being released.
           */
          this.onPointerUp = function () {
              if (!_this._isPointerDown) {
                  return;
              }
              _this._isPointerDown = false;
              // Fade-out all ripples that are visible and not persistent.
              _this._activeRipples.forEach(function (ripple) {
                  // By default, only ripples that are completely visible will fade out on pointer release.
                  // If the `terminateOnPointerUp` option is set, ripples that still fade in will also fade out.
                  /** @type {?} */
                  var isVisible = ripple.state === RippleState.VISIBLE ||
                      ripple.config.terminateOnPointerUp && ripple.state === RippleState.FADING_IN;
                  if (!ripple.config.persistent && isVisible) {
                      ripple.fadeOut();
                  }
              });
          };
          // Only do anything if we're on the browser.
          if (platform.isBrowser) {
              this._containerElement = elementRef.nativeElement;
              // Specify events which need to be registered on the trigger.
              this._triggerEvents
                  .set('mousedown', this.onMousedown)
                  .set('mouseup', this.onPointerUp)
                  .set('mouseleave', this.onPointerUp)
                  .set('touchstart', this.onTouchStart)
                  .set('touchend', this.onPointerUp)
                  .set('touchcancel', this.onPointerUp);
          }
      }
      /**
       * Fades in a ripple at the given coordinates.
       * @param x Coordinate within the element, along the X axis at which to start the ripple.
       * @param y Coordinate within the element, along the Y axis at which to start the ripple.
       * @param config Extra ripple options.
       */
      /**
       * Fades in a ripple at the given coordinates.
       * @param {?} x Coordinate within the element, along the X axis at which to start the ripple.
       * @param {?} y Coordinate within the element, along the Y axis at which to start the ripple.
       * @param {?=} config Extra ripple options.
       * @return {?}
       */
      RippleRenderer.prototype.fadeInRipple = /**
       * Fades in a ripple at the given coordinates.
       * @param {?} x Coordinate within the element, along the X axis at which to start the ripple.
       * @param {?} y Coordinate within the element, along the Y axis at which to start the ripple.
       * @param {?=} config Extra ripple options.
       * @return {?}
       */
          function (x, y, config) {
              var _this = this;
              if (config === void 0) {
                  config = {};
              }
              /** @type {?} */
              var containerRect = this._containerRect =
                  this._containerRect || this._containerElement.getBoundingClientRect();
              /** @type {?} */
              var animationConfig = tslib_1.__assign({}, defaultRippleAnimationConfig, config.animation);
              if (config.centered) {
                  x = containerRect.left + containerRect.width / 2;
                  y = containerRect.top + containerRect.height / 2;
              }
              /** @type {?} */
              var radius = config.radius || distanceToFurthestCorner(x, y, containerRect);
              /** @type {?} */
              var offsetX = x - containerRect.left;
              /** @type {?} */
              var offsetY = y - containerRect.top;
              /** @type {?} */
              var duration = animationConfig.enterDuration;
              /** @type {?} */
              var ripple = document.createElement('div');
              ripple.classList.add('mat-ripple-element');
              ripple.style.left = offsetX - radius + "px";
              ripple.style.top = offsetY - radius + "px";
              ripple.style.height = radius * 2 + "px";
              ripple.style.width = radius * 2 + "px";
              // If the color is not set, the default CSS color will be used.
              ripple.style.backgroundColor = config.color || null;
              ripple.style.transitionDuration = duration + "ms";
              this._containerElement.appendChild(ripple);
              // By default the browser does not recalculate the styles of dynamically created
              // ripple elements. This is critical because then the `scale` would not animate properly.
              enforceStyleRecalculation(ripple);
              ripple.style.transform = 'scale(1)';
              // Exposed reference to the ripple that will be returned.
              /** @type {?} */
              var rippleRef = new RippleRef(this, ripple, config);
              rippleRef.state = RippleState.FADING_IN;
              // Add the ripple reference to the list of all active ripples.
              this._activeRipples.add(rippleRef);
              if (!config.persistent) {
                  this._mostRecentTransientRipple = rippleRef;
              }
              // Wait for the ripple element to be completely faded in.
              // Once it's faded in, the ripple can be hidden immediately if the mouse is released.
              this.runTimeoutOutsideZone(function () {
                  /** @type {?} */
                  var isMostRecentTransientRipple = rippleRef === _this._mostRecentTransientRipple;
                  rippleRef.state = RippleState.VISIBLE;
                  // When the timer runs out while the user has kept their pointer down, we want to
                  // keep only the persistent ripples and the latest transient ripple. We do this,
                  // because we don't want stacked transient ripples to appear after their enter
                  // animation has finished.
                  if (!config.persistent && (!isMostRecentTransientRipple || !_this._isPointerDown)) {
                      rippleRef.fadeOut();
                  }
              }, duration);
              return rippleRef;
          };
      /** Fades out a ripple reference. */
      /**
       * Fades out a ripple reference.
       * @param {?} rippleRef
       * @return {?}
       */
      RippleRenderer.prototype.fadeOutRipple = /**
       * Fades out a ripple reference.
       * @param {?} rippleRef
       * @return {?}
       */
          function (rippleRef) {
              /** @type {?} */
              var wasActive = this._activeRipples.delete(rippleRef);
              if (rippleRef === this._mostRecentTransientRipple) {
                  this._mostRecentTransientRipple = null;
              }
              // Clear out the cached bounding rect if we have no more ripples.
              if (!this._activeRipples.size) {
                  this._containerRect = null;
              }
              // For ripples that are not active anymore, don't re-run the fade-out animation.
              if (!wasActive) {
                  return;
              }
              /** @type {?} */
              var rippleEl = rippleRef.element;
              /** @type {?} */
              var animationConfig = tslib_1.__assign({}, defaultRippleAnimationConfig, rippleRef.config.animation);
              rippleEl.style.transitionDuration = animationConfig.exitDuration + "ms";
              rippleEl.style.opacity = '0';
              rippleRef.state = RippleState.FADING_OUT;
              // Once the ripple faded out, the ripple can be safely removed from the DOM.
              this.runTimeoutOutsideZone(function () {
                  rippleRef.state = RippleState.HIDDEN;
                  ( /** @type {?} */(rippleEl.parentNode)).removeChild(rippleEl);
              }, animationConfig.exitDuration);
          };
      /** Fades out all currently active ripples. */
      /**
       * Fades out all currently active ripples.
       * @return {?}
       */
      RippleRenderer.prototype.fadeOutAll = /**
       * Fades out all currently active ripples.
       * @return {?}
       */
          function () {
              this._activeRipples.forEach(function (ripple) { return ripple.fadeOut(); });
          };
      /** Sets up the trigger event listeners */
      /**
       * Sets up the trigger event listeners
       * @param {?} element
       * @return {?}
       */
      RippleRenderer.prototype.setupTriggerEvents = /**
       * Sets up the trigger event listeners
       * @param {?} element
       * @return {?}
       */
          function (element) {
              var _this = this;
              if (!element || element === this._triggerElement) {
                  return;
              }
              // Remove all previously registered event listeners from the trigger element.
              this._removeTriggerEvents();
              this._ngZone.runOutsideAngular(function () {
                  _this._triggerEvents.forEach(function (fn, type) {
                      element.addEventListener(type, fn, passiveEventOptions);
                  });
              });
              this._triggerElement = element;
          };
      /** Runs a timeout outside of the Angular zone to avoid triggering the change detection. */
      /**
       * Runs a timeout outside of the Angular zone to avoid triggering the change detection.
       * @private
       * @param {?} fn
       * @param {?=} delay
       * @return {?}
       */
      RippleRenderer.prototype.runTimeoutOutsideZone = /**
       * Runs a timeout outside of the Angular zone to avoid triggering the change detection.
       * @private
       * @param {?} fn
       * @param {?=} delay
       * @return {?}
       */
          function (fn, delay) {
              if (delay === void 0) {
                  delay = 0;
              }
              this._ngZone.runOutsideAngular(function () { return setTimeout(fn, delay); });
          };
      /** Removes previously registered event listeners from the trigger element. */
      /**
       * Removes previously registered event listeners from the trigger element.
       * @return {?}
       */
      RippleRenderer.prototype._removeTriggerEvents = /**
       * Removes previously registered event listeners from the trigger element.
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._triggerElement) {
                  this._triggerEvents.forEach(function (fn, type) {
                      ( /** @type {?} */(_this._triggerElement)).removeEventListener(type, fn, passiveEventOptions);
                  });
              }
          };
      return RippleRenderer;
  }());
  /**
   * Enforces a style recalculation of a DOM element by computing its styles.
   * @param {?} element
   * @return {?}
   */
  function enforceStyleRecalculation(element) {
      // Enforce a style recalculation by calling `getComputedStyle` and accessing any property.
      // Calling `getPropertyValue` is important to let optimizers know that this is not a noop.
      // See: https://gist.github.com/paulirish/5d52fb081b3570c81e3a
      window.getComputedStyle(element).getPropertyValue('opacity');
  }
  /**
   * Returns the distance from the point (x, y) to the furthest corner of a rectangle.
   * @param {?} x
   * @param {?} y
   * @param {?} rect
   * @return {?}
   */
  function distanceToFurthestCorner(x, y, rect) {
      /** @type {?} */
      var distX = Math.max(Math.abs(x - rect.left), Math.abs(x - rect.right));
      /** @type {?} */
      var distY = Math.max(Math.abs(y - rect.top), Math.abs(y - rect.bottom));
      return Math.sqrt(distX * distX + distY * distY);
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token that can be used to specify the global ripple options.
   * @type {?}
   */
  var MAT_RIPPLE_GLOBAL_OPTIONS = new core.InjectionToken('mat-ripple-global-options');
  var MatRipple = /** @class */ (function () {
      function MatRipple(_elementRef, ngZone, platform, globalOptions, animationMode) {
          this._elementRef = _elementRef;
          /**
           * If set, the radius in pixels of foreground ripples when fully expanded. If unset, the radius
           * will be the distance from the center of the ripple to the furthest corner of the host element's
           * bounding rectangle.
           */
          this.radius = 0;
          this._disabled = false;
          /**
           * Whether ripple directive is initialized and the input bindings are set.
           */
          this._isInitialized = false;
          this._globalOptions = globalOptions || {};
          this._rippleRenderer = new RippleRenderer(this, ngZone, _elementRef, platform);
          if (animationMode === 'NoopAnimations') {
              this._globalOptions.animation = { enterDuration: 0, exitDuration: 0 };
          }
      }
      Object.defineProperty(MatRipple.prototype, "disabled", {
          /**
           * Whether click events will not trigger the ripple. Ripples can be still launched manually
           * by using the `launch()` method.
           */
          get: /**
           * Whether click events will not trigger the ripple. Ripples can be still launched manually
           * by using the `launch()` method.
           * @return {?}
           */ function () { return this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._disabled = value;
              this._setupTriggerEventsIfEnabled();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatRipple.prototype, "trigger", {
          /**
           * The element that triggers the ripple when click events are received.
           * Defaults to the directive's host element.
           */
          get: /**
           * The element that triggers the ripple when click events are received.
           * Defaults to the directive's host element.
           * @return {?}
           */ function () { return this._trigger || this._elementRef.nativeElement; },
          set: /**
           * @param {?} trigger
           * @return {?}
           */ function (trigger) {
              this._trigger = trigger;
              this._setupTriggerEventsIfEnabled();
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatRipple.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              this._isInitialized = true;
              this._setupTriggerEventsIfEnabled();
          };
      /**
       * @return {?}
       */
      MatRipple.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._rippleRenderer._removeTriggerEvents();
          };
      /** Fades out all currently showing ripple elements. */
      /**
       * Fades out all currently showing ripple elements.
       * @return {?}
       */
      MatRipple.prototype.fadeOutAll = /**
       * Fades out all currently showing ripple elements.
       * @return {?}
       */
          function () {
              this._rippleRenderer.fadeOutAll();
          };
      Object.defineProperty(MatRipple.prototype, "rippleConfig", {
          /**
           * Ripple configuration from the directive's input values.
           * @docs-private Implemented as part of RippleTarget
           */
          get: /**
           * Ripple configuration from the directive's input values.
           * \@docs-private Implemented as part of RippleTarget
           * @return {?}
           */ function () {
              return {
                  centered: this.centered,
                  radius: this.radius,
                  color: this.color,
                  animation: tslib_1.__assign({}, this._globalOptions.animation, this.animation),
                  terminateOnPointerUp: this._globalOptions.terminateOnPointerUp,
              };
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatRipple.prototype, "rippleDisabled", {
          /**
           * Whether ripples on pointer-down are disabled or not.
           * @docs-private Implemented as part of RippleTarget
           */
          get: /**
           * Whether ripples on pointer-down are disabled or not.
           * \@docs-private Implemented as part of RippleTarget
           * @return {?}
           */ function () {
              return this.disabled || !!this._globalOptions.disabled;
          },
          enumerable: true,
          configurable: true
      });
      /** Sets up the trigger event listeners if ripples are enabled. */
      /**
       * Sets up the trigger event listeners if ripples are enabled.
       * @private
       * @return {?}
       */
      MatRipple.prototype._setupTriggerEventsIfEnabled = /**
       * Sets up the trigger event listeners if ripples are enabled.
       * @private
       * @return {?}
       */
          function () {
              if (!this.disabled && this._isInitialized) {
                  this._rippleRenderer.setupTriggerEvents(this.trigger);
              }
          };
      /** Launches a manual ripple at the specified coordinated or just by the ripple config. */
      /**
       * Launches a manual ripple at the specified coordinated or just by the ripple config.
       * @param {?} configOrX
       * @param {?=} y
       * @param {?=} config
       * @return {?}
       */
      MatRipple.prototype.launch = /**
       * Launches a manual ripple at the specified coordinated or just by the ripple config.
       * @param {?} configOrX
       * @param {?=} y
       * @param {?=} config
       * @return {?}
       */
          function (configOrX, y, config) {
              if (y === void 0) {
                  y = 0;
              }
              if (typeof configOrX === 'number') {
                  return this._rippleRenderer.fadeInRipple(configOrX, y, tslib_1.__assign({}, this.rippleConfig, config));
              }
              else {
                  return this._rippleRenderer.fadeInRipple(0, 0, tslib_1.__assign({}, this.rippleConfig, configOrX));
              }
          };
      MatRipple.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mat-ripple], [matRipple]',
                      exportAs: 'matRipple',
                      host: {
                          'class': 'mat-ripple',
                          '[class.mat-ripple-unbounded]': 'unbounded'
                      }
                  },] },
      ];
      /** @nocollapse */
      MatRipple.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.NgZone },
              { type: Platform },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_RIPPLE_GLOBAL_OPTIONS,] }] },
              { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] }
          ];
      };
      MatRipple.propDecorators = {
          color: [{ type: core.Input, args: ['matRippleColor',] }],
          unbounded: [{ type: core.Input, args: ['matRippleUnbounded',] }],
          centered: [{ type: core.Input, args: ['matRippleCentered',] }],
          radius: [{ type: core.Input, args: ['matRippleRadius',] }],
          animation: [{ type: core.Input, args: ['matRippleAnimation',] }],
          disabled: [{ type: core.Input, args: ['matRippleDisabled',] }],
          trigger: [{ type: core.Input, args: ['matRippleTrigger',] }]
      };
      return MatRipple;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var MatRippleModule = /** @class */ (function () {
      function MatRippleModule() {
      }
      MatRippleModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [MatCommonModule, PlatformModule],
                      exports: [MatRipple, MatCommonModule],
                      declarations: [MatRipple],
                  },] },
      ];
      return MatRippleModule;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Component that shows a simplified checkbox without including any kind of "real" checkbox.
   * Meant to be used when the checkbox is purely decorative and a large number of them will be
   * included, such as for the options in a multi-select. Uses no SVGs or complex animations.
   * Note that theming is meant to be handled by the parent element, e.g.
   * `mat-primary .mat-pseudo-checkbox`.
   *
   * Note that this component will be completely invisible to screen-reader users. This is *not*
   * interchangeable with `<mat-checkbox>` and should *not* be used if the user would directly
   * interact with the checkbox. The pseudo-checkbox should only be used as an implementation detail
   * of more complex components that appropriately handle selected / checked state.
   * \@docs-private
   */
  var MatPseudoCheckbox = /** @class */ (function () {
      function MatPseudoCheckbox(_animationMode) {
          this._animationMode = _animationMode;
          /**
           * Display state of the checkbox.
           */
          this.state = 'unchecked';
          /**
           * Whether the checkbox is disabled.
           */
          this.disabled = false;
      }
      MatPseudoCheckbox.decorators = [
          { type: core.Component, args: [{ encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      selector: 'mat-pseudo-checkbox',
                      styles: [".mat-pseudo-checkbox{width:16px;height:16px;border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0,0,.2,.1),background-color 90ms cubic-bezier(0,0,.2,.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:'';border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0,0,.2,.1)}.mat-pseudo-checkbox.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox.mat-pseudo-checkbox-indeterminate{border-color:transparent}._mat-animation-noopable.mat-pseudo-checkbox{transition:none;animation:none}._mat-animation-noopable.mat-pseudo-checkbox::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{top:5px;left:1px;width:10px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{top:2.4px;left:1px;width:8px;height:3px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}"],
                      template: '',
                      host: {
                          'class': 'mat-pseudo-checkbox',
                          '[class.mat-pseudo-checkbox-indeterminate]': 'state === "indeterminate"',
                          '[class.mat-pseudo-checkbox-checked]': 'state === "checked"',
                          '[class.mat-pseudo-checkbox-disabled]': 'disabled',
                          '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                      },
                  },] },
      ];
      /** @nocollapse */
      MatPseudoCheckbox.ctorParameters = function () {
          return [
              { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] }
          ];
      };
      MatPseudoCheckbox.propDecorators = {
          state: [{ type: core.Input }],
          disabled: [{ type: core.Input }]
      };
      return MatPseudoCheckbox;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Boilerplate for applying mixins to MatOptgroup.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatOptgroup.
  /**
   * \@docs-private
   */
  MatOptgroupBase = /** @class */ (function () {
      function MatOptgroupBase() {
      }
      return MatOptgroupBase;
  }());
  /** @type {?} */
  var _MatOptgroupMixinBase = mixinDisabled(MatOptgroupBase);
  // Counter for unique group ids.
  /** @type {?} */
  var _uniqueOptgroupIdCounter = 0;
  /**
   * Component that is used to group instances of `mat-option`.
   */
  var MatOptgroup = /** @class */ (function (_super) {
      tslib_1.__extends(MatOptgroup, _super);
      function MatOptgroup() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          /**
           * Unique id for the underlying label.
           */
          _this._labelId = "mat-optgroup-label-" + _uniqueOptgroupIdCounter++;
          return _this;
      }
      MatOptgroup.decorators = [
          { type: core.Component, args: [{ selector: 'mat-optgroup',
                      exportAs: 'matOptgroup',
                      template: "<label class=\"mat-optgroup-label\" [id]=\"_labelId\">{{ label }}<ng-content></ng-content></label><ng-content select=\"mat-option, ng-container\"></ng-content>",
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      inputs: ['disabled'],
                      styles: [".mat-optgroup-label{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-optgroup-label[disabled]{cursor:default}[dir=rtl] .mat-optgroup-label{text-align:right}.mat-optgroup-label .mat-icon{margin-right:16px;vertical-align:middle}.mat-optgroup-label .mat-icon svg{vertical-align:top}[dir=rtl] .mat-optgroup-label .mat-icon{margin-left:16px;margin-right:0}"],
                      host: {
                          'class': 'mat-optgroup',
                          'role': 'group',
                          '[class.mat-optgroup-disabled]': 'disabled',
                          '[attr.aria-disabled]': 'disabled.toString()',
                          '[attr.aria-labelledby]': '_labelId',
                      }
                  },] },
      ];
      MatOptgroup.propDecorators = {
          label: [{ type: core.Input }]
      };
      return MatOptgroup;
  }(_MatOptgroupMixinBase));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Option IDs need to be unique across components, so this counter exists outside of
   * the component definition.
   * @type {?}
   */
  var _uniqueIdCounter = 0;
  /**
   * Event object emitted by MatOption when selected or deselected.
   */
  var /**
   * Event object emitted by MatOption when selected or deselected.
   */ MatOptionSelectionChange = /** @class */ (function () {
      function MatOptionSelectionChange(source, isUserInput) {
          if (isUserInput === void 0) {
              isUserInput = false;
          }
          this.source = source;
          this.isUserInput = isUserInput;
      }
      return MatOptionSelectionChange;
  }());
  /**
   * Injection token used to provide the parent component to options.
   * @type {?}
   */
  var MAT_OPTION_PARENT_COMPONENT = new core.InjectionToken('MAT_OPTION_PARENT_COMPONENT');
  /**
   * Single option inside of a `<mat-select>` element.
   */
  var MatOption = /** @class */ (function () {
      function MatOption(_element, _changeDetectorRef, _parent, group) {
          this._element = _element;
          this._changeDetectorRef = _changeDetectorRef;
          this._parent = _parent;
          this.group = group;
          this._selected = false;
          this._active = false;
          this._disabled = false;
          this._mostRecentViewValue = '';
          /**
           * The unique ID of the option.
           */
          this.id = "mat-option-" + _uniqueIdCounter++;
          /**
           * Event emitted when the option is selected or deselected.
           */
          // tslint:disable-next-line:no-output-on-prefix
          this.onSelectionChange = new core.EventEmitter();
          /**
           * Emits when the state of the option changes and any parents have to be notified.
           */
          this._stateChanges = new rxjs.Subject();
      }
      Object.defineProperty(MatOption.prototype, "multiple", {
          /** Whether the wrapping component is in multiple selection mode. */
          get: /**
           * Whether the wrapping component is in multiple selection mode.
           * @return {?}
           */ function () { return this._parent && this._parent.multiple; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatOption.prototype, "selected", {
          /** Whether or not the option is currently selected. */
          get: /**
           * Whether or not the option is currently selected.
           * @return {?}
           */ function () { return this._selected; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatOption.prototype, "disabled", {
          /** Whether the option is disabled. */
          get: /**
           * Whether the option is disabled.
           * @return {?}
           */ function () { return (this.group && this.group.disabled) || this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._disabled = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatOption.prototype, "disableRipple", {
          /** Whether ripples for the option are disabled. */
          get: /**
           * Whether ripples for the option are disabled.
           * @return {?}
           */ function () { return this._parent && this._parent.disableRipple; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatOption.prototype, "active", {
          /**
           * Whether or not the option is currently active and ready to be selected.
           * An active option displays styles as if it is focused, but the
           * focus is actually retained somewhere else. This comes in handy
           * for components like autocomplete where focus must remain on the input.
           */
          get: /**
           * Whether or not the option is currently active and ready to be selected.
           * An active option displays styles as if it is focused, but the
           * focus is actually retained somewhere else. This comes in handy
           * for components like autocomplete where focus must remain on the input.
           * @return {?}
           */ function () {
              return this._active;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatOption.prototype, "viewValue", {
          /**
           * The displayed value of the option. It is necessary to show the selected option in the
           * select's trigger.
           */
          get: /**
           * The displayed value of the option. It is necessary to show the selected option in the
           * select's trigger.
           * @return {?}
           */ function () {
              // TODO(kara): Add input property alternative for node envs.
              return (this._getHostElement().textContent || '').trim();
          },
          enumerable: true,
          configurable: true
      });
      /** Selects the option. */
      /**
       * Selects the option.
       * @return {?}
       */
      MatOption.prototype.select = /**
       * Selects the option.
       * @return {?}
       */
          function () {
              if (!this._selected) {
                  this._selected = true;
                  this._changeDetectorRef.markForCheck();
                  this._emitSelectionChangeEvent();
              }
          };
      /** Deselects the option. */
      /**
       * Deselects the option.
       * @return {?}
       */
      MatOption.prototype.deselect = /**
       * Deselects the option.
       * @return {?}
       */
          function () {
              if (this._selected) {
                  this._selected = false;
                  this._changeDetectorRef.markForCheck();
                  this._emitSelectionChangeEvent();
              }
          };
      /** Sets focus onto this option. */
      /**
       * Sets focus onto this option.
       * @return {?}
       */
      MatOption.prototype.focus = /**
       * Sets focus onto this option.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var element = this._getHostElement();
              if (typeof element.focus === 'function') {
                  element.focus();
              }
          };
      /**
       * This method sets display styles on the option to make it appear
       * active. This is used by the ActiveDescendantKeyManager so key
       * events will display the proper options as active on arrow key events.
       */
      /**
       * This method sets display styles on the option to make it appear
       * active. This is used by the ActiveDescendantKeyManager so key
       * events will display the proper options as active on arrow key events.
       * @return {?}
       */
      MatOption.prototype.setActiveStyles = /**
       * This method sets display styles on the option to make it appear
       * active. This is used by the ActiveDescendantKeyManager so key
       * events will display the proper options as active on arrow key events.
       * @return {?}
       */
          function () {
              if (!this._active) {
                  this._active = true;
                  this._changeDetectorRef.markForCheck();
              }
          };
      /**
       * This method removes display styles on the option that made it appear
       * active. This is used by the ActiveDescendantKeyManager so key
       * events will display the proper options as active on arrow key events.
       */
      /**
       * This method removes display styles on the option that made it appear
       * active. This is used by the ActiveDescendantKeyManager so key
       * events will display the proper options as active on arrow key events.
       * @return {?}
       */
      MatOption.prototype.setInactiveStyles = /**
       * This method removes display styles on the option that made it appear
       * active. This is used by the ActiveDescendantKeyManager so key
       * events will display the proper options as active on arrow key events.
       * @return {?}
       */
          function () {
              if (this._active) {
                  this._active = false;
                  this._changeDetectorRef.markForCheck();
              }
          };
      /** Gets the label to be used when determining whether the option should be focused. */
      /**
       * Gets the label to be used when determining whether the option should be focused.
       * @return {?}
       */
      MatOption.prototype.getLabel = /**
       * Gets the label to be used when determining whether the option should be focused.
       * @return {?}
       */
          function () {
              return this.viewValue;
          };
      /** Ensures the option is selected when activated from the keyboard. */
      /**
       * Ensures the option is selected when activated from the keyboard.
       * @param {?} event
       * @return {?}
       */
      MatOption.prototype._handleKeydown = /**
       * Ensures the option is selected when activated from the keyboard.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if ((event.keyCode === ENTER || event.keyCode === SPACE) && !hasModifierKey(event)) {
                  this._selectViaInteraction();
                  // Prevent the page from scrolling down and form submits.
                  event.preventDefault();
              }
          };
      /**
       * `Selects the option while indicating the selection came from the user. Used to
       * determine if the select's view -> model callback should be invoked.`
       */
      /**
       * `Selects the option while indicating the selection came from the user. Used to
       * determine if the select's view -> model callback should be invoked.`
       * @return {?}
       */
      MatOption.prototype._selectViaInteraction = /**
       * `Selects the option while indicating the selection came from the user. Used to
       * determine if the select's view -> model callback should be invoked.`
       * @return {?}
       */
          function () {
              if (!this.disabled) {
                  this._selected = this.multiple ? !this._selected : true;
                  this._changeDetectorRef.markForCheck();
                  this._emitSelectionChangeEvent(true);
              }
          };
      /** Returns the correct tabindex for the option depending on disabled state. */
      /**
       * Returns the correct tabindex for the option depending on disabled state.
       * @return {?}
       */
      MatOption.prototype._getTabIndex = /**
       * Returns the correct tabindex for the option depending on disabled state.
       * @return {?}
       */
          function () {
              return this.disabled ? '-1' : '0';
          };
      /** Gets the host DOM element. */
      /**
       * Gets the host DOM element.
       * @return {?}
       */
      MatOption.prototype._getHostElement = /**
       * Gets the host DOM element.
       * @return {?}
       */
          function () {
              return this._element.nativeElement;
          };
      /**
       * @return {?}
       */
      MatOption.prototype.ngAfterViewChecked = /**
       * @return {?}
       */
          function () {
              // Since parent components could be using the option's label to display the selected values
              // (e.g. `mat-select`) and they don't have a way of knowing if the option's label has changed
              // we have to check for changes in the DOM ourselves and dispatch an event. These checks are
              // relatively cheap, however we still limit them only to selected options in order to avoid
              // hitting the DOM too often.
              if (this._selected) {
                  /** @type {?} */
                  var viewValue = this.viewValue;
                  if (viewValue !== this._mostRecentViewValue) {
                      this._mostRecentViewValue = viewValue;
                      this._stateChanges.next();
                  }
              }
          };
      /**
       * @return {?}
       */
      MatOption.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._stateChanges.complete();
          };
      /** Emits the selection change event. */
      /**
       * Emits the selection change event.
       * @private
       * @param {?=} isUserInput
       * @return {?}
       */
      MatOption.prototype._emitSelectionChangeEvent = /**
       * Emits the selection change event.
       * @private
       * @param {?=} isUserInput
       * @return {?}
       */
          function (isUserInput) {
              if (isUserInput === void 0) {
                  isUserInput = false;
              }
              this.onSelectionChange.emit(new MatOptionSelectionChange(this, isUserInput));
          };
      MatOption.decorators = [
          { type: core.Component, args: [{ selector: 'mat-option',
                      exportAs: 'matOption',
                      host: {
                          'role': 'option',
                          '[attr.tabindex]': '_getTabIndex()',
                          '[class.mat-selected]': 'selected',
                          '[class.mat-option-multiple]': 'multiple',
                          '[class.mat-active]': 'active',
                          '[id]': 'id',
                          '[attr.aria-selected]': 'selected.toString()',
                          '[attr.aria-disabled]': 'disabled.toString()',
                          '[class.mat-option-disabled]': 'disabled',
                          '(click)': '_selectViaInteraction()',
                          '(keydown)': '_handleKeydown($event)',
                          'class': 'mat-option',
                      },
                      styles: [".mat-option{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative;cursor:pointer;outline:0;display:flex;flex-direction:row;max-width:100%;box-sizing:border-box;align-items:center;-webkit-tap-highlight-color:transparent}.mat-option[disabled]{cursor:default}[dir=rtl] .mat-option{text-align:right}.mat-option .mat-icon{margin-right:16px;vertical-align:middle}.mat-option .mat-icon svg{vertical-align:top}[dir=rtl] .mat-option .mat-icon{margin-left:16px;margin-right:0}.mat-option[aria-disabled=true]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:32px}[dir=rtl] .mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:16px;padding-right:32px}@media (-ms-high-contrast:active){.mat-option{margin:0 1px}.mat-option.mat-active{border:solid 1px currentColor;margin:0}}.mat-option-text{display:inline-block;flex-grow:1;overflow:hidden;text-overflow:ellipsis}.mat-option .mat-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}@media (-ms-high-contrast:active){.mat-option .mat-option-ripple{opacity:.5}}.mat-option-pseudo-checkbox{margin-right:8px}[dir=rtl] .mat-option-pseudo-checkbox{margin-left:8px;margin-right:0}"],
                      template: "<mat-pseudo-checkbox *ngIf=\"multiple\" class=\"mat-option-pseudo-checkbox\" [state]=\"selected ? 'checked' : ''\" [disabled]=\"disabled\"></mat-pseudo-checkbox><span class=\"mat-option-text\"><ng-content></ng-content></span><div class=\"mat-option-ripple\" mat-ripple [matRippleTrigger]=\"_getHostElement()\" [matRippleDisabled]=\"disabled || disableRipple\"></div>",
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatOption.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.ChangeDetectorRef },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_OPTION_PARENT_COMPONENT,] }] },
              { type: MatOptgroup, decorators: [{ type: core.Optional }] }
          ];
      };
      MatOption.propDecorators = {
          value: [{ type: core.Input }],
          id: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          onSelectionChange: [{ type: core.Output }]
      };
      return MatOption;
  }());
  /**
   * Counts the amount of option group labels that precede the specified option.
   * \@docs-private
   * @param {?} optionIndex Index of the option at which to start counting.
   * @param {?} options Flat list of all of the options.
   * @param {?} optionGroups Flat list of all of the option groups.
   * @return {?}
   */
  function _countGroupLabelsBeforeOption(optionIndex, options, optionGroups) {
      if (optionGroups.length) {
          /** @type {?} */
          var optionsArray = options.toArray();
          /** @type {?} */
          var groups = optionGroups.toArray();
          /** @type {?} */
          var groupCounter = 0;
          for (var i = 0; i < optionIndex + 1; i++) {
              if (optionsArray[i].group && optionsArray[i].group === groups[groupCounter]) {
                  groupCounter++;
              }
          }
          return groupCounter;
      }
      return 0;
  }
  /**
   * Determines the position to which to scroll a panel in order for an option to be into view.
   * \@docs-private
   * @param {?} optionIndex Index of the option to be scrolled into the view.
   * @param {?} optionHeight Height of the options.
   * @param {?} currentScrollPosition Current scroll position of the panel.
   * @param {?} panelHeight Height of the panel.
   * @return {?}
   */
  function _getOptionScrollPosition(optionIndex, optionHeight, currentScrollPosition, panelHeight) {
      /** @type {?} */
      var optionOffset = optionIndex * optionHeight;
      if (optionOffset < currentScrollPosition) {
          return optionOffset;
      }
      if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {
          return Math.max(0, optionOffset - panelHeight + optionHeight);
      }
      return currentScrollPosition;
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * InjectionToken that can be used to specify the global label options.
   * @type {?}
   */
  var MAT_LABEL_GLOBAL_OPTIONS = new core.InjectionToken('mat-label-global-options');

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @abstract
   * @template T
   */
  var /**
   * @abstract
   * @template T
   */ DataSource = /** @class */ (function () {
      function DataSource() {
      }
      return DataSource;
  }());
  /**
   * Checks whether an object is a data source.
   * @param {?} value
   * @return {?}
   */
  function isDataSource(value) {
      // Check if the value is a DataSource by observing if it has a connect function. Cannot
      // be checked as an `instanceof DataSource` since people could create their own sources
      // that match the interface, but don't extend DataSource.
      return value && typeof value.connect === 'function';
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * DataSource wrapper for a native array.
   * @template T
   */
  var /**
   * DataSource wrapper for a native array.
   * @template T
   */ ArrayDataSource = /** @class */ (function (_super) {
      tslib_1.__extends(ArrayDataSource, _super);
      function ArrayDataSource(_data) {
          var _this = _super.call(this) || this;
          _this._data = _data;
          return _this;
      }
      /**
       * @return {?}
       */
      ArrayDataSource.prototype.connect = /**
       * @return {?}
       */
          function () {
              return this._data instanceof rxjs.Observable ? this._data : rxjs.of(this._data);
          };
      /**
       * @return {?}
       */
      ArrayDataSource.prototype.disconnect = /**
       * @return {?}
       */
          function () { };
      return ArrayDataSource;
  }(DataSource));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Class to be used to power selecting one or more options from a list.
   * @template T
   */
  var /**
   * Class to be used to power selecting one or more options from a list.
   * @template T
   */ SelectionModel = /** @class */ (function () {
      function SelectionModel(_multiple, initiallySelectedValues, _emitChanges) {
          if (_multiple === void 0) {
              _multiple = false;
          }
          if (_emitChanges === void 0) {
              _emitChanges = true;
          }
          var _this = this;
          this._multiple = _multiple;
          this._emitChanges = _emitChanges;
          /**
           * Currently-selected values.
           */
          this._selection = new Set();
          /**
           * Keeps track of the deselected options that haven't been emitted by the change event.
           */
          this._deselectedToEmit = [];
          /**
           * Keeps track of the selected options that haven't been emitted by the change event.
           */
          this._selectedToEmit = [];
          /**
           * Event emitted when the value has changed.
           */
          this.changed = new rxjs.Subject();
          /**
           * Event emitted when the value has changed.
           * @deprecated Use `changed` instead.
           * \@breaking-change 8.0.0 To be changed to `changed`
           */
          this.onChange = this.changed;
          if (initiallySelectedValues && initiallySelectedValues.length) {
              if (_multiple) {
                  initiallySelectedValues.forEach(function (value) { return _this._markSelected(value); });
              }
              else {
                  this._markSelected(initiallySelectedValues[0]);
              }
              // Clear the array in order to avoid firing the change event for preselected values.
              this._selectedToEmit.length = 0;
          }
      }
      Object.defineProperty(SelectionModel.prototype, "selected", {
          /** Selected values. */
          get: /**
           * Selected values.
           * @return {?}
           */ function () {
              if (!this._selected) {
                  this._selected = Array.from(this._selection.values());
              }
              return this._selected;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Selects a value or an array of values.
       */
      /**
       * Selects a value or an array of values.
       * @param {...?} values
       * @return {?}
       */
      SelectionModel.prototype.select = /**
       * Selects a value or an array of values.
       * @param {...?} values
       * @return {?}
       */
          function () {
              var _this = this;
              var values = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  values[_i] = arguments[_i];
              }
              this._verifyValueAssignment(values);
              values.forEach(function (value) { return _this._markSelected(value); });
              this._emitChangeEvent();
          };
      /**
       * Deselects a value or an array of values.
       */
      /**
       * Deselects a value or an array of values.
       * @param {...?} values
       * @return {?}
       */
      SelectionModel.prototype.deselect = /**
       * Deselects a value or an array of values.
       * @param {...?} values
       * @return {?}
       */
          function () {
              var _this = this;
              var values = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  values[_i] = arguments[_i];
              }
              this._verifyValueAssignment(values);
              values.forEach(function (value) { return _this._unmarkSelected(value); });
              this._emitChangeEvent();
          };
      /**
       * Toggles a value between selected and deselected.
       */
      /**
       * Toggles a value between selected and deselected.
       * @param {?} value
       * @return {?}
       */
      SelectionModel.prototype.toggle = /**
       * Toggles a value between selected and deselected.
       * @param {?} value
       * @return {?}
       */
          function (value) {
              this.isSelected(value) ? this.deselect(value) : this.select(value);
          };
      /**
       * Clears all of the selected values.
       */
      /**
       * Clears all of the selected values.
       * @return {?}
       */
      SelectionModel.prototype.clear = /**
       * Clears all of the selected values.
       * @return {?}
       */
          function () {
              this._unmarkAll();
              this._emitChangeEvent();
          };
      /**
       * Determines whether a value is selected.
       */
      /**
       * Determines whether a value is selected.
       * @param {?} value
       * @return {?}
       */
      SelectionModel.prototype.isSelected = /**
       * Determines whether a value is selected.
       * @param {?} value
       * @return {?}
       */
          function (value) {
              return this._selection.has(value);
          };
      /**
       * Determines whether the model does not have a value.
       */
      /**
       * Determines whether the model does not have a value.
       * @return {?}
       */
      SelectionModel.prototype.isEmpty = /**
       * Determines whether the model does not have a value.
       * @return {?}
       */
          function () {
              return this._selection.size === 0;
          };
      /**
       * Determines whether the model has a value.
       */
      /**
       * Determines whether the model has a value.
       * @return {?}
       */
      SelectionModel.prototype.hasValue = /**
       * Determines whether the model has a value.
       * @return {?}
       */
          function () {
              return !this.isEmpty();
          };
      /**
       * Sorts the selected values based on a predicate function.
       */
      /**
       * Sorts the selected values based on a predicate function.
       * @param {?=} predicate
       * @return {?}
       */
      SelectionModel.prototype.sort = /**
       * Sorts the selected values based on a predicate function.
       * @param {?=} predicate
       * @return {?}
       */
          function (predicate) {
              if (this._multiple && this.selected) {
                  ( /** @type {?} */(this._selected)).sort(predicate);
              }
          };
      /**
       * Gets whether multiple values can be selected.
       */
      /**
       * Gets whether multiple values can be selected.
       * @return {?}
       */
      SelectionModel.prototype.isMultipleSelection = /**
       * Gets whether multiple values can be selected.
       * @return {?}
       */
          function () {
              return this._multiple;
          };
      /** Emits a change event and clears the records of selected and deselected values. */
      /**
       * Emits a change event and clears the records of selected and deselected values.
       * @private
       * @return {?}
       */
      SelectionModel.prototype._emitChangeEvent = /**
       * Emits a change event and clears the records of selected and deselected values.
       * @private
       * @return {?}
       */
          function () {
              // Clear the selected values so they can be re-cached.
              this._selected = null;
              if (this._selectedToEmit.length || this._deselectedToEmit.length) {
                  this.changed.next({
                      source: this,
                      added: this._selectedToEmit,
                      removed: this._deselectedToEmit
                  });
                  this._deselectedToEmit = [];
                  this._selectedToEmit = [];
              }
          };
      /** Selects a value. */
      /**
       * Selects a value.
       * @private
       * @param {?} value
       * @return {?}
       */
      SelectionModel.prototype._markSelected = /**
       * Selects a value.
       * @private
       * @param {?} value
       * @return {?}
       */
          function (value) {
              if (!this.isSelected(value)) {
                  if (!this._multiple) {
                      this._unmarkAll();
                  }
                  this._selection.add(value);
                  if (this._emitChanges) {
                      this._selectedToEmit.push(value);
                  }
              }
          };
      /** Deselects a value. */
      /**
       * Deselects a value.
       * @private
       * @param {?} value
       * @return {?}
       */
      SelectionModel.prototype._unmarkSelected = /**
       * Deselects a value.
       * @private
       * @param {?} value
       * @return {?}
       */
          function (value) {
              if (this.isSelected(value)) {
                  this._selection.delete(value);
                  if (this._emitChanges) {
                      this._deselectedToEmit.push(value);
                  }
              }
          };
      /** Clears out the selected values. */
      /**
       * Clears out the selected values.
       * @private
       * @return {?}
       */
      SelectionModel.prototype._unmarkAll = /**
       * Clears out the selected values.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this.isEmpty()) {
                  this._selection.forEach(function (value) { return _this._unmarkSelected(value); });
              }
          };
      /**
       * Verifies the value assignment and throws an error if the specified value array is
       * including multiple values while the selection model is not supporting multiple values.
       */
      /**
       * Verifies the value assignment and throws an error if the specified value array is
       * including multiple values while the selection model is not supporting multiple values.
       * @private
       * @param {?} values
       * @return {?}
       */
      SelectionModel.prototype._verifyValueAssignment = /**
       * Verifies the value assignment and throws an error if the specified value array is
       * including multiple values while the selection model is not supporting multiple values.
       * @private
       * @param {?} values
       * @return {?}
       */
          function (values) {
              if (values.length > 1 && !this._multiple) {
                  throw getMultipleValuesInSingleSelectionError();
              }
          };
      return SelectionModel;
  }());
  /**
   * Returns an error that reports that multiple values are passed into a selection model
   * with a single value.
   * \@docs-private
   * @return {?}
   */
  function getMultipleValuesInSingleSelectionError() {
      return Error('Cannot pass multiple values into SelectionModel with single-value mode.');
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Class to coordinate unique selection based on name.
   * Intended to be consumed as an Angular service.
   * This service is needed because native radio change events are only fired on the item currently
   * being selected, and we still need to uncheck the previous selection.
   *
   * This service does not *store* any IDs and names because they may change at any time, so it is
   * less error-prone if they are simply passed through when the events occur.
   */
  var UniqueSelectionDispatcher = /** @class */ (function () {
      function UniqueSelectionDispatcher() {
          this._listeners = [];
      }
      /**
       * Notify other items that selection for the given name has been set.
       * @param id ID of the item.
       * @param name Name of the item.
       */
      /**
       * Notify other items that selection for the given name has been set.
       * @param {?} id ID of the item.
       * @param {?} name Name of the item.
       * @return {?}
       */
      UniqueSelectionDispatcher.prototype.notify = /**
       * Notify other items that selection for the given name has been set.
       * @param {?} id ID of the item.
       * @param {?} name Name of the item.
       * @return {?}
       */
          function (id, name) {
              for (var _i = 0, _a = this._listeners; _i < _a.length; _i++) {
                  var listener = _a[_i];
                  listener(id, name);
              }
          };
      /**
       * Listen for future changes to item selection.
       * @return Function used to deregister listener
       */
      /**
       * Listen for future changes to item selection.
       * @param {?} listener
       * @return {?} Function used to deregister listener
       */
      UniqueSelectionDispatcher.prototype.listen = /**
       * Listen for future changes to item selection.
       * @param {?} listener
       * @return {?} Function used to deregister listener
       */
          function (listener) {
              var _this = this;
              this._listeners.push(listener);
              return function () {
                  _this._listeners = _this._listeners.filter(function (registered) {
                      return listener !== registered;
                  });
              };
          };
      /**
       * @return {?}
       */
      UniqueSelectionDispatcher.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._listeners = [];
          };
      UniqueSelectionDispatcher.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */ UniqueSelectionDispatcher.ngInjectableDef = core.defineInjectable({ factory: function UniqueSelectionDispatcher_Factory() { return new UniqueSelectionDispatcher(); }, token: UniqueSelectionDispatcher, providedIn: "root" });
      return UniqueSelectionDispatcher;
  }());

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * The injection token used to specify the virtual scrolling strategy.
   * @type {?}
   */
  var VIRTUAL_SCROLL_STRATEGY = new core.InjectionToken('VIRTUAL_SCROLL_STRATEGY');
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Virtual scrolling strategy for lists with items of known fixed size.
   */
  var /**
   * Virtual scrolling strategy for lists with items of known fixed size.
   */ FixedSizeVirtualScrollStrategy = /** @class */ (function () {
      /**
       * @param itemSize The size of the items in the virtually scrolling list.
       * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
       * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
       */
      function FixedSizeVirtualScrollStrategy(itemSize, minBufferPx, maxBufferPx) {
          this._scrolledIndexChange = new rxjs.Subject();
          /**
           * \@docs-private Implemented as part of VirtualScrollStrategy.
           */
          this.scrolledIndexChange = this._scrolledIndexChange.pipe(operators.distinctUntilChanged());
          /**
           * The attached viewport.
           */
          this._viewport = null;
          this._itemSize = itemSize;
          this._minBufferPx = minBufferPx;
          this._maxBufferPx = maxBufferPx;
      }
      /**
       * Attaches this scroll strategy to a viewport.
       * @param viewport The viewport to attach this strategy to.
       */
      /**
       * Attaches this scroll strategy to a viewport.
       * @param {?} viewport The viewport to attach this strategy to.
       * @return {?}
       */
      FixedSizeVirtualScrollStrategy.prototype.attach = /**
       * Attaches this scroll strategy to a viewport.
       * @param {?} viewport The viewport to attach this strategy to.
       * @return {?}
       */
          function (viewport) {
              this._viewport = viewport;
              this._updateTotalContentSize();
              this._updateRenderedRange();
          };
      /** Detaches this scroll strategy from the currently attached viewport. */
      /**
       * Detaches this scroll strategy from the currently attached viewport.
       * @return {?}
       */
      FixedSizeVirtualScrollStrategy.prototype.detach = /**
       * Detaches this scroll strategy from the currently attached viewport.
       * @return {?}
       */
          function () {
              this._scrolledIndexChange.complete();
              this._viewport = null;
          };
      /**
       * Update the item size and buffer size.
       * @param itemSize The size of the items in the virtually scrolling list.
       * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
       * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
       */
      /**
       * Update the item size and buffer size.
       * @param {?} itemSize The size of the items in the virtually scrolling list.
       * @param {?} minBufferPx The minimum amount of buffer (in pixels) before needing to render more
       * @param {?} maxBufferPx The amount of buffer (in pixels) to render when rendering more.
       * @return {?}
       */
      FixedSizeVirtualScrollStrategy.prototype.updateItemAndBufferSize = /**
       * Update the item size and buffer size.
       * @param {?} itemSize The size of the items in the virtually scrolling list.
       * @param {?} minBufferPx The minimum amount of buffer (in pixels) before needing to render more
       * @param {?} maxBufferPx The amount of buffer (in pixels) to render when rendering more.
       * @return {?}
       */
          function (itemSize, minBufferPx, maxBufferPx) {
              if (maxBufferPx < minBufferPx) {
                  throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');
              }
              this._itemSize = itemSize;
              this._minBufferPx = minBufferPx;
              this._maxBufferPx = maxBufferPx;
              this._updateTotalContentSize();
              this._updateRenderedRange();
          };
      /** @docs-private Implemented as part of VirtualScrollStrategy. */
      /**
       * \@docs-private Implemented as part of VirtualScrollStrategy.
       * @return {?}
       */
      FixedSizeVirtualScrollStrategy.prototype.onContentScrolled = /**
       * \@docs-private Implemented as part of VirtualScrollStrategy.
       * @return {?}
       */
          function () {
              this._updateRenderedRange();
          };
      /** @docs-private Implemented as part of VirtualScrollStrategy. */
      /**
       * \@docs-private Implemented as part of VirtualScrollStrategy.
       * @return {?}
       */
      FixedSizeVirtualScrollStrategy.prototype.onDataLengthChanged = /**
       * \@docs-private Implemented as part of VirtualScrollStrategy.
       * @return {?}
       */
          function () {
              this._updateTotalContentSize();
              this._updateRenderedRange();
          };
      /** @docs-private Implemented as part of VirtualScrollStrategy. */
      /**
       * \@docs-private Implemented as part of VirtualScrollStrategy.
       * @return {?}
       */
      FixedSizeVirtualScrollStrategy.prototype.onContentRendered = /**
       * \@docs-private Implemented as part of VirtualScrollStrategy.
       * @return {?}
       */
          function () { };
      /** @docs-private Implemented as part of VirtualScrollStrategy. */
      /**
       * \@docs-private Implemented as part of VirtualScrollStrategy.
       * @return {?}
       */
      FixedSizeVirtualScrollStrategy.prototype.onRenderedOffsetChanged = /**
       * \@docs-private Implemented as part of VirtualScrollStrategy.
       * @return {?}
       */
          function () { };
      /**
       * Scroll to the offset for the given index.
       * @param index The index of the element to scroll to.
       * @param behavior The ScrollBehavior to use when scrolling.
       */
      /**
       * Scroll to the offset for the given index.
       * @param {?} index The index of the element to scroll to.
       * @param {?} behavior The ScrollBehavior to use when scrolling.
       * @return {?}
       */
      FixedSizeVirtualScrollStrategy.prototype.scrollToIndex = /**
       * Scroll to the offset for the given index.
       * @param {?} index The index of the element to scroll to.
       * @param {?} behavior The ScrollBehavior to use when scrolling.
       * @return {?}
       */
          function (index, behavior) {
              if (this._viewport) {
                  this._viewport.scrollToOffset(index * this._itemSize, behavior);
              }
          };
      /** Update the viewport's total content size. */
      /**
       * Update the viewport's total content size.
       * @private
       * @return {?}
       */
      FixedSizeVirtualScrollStrategy.prototype._updateTotalContentSize = /**
       * Update the viewport's total content size.
       * @private
       * @return {?}
       */
          function () {
              if (!this._viewport) {
                  return;
              }
              this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);
          };
      /** Update the viewport's rendered range. */
      /**
       * Update the viewport's rendered range.
       * @private
       * @return {?}
       */
      FixedSizeVirtualScrollStrategy.prototype._updateRenderedRange = /**
       * Update the viewport's rendered range.
       * @private
       * @return {?}
       */
          function () {
              if (!this._viewport) {
                  return;
              }
              /** @type {?} */
              var scrollOffset = this._viewport.measureScrollOffset();
              /** @type {?} */
              var firstVisibleIndex = scrollOffset / this._itemSize;
              /** @type {?} */
              var renderedRange = this._viewport.getRenderedRange();
              /** @type {?} */
              var newRange = { start: renderedRange.start, end: renderedRange.end };
              /** @type {?} */
              var viewportSize = this._viewport.getViewportSize();
              /** @type {?} */
              var dataLength = this._viewport.getDataLength();
              /** @type {?} */
              var startBuffer = scrollOffset - newRange.start * this._itemSize;
              if (startBuffer < this._minBufferPx && newRange.start != 0) {
                  /** @type {?} */
                  var expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);
                  newRange.start = Math.max(0, newRange.start - expandStart);
                  newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));
              }
              else {
                  /** @type {?} */
                  var endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);
                  if (endBuffer < this._minBufferPx && newRange.end != dataLength) {
                      /** @type {?} */
                      var expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);
                      if (expandEnd > 0) {
                          newRange.end = Math.min(dataLength, newRange.end + expandEnd);
                          newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));
                      }
                  }
              }
              this._viewport.setRenderedRange(newRange);
              this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);
              this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));
          };
      return FixedSizeVirtualScrollStrategy;
  }());
  /**
   * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created
   * `FixedSizeVirtualScrollStrategy` from the given directive.
   * @param {?} fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the
   *     `FixedSizeVirtualScrollStrategy` from.
   * @return {?}
   */
  function _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {
      return fixedSizeDir._scrollStrategy;
  }
  /**
   * A virtual scroll strategy that supports fixed-size items.
   */
  var CdkFixedSizeVirtualScroll = /** @class */ (function () {
      function CdkFixedSizeVirtualScroll() {
          this._itemSize = 20;
          this._minBufferPx = 100;
          this._maxBufferPx = 200;
          /**
           * The scroll strategy used by this directive.
           */
          this._scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);
      }
      Object.defineProperty(CdkFixedSizeVirtualScroll.prototype, "itemSize", {
          /** The size of the items in the list (in pixels). */
          get: /**
           * The size of the items in the list (in pixels).
           * @return {?}
           */ function () { return this._itemSize; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._itemSize = coerceNumberProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkFixedSizeVirtualScroll.prototype, "minBufferPx", {
          /**
           * The minimum amount of buffer rendered beyond the viewport (in pixels).
           * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.
           */
          get: /**
           * The minimum amount of buffer rendered beyond the viewport (in pixels).
           * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.
           * @return {?}
           */ function () { return this._minBufferPx; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._minBufferPx = coerceNumberProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkFixedSizeVirtualScroll.prototype, "maxBufferPx", {
          /**
           * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.
           */
          get: /**
           * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.
           * @return {?}
           */ function () { return this._maxBufferPx; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._maxBufferPx = coerceNumberProperty(value); },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      CdkFixedSizeVirtualScroll.prototype.ngOnChanges = /**
       * @return {?}
       */
          function () {
              this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);
          };
      CdkFixedSizeVirtualScroll.decorators = [
          { type: core.Directive, args: [{
                      selector: 'cdk-virtual-scroll-viewport[itemSize]',
                      providers: [{
                              provide: VIRTUAL_SCROLL_STRATEGY,
                              useFactory: _fixedSizeVirtualScrollStrategyFactory,
                              deps: [core.forwardRef(function () { return CdkFixedSizeVirtualScroll; })],
                          }],
                  },] },
      ];
      CdkFixedSizeVirtualScroll.propDecorators = {
          itemSize: [{ type: core.Input }],
          minBufferPx: [{ type: core.Input }],
          maxBufferPx: [{ type: core.Input }]
      };
      return CdkFixedSizeVirtualScroll;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Time in ms to throttle the scrolling events by default.
   * @type {?}
   */
  var DEFAULT_SCROLL_TIME = 20;
  /**
   * Service contained all registered Scrollable references and emits an event when any one of the
   * Scrollable references emit a scrolled event.
   */
  var ScrollDispatcher = /** @class */ (function () {
      function ScrollDispatcher(_ngZone, _platform) {
          this._ngZone = _ngZone;
          this._platform = _platform;
          /**
           * Subject for notifying that a registered scrollable reference element has been scrolled.
           */
          this._scrolled = new rxjs.Subject();
          /**
           * Keeps track of the global `scroll` and `resize` subscriptions.
           */
          this._globalSubscription = null;
          /**
           * Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards.
           */
          this._scrolledCount = 0;
          /**
           * Map of all the scrollable references that are registered with the service and their
           * scroll event subscriptions.
           */
          this.scrollContainers = new Map();
      }
      /**
       * Registers a scrollable instance with the service and listens for its scrolled events. When the
       * scrollable is scrolled, the service emits the event to its scrolled observable.
       * @param scrollable Scrollable instance to be registered.
       */
      /**
       * Registers a scrollable instance with the service and listens for its scrolled events. When the
       * scrollable is scrolled, the service emits the event to its scrolled observable.
       * @param {?} scrollable Scrollable instance to be registered.
       * @return {?}
       */
      ScrollDispatcher.prototype.register = /**
       * Registers a scrollable instance with the service and listens for its scrolled events. When the
       * scrollable is scrolled, the service emits the event to its scrolled observable.
       * @param {?} scrollable Scrollable instance to be registered.
       * @return {?}
       */
          function (scrollable) {
              var _this = this;
              if (!this.scrollContainers.has(scrollable)) {
                  this.scrollContainers.set(scrollable, scrollable.elementScrolled()
                      .subscribe(function () { return _this._scrolled.next(scrollable); }));
              }
          };
      /**
       * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.
       * @param scrollable Scrollable instance to be deregistered.
       */
      /**
       * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.
       * @param {?} scrollable Scrollable instance to be deregistered.
       * @return {?}
       */
      ScrollDispatcher.prototype.deregister = /**
       * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.
       * @param {?} scrollable Scrollable instance to be deregistered.
       * @return {?}
       */
          function (scrollable) {
              /** @type {?} */
              var scrollableReference = this.scrollContainers.get(scrollable);
              if (scrollableReference) {
                  scrollableReference.unsubscribe();
                  this.scrollContainers.delete(scrollable);
              }
          };
      /**
       * Returns an observable that emits an event whenever any of the registered Scrollable
       * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
       * to override the default "throttle" time.
       *
       * **Note:** in order to avoid hitting change detection for every scroll event,
       * all of the events emitted from this stream will be run outside the Angular zone.
       * If you need to update any data bindings as a result of a scroll event, you have
       * to run the callback using `NgZone.run`.
       */
      /**
       * Returns an observable that emits an event whenever any of the registered Scrollable
       * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
       * to override the default "throttle" time.
       *
       * **Note:** in order to avoid hitting change detection for every scroll event,
       * all of the events emitted from this stream will be run outside the Angular zone.
       * If you need to update any data bindings as a result of a scroll event, you have
       * to run the callback using `NgZone.run`.
       * @param {?=} auditTimeInMs
       * @return {?}
       */
      ScrollDispatcher.prototype.scrolled = /**
       * Returns an observable that emits an event whenever any of the registered Scrollable
       * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
       * to override the default "throttle" time.
       *
       * **Note:** in order to avoid hitting change detection for every scroll event,
       * all of the events emitted from this stream will be run outside the Angular zone.
       * If you need to update any data bindings as a result of a scroll event, you have
       * to run the callback using `NgZone.run`.
       * @param {?=} auditTimeInMs
       * @return {?}
       */
          function (auditTimeInMs) {
              var _this = this;
              if (auditTimeInMs === void 0) {
                  auditTimeInMs = DEFAULT_SCROLL_TIME;
              }
              if (!this._platform.isBrowser) {
                  return rxjs.of();
              }
              return new rxjs.Observable(function (observer) {
                  if (!_this._globalSubscription) {
                      _this._addGlobalListener();
                  }
                  // In the case of a 0ms delay, use an observable without auditTime
                  // since it does add a perceptible delay in processing overhead.
                  /** @type {?} */
                  var subscription = auditTimeInMs > 0 ?
                      _this._scrolled.pipe(operators.auditTime(auditTimeInMs)).subscribe(observer) :
                      _this._scrolled.subscribe(observer);
                  _this._scrolledCount++;
                  return function () {
                      subscription.unsubscribe();
                      _this._scrolledCount--;
                      if (!_this._scrolledCount) {
                          _this._removeGlobalListener();
                      }
                  };
              });
          };
      /**
       * @return {?}
       */
      ScrollDispatcher.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._removeGlobalListener();
              this.scrollContainers.forEach(function (_, container) { return _this.deregister(container); });
              this._scrolled.complete();
          };
      /**
       * Returns an observable that emits whenever any of the
       * scrollable ancestors of an element are scrolled.
       * @param elementRef Element whose ancestors to listen for.
       * @param auditTimeInMs Time to throttle the scroll events.
       */
      /**
       * Returns an observable that emits whenever any of the
       * scrollable ancestors of an element are scrolled.
       * @param {?} elementRef Element whose ancestors to listen for.
       * @param {?=} auditTimeInMs Time to throttle the scroll events.
       * @return {?}
       */
      ScrollDispatcher.prototype.ancestorScrolled = /**
       * Returns an observable that emits whenever any of the
       * scrollable ancestors of an element are scrolled.
       * @param {?} elementRef Element whose ancestors to listen for.
       * @param {?=} auditTimeInMs Time to throttle the scroll events.
       * @return {?}
       */
          function (elementRef, auditTimeInMs) {
              /** @type {?} */
              var ancestors = this.getAncestorScrollContainers(elementRef);
              return this.scrolled(auditTimeInMs).pipe(operators.filter(function (target) {
                  return !target || ancestors.indexOf(target) > -1;
              }));
          };
      /** Returns all registered Scrollables that contain the provided element. */
      /**
       * Returns all registered Scrollables that contain the provided element.
       * @param {?} elementRef
       * @return {?}
       */
      ScrollDispatcher.prototype.getAncestorScrollContainers = /**
       * Returns all registered Scrollables that contain the provided element.
       * @param {?} elementRef
       * @return {?}
       */
          function (elementRef) {
              var _this = this;
              /** @type {?} */
              var scrollingContainers = [];
              this.scrollContainers.forEach(function (_subscription, scrollable) {
                  if (_this._scrollableContainsElement(scrollable, elementRef)) {
                      scrollingContainers.push(scrollable);
                  }
              });
              return scrollingContainers;
          };
      /** Returns true if the element is contained within the provided Scrollable. */
      /**
       * Returns true if the element is contained within the provided Scrollable.
       * @private
       * @param {?} scrollable
       * @param {?} elementRef
       * @return {?}
       */
      ScrollDispatcher.prototype._scrollableContainsElement = /**
       * Returns true if the element is contained within the provided Scrollable.
       * @private
       * @param {?} scrollable
       * @param {?} elementRef
       * @return {?}
       */
          function (scrollable, elementRef) {
              /** @type {?} */
              var element = elementRef.nativeElement;
              /** @type {?} */
              var scrollableElement = scrollable.getElementRef().nativeElement;
              // Traverse through the element parents until we reach null, checking if any of the elements
              // are the scrollable's element.
              do {
                  if (element == scrollableElement) {
                      return true;
                  }
              } while (element = ( /** @type {?} */(element)).parentElement);
              return false;
          };
      /** Sets up the global scroll listeners. */
      /**
       * Sets up the global scroll listeners.
       * @private
       * @return {?}
       */
      ScrollDispatcher.prototype._addGlobalListener = /**
       * Sets up the global scroll listeners.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              this._globalSubscription = this._ngZone.runOutsideAngular(function () {
                  return rxjs.fromEvent(window.document, 'scroll').subscribe(function () { return _this._scrolled.next(); });
              });
          };
      /** Cleans up the global scroll listener. */
      /**
       * Cleans up the global scroll listener.
       * @private
       * @return {?}
       */
      ScrollDispatcher.prototype._removeGlobalListener = /**
       * Cleans up the global scroll listener.
       * @private
       * @return {?}
       */
          function () {
              if (this._globalSubscription) {
                  this._globalSubscription.unsubscribe();
                  this._globalSubscription = null;
              }
          };
      ScrollDispatcher.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */
      ScrollDispatcher.ctorParameters = function () {
          return [
              { type: core.NgZone },
              { type: Platform }
          ];
      };
      /** @nocollapse */ ScrollDispatcher.ngInjectableDef = core.defineInjectable({ factory: function ScrollDispatcher_Factory() { return new ScrollDispatcher(core.inject(core.NgZone), core.inject(Platform)); }, token: ScrollDispatcher, providedIn: "root" });
      return ScrollDispatcher;
  }());
  /**
   * \@docs-private \@deprecated \@breaking-change 8.0.0
   * @param {?} parentDispatcher
   * @param {?} ngZone
   * @param {?} platform
   * @return {?}
   */
  function SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher, ngZone, platform) {
      return parentDispatcher || new ScrollDispatcher(ngZone, platform);
  }
  /**
   * \@docs-private \@deprecated \@breaking-change 8.0.0
   * @type {?}
   */
  var SCROLL_DISPATCHER_PROVIDER = {
      // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.
      provide: ScrollDispatcher,
      deps: [[new core.Optional(), new core.SkipSelf(), ScrollDispatcher], core.NgZone, Platform],
      useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Sends an event when the directive's element is scrolled. Registers itself with the
   * ScrollDispatcher service to include itself as part of its collection of scrolling events that it
   * can be listened to through the service.
   */
  var CdkScrollable = /** @class */ (function () {
      function CdkScrollable(elementRef, scrollDispatcher, ngZone, dir) {
          var _this = this;
          this.elementRef = elementRef;
          this.scrollDispatcher = scrollDispatcher;
          this.ngZone = ngZone;
          this.dir = dir;
          this._destroyed = new rxjs.Subject();
          this._elementScrolled = new rxjs.Observable(function (observer) {
              return _this.ngZone.runOutsideAngular(function () {
                  return rxjs.fromEvent(_this.elementRef.nativeElement, 'scroll').pipe(operators.takeUntil(_this._destroyed))
                      .subscribe(observer);
              });
          });
      }
      /**
       * @return {?}
       */
      CdkScrollable.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              this.scrollDispatcher.register(this);
          };
      /**
       * @return {?}
       */
      CdkScrollable.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this.scrollDispatcher.deregister(this);
              this._destroyed.next();
              this._destroyed.complete();
          };
      /** Returns observable that emits when a scroll event is fired on the host element. */
      /**
       * Returns observable that emits when a scroll event is fired on the host element.
       * @return {?}
       */
      CdkScrollable.prototype.elementScrolled = /**
       * Returns observable that emits when a scroll event is fired on the host element.
       * @return {?}
       */
          function () {
              return this._elementScrolled;
          };
      /** Gets the ElementRef for the viewport. */
      /**
       * Gets the ElementRef for the viewport.
       * @return {?}
       */
      CdkScrollable.prototype.getElementRef = /**
       * Gets the ElementRef for the viewport.
       * @return {?}
       */
          function () {
              return this.elementRef;
          };
      /**
       * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
       * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
       * left and right always refer to the left and right side of the scrolling container irrespective
       * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
       * in an RTL context.
       * @param options specified the offsets to scroll to.
       */
      /**
       * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
       * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
       * left and right always refer to the left and right side of the scrolling container irrespective
       * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
       * in an RTL context.
       * @param {?} options specified the offsets to scroll to.
       * @return {?}
       */
      CdkScrollable.prototype.scrollTo = /**
       * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
       * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
       * left and right always refer to the left and right side of the scrolling container irrespective
       * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
       * in an RTL context.
       * @param {?} options specified the offsets to scroll to.
       * @return {?}
       */
          function (options) {
              /** @type {?} */
              var el = this.elementRef.nativeElement;
              /** @type {?} */
              var isRtl = this.dir && this.dir.value == 'rtl';
              // Rewrite start & end offsets as right or left offsets.
              options.left = options.left == null ? (isRtl ? options.end : options.start) : options.left;
              options.right = options.right == null ? (isRtl ? options.start : options.end) : options.right;
              // Rewrite the bottom offset as a top offset.
              if (options.bottom != null) {
                  (( /** @type {?} */(options))).top =
                      el.scrollHeight - el.clientHeight - options.bottom;
              }
              // Rewrite the right offset as a left offset.
              if (isRtl && getRtlScrollAxisType() != RtlScrollAxisType.NORMAL) {
                  if (options.left != null) {
                      (( /** @type {?} */(options))).right =
                          el.scrollWidth - el.clientWidth - options.left;
                  }
                  if (getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
                      options.left = options.right;
                  }
                  else if (getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
                      options.left = options.right ? -options.right : options.right;
                  }
              }
              else {
                  if (options.right != null) {
                      (( /** @type {?} */(options))).left =
                          el.scrollWidth - el.clientWidth - options.right;
                  }
              }
              this._applyScrollToOptions(options);
          };
      /**
       * @private
       * @param {?} options
       * @return {?}
       */
      CdkScrollable.prototype._applyScrollToOptions = /**
       * @private
       * @param {?} options
       * @return {?}
       */
          function (options) {
              /** @type {?} */
              var el = this.elementRef.nativeElement;
              if (supportsScrollBehavior()) {
                  el.scrollTo(options);
              }
              else {
                  if (options.top != null) {
                      el.scrollTop = options.top;
                  }
                  if (options.left != null) {
                      el.scrollLeft = options.left;
                  }
              }
          };
      /**
       * Measures the scroll offset relative to the specified edge of the viewport. This method can be
       * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent
       * about what scrollLeft means in RTL. The values returned by this method are normalized such that
       * left and right always refer to the left and right side of the scrolling container irrespective
       * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
       * in an RTL context.
       * @param from The edge to measure from.
       */
      /**
       * Measures the scroll offset relative to the specified edge of the viewport. This method can be
       * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent
       * about what scrollLeft means in RTL. The values returned by this method are normalized such that
       * left and right always refer to the left and right side of the scrolling container irrespective
       * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
       * in an RTL context.
       * @param {?} from The edge to measure from.
       * @return {?}
       */
      CdkScrollable.prototype.measureScrollOffset = /**
       * Measures the scroll offset relative to the specified edge of the viewport. This method can be
       * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent
       * about what scrollLeft means in RTL. The values returned by this method are normalized such that
       * left and right always refer to the left and right side of the scrolling container irrespective
       * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
       * in an RTL context.
       * @param {?} from The edge to measure from.
       * @return {?}
       */
          function (from) {
              /** @type {?} */
              var LEFT = 'left';
              /** @type {?} */
              var RIGHT = 'right';
              /** @type {?} */
              var el = this.elementRef.nativeElement;
              if (from == 'top') {
                  return el.scrollTop;
              }
              if (from == 'bottom') {
                  return el.scrollHeight - el.clientHeight - el.scrollTop;
              }
              // Rewrite start & end as left or right offsets.
              /** @type {?} */
              var isRtl = this.dir && this.dir.value == 'rtl';
              if (from == 'start') {
                  from = isRtl ? RIGHT : LEFT;
              }
              else if (from == 'end') {
                  from = isRtl ? LEFT : RIGHT;
              }
              if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
                  // For INVERTED, scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and
                  // 0 when scrolled all the way right.
                  if (from == LEFT) {
                      return el.scrollWidth - el.clientWidth - el.scrollLeft;
                  }
                  else {
                      return el.scrollLeft;
                  }
              }
              else if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
                  // For NEGATED, scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and
                  // 0 when scrolled all the way right.
                  if (from == LEFT) {
                      return el.scrollLeft + el.scrollWidth - el.clientWidth;
                  }
                  else {
                      return -el.scrollLeft;
                  }
              }
              else {
                  // For NORMAL, as well as non-RTL contexts, scrollLeft is 0 when scrolled all the way left and
                  // (scrollWidth - clientWidth) when scrolled all the way right.
                  if (from == LEFT) {
                      return el.scrollLeft;
                  }
                  else {
                      return el.scrollWidth - el.clientWidth - el.scrollLeft;
                  }
              }
          };
      CdkScrollable.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdk-scrollable], [cdkScrollable]'
                  },] },
      ];
      /** @nocollapse */
      CdkScrollable.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: ScrollDispatcher },
              { type: core.NgZone },
              { type: Directionality, decorators: [{ type: core.Optional }] }
          ];
      };
      return CdkScrollable;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Checks if the given ranges are equal.
   * @param {?} r1
   * @param {?} r2
   * @return {?}
   */
  function rangesEqual(r1, r2) {
      return r1.start == r2.start && r1.end == r2.end;
  }
  /**
   * A viewport that virtualizes it's scrolling with the help of `CdkVirtualForOf`.
   */
  var CdkVirtualScrollViewport = /** @class */ (function (_super) {
      tslib_1.__extends(CdkVirtualScrollViewport, _super);
      function CdkVirtualScrollViewport(elementRef, _changeDetectorRef, ngZone, _scrollStrategy, dir, scrollDispatcher) {
          var _this = _super.call(this, elementRef, scrollDispatcher, ngZone, dir) || this;
          _this.elementRef = elementRef;
          _this._changeDetectorRef = _changeDetectorRef;
          _this._scrollStrategy = _scrollStrategy;
          /**
           * Emits when the viewport is detached from a CdkVirtualForOf.
           */
          _this._detachedSubject = new rxjs.Subject();
          /**
           * Emits when the rendered range changes.
           */
          _this._renderedRangeSubject = new rxjs.Subject();
          /**
           * The direction the viewport scrolls.
           */
          _this.orientation = 'vertical';
          // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll
          // strategy lazily (i.e. only if the user is actually listening to the events). We do this because
          // depending on how the strategy calculates the scrolled index, it may come at a cost to
          // performance.
          /**
           * Emits when the index of the first element visible in the viewport changes.
           */
          _this.scrolledIndexChange = new rxjs.Observable(function (observer) {
              return _this._scrollStrategy.scrolledIndexChange.subscribe(function (index) {
                  return Promise.resolve().then(function () { return _this.ngZone.run(function () { return observer.next(index); }); });
              });
          });
          /**
           * A stream that emits whenever the rendered range changes.
           */
          _this.renderedRangeStream = _this._renderedRangeSubject.asObservable();
          /**
           * The transform used to scale the spacer to the same size as all content, including content that
           * is not currently rendered.
           */
          _this._totalContentSizeTransform = '';
          /**
           * The total size of all content (in pixels), including content that is not currently rendered.
           */
          _this._totalContentSize = 0;
          /**
           * The currently rendered range of indices.
           */
          _this._renderedRange = { start: 0, end: 0 };
          /**
           * The length of the data bound to this viewport (in number of items).
           */
          _this._dataLength = 0;
          /**
           * The size of the viewport (in pixels).
           */
          _this._viewportSize = 0;
          /**
           * The last rendered content offset that was set.
           */
          _this._renderedContentOffset = 0;
          /**
           * Whether the last rendered content offset was to the end of the content (and therefore needs to
           * be rewritten as an offset to the start of the content).
           */
          _this._renderedContentOffsetNeedsRewrite = false;
          /**
           * Whether there is a pending change detection cycle.
           */
          _this._isChangeDetectionPending = false;
          /**
           * A list of functions to run after the next change detection cycle.
           */
          _this._runAfterChangeDetection = [];
          if (!_scrollStrategy) {
              throw Error('Error: cdk-virtual-scroll-viewport requires the "itemSize" property to be set.');
          }
          return _this;
      }
      /**
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              _super.prototype.ngOnInit.call(this);
              // It's still too early to measure the viewport at this point. Deferring with a promise allows
              // the Viewport to be rendered with the correct size before we measure. We run this outside the
              // zone to avoid causing more change detection cycles. We handle the change detection loop
              // ourselves instead.
              this.ngZone.runOutsideAngular(function () {
                  return Promise.resolve().then(function () {
                      _this._measureViewportSize();
                      _this._scrollStrategy.attach(_this);
                      _this.elementScrolled()
                          .pipe(
                      // Start off with a fake scroll event so we properly detect our initial position.
                      operators.startWith(( /** @type {?} */(null))), 
                      // Collect multiple events into one until the next animation frame. This way if
                      // there are multiple scroll events in the same frame we only need to recheck
                      // our layout once.
                      operators.auditTime(0, rxjs.animationFrameScheduler))
                          .subscribe(function () { return _this._scrollStrategy.onContentScrolled(); });
                      _this._markChangeDetectionNeeded();
                  });
              });
          };
      /**
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this.detach();
              this._scrollStrategy.detach();
              // Complete all subjects
              this._renderedRangeSubject.complete();
              this._detachedSubject.complete();
              _super.prototype.ngOnDestroy.call(this);
          };
      /** Attaches a `CdkVirtualForOf` to this viewport. */
      /**
       * Attaches a `CdkVirtualForOf` to this viewport.
       * @param {?} forOf
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype.attach = /**
       * Attaches a `CdkVirtualForOf` to this viewport.
       * @param {?} forOf
       * @return {?}
       */
          function (forOf) {
              var _this = this;
              if (this._forOf) {
                  throw Error('CdkVirtualScrollViewport is already attached.');
              }
              // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length
              // changes. Run outside the zone to avoid triggering change detection, since we're managing the
              // change detection loop ourselves.
              this.ngZone.runOutsideAngular(function () {
                  _this._forOf = forOf;
                  _this._forOf.dataStream.pipe(operators.takeUntil(_this._detachedSubject)).subscribe(function (data) {
                      /** @type {?} */
                      var newLength = data.length;
                      if (newLength !== _this._dataLength) {
                          _this._dataLength = newLength;
                          _this._scrollStrategy.onDataLengthChanged();
                      }
                      _this._doChangeDetection();
                  });
              });
          };
      /** Detaches the current `CdkVirtualForOf`. */
      /**
       * Detaches the current `CdkVirtualForOf`.
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype.detach = /**
       * Detaches the current `CdkVirtualForOf`.
       * @return {?}
       */
          function () {
              this._forOf = null;
              this._detachedSubject.next();
          };
      /** Gets the length of the data bound to this viewport (in number of items). */
      /**
       * Gets the length of the data bound to this viewport (in number of items).
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype.getDataLength = /**
       * Gets the length of the data bound to this viewport (in number of items).
       * @return {?}
       */
          function () {
              return this._dataLength;
          };
      /** Gets the size of the viewport (in pixels). */
      /**
       * Gets the size of the viewport (in pixels).
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype.getViewportSize = /**
       * Gets the size of the viewport (in pixels).
       * @return {?}
       */
          function () {
              return this._viewportSize;
          };
      // TODO(mmalerba): This is technically out of sync with what's really rendered until a render
      // cycle happens. I'm being careful to only call it after the render cycle is complete and before
      // setting it to something else, but its error prone and should probably be split into
      // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.
      /** Get the current rendered range of items. */
      // TODO(mmalerba): This is technically out of sync with what's really rendered until a render
      // cycle happens. I'm being careful to only call it after the render cycle is complete and before
      // setting it to something else, but its error prone and should probably be split into
      // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.
      /**
       * Get the current rendered range of items.
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype.getRenderedRange =
          // TODO(mmalerba): This is technically out of sync with what's really rendered until a render
          // cycle happens. I'm being careful to only call it after the render cycle is complete and before
          // setting it to something else, but its error prone and should probably be split into
          // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.
          /**
           * Get the current rendered range of items.
           * @return {?}
           */
          function () {
              return this._renderedRange;
          };
      /**
       * Sets the total size of all content (in pixels), including content that is not currently
       * rendered.
       */
      /**
       * Sets the total size of all content (in pixels), including content that is not currently
       * rendered.
       * @param {?} size
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype.setTotalContentSize = /**
       * Sets the total size of all content (in pixels), including content that is not currently
       * rendered.
       * @param {?} size
       * @return {?}
       */
          function (size) {
              if (this._totalContentSize !== size) {
                  this._totalContentSize = size;
                  /** @type {?} */
                  var axis = this.orientation == 'horizontal' ? 'X' : 'Y';
                  this._totalContentSizeTransform = "scale" + axis + "(" + this._totalContentSize + ")";
                  this._markChangeDetectionNeeded();
              }
          };
      /** Sets the currently rendered range of indices. */
      /**
       * Sets the currently rendered range of indices.
       * @param {?} range
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype.setRenderedRange = /**
       * Sets the currently rendered range of indices.
       * @param {?} range
       * @return {?}
       */
          function (range) {
              var _this = this;
              if (!rangesEqual(this._renderedRange, range)) {
                  this._renderedRangeSubject.next(this._renderedRange = range);
                  this._markChangeDetectionNeeded(function () { return _this._scrollStrategy.onContentRendered(); });
              }
          };
      /**
       * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).
       */
      /**
       * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype.getOffsetToRenderedContentStart = /**
       * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).
       * @return {?}
       */
          function () {
              return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;
          };
      /**
       * Sets the offset from the start of the viewport to either the start or end of the rendered data
       * (in pixels).
       */
      /**
       * Sets the offset from the start of the viewport to either the start or end of the rendered data
       * (in pixels).
       * @param {?} offset
       * @param {?=} to
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype.setRenderedContentOffset = /**
       * Sets the offset from the start of the viewport to either the start or end of the rendered data
       * (in pixels).
       * @param {?} offset
       * @param {?=} to
       * @return {?}
       */
          function (offset, to) {
              var _this = this;
              if (to === void 0) {
                  to = 'to-start';
              }
              // For a horizontal viewport in a right-to-left language we need to translate along the x-axis
              // in the negative direction.
              /** @type {?} */
              var isRtl = this.dir && this.dir.value == 'rtl';
              /** @type {?} */
              var isHorizontal = this.orientation == 'horizontal';
              /** @type {?} */
              var axis = isHorizontal ? 'X' : 'Y';
              /** @type {?} */
              var axisDirection = isHorizontal && isRtl ? -1 : 1;
              /** @type {?} */
              var transform = "translate" + axis + "(" + Number(axisDirection * offset) + "px)";
              this._renderedContentOffset = offset;
              if (to === 'to-end') {
                  transform += " translate" + axis + "(-100%)";
                  // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise
                  // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would
                  // expand upward).
                  this._renderedContentOffsetNeedsRewrite = true;
              }
              if (this._renderedContentTransform != transform) {
                  // We know this value is safe because we parse `offset` with `Number()` before passing it
                  // into the string.
                  this._renderedContentTransform = transform;
                  this._markChangeDetectionNeeded(function () {
                      if (_this._renderedContentOffsetNeedsRewrite) {
                          _this._renderedContentOffset -= _this.measureRenderedContentSize();
                          _this._renderedContentOffsetNeedsRewrite = false;
                          _this.setRenderedContentOffset(_this._renderedContentOffset);
                      }
                      else {
                          _this._scrollStrategy.onRenderedOffsetChanged();
                      }
                  });
              }
          };
      /**
       * Scrolls to the given offset from the start of the viewport. Please note that this is not always
       * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left
       * direction, this would be the equivalent of setting a fictional `scrollRight` property.
       * @param offset The offset to scroll to.
       * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
       */
      /**
       * Scrolls to the given offset from the start of the viewport. Please note that this is not always
       * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left
       * direction, this would be the equivalent of setting a fictional `scrollRight` property.
       * @param {?} offset The offset to scroll to.
       * @param {?=} behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype.scrollToOffset = /**
       * Scrolls to the given offset from the start of the viewport. Please note that this is not always
       * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left
       * direction, this would be the equivalent of setting a fictional `scrollRight` property.
       * @param {?} offset The offset to scroll to.
       * @param {?=} behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
       * @return {?}
       */
          function (offset, behavior) {
              if (behavior === void 0) {
                  behavior = 'auto';
              }
              /** @type {?} */
              var options = { behavior: behavior };
              if (this.orientation === 'horizontal') {
                  options.start = offset;
              }
              else {
                  options.top = offset;
              }
              this.scrollTo(options);
          };
      /**
       * Scrolls to the offset for the given index.
       * @param index The index of the element to scroll to.
       * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
       */
      /**
       * Scrolls to the offset for the given index.
       * @param {?} index The index of the element to scroll to.
       * @param {?=} behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype.scrollToIndex = /**
       * Scrolls to the offset for the given index.
       * @param {?} index The index of the element to scroll to.
       * @param {?=} behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
       * @return {?}
       */
          function (index, behavior) {
              if (behavior === void 0) {
                  behavior = 'auto';
              }
              this._scrollStrategy.scrollToIndex(index, behavior);
          };
      /**
       * Gets the current scroll offset from the start of the viewport (in pixels).
       * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'
       *     in horizontal mode.
       */
      /**
       * Gets the current scroll offset from the start of the viewport (in pixels).
       * @param {?=} from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'
       *     in horizontal mode.
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype.measureScrollOffset = /**
       * Gets the current scroll offset from the start of the viewport (in pixels).
       * @param {?=} from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'
       *     in horizontal mode.
       * @return {?}
       */
          function (from) {
              return _super.prototype.measureScrollOffset.call(this, from ? from : this.orientation === 'horizontal' ? 'start' : 'top');
          };
      /** Measure the combined size of all of the rendered items. */
      /**
       * Measure the combined size of all of the rendered items.
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype.measureRenderedContentSize = /**
       * Measure the combined size of all of the rendered items.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var contentEl = this._contentWrapper.nativeElement;
              return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;
          };
      /**
       * Measure the total combined size of the given range. Throws if the range includes items that are
       * not rendered.
       */
      /**
       * Measure the total combined size of the given range. Throws if the range includes items that are
       * not rendered.
       * @param {?} range
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype.measureRangeSize = /**
       * Measure the total combined size of the given range. Throws if the range includes items that are
       * not rendered.
       * @param {?} range
       * @return {?}
       */
          function (range) {
              if (!this._forOf) {
                  return 0;
              }
              return this._forOf.measureRangeSize(range, this.orientation);
          };
      /** Update the viewport dimensions and re-render. */
      /**
       * Update the viewport dimensions and re-render.
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype.checkViewportSize = /**
       * Update the viewport dimensions and re-render.
       * @return {?}
       */
          function () {
              // TODO: Cleanup later when add logic for handling content resize
              this._measureViewportSize();
              this._scrollStrategy.onDataLengthChanged();
          };
      /** Measure the viewport size. */
      /**
       * Measure the viewport size.
       * @private
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype._measureViewportSize = /**
       * Measure the viewport size.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var viewportEl = this.elementRef.nativeElement;
              this._viewportSize = this.orientation === 'horizontal' ?
                  viewportEl.clientWidth : viewportEl.clientHeight;
          };
      /** Queue up change detection to run. */
      /**
       * Queue up change detection to run.
       * @private
       * @param {?=} runAfter
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype._markChangeDetectionNeeded = /**
       * Queue up change detection to run.
       * @private
       * @param {?=} runAfter
       * @return {?}
       */
          function (runAfter) {
              var _this = this;
              if (runAfter) {
                  this._runAfterChangeDetection.push(runAfter);
              }
              // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of
              // properties sequentially we only have to run `_doChangeDetection` once at the end.
              if (!this._isChangeDetectionPending) {
                  this._isChangeDetectionPending = true;
                  this.ngZone.runOutsideAngular(function () {
                      return Promise.resolve().then(function () {
                          _this._doChangeDetection();
                      });
                  });
              }
          };
      /** Run change detection. */
      /**
       * Run change detection.
       * @private
       * @return {?}
       */
      CdkVirtualScrollViewport.prototype._doChangeDetection = /**
       * Run change detection.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              this._isChangeDetectionPending = false;
              // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection
              // from the root, since the repeated items are content projected in. Calling `detectChanges`
              // instead does not properly check the projected content.
              this.ngZone.run(function () { return _this._changeDetectorRef.markForCheck(); });
              // Apply the content transform. The transform can't be set via an Angular binding because
              // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of
              // string literals, a variable that can only be 'X' or 'Y', and user input that is run through
              // the `Number` function first to coerce it to a numeric value.
              this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;
              /** @type {?} */
              var runAfterChangeDetection = this._runAfterChangeDetection;
              this._runAfterChangeDetection = [];
              for (var _i = 0, runAfterChangeDetection_1 = runAfterChangeDetection; _i < runAfterChangeDetection_1.length; _i++) {
                  var fn = runAfterChangeDetection_1[_i];
                  fn();
              }
          };
      CdkVirtualScrollViewport.decorators = [
          { type: core.Component, args: [{ selector: 'cdk-virtual-scroll-viewport',
                      template: "<div #contentWrapper class=\"cdk-virtual-scroll-content-wrapper\"><ng-content></ng-content></div><div class=\"cdk-virtual-scroll-spacer\" [style.transform]=\"_totalContentSizeTransform\"></div>",
                      styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;overflow:auto;contain:strict;transform:translateZ(0);will-change:scroll-position;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:0}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:0}.cdk-virtual-scroll-spacer{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0}[dir=rtl] .cdk-virtual-scroll-spacer{right:0;left:auto;transform-origin:100% 0}"],
                      host: {
                          'class': 'cdk-virtual-scroll-viewport',
                          '[class.cdk-virtual-scroll-orientation-horizontal]': 'orientation === "horizontal"',
                          '[class.cdk-virtual-scroll-orientation-vertical]': 'orientation !== "horizontal"',
                      },
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      providers: [{
                              provide: CdkScrollable,
                              useExisting: CdkVirtualScrollViewport,
                          }]
                  },] },
      ];
      /** @nocollapse */
      CdkVirtualScrollViewport.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.ChangeDetectorRef },
              { type: core.NgZone },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [VIRTUAL_SCROLL_STRATEGY,] }] },
              { type: Directionality, decorators: [{ type: core.Optional }] },
              { type: ScrollDispatcher }
          ];
      };
      CdkVirtualScrollViewport.propDecorators = {
          orientation: [{ type: core.Input }],
          scrolledIndexChange: [{ type: core.Output }],
          _contentWrapper: [{ type: core.ViewChild, args: ['contentWrapper',] }]
      };
      return CdkVirtualScrollViewport;
  }(CdkScrollable));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Helper to extract size from a DOM Node.
   * @param {?} orientation
   * @param {?} node
   * @return {?}
   */
  function getSize(orientation, node) {
      /** @type {?} */
      var el = ( /** @type {?} */(node));
      if (!el.getBoundingClientRect) {
          return 0;
      }
      /** @type {?} */
      var rect = el.getBoundingClientRect();
      return orientation == 'horizontal' ? rect.width : rect.height;
  }
  /**
   * A directive similar to `ngForOf` to be used for rendering data inside a virtual scrolling
   * container.
   * @template T
   */
  var CdkVirtualForOf = /** @class */ (function () {
      function CdkVirtualForOf(_viewContainerRef, _template, _differs, _viewport, ngZone) {
          var _this = this;
          this._viewContainerRef = _viewContainerRef;
          this._template = _template;
          this._differs = _differs;
          this._viewport = _viewport;
          /**
           * Emits when the rendered view of the data changes.
           */
          this.viewChange = new rxjs.Subject();
          /**
           * Subject that emits when a new DataSource instance is given.
           */
          this._dataSourceChanges = new rxjs.Subject();
          /**
           * The size of the cache used to store templates that are not being used for re-use later.
           * Setting the cache size to `0` will disable caching. Defaults to 20 templates.
           */
          this.cdkVirtualForTemplateCacheSize = 20;
          /**
           * Emits whenever the data in the current DataSource changes.
           */
          this.dataStream = this._dataSourceChanges
              .pipe(
          // Start off with null `DataSource`.
          operators.startWith(( /** @type {?} */(null))), 
          // Bundle up the previous and current data sources so we can work with both.
          operators.pairwise(), 
          // Use `_changeDataSource` to disconnect from the previous data source and connect to the
          // new one, passing back a stream of data changes which we run through `switchMap` to give
          // us a data stream that emits the latest data from whatever the current `DataSource` is.
          operators.switchMap(function (_a) {
              var prev = _a[0], cur = _a[1];
              return _this._changeDataSource(prev, cur);
          }), 
          // Replay the last emitted data when someone subscribes.
          operators.shareReplay(1));
          /**
           * The differ used to calculate changes to the data.
           */
          this._differ = null;
          /**
           * The template cache used to hold on ot template instancess that have been stamped out, but don't
           * currently need to be rendered. These instances will be reused in the future rather than
           * stamping out brand new ones.
           */
          this._templateCache = [];
          /**
           * Whether the rendered data should be updated during the next ngDoCheck cycle.
           */
          this._needsUpdate = false;
          this._destroyed = new rxjs.Subject();
          this.dataStream.subscribe(function (data) {
              _this._data = data;
              _this._onRenderedDataChange();
          });
          this._viewport.renderedRangeStream.pipe(operators.takeUntil(this._destroyed)).subscribe(function (range) {
              _this._renderedRange = range;
              ngZone.run(function () { return _this.viewChange.next(_this._renderedRange); });
              _this._onRenderedDataChange();
          });
          this._viewport.attach(this);
      }
      Object.defineProperty(CdkVirtualForOf.prototype, "cdkVirtualForOf", {
          /** The DataSource to display. */
          get: /**
           * The DataSource to display.
           * @return {?}
           */ function () {
              return this._cdkVirtualForOf;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._cdkVirtualForOf = value;
              /** @type {?} */
              var ds = isDataSource(value) ? value :
                  // Slice the value if its an NgIterable to ensure we're working with an array.
                  new ArrayDataSource(value instanceof rxjs.Observable ? value : Array.prototype.slice.call(value || []));
              this._dataSourceChanges.next(ds);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkVirtualForOf.prototype, "cdkVirtualForTrackBy", {
          /**
           * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and
           * the item and produces a value to be used as the item's identity when tracking changes.
           */
          get: /**
           * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and
           * the item and produces a value to be used as the item's identity when tracking changes.
           * @return {?}
           */ function () {
              return this._cdkVirtualForTrackBy;
          },
          set: /**
           * @param {?} fn
           * @return {?}
           */ function (fn) {
              var _this = this;
              this._needsUpdate = true;
              this._cdkVirtualForTrackBy = fn ?
                  function (index, item) { return fn(index + (_this._renderedRange ? _this._renderedRange.start : 0), item); } :
                  undefined;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkVirtualForOf.prototype, "cdkVirtualForTemplate", {
          /** The template used to stamp out new elements. */
          set: /**
           * The template used to stamp out new elements.
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (value) {
                  this._needsUpdate = true;
                  this._template = value;
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Measures the combined size (width for horizontal orientation, height for vertical) of all items
       * in the specified range. Throws an error if the range includes items that are not currently
       * rendered.
       */
      /**
       * Measures the combined size (width for horizontal orientation, height for vertical) of all items
       * in the specified range. Throws an error if the range includes items that are not currently
       * rendered.
       * @param {?} range
       * @param {?} orientation
       * @return {?}
       */
      CdkVirtualForOf.prototype.measureRangeSize = /**
       * Measures the combined size (width for horizontal orientation, height for vertical) of all items
       * in the specified range. Throws an error if the range includes items that are not currently
       * rendered.
       * @param {?} range
       * @param {?} orientation
       * @return {?}
       */
          function (range, orientation) {
              if (range.start >= range.end) {
                  return 0;
              }
              if (range.start < this._renderedRange.start || range.end > this._renderedRange.end) {
                  throw Error("Error: attempted to measure an item that isn't rendered.");
              }
              // The index into the list of rendered views for the first item in the range.
              /** @type {?} */
              var renderedStartIndex = range.start - this._renderedRange.start;
              // The length of the range we're measuring.
              /** @type {?} */
              var rangeLen = range.end - range.start;
              // Loop over all root nodes for all items in the range and sum up their size.
              /** @type {?} */
              var totalSize = 0;
              /** @type {?} */
              var i = rangeLen;
              while (i--) {
                  /** @type {?} */
                  var view = ( /** @type {?} */(this._viewContainerRef.get(i + renderedStartIndex)));
                  /** @type {?} */
                  var j = view ? view.rootNodes.length : 0;
                  while (j--) {
                      totalSize += getSize(orientation, ( /** @type {?} */(view)).rootNodes[j]);
                  }
              }
              return totalSize;
          };
      /**
       * @return {?}
       */
      CdkVirtualForOf.prototype.ngDoCheck = /**
       * @return {?}
       */
          function () {
              if (this._differ && this._needsUpdate) {
                  // TODO(mmalerba): We should differentiate needs update due to scrolling and a new portion of
                  // this list being rendered (can use simpler algorithm) vs needs update due to data actually
                  // changing (need to do this diff).
                  /** @type {?} */
                  var changes = this._differ.diff(this._renderedItems);
                  if (!changes) {
                      this._updateContext();
                  }
                  else {
                      this._applyChanges(changes);
                  }
                  this._needsUpdate = false;
              }
          };
      /**
       * @return {?}
       */
      CdkVirtualForOf.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._viewport.detach();
              this._dataSourceChanges.complete();
              this.viewChange.complete();
              this._destroyed.next();
              this._destroyed.complete();
              for (var _i = 0, _a = this._templateCache; _i < _a.length; _i++) {
                  var view = _a[_i];
                  view.destroy();
              }
          };
      /** React to scroll state changes in the viewport. */
      /**
       * React to scroll state changes in the viewport.
       * @private
       * @return {?}
       */
      CdkVirtualForOf.prototype._onRenderedDataChange = /**
       * React to scroll state changes in the viewport.
       * @private
       * @return {?}
       */
          function () {
              if (!this._renderedRange) {
                  return;
              }
              this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);
              if (!this._differ) {
                  this._differ = this._differs.find(this._renderedItems).create(this.cdkVirtualForTrackBy);
              }
              this._needsUpdate = true;
          };
      /** Swap out one `DataSource` for another. */
      /**
       * Swap out one `DataSource` for another.
       * @private
       * @param {?} oldDs
       * @param {?} newDs
       * @return {?}
       */
      CdkVirtualForOf.prototype._changeDataSource = /**
       * Swap out one `DataSource` for another.
       * @private
       * @param {?} oldDs
       * @param {?} newDs
       * @return {?}
       */
          function (oldDs, newDs) {
              if (oldDs) {
                  oldDs.disconnect(this);
              }
              this._needsUpdate = true;
              return newDs.connect(this);
          };
      /** Update the `CdkVirtualForOfContext` for all views. */
      /**
       * Update the `CdkVirtualForOfContext` for all views.
       * @private
       * @return {?}
       */
      CdkVirtualForOf.prototype._updateContext = /**
       * Update the `CdkVirtualForOfContext` for all views.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var count = this._data.length;
              /** @type {?} */
              var i = this._viewContainerRef.length;
              while (i--) {
                  /** @type {?} */
                  var view = ( /** @type {?} */(this._viewContainerRef.get(i)));
                  view.context.index = this._renderedRange.start + i;
                  view.context.count = count;
                  this._updateComputedContextProperties(view.context);
                  view.detectChanges();
              }
          };
      /** Apply changes to the DOM. */
      /**
       * Apply changes to the DOM.
       * @private
       * @param {?} changes
       * @return {?}
       */
      CdkVirtualForOf.prototype._applyChanges = /**
       * Apply changes to the DOM.
       * @private
       * @param {?} changes
       * @return {?}
       */
          function (changes) {
              var _this = this;
              // Rearrange the views to put them in the right location.
              changes.forEachOperation(function (record, adjustedPreviousIndex, currentIndex) {
                  if (record.previousIndex == null) { // Item added.
                      // Item added.
                      /** @type {?} */
                      var view = _this._getViewForNewItem();
                      _this._viewContainerRef.insert(view, ( /** @type {?} */(currentIndex)));
                      view.context.$implicit = record.item;
                  }
                  else if (currentIndex == null) { // Item removed.
                      _this._cacheView(( /** @type {?} */(_this._viewContainerRef.detach(( /** @type {?} */(adjustedPreviousIndex))))));
                  }
                  else { // Item moved.
                      // Item moved.
                      /** @type {?} */
                      var view = ( /** @type {?} */(_this._viewContainerRef.get(( /** @type {?} */(adjustedPreviousIndex)))));
                      _this._viewContainerRef.move(view, currentIndex);
                      view.context.$implicit = record.item;
                  }
              });
              // Update $implicit for any items that had an identity change.
              changes.forEachIdentityChange(function (record) {
                  /** @type {?} */
                  var view = ( /** @type {?} */(_this._viewContainerRef.get(( /** @type {?} */(record.currentIndex)))));
                  view.context.$implicit = record.item;
              });
              // Update the context variables on all items.
              /** @type {?} */
              var count = this._data.length;
              /** @type {?} */
              var i = this._viewContainerRef.length;
              while (i--) {
                  /** @type {?} */
                  var view = ( /** @type {?} */(this._viewContainerRef.get(i)));
                  view.context.index = this._renderedRange.start + i;
                  view.context.count = count;
                  this._updateComputedContextProperties(view.context);
              }
          };
      /** Cache the given detached view. */
      /**
       * Cache the given detached view.
       * @private
       * @param {?} view
       * @return {?}
       */
      CdkVirtualForOf.prototype._cacheView = /**
       * Cache the given detached view.
       * @private
       * @param {?} view
       * @return {?}
       */
          function (view) {
              if (this._templateCache.length < this.cdkVirtualForTemplateCacheSize) {
                  this._templateCache.push(view);
              }
              else {
                  /** @type {?} */
                  var index = this._viewContainerRef.indexOf(view);
                  // It's very unlikely that the index will ever be -1, but just in case,
                  // destroy the view on its own, otherwise destroy it through the
                  // container to ensure that all the references are removed.
                  if (index === -1) {
                      view.destroy();
                  }
                  else {
                      this._viewContainerRef.remove(index);
                  }
              }
          };
      /** Get a view for a new item, either from the cache or by creating a new one. */
      /**
       * Get a view for a new item, either from the cache or by creating a new one.
       * @private
       * @return {?}
       */
      CdkVirtualForOf.prototype._getViewForNewItem = /**
       * Get a view for a new item, either from the cache or by creating a new one.
       * @private
       * @return {?}
       */
          function () {
              return this._templateCache.pop() || this._viewContainerRef.createEmbeddedView(this._template, {
                  $implicit: ( /** @type {?} */(null)),
                  cdkVirtualForOf: this._cdkVirtualForOf,
                  index: -1,
                  count: -1,
                  first: false,
                  last: false,
                  odd: false,
                  even: false
              });
          };
      /** Update the computed properties on the `CdkVirtualForOfContext`. */
      /**
       * Update the computed properties on the `CdkVirtualForOfContext`.
       * @private
       * @param {?} context
       * @return {?}
       */
      CdkVirtualForOf.prototype._updateComputedContextProperties = /**
       * Update the computed properties on the `CdkVirtualForOfContext`.
       * @private
       * @param {?} context
       * @return {?}
       */
          function (context) {
              context.first = context.index === 0;
              context.last = context.index === context.count - 1;
              context.even = context.index % 2 === 0;
              context.odd = !context.even;
          };
      CdkVirtualForOf.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkVirtualFor][cdkVirtualForOf]',
                  },] },
      ];
      /** @nocollapse */
      CdkVirtualForOf.ctorParameters = function () {
          return [
              { type: core.ViewContainerRef },
              { type: core.TemplateRef },
              { type: core.IterableDiffers },
              { type: CdkVirtualScrollViewport, decorators: [{ type: core.SkipSelf }] },
              { type: core.NgZone }
          ];
      };
      CdkVirtualForOf.propDecorators = {
          cdkVirtualForOf: [{ type: core.Input }],
          cdkVirtualForTrackBy: [{ type: core.Input }],
          cdkVirtualForTemplate: [{ type: core.Input }],
          cdkVirtualForTemplateCacheSize: [{ type: core.Input }]
      };
      return CdkVirtualForOf;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var ScrollingModule = /** @class */ (function () {
      function ScrollingModule() {
      }
      ScrollingModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [BidiModule, PlatformModule],
                      exports: [
                          BidiModule,
                          CdkFixedSizeVirtualScroll,
                          CdkScrollable,
                          CdkVirtualForOf,
                          CdkVirtualScrollViewport,
                      ],
                      declarations: [
                          CdkFixedSizeVirtualScroll,
                          CdkScrollable,
                          CdkVirtualForOf,
                          CdkVirtualScrollViewport,
                      ],
                  },] },
      ];
      return ScrollingModule;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Time in ms to throttle the resize events by default.
   * @type {?}
   */
  var DEFAULT_RESIZE_TIME = 20;
  /**
   * Simple utility for getting the bounds of the browser viewport.
   * \@docs-private
   */
  var ViewportRuler = /** @class */ (function () {
      function ViewportRuler(_platform, ngZone) {
          var _this = this;
          this._platform = _platform;
          ngZone.runOutsideAngular(function () {
              _this._change = _platform.isBrowser ?
                  rxjs.merge(rxjs.fromEvent(window, 'resize'), rxjs.fromEvent(window, 'orientationchange')) :
                  rxjs.of();
              // Note that we need to do the subscription inside `runOutsideAngular`
              // since subscribing is what causes the event listener to be added.
              _this._invalidateCache = _this.change().subscribe(function () { return _this._updateViewportSize(); });
          });
      }
      /**
       * @return {?}
       */
      ViewportRuler.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._invalidateCache.unsubscribe();
          };
      /** Returns the viewport's width and height. */
      /**
       * Returns the viewport's width and height.
       * @return {?}
       */
      ViewportRuler.prototype.getViewportSize = /**
       * Returns the viewport's width and height.
       * @return {?}
       */
          function () {
              if (!this._viewportSize) {
                  this._updateViewportSize();
              }
              /** @type {?} */
              var output = { width: this._viewportSize.width, height: this._viewportSize.height };
              // If we're not on a browser, don't cache the size since it'll be mocked out anyway.
              if (!this._platform.isBrowser) {
                  this._viewportSize = ( /** @type {?} */(null));
              }
              return output;
          };
      /** Gets a ClientRect for the viewport's bounds. */
      /**
       * Gets a ClientRect for the viewport's bounds.
       * @return {?}
       */
      ViewportRuler.prototype.getViewportRect = /**
       * Gets a ClientRect for the viewport's bounds.
       * @return {?}
       */
          function () {
              // Use the document element's bounding rect rather than the window scroll properties
              // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll
              // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different
              // conceptual viewports. Under most circumstances these viewports are equivalent, but they
              // can disagree when the page is pinch-zoomed (on devices that support touch).
              // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4
              // We use the documentElement instead of the body because, by default (without a css reset)
              // browsers typically give the document body an 8px margin, which is not included in
              // getBoundingClientRect().
              /** @type {?} */
              var scrollPosition = this.getViewportScrollPosition();
              var _a = this.getViewportSize(), width = _a.width, height = _a.height;
              return {
                  top: scrollPosition.top,
                  left: scrollPosition.left,
                  bottom: scrollPosition.top + height,
                  right: scrollPosition.left + width,
                  height: height,
                  width: width,
              };
          };
      /** Gets the (top, left) scroll position of the viewport. */
      /**
       * Gets the (top, left) scroll position of the viewport.
       * @return {?}
       */
      ViewportRuler.prototype.getViewportScrollPosition = /**
       * Gets the (top, left) scroll position of the viewport.
       * @return {?}
       */
          function () {
              // While we can get a reference to the fake document
              // during SSR, it doesn't have getBoundingClientRect.
              if (!this._platform.isBrowser) {
                  return { top: 0, left: 0 };
              }
              // The top-left-corner of the viewport is determined by the scroll position of the document
              // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about
              // whether `document.body` or `document.documentElement` is the scrolled element, so reading
              // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of
              // `document.documentElement` works consistently, where the `top` and `left` values will
              // equal negative the scroll position.
              /** @type {?} */
              var documentElement = ( /** @type {?} */(document.documentElement));
              /** @type {?} */
              var documentRect = documentElement.getBoundingClientRect();
              /** @type {?} */
              var top = -documentRect.top || document.body.scrollTop || window.scrollY ||
                  documentElement.scrollTop || 0;
              /** @type {?} */
              var left = -documentRect.left || document.body.scrollLeft || window.scrollX ||
                  documentElement.scrollLeft || 0;
              return { top: top, left: left };
          };
      /**
       * Returns a stream that emits whenever the size of the viewport changes.
       * @param throttleTime Time in milliseconds to throttle the stream.
       */
      /**
       * Returns a stream that emits whenever the size of the viewport changes.
       * @param {?=} throttleTime Time in milliseconds to throttle the stream.
       * @return {?}
       */
      ViewportRuler.prototype.change = /**
       * Returns a stream that emits whenever the size of the viewport changes.
       * @param {?=} throttleTime Time in milliseconds to throttle the stream.
       * @return {?}
       */
          function (throttleTime) {
              if (throttleTime === void 0) {
                  throttleTime = DEFAULT_RESIZE_TIME;
              }
              return throttleTime > 0 ? this._change.pipe(operators.auditTime(throttleTime)) : this._change;
          };
      /** Updates the cached viewport size. */
      /**
       * Updates the cached viewport size.
       * @private
       * @return {?}
       */
      ViewportRuler.prototype._updateViewportSize = /**
       * Updates the cached viewport size.
       * @private
       * @return {?}
       */
          function () {
              this._viewportSize = this._platform.isBrowser ?
                  { width: window.innerWidth, height: window.innerHeight } :
                  { width: 0, height: 0 };
          };
      ViewportRuler.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */
      ViewportRuler.ctorParameters = function () {
          return [
              { type: Platform },
              { type: core.NgZone }
          ];
      };
      /** @nocollapse */ ViewportRuler.ngInjectableDef = core.defineInjectable({ factory: function ViewportRuler_Factory() { return new ViewportRuler(core.inject(Platform), core.inject(core.NgZone)); }, token: ViewportRuler, providedIn: "root" });
      return ViewportRuler;
  }());
  /**
   * \@docs-private \@deprecated \@breaking-change 8.0.0
   * @param {?} parentRuler
   * @param {?} platform
   * @param {?} ngZone
   * @return {?}
   */
  function VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler, platform, ngZone) {
      return parentRuler || new ViewportRuler(platform, ngZone);
  }
  /**
   * \@docs-private \@deprecated \@breaking-change 8.0.0
   * @type {?}
   */
  var VIEWPORT_RULER_PROVIDER = {
      // If there is already a ViewportRuler available, use that. Otherwise, provide a new one.
      provide: ViewportRuler,
      deps: [[new core.Optional(), new core.SkipSelf(), ViewportRuler], Platform, core.NgZone],
      useFactory: VIEWPORT_RULER_PROVIDER_FACTORY
  };

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Throws an exception when attempting to attach a null portal to a host.
   * \@docs-private
   * @return {?}
   */
  function throwNullPortalError() {
      throw Error('Must provide a portal to attach');
  }
  /**
   * Throws an exception when attempting to attach a portal to a host that is already attached.
   * \@docs-private
   * @return {?}
   */
  function throwPortalAlreadyAttachedError() {
      throw Error('Host already has a portal attached');
  }
  /**
   * Throws an exception when attempting to attach a portal to an already-disposed host.
   * \@docs-private
   * @return {?}
   */
  function throwPortalOutletAlreadyDisposedError() {
      throw Error('This PortalOutlet has already been disposed');
  }
  /**
   * Throws an exception when attempting to attach an unknown portal type.
   * \@docs-private
   * @return {?}
   */
  function throwUnknownPortalTypeError() {
      throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +
          'a ComponentPortal or a TemplatePortal.');
  }
  /**
   * Throws an exception when attempting to attach a portal to a null host.
   * \@docs-private
   * @return {?}
   */
  function throwNullPortalOutletError() {
      throw Error('Attempting to attach a portal to a null PortalOutlet');
  }
  /**
   * Throws an exception when attempting to detach a portal that is not attached.
   * \@docs-private
   * @return {?}
   */
  function throwNoPortalAttachedError() {
      throw Error('Attempting to detach a portal that is not attached to a host');
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * A `Portal` is something that you want to render somewhere else.
   * It can be attach to / detached from a `PortalOutlet`.
   * @abstract
   * @template T
   */
  var /**
   * A `Portal` is something that you want to render somewhere else.
   * It can be attach to / detached from a `PortalOutlet`.
   * @abstract
   * @template T
   */ Portal = /** @class */ (function () {
      function Portal() {
      }
      /** Attach this portal to a host. */
      /**
       * Attach this portal to a host.
       * @param {?} host
       * @return {?}
       */
      Portal.prototype.attach = /**
       * Attach this portal to a host.
       * @param {?} host
       * @return {?}
       */
          function (host) {
              if (host == null) {
                  throwNullPortalOutletError();
              }
              if (host.hasAttached()) {
                  throwPortalAlreadyAttachedError();
              }
              this._attachedHost = host;
              return ( /** @type {?} */(host.attach(this)));
          };
      /** Detach this portal from its host */
      /**
       * Detach this portal from its host
       * @return {?}
       */
      Portal.prototype.detach = /**
       * Detach this portal from its host
       * @return {?}
       */
          function () {
              /** @type {?} */
              var host = this._attachedHost;
              if (host == null) {
                  throwNoPortalAttachedError();
              }
              else {
                  this._attachedHost = null;
                  host.detach();
              }
          };
      Object.defineProperty(Portal.prototype, "isAttached", {
          /** Whether this portal is attached to a host. */
          get: /**
           * Whether this portal is attached to a host.
           * @return {?}
           */ function () {
              return this._attachedHost != null;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
       * the PortalOutlet when it is performing an `attach()` or `detach()`.
       */
      /**
       * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
       * the PortalOutlet when it is performing an `attach()` or `detach()`.
       * @param {?} host
       * @return {?}
       */
      Portal.prototype.setAttachedHost = /**
       * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
       * the PortalOutlet when it is performing an `attach()` or `detach()`.
       * @param {?} host
       * @return {?}
       */
          function (host) {
              this._attachedHost = host;
          };
      return Portal;
  }());
  /**
   * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
   * @template T
   */
  var /**
   * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
   * @template T
   */ ComponentPortal = /** @class */ (function (_super) {
      tslib_1.__extends(ComponentPortal, _super);
      function ComponentPortal(component, viewContainerRef, injector, componentFactoryResolver) {
          var _this = _super.call(this) || this;
          _this.component = component;
          _this.viewContainerRef = viewContainerRef;
          _this.injector = injector;
          _this.componentFactoryResolver = componentFactoryResolver;
          return _this;
      }
      return ComponentPortal;
  }(Portal));
  /**
   * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).
   * @template C
   */
  var /**
   * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).
   * @template C
   */ TemplatePortal = /** @class */ (function (_super) {
      tslib_1.__extends(TemplatePortal, _super);
      function TemplatePortal(template, viewContainerRef, context) {
          var _this = _super.call(this) || this;
          _this.templateRef = template;
          _this.viewContainerRef = viewContainerRef;
          _this.context = context;
          return _this;
      }
      Object.defineProperty(TemplatePortal.prototype, "origin", {
          get: /**
           * @return {?}
           */ function () {
              return this.templateRef.elementRef;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Attach the portal to the provided `PortalOutlet`.
       * When a context is provided it will override the `context` property of the `TemplatePortal`
       * instance.
       */
      /**
       * Attach the portal to the provided `PortalOutlet`.
       * When a context is provided it will override the `context` property of the `TemplatePortal`
       * instance.
       * @param {?} host
       * @param {?=} context
       * @return {?}
       */
      TemplatePortal.prototype.attach = /**
       * Attach the portal to the provided `PortalOutlet`.
       * When a context is provided it will override the `context` property of the `TemplatePortal`
       * instance.
       * @param {?} host
       * @param {?=} context
       * @return {?}
       */
          function (host, context) {
              if (context === void 0) {
                  context = this.context;
              }
              this.context = context;
              return _super.prototype.attach.call(this, host);
          };
      /**
       * @return {?}
       */
      TemplatePortal.prototype.detach = /**
       * @return {?}
       */
          function () {
              this.context = undefined;
              return _super.prototype.detach.call(this);
          };
      return TemplatePortal;
  }(Portal));
  /**
   * Partial implementation of PortalOutlet that handles attaching
   * ComponentPortal and TemplatePortal.
   * @abstract
   */
  var /**
   * Partial implementation of PortalOutlet that handles attaching
   * ComponentPortal and TemplatePortal.
   * @abstract
   */ BasePortalOutlet = /** @class */ (function () {
      function BasePortalOutlet() {
          /**
           * Whether this host has already been permanently disposed.
           */
          this._isDisposed = false;
      }
      /** Whether this host has an attached portal. */
      /**
       * Whether this host has an attached portal.
       * @return {?}
       */
      BasePortalOutlet.prototype.hasAttached = /**
       * Whether this host has an attached portal.
       * @return {?}
       */
          function () {
              return !!this._attachedPortal;
          };
      /** Attaches a portal. */
      /**
       * Attaches a portal.
       * @param {?} portal
       * @return {?}
       */
      BasePortalOutlet.prototype.attach = /**
       * Attaches a portal.
       * @param {?} portal
       * @return {?}
       */
          function (portal) {
              if (!portal) {
                  throwNullPortalError();
              }
              if (this.hasAttached()) {
                  throwPortalAlreadyAttachedError();
              }
              if (this._isDisposed) {
                  throwPortalOutletAlreadyDisposedError();
              }
              if (portal instanceof ComponentPortal) {
                  this._attachedPortal = portal;
                  return this.attachComponentPortal(portal);
              }
              else if (portal instanceof TemplatePortal) {
                  this._attachedPortal = portal;
                  return this.attachTemplatePortal(portal);
              }
              throwUnknownPortalTypeError();
          };
      /** Detaches a previously attached portal. */
      /**
       * Detaches a previously attached portal.
       * @return {?}
       */
      BasePortalOutlet.prototype.detach = /**
       * Detaches a previously attached portal.
       * @return {?}
       */
          function () {
              if (this._attachedPortal) {
                  this._attachedPortal.setAttachedHost(null);
                  this._attachedPortal = null;
              }
              this._invokeDisposeFn();
          };
      /** Permanently dispose of this portal host. */
      /**
       * Permanently dispose of this portal host.
       * @return {?}
       */
      BasePortalOutlet.prototype.dispose = /**
       * Permanently dispose of this portal host.
       * @return {?}
       */
          function () {
              if (this.hasAttached()) {
                  this.detach();
              }
              this._invokeDisposeFn();
              this._isDisposed = true;
          };
      /** @docs-private */
      /**
       * \@docs-private
       * @param {?} fn
       * @return {?}
       */
      BasePortalOutlet.prototype.setDisposeFn = /**
       * \@docs-private
       * @param {?} fn
       * @return {?}
       */
          function (fn) {
              this._disposeFn = fn;
          };
      /**
       * @private
       * @return {?}
       */
      BasePortalOutlet.prototype._invokeDisposeFn = /**
       * @private
       * @return {?}
       */
          function () {
              if (this._disposeFn) {
                  this._disposeFn();
                  this._disposeFn = null;
              }
          };
      return BasePortalOutlet;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular
   * application context.
   */
  var /**
   * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular
   * application context.
   */ DomPortalOutlet = /** @class */ (function (_super) {
      tslib_1.__extends(DomPortalOutlet, _super);
      function DomPortalOutlet(outletElement, _componentFactoryResolver, _appRef, _defaultInjector) {
          var _this = _super.call(this) || this;
          _this.outletElement = outletElement;
          _this._componentFactoryResolver = _componentFactoryResolver;
          _this._appRef = _appRef;
          _this._defaultInjector = _defaultInjector;
          return _this;
      }
      /**
       * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
       * @param portal Portal to be attached
       * @returns Reference to the created component.
       */
      /**
       * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
       * @template T
       * @param {?} portal Portal to be attached
       * @return {?} Reference to the created component.
       */
      DomPortalOutlet.prototype.attachComponentPortal = /**
       * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
       * @template T
       * @param {?} portal Portal to be attached
       * @return {?} Reference to the created component.
       */
          function (portal) {
              var _this = this;
              /** @type {?} */
              var resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
              /** @type {?} */
              var componentFactory = resolver.resolveComponentFactory(portal.component);
              /** @type {?} */
              var componentRef;
              // If the portal specifies a ViewContainerRef, we will use that as the attachment point
              // for the component (in terms of Angular's component tree, not rendering).
              // When the ViewContainerRef is missing, we use the factory to create the component directly
              // and then manually attach the view to the application.
              if (portal.viewContainerRef) {
                  componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector);
                  this.setDisposeFn(function () { return componentRef.destroy(); });
              }
              else {
                  componentRef = componentFactory.create(portal.injector || this._defaultInjector);
                  this._appRef.attachView(componentRef.hostView);
                  this.setDisposeFn(function () {
                      _this._appRef.detachView(componentRef.hostView);
                      componentRef.destroy();
                  });
              }
              // At this point the component has been instantiated, so we move it to the location in the DOM
              // where we want it to be rendered.
              this.outletElement.appendChild(this._getComponentRootNode(componentRef));
              return componentRef;
          };
      /**
       * Attaches a template portal to the DOM as an embedded view.
       * @param portal Portal to be attached.
       * @returns Reference to the created embedded view.
       */
      /**
       * Attaches a template portal to the DOM as an embedded view.
       * @template C
       * @param {?} portal Portal to be attached.
       * @return {?} Reference to the created embedded view.
       */
      DomPortalOutlet.prototype.attachTemplatePortal = /**
       * Attaches a template portal to the DOM as an embedded view.
       * @template C
       * @param {?} portal Portal to be attached.
       * @return {?} Reference to the created embedded view.
       */
          function (portal) {
              var _this = this;
              /** @type {?} */
              var viewContainer = portal.viewContainerRef;
              /** @type {?} */
              var viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);
              viewRef.detectChanges();
              // The method `createEmbeddedView` will add the view as a child of the viewContainer.
              // But for the DomPortalOutlet the view can be added everywhere in the DOM
              // (e.g Overlay Container) To move the view to the specified host element. We just
              // re-append the existing root nodes.
              viewRef.rootNodes.forEach(function (rootNode) { return _this.outletElement.appendChild(rootNode); });
              this.setDisposeFn((function () {
                  /** @type {?} */
                  var index = viewContainer.indexOf(viewRef);
                  if (index !== -1) {
                      viewContainer.remove(index);
                  }
              }));
              // TODO(jelbourn): Return locals from view.
              return viewRef;
          };
      /**
       * Clears out a portal from the DOM.
       */
      /**
       * Clears out a portal from the DOM.
       * @return {?}
       */
      DomPortalOutlet.prototype.dispose = /**
       * Clears out a portal from the DOM.
       * @return {?}
       */
          function () {
              _super.prototype.dispose.call(this);
              if (this.outletElement.parentNode != null) {
                  this.outletElement.parentNode.removeChild(this.outletElement);
              }
          };
      /** Gets the root HTMLElement for an instantiated component. */
      /**
       * Gets the root HTMLElement for an instantiated component.
       * @private
       * @param {?} componentRef
       * @return {?}
       */
      DomPortalOutlet.prototype._getComponentRootNode = /**
       * Gets the root HTMLElement for an instantiated component.
       * @private
       * @param {?} componentRef
       * @return {?}
       */
          function (componentRef) {
              return ( /** @type {?} */((( /** @type {?} */(componentRef.hostView))).rootNodes[0]));
          };
      return DomPortalOutlet;
  }(BasePortalOutlet));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,
   * the directive instance itself can be attached to a host, enabling declarative use of portals.
   */
  var CdkPortal = /** @class */ (function (_super) {
      tslib_1.__extends(CdkPortal, _super);
      function CdkPortal(templateRef, viewContainerRef) {
          return _super.call(this, templateRef, viewContainerRef) || this;
      }
      CdkPortal.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdk-portal], [cdkPortal], [portal]',
                      exportAs: 'cdkPortal',
                  },] },
      ];
      /** @nocollapse */
      CdkPortal.ctorParameters = function () {
          return [
              { type: core.TemplateRef },
              { type: core.ViewContainerRef }
          ];
      };
      return CdkPortal;
  }(TemplatePortal));
  /**
   * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be
   * directly attached to it, enabling declarative use.
   *
   * Usage:
   * `<ng-template [cdkPortalOutlet]="greeting"></ng-template>`
   */
  var CdkPortalOutlet = /** @class */ (function (_super) {
      tslib_1.__extends(CdkPortalOutlet, _super);
      function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef) {
          var _this = _super.call(this) || this;
          _this._componentFactoryResolver = _componentFactoryResolver;
          _this._viewContainerRef = _viewContainerRef;
          /**
           * Whether the portal component is initialized.
           */
          _this._isInitialized = false;
          /**
           * Emits when a portal is attached to the outlet.
           */
          _this.attached = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(CdkPortalOutlet.prototype, "portal", {
          /** Portal associated with the Portal outlet. */
          get: /**
           * Portal associated with the Portal outlet.
           * @return {?}
           */ function () {
              return this._attachedPortal;
          },
          set: /**
           * @param {?} portal
           * @return {?}
           */ function (portal) {
              // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have
              // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`
              // and attach a portal programmatically in the parent component. When Angular does the first CD
              // round, it will fire the setter with empty string, causing the user's content to be cleared.
              if (this.hasAttached() && !portal && !this._isInitialized) {
                  return;
              }
              if (this.hasAttached()) {
                  _super.prototype.detach.call(this);
              }
              if (portal) {
                  _super.prototype.attach.call(this, portal);
              }
              this._attachedPortal = portal;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkPortalOutlet.prototype, "attachedRef", {
          /** Component or view reference that is attached to the portal. */
          get: /**
           * Component or view reference that is attached to the portal.
           * @return {?}
           */ function () {
              return this._attachedRef;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      CdkPortalOutlet.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              this._isInitialized = true;
          };
      /**
       * @return {?}
       */
      CdkPortalOutlet.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              _super.prototype.dispose.call(this);
              this._attachedPortal = null;
              this._attachedRef = null;
          };
      /**
       * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
       *
       * @param portal Portal to be attached to the portal outlet.
       * @returns Reference to the created component.
       */
      /**
       * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
       *
       * @template T
       * @param {?} portal Portal to be attached to the portal outlet.
       * @return {?} Reference to the created component.
       */
      CdkPortalOutlet.prototype.attachComponentPortal = /**
       * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
       *
       * @template T
       * @param {?} portal Portal to be attached to the portal outlet.
       * @return {?} Reference to the created component.
       */
          function (portal) {
              portal.setAttachedHost(this);
              // If the portal specifies an origin, use that as the logical location of the component
              // in the application tree. Otherwise use the location of this PortalOutlet.
              /** @type {?} */
              var viewContainerRef = portal.viewContainerRef != null ?
                  portal.viewContainerRef :
                  this._viewContainerRef;
              /** @type {?} */
              var resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
              /** @type {?} */
              var componentFactory = resolver.resolveComponentFactory(portal.component);
              /** @type {?} */
              var ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector);
              _super.prototype.setDisposeFn.call(this, function () { return ref.destroy(); });
              this._attachedPortal = portal;
              this._attachedRef = ref;
              this.attached.emit(ref);
              return ref;
          };
      /**
       * Attach the given TemplatePortal to this PortlHost as an embedded View.
       * @param portal Portal to be attached.
       * @returns Reference to the created embedded view.
       */
      /**
       * Attach the given TemplatePortal to this PortlHost as an embedded View.
       * @template C
       * @param {?} portal Portal to be attached.
       * @return {?} Reference to the created embedded view.
       */
      CdkPortalOutlet.prototype.attachTemplatePortal = /**
       * Attach the given TemplatePortal to this PortlHost as an embedded View.
       * @template C
       * @param {?} portal Portal to be attached.
       * @return {?} Reference to the created embedded view.
       */
          function (portal) {
              var _this = this;
              portal.setAttachedHost(this);
              /** @type {?} */
              var viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);
              _super.prototype.setDisposeFn.call(this, function () { return _this._viewContainerRef.clear(); });
              this._attachedPortal = portal;
              this._attachedRef = viewRef;
              this.attached.emit(viewRef);
              return viewRef;
          };
      CdkPortalOutlet.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkPortalOutlet], [cdkPortalHost], [portalHost]',
                      exportAs: 'cdkPortalOutlet, cdkPortalHost',
                      inputs: ['portal: cdkPortalOutlet']
                  },] },
      ];
      /** @nocollapse */
      CdkPortalOutlet.ctorParameters = function () {
          return [
              { type: core.ComponentFactoryResolver },
              { type: core.ViewContainerRef }
          ];
      };
      CdkPortalOutlet.propDecorators = {
          attached: [{ type: core.Output }]
      };
      return CdkPortalOutlet;
  }(BasePortalOutlet));
  var PortalModule = /** @class */ (function () {
      function PortalModule() {
      }
      PortalModule.decorators = [
          { type: core.NgModule, args: [{
                      exports: [CdkPortal, CdkPortalOutlet],
                      declarations: [CdkPortal, CdkPortalOutlet],
                  },] },
      ];
      return PortalModule;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Custom injector to be used when providing custom
   * injection tokens to components inside a portal.
   * \@docs-private
   */
  var /**
   * Custom injector to be used when providing custom
   * injection tokens to components inside a portal.
   * \@docs-private
   */ PortalInjector = /** @class */ (function () {
      function PortalInjector(_parentInjector, _customTokens) {
          this._parentInjector = _parentInjector;
          this._customTokens = _customTokens;
      }
      /**
       * @param {?} token
       * @param {?=} notFoundValue
       * @return {?}
       */
      PortalInjector.prototype.get = /**
       * @param {?} token
       * @param {?=} notFoundValue
       * @return {?}
       */
          function (token, notFoundValue) {
              /** @type {?} */
              var value = this._customTokens.get(token);
              if (typeof value !== 'undefined') {
                  return value;
              }
              return this._parentInjector.get(token, notFoundValue);
          };
      return PortalInjector;
  }());

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Strategy that will prevent the user from scrolling while the overlay is visible.
   */
  var /**
   * Strategy that will prevent the user from scrolling while the overlay is visible.
   */ BlockScrollStrategy = /** @class */ (function () {
      function BlockScrollStrategy(_viewportRuler, document) {
          this._viewportRuler = _viewportRuler;
          this._previousHTMLStyles = { top: '', left: '' };
          this._isEnabled = false;
          this._document = document;
      }
      /** Attaches this scroll strategy to an overlay. */
      /**
       * Attaches this scroll strategy to an overlay.
       * @return {?}
       */
      BlockScrollStrategy.prototype.attach = /**
       * Attaches this scroll strategy to an overlay.
       * @return {?}
       */
          function () { };
      /** Blocks page-level scroll while the attached overlay is open. */
      /**
       * Blocks page-level scroll while the attached overlay is open.
       * @return {?}
       */
      BlockScrollStrategy.prototype.enable = /**
       * Blocks page-level scroll while the attached overlay is open.
       * @return {?}
       */
          function () {
              if (this._canBeEnabled()) {
                  /** @type {?} */
                  var root = ( /** @type {?} */(this._document.documentElement));
                  this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();
                  // Cache the previous inline styles in case the user had set them.
                  this._previousHTMLStyles.left = root.style.left || '';
                  this._previousHTMLStyles.top = root.style.top || '';
                  // Note: we're using the `html` node, instead of the `body`, because the `body` may
                  // have the user agent margin, whereas the `html` is guaranteed not to have one.
                  root.style.left = coerceCssPixelValue(-this._previousScrollPosition.left);
                  root.style.top = coerceCssPixelValue(-this._previousScrollPosition.top);
                  root.classList.add('cdk-global-scrollblock');
                  this._isEnabled = true;
              }
          };
      /** Unblocks page-level scroll while the attached overlay is open. */
      /**
       * Unblocks page-level scroll while the attached overlay is open.
       * @return {?}
       */
      BlockScrollStrategy.prototype.disable = /**
       * Unblocks page-level scroll while the attached overlay is open.
       * @return {?}
       */
          function () {
              if (this._isEnabled) {
                  /** @type {?} */
                  var html = ( /** @type {?} */(this._document.documentElement));
                  /** @type {?} */
                  var body = ( /** @type {?} */(this._document.body));
                  /** @type {?} */
                  var htmlStyle = ( /** @type {?} */(html.style));
                  /** @type {?} */
                  var bodyStyle = ( /** @type {?} */(body.style));
                  /** @type {?} */
                  var previousHtmlScrollBehavior = htmlStyle.scrollBehavior || '';
                  /** @type {?} */
                  var previousBodyScrollBehavior = bodyStyle.scrollBehavior || '';
                  this._isEnabled = false;
                  htmlStyle.left = this._previousHTMLStyles.left;
                  htmlStyle.top = this._previousHTMLStyles.top;
                  html.classList.remove('cdk-global-scrollblock');
                  // Disable user-defined smooth scrolling temporarily while we restore the scroll position.
                  // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior
                  htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = 'auto';
                  window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);
                  htmlStyle.scrollBehavior = previousHtmlScrollBehavior;
                  bodyStyle.scrollBehavior = previousBodyScrollBehavior;
              }
          };
      /**
       * @private
       * @return {?}
       */
      BlockScrollStrategy.prototype._canBeEnabled = /**
       * @private
       * @return {?}
       */
          function () {
              // Since the scroll strategies can't be singletons, we have to use a global CSS class
              // (`cdk-global-scrollblock`) to make sure that we don't try to disable global
              // scrolling multiple times.
              /** @type {?} */
              var html = ( /** @type {?} */(this._document.documentElement));
              if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {
                  return false;
              }
              /** @type {?} */
              var body = this._document.body;
              /** @type {?} */
              var viewport = this._viewportRuler.getViewportSize();
              return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;
          };
      return BlockScrollStrategy;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.
   * @return {?}
   */
  function getMatScrollStrategyAlreadyAttachedError() {
      return Error("Scroll strategy has already been attached.");
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Strategy that will close the overlay as soon as the user starts scrolling.
   */
  var /**
   * Strategy that will close the overlay as soon as the user starts scrolling.
   */ CloseScrollStrategy = /** @class */ (function () {
      function CloseScrollStrategy(_scrollDispatcher, _ngZone, _viewportRuler, _config) {
          var _this = this;
          this._scrollDispatcher = _scrollDispatcher;
          this._ngZone = _ngZone;
          this._viewportRuler = _viewportRuler;
          this._config = _config;
          this._scrollSubscription = null;
          /**
           * Detaches the overlay ref and disables the scroll strategy.
           */
          this._detach = function () {
              _this.disable();
              if (_this._overlayRef.hasAttached()) {
                  _this._ngZone.run(function () { return _this._overlayRef.detach(); });
              }
          };
      }
      /** Attaches this scroll strategy to an overlay. */
      /**
       * Attaches this scroll strategy to an overlay.
       * @param {?} overlayRef
       * @return {?}
       */
      CloseScrollStrategy.prototype.attach = /**
       * Attaches this scroll strategy to an overlay.
       * @param {?} overlayRef
       * @return {?}
       */
          function (overlayRef) {
              if (this._overlayRef) {
                  throw getMatScrollStrategyAlreadyAttachedError();
              }
              this._overlayRef = overlayRef;
          };
      /** Enables the closing of the attached overlay on scroll. */
      /**
       * Enables the closing of the attached overlay on scroll.
       * @return {?}
       */
      CloseScrollStrategy.prototype.enable = /**
       * Enables the closing of the attached overlay on scroll.
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._scrollSubscription) {
                  return;
              }
              /** @type {?} */
              var stream = this._scrollDispatcher.scrolled(0);
              if (this._config && this._config.threshold && this._config.threshold > 1) {
                  this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;
                  this._scrollSubscription = stream.subscribe(function () {
                      /** @type {?} */
                      var scrollPosition = _this._viewportRuler.getViewportScrollPosition().top;
                      if (Math.abs(scrollPosition - _this._initialScrollPosition) > ( /** @type {?} */(( /** @type {?} */(_this._config)).threshold))) {
                          _this._detach();
                      }
                      else {
                          _this._overlayRef.updatePosition();
                      }
                  });
              }
              else {
                  this._scrollSubscription = stream.subscribe(this._detach);
              }
          };
      /** Disables the closing the attached overlay on scroll. */
      /**
       * Disables the closing the attached overlay on scroll.
       * @return {?}
       */
      CloseScrollStrategy.prototype.disable = /**
       * Disables the closing the attached overlay on scroll.
       * @return {?}
       */
          function () {
              if (this._scrollSubscription) {
                  this._scrollSubscription.unsubscribe();
                  this._scrollSubscription = null;
              }
          };
      return CloseScrollStrategy;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Scroll strategy that doesn't do anything.
   */
  var /**
   * Scroll strategy that doesn't do anything.
   */ NoopScrollStrategy = /** @class */ (function () {
      function NoopScrollStrategy() {
      }
      /** Does nothing, as this scroll strategy is a no-op. */
      /**
       * Does nothing, as this scroll strategy is a no-op.
       * @return {?}
       */
      NoopScrollStrategy.prototype.enable = /**
       * Does nothing, as this scroll strategy is a no-op.
       * @return {?}
       */
          function () { };
      /** Does nothing, as this scroll strategy is a no-op. */
      /**
       * Does nothing, as this scroll strategy is a no-op.
       * @return {?}
       */
      NoopScrollStrategy.prototype.disable = /**
       * Does nothing, as this scroll strategy is a no-op.
       * @return {?}
       */
          function () { };
      /** Does nothing, as this scroll strategy is a no-op. */
      /**
       * Does nothing, as this scroll strategy is a no-op.
       * @return {?}
       */
      NoopScrollStrategy.prototype.attach = /**
       * Does nothing, as this scroll strategy is a no-op.
       * @return {?}
       */
          function () { };
      return NoopScrollStrategy;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // TODO(jelbourn): move this to live with the rest of the scrolling code
  // TODO(jelbourn): someday replace this with IntersectionObservers
  /**
   * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.
   * \@docs-private
   * @param {?} element Dimensions of the element (from getBoundingClientRect)
   * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)
   * @return {?} Whether the element is scrolled out of view
   */
  function isElementScrolledOutsideView(element, scrollContainers) {
      return scrollContainers.some(function (containerBounds) {
          /** @type {?} */
          var outsideAbove = element.bottom < containerBounds.top;
          /** @type {?} */
          var outsideBelow = element.top > containerBounds.bottom;
          /** @type {?} */
          var outsideLeft = element.right < containerBounds.left;
          /** @type {?} */
          var outsideRight = element.left > containerBounds.right;
          return outsideAbove || outsideBelow || outsideLeft || outsideRight;
      });
  }
  /**
   * Gets whether an element is clipped by any of its scrolling containers.
   * \@docs-private
   * @param {?} element Dimensions of the element (from getBoundingClientRect)
   * @param {?} scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)
   * @return {?} Whether the element is clipped
   */
  function isElementClippedByScrolling(element, scrollContainers) {
      return scrollContainers.some(function (scrollContainerRect) {
          /** @type {?} */
          var clippedAbove = element.top < scrollContainerRect.top;
          /** @type {?} */
          var clippedBelow = element.bottom > scrollContainerRect.bottom;
          /** @type {?} */
          var clippedLeft = element.left < scrollContainerRect.left;
          /** @type {?} */
          var clippedRight = element.right > scrollContainerRect.right;
          return clippedAbove || clippedBelow || clippedLeft || clippedRight;
      });
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Strategy that will update the element position as the user is scrolling.
   */
  var /**
   * Strategy that will update the element position as the user is scrolling.
   */ RepositionScrollStrategy = /** @class */ (function () {
      function RepositionScrollStrategy(_scrollDispatcher, _viewportRuler, _ngZone, _config) {
          this._scrollDispatcher = _scrollDispatcher;
          this._viewportRuler = _viewportRuler;
          this._ngZone = _ngZone;
          this._config = _config;
          this._scrollSubscription = null;
      }
      /** Attaches this scroll strategy to an overlay. */
      /**
       * Attaches this scroll strategy to an overlay.
       * @param {?} overlayRef
       * @return {?}
       */
      RepositionScrollStrategy.prototype.attach = /**
       * Attaches this scroll strategy to an overlay.
       * @param {?} overlayRef
       * @return {?}
       */
          function (overlayRef) {
              if (this._overlayRef) {
                  throw getMatScrollStrategyAlreadyAttachedError();
              }
              this._overlayRef = overlayRef;
          };
      /** Enables repositioning of the attached overlay on scroll. */
      /**
       * Enables repositioning of the attached overlay on scroll.
       * @return {?}
       */
      RepositionScrollStrategy.prototype.enable = /**
       * Enables repositioning of the attached overlay on scroll.
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this._scrollSubscription) {
                  /** @type {?} */
                  var throttle = this._config ? this._config.scrollThrottle : 0;
                  this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(function () {
                      _this._overlayRef.updatePosition();
                      // TODO(crisbeto): make `close` on by default once all components can handle it.
                      if (_this._config && _this._config.autoClose) {
                          /** @type {?} */
                          var overlayRect = _this._overlayRef.overlayElement.getBoundingClientRect();
                          var _a = _this._viewportRuler.getViewportSize(), width = _a.width, height = _a.height;
                          // TODO(crisbeto): include all ancestor scroll containers here once
                          // we have a way of exposing the trigger element to the scroll strategy.
                          /** @type {?} */
                          var parentRects = [{ width: width, height: height, bottom: height, right: width, top: 0, left: 0 }];
                          if (isElementScrolledOutsideView(overlayRect, parentRects)) {
                              _this.disable();
                              _this._ngZone.run(function () { return _this._overlayRef.detach(); });
                          }
                      }
                  });
              }
          };
      /** Disables repositioning of the attached overlay on scroll. */
      /**
       * Disables repositioning of the attached overlay on scroll.
       * @return {?}
       */
      RepositionScrollStrategy.prototype.disable = /**
       * Disables repositioning of the attached overlay on scroll.
       * @return {?}
       */
          function () {
              if (this._scrollSubscription) {
                  this._scrollSubscription.unsubscribe();
                  this._scrollSubscription = null;
              }
          };
      return RepositionScrollStrategy;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Options for how an overlay will handle scrolling.
   *
   * Users can provide a custom value for `ScrollStrategyOptions` to replace the default
   * behaviors. This class primarily acts as a factory for ScrollStrategy instances.
   */
  var ScrollStrategyOptions = /** @class */ (function () {
      function ScrollStrategyOptions(_scrollDispatcher, _viewportRuler, _ngZone, document) {
          var _this = this;
          this._scrollDispatcher = _scrollDispatcher;
          this._viewportRuler = _viewportRuler;
          this._ngZone = _ngZone;
          /**
           * Do nothing on scroll.
           */
          this.noop = function () { return new NoopScrollStrategy(); };
          /**
           * Close the overlay as soon as the user scrolls.
           * @param config Configuration to be used inside the scroll strategy.
           */
          this.close = function (config) { return new CloseScrollStrategy(_this._scrollDispatcher, _this._ngZone, _this._viewportRuler, config); };
          /**
           * Block scrolling.
           */
          this.block = function () { return new BlockScrollStrategy(_this._viewportRuler, _this._document); };
          /**
           * Update the overlay's position on scroll.
           * @param config Configuration to be used inside the scroll strategy.
           * Allows debouncing the reposition calls.
           */
          this.reposition = function (config) { return new RepositionScrollStrategy(_this._scrollDispatcher, _this._viewportRuler, _this._ngZone, config); };
          this._document = document;
      }
      ScrollStrategyOptions.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */
      ScrollStrategyOptions.ctorParameters = function () {
          return [
              { type: ScrollDispatcher },
              { type: ViewportRuler },
              { type: core.NgZone },
              { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
          ];
      };
      /** @nocollapse */ ScrollStrategyOptions.ngInjectableDef = core.defineInjectable({ factory: function ScrollStrategyOptions_Factory() { return new ScrollStrategyOptions(core.inject(ScrollDispatcher), core.inject(ViewportRuler), core.inject(core.NgZone), core.inject(common.DOCUMENT)); }, token: ScrollStrategyOptions, providedIn: "root" });
      return ScrollStrategyOptions;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Initial configuration used when creating an overlay.
   */
  var /**
   * Initial configuration used when creating an overlay.
   */ OverlayConfig = /** @class */ (function () {
      function OverlayConfig(config) {
          var _this = this;
          /**
           * Strategy to be used when handling scroll events while the overlay is open.
           */
          this.scrollStrategy = new NoopScrollStrategy();
          /**
           * Custom class to add to the overlay pane.
           */
          this.panelClass = '';
          /**
           * Whether the overlay has a backdrop.
           */
          this.hasBackdrop = false;
          /**
           * Custom class to add to the backdrop
           */
          this.backdropClass = 'cdk-overlay-dark-backdrop';
          /**
           * Whether the overlay should be disposed of when the user goes backwards/forwards in history.
           * Note that this usually doesn't include clicking on links (unless the user is using
           * the `HashLocationStrategy`).
           */
          this.disposeOnNavigation = false;
          if (config) {
              Object.keys(config).forEach(function (k) {
                  /** @type {?} */
                  var key = ( /** @type {?} */(k));
                  if (typeof config[key] !== 'undefined') {
                      _this[key] = config[key];
                  }
              });
          }
      }
      return OverlayConfig;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * The points of the origin element and the overlay element to connect.
   */
  var /**
   * The points of the origin element and the overlay element to connect.
   */ ConnectionPositionPair = /** @class */ (function () {
      function ConnectionPositionPair(origin, overlay, offsetX, offsetY, panelClass) {
          this.offsetX = offsetX;
          this.offsetY = offsetY;
          this.panelClass = panelClass;
          this.originX = origin.originX;
          this.originY = origin.originY;
          this.overlayX = overlay.overlayX;
          this.overlayY = overlay.overlayY;
      }
      return ConnectionPositionPair;
  }());
  /**
   * Set of properties regarding the position of the origin and overlay relative to the viewport
   * with respect to the containing Scrollable elements.
   *
   * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the
   * bounds of any one of the strategy's Scrollable's bounding client rectangle.
   *
   * The overlay and origin are outside view if there is no overlap between their bounding client
   * rectangle and any one of the strategy's Scrollable's bounding client rectangle.
   *
   *       -----------                    -----------
   *       | outside |                    | clipped |
   *       |  view   |              --------------------------
   *       |         |              |     |         |        |
   *       ----------               |     -----------        |
   *  --------------------------    |                        |
   *  |                        |    |      Scrollable        |
   *  |                        |    |                        |
   *  |                        |     --------------------------
   *  |      Scrollable        |
   *  |                        |
   *  --------------------------
   *
   * \@docs-private
   */
  var /**
   * Set of properties regarding the position of the origin and overlay relative to the viewport
   * with respect to the containing Scrollable elements.
   *
   * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the
   * bounds of any one of the strategy's Scrollable's bounding client rectangle.
   *
   * The overlay and origin are outside view if there is no overlap between their bounding client
   * rectangle and any one of the strategy's Scrollable's bounding client rectangle.
   *
   *       -----------                    -----------
   *       | outside |                    | clipped |
   *       |  view   |              --------------------------
   *       |         |              |     |         |        |
   *       ----------               |     -----------        |
   *  --------------------------    |                        |
   *  |                        |    |      Scrollable        |
   *  |                        |    |                        |
   *  |                        |     --------------------------
   *  |      Scrollable        |
   *  |                        |
   *  --------------------------
   *
   * \@docs-private
   */ ScrollingVisibility = /** @class */ (function () {
      function ScrollingVisibility() {
      }
      return ScrollingVisibility;
  }());
  /**
   * The change event emitted by the strategy when a fallback position is used.
   */
  var ConnectedOverlayPositionChange = /** @class */ (function () {
      function ConnectedOverlayPositionChange(connectionPair, scrollableViewProperties) {
          this.connectionPair = connectionPair;
          this.scrollableViewProperties = scrollableViewProperties;
      }
      /** @nocollapse */
      ConnectedOverlayPositionChange.ctorParameters = function () {
          return [
              { type: ConnectionPositionPair },
              { type: ScrollingVisibility, decorators: [{ type: core.Optional }] }
          ];
      };
      return ConnectedOverlayPositionChange;
  }());
  /**
   * Validates whether a vertical position property matches the expected values.
   * \@docs-private
   * @param {?} property Name of the property being validated.
   * @param {?} value Value of the property being validated.
   * @return {?}
   */
  function validateVerticalPosition(property, value) {
      if (value !== 'top' && value !== 'bottom' && value !== 'center') {
          throw Error("ConnectedPosition: Invalid " + property + " \"" + value + "\". " +
              "Expected \"top\", \"bottom\" or \"center\".");
      }
  }
  /**
   * Validates whether a horizontal position property matches the expected values.
   * \@docs-private
   * @param {?} property Name of the property being validated.
   * @param {?} value Value of the property being validated.
   * @return {?}
   */
  function validateHorizontalPosition(property, value) {
      if (value !== 'start' && value !== 'end' && value !== 'center') {
          throw Error("ConnectedPosition: Invalid " + property + " \"" + value + "\". " +
              "Expected \"start\", \"end\" or \"center\".");
      }
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Service for dispatching keyboard events that land on the body to appropriate overlay ref,
   * if any. It maintains a list of attached overlays to determine best suited overlay based
   * on event target and order of overlay opens.
   */
  var OverlayKeyboardDispatcher = /** @class */ (function () {
      function OverlayKeyboardDispatcher(document) {
          var _this = this;
          /**
           * Currently attached overlays in the order they were attached.
           */
          this._attachedOverlays = [];
          /**
           * Keyboard event listener that will be attached to the body.
           */
          this._keydownListener = function (event) {
              /** @type {?} */
              var overlays = _this._attachedOverlays;
              for (var i = overlays.length - 1; i > -1; i--) {
                  // Dispatch the keydown event to the top overlay which has subscribers to its keydown events.
                  // We want to target the most recent overlay, rather than trying to match where the event came
                  // from, because some components might open an overlay, but keep focus on a trigger element
                  // (e.g. for select and autocomplete). We skip overlays without keydown event subscriptions,
                  // because we don't want overlays that don't handle keyboard events to block the ones below
                  // them that do.
                  if (overlays[i]._keydownEventSubscriptions > 0) {
                      overlays[i]._keydownEvents.next(event);
                      break;
                  }
              }
          };
          this._document = document;
      }
      /**
       * @return {?}
       */
      OverlayKeyboardDispatcher.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._detach();
          };
      /** Add a new overlay to the list of attached overlay refs. */
      /**
       * Add a new overlay to the list of attached overlay refs.
       * @param {?} overlayRef
       * @return {?}
       */
      OverlayKeyboardDispatcher.prototype.add = /**
       * Add a new overlay to the list of attached overlay refs.
       * @param {?} overlayRef
       * @return {?}
       */
          function (overlayRef) {
              // Ensure that we don't get the same overlay multiple times.
              this.remove(overlayRef);
              // Lazily start dispatcher once first overlay is added
              if (!this._isAttached) {
                  this._document.body.addEventListener('keydown', this._keydownListener, true);
                  this._isAttached = true;
              }
              this._attachedOverlays.push(overlayRef);
          };
      /** Remove an overlay from the list of attached overlay refs. */
      /**
       * Remove an overlay from the list of attached overlay refs.
       * @param {?} overlayRef
       * @return {?}
       */
      OverlayKeyboardDispatcher.prototype.remove = /**
       * Remove an overlay from the list of attached overlay refs.
       * @param {?} overlayRef
       * @return {?}
       */
          function (overlayRef) {
              /** @type {?} */
              var index = this._attachedOverlays.indexOf(overlayRef);
              if (index > -1) {
                  this._attachedOverlays.splice(index, 1);
              }
              // Remove the global listener once there are no more overlays.
              if (this._attachedOverlays.length === 0) {
                  this._detach();
              }
          };
      /** Detaches the global keyboard event listener. */
      /**
       * Detaches the global keyboard event listener.
       * @private
       * @return {?}
       */
      OverlayKeyboardDispatcher.prototype._detach = /**
       * Detaches the global keyboard event listener.
       * @private
       * @return {?}
       */
          function () {
              if (this._isAttached) {
                  this._document.body.removeEventListener('keydown', this._keydownListener, true);
                  this._isAttached = false;
              }
          };
      OverlayKeyboardDispatcher.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */
      OverlayKeyboardDispatcher.ctorParameters = function () {
          return [
              { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
          ];
      };
      /** @nocollapse */ OverlayKeyboardDispatcher.ngInjectableDef = core.defineInjectable({ factory: function OverlayKeyboardDispatcher_Factory() { return new OverlayKeyboardDispatcher(core.inject(common.DOCUMENT)); }, token: OverlayKeyboardDispatcher, providedIn: "root" });
      return OverlayKeyboardDispatcher;
  }());
  /**
   * \@docs-private \@deprecated \@breaking-change 8.0.0
   * @param {?} dispatcher
   * @param {?} _document
   * @return {?}
   */
  function OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY(dispatcher, _document) {
      return dispatcher || new OverlayKeyboardDispatcher(_document);
  }
  /**
   * \@docs-private \@deprecated \@breaking-change 8.0.0
   * @type {?}
   */
  var OVERLAY_KEYBOARD_DISPATCHER_PROVIDER = {
      // If there is already an OverlayKeyboardDispatcher available, use that.
      // Otherwise, provide a new one.
      provide: OverlayKeyboardDispatcher,
      deps: [
          [new core.Optional(), new core.SkipSelf(), OverlayKeyboardDispatcher],
          ( /** @type {?} */(
          // Coerce to `InjectionToken` so that the `deps` match the "shape"
          // of the type expected by Angular
          common.DOCUMENT))
      ],
      useFactory: OVERLAY_KEYBOARD_DISPATCHER_PROVIDER_FACTORY
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Container inside which all overlays will render.
   */
  var OverlayContainer = /** @class */ (function () {
      function OverlayContainer(_document) {
          this._document = _document;
      }
      /**
       * @return {?}
       */
      OverlayContainer.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              if (this._containerElement && this._containerElement.parentNode) {
                  this._containerElement.parentNode.removeChild(this._containerElement);
              }
          };
      /**
       * This method returns the overlay container element. It will lazily
       * create the element the first time  it is called to facilitate using
       * the container in non-browser environments.
       * @returns the container element
       */
      /**
       * This method returns the overlay container element. It will lazily
       * create the element the first time  it is called to facilitate using
       * the container in non-browser environments.
       * @return {?} the container element
       */
      OverlayContainer.prototype.getContainerElement = /**
       * This method returns the overlay container element. It will lazily
       * create the element the first time  it is called to facilitate using
       * the container in non-browser environments.
       * @return {?} the container element
       */
          function () {
              if (!this._containerElement) {
                  this._createContainer();
              }
              return this._containerElement;
          };
      /**
       * Create the overlay container element, which is simply a div
       * with the 'cdk-overlay-container' class on the document body.
       */
      /**
       * Create the overlay container element, which is simply a div
       * with the 'cdk-overlay-container' class on the document body.
       * @protected
       * @return {?}
       */
      OverlayContainer.prototype._createContainer = /**
       * Create the overlay container element, which is simply a div
       * with the 'cdk-overlay-container' class on the document body.
       * @protected
       * @return {?}
       */
          function () {
              /** @type {?} */
              var container = this._document.createElement('div');
              container.classList.add('cdk-overlay-container');
              this._document.body.appendChild(container);
              this._containerElement = container;
          };
      OverlayContainer.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */
      OverlayContainer.ctorParameters = function () {
          return [
              { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
          ];
      };
      /** @nocollapse */ OverlayContainer.ngInjectableDef = core.defineInjectable({ factory: function OverlayContainer_Factory() { return new OverlayContainer(core.inject(common.DOCUMENT)); }, token: OverlayContainer, providedIn: "root" });
      return OverlayContainer;
  }());
  /**
   * \@docs-private \@deprecated \@breaking-change 8.0.0
   * @param {?} parentContainer
   * @param {?} _document
   * @return {?}
   */
  function OVERLAY_CONTAINER_PROVIDER_FACTORY(parentContainer, _document) {
      return parentContainer || new OverlayContainer(_document);
  }
  /**
   * \@docs-private \@deprecated \@breaking-change 8.0.0
   * @type {?}
   */
  var OVERLAY_CONTAINER_PROVIDER = {
      // If there is already an OverlayContainer available, use that. Otherwise, provide a new one.
      provide: OverlayContainer,
      deps: [
          [new core.Optional(), new core.SkipSelf(), OverlayContainer],
          ( /** @type {?} */(common.DOCUMENT))
      ],
      useFactory: OVERLAY_CONTAINER_PROVIDER_FACTORY
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Reference to an overlay that has been created with the Overlay service.
   * Used to manipulate or dispose of said overlay.
   */
  var /**
   * Reference to an overlay that has been created with the Overlay service.
   * Used to manipulate or dispose of said overlay.
   */ OverlayRef = /** @class */ (function () {
      function OverlayRef(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document, _location) {
          var _this = this;
          this._portalOutlet = _portalOutlet;
          this._host = _host;
          this._pane = _pane;
          this._config = _config;
          this._ngZone = _ngZone;
          this._keyboardDispatcher = _keyboardDispatcher;
          this._document = _document;
          this._location = _location;
          this._backdropElement = null;
          this._backdropClick = new rxjs.Subject();
          this._attachments = new rxjs.Subject();
          this._detachments = new rxjs.Subject();
          this._locationChanges = rxjs.Subscription.EMPTY;
          this._keydownEventsObservable = new rxjs.Observable(function (observer) {
              /** @type {?} */
              var subscription = _this._keydownEvents.subscribe(observer);
              _this._keydownEventSubscriptions++;
              return function () {
                  subscription.unsubscribe();
                  _this._keydownEventSubscriptions--;
              };
          });
          /**
           * Stream of keydown events dispatched to this overlay.
           */
          this._keydownEvents = new rxjs.Subject();
          /**
           * Amount of subscriptions to the keydown events.
           */
          this._keydownEventSubscriptions = 0;
          if (_config.scrollStrategy) {
              _config.scrollStrategy.attach(this);
          }
          this._positionStrategy = _config.positionStrategy;
      }
      Object.defineProperty(OverlayRef.prototype, "overlayElement", {
          /** The overlay's HTML element */
          get: /**
           * The overlay's HTML element
           * @return {?}
           */ function () {
              return this._pane;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(OverlayRef.prototype, "backdropElement", {
          /** The overlay's backdrop HTML element. */
          get: /**
           * The overlay's backdrop HTML element.
           * @return {?}
           */ function () {
              return this._backdropElement;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(OverlayRef.prototype, "hostElement", {
          /**
           * Wrapper around the panel element. Can be used for advanced
           * positioning where a wrapper with specific styling is
           * required around the overlay pane.
           */
          get: /**
           * Wrapper around the panel element. Can be used for advanced
           * positioning where a wrapper with specific styling is
           * required around the overlay pane.
           * @return {?}
           */ function () {
              return this._host;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Attaches content, given via a Portal, to the overlay.
       * If the overlay is configured to have a backdrop, it will be created.
       *
       * @param portal Portal instance to which to attach the overlay.
       * @returns The portal attachment result.
       */
      /**
       * Attaches content, given via a Portal, to the overlay.
       * If the overlay is configured to have a backdrop, it will be created.
       *
       * @param {?} portal Portal instance to which to attach the overlay.
       * @return {?} The portal attachment result.
       */
      OverlayRef.prototype.attach = /**
       * Attaches content, given via a Portal, to the overlay.
       * If the overlay is configured to have a backdrop, it will be created.
       *
       * @param {?} portal Portal instance to which to attach the overlay.
       * @return {?} The portal attachment result.
       */
          function (portal) {
              var _this = this;
              /** @type {?} */
              var attachResult = this._portalOutlet.attach(portal);
              if (this._positionStrategy) {
                  this._positionStrategy.attach(this);
              }
              // Update the pane element with the given configuration.
              if (!this._host.parentElement && this._previousHostParent) {
                  this._previousHostParent.appendChild(this._host);
              }
              this._updateStackingOrder();
              this._updateElementSize();
              this._updateElementDirection();
              if (this._config.scrollStrategy) {
                  this._config.scrollStrategy.enable();
              }
              // Update the position once the zone is stable so that the overlay will be fully rendered
              // before attempting to position it, as the position may depend on the size of the rendered
              // content.
              this._ngZone.onStable
                  .asObservable()
                  .pipe(operators.take(1))
                  .subscribe(function () {
                  // The overlay could've been detached before the zone has stabilized.
                  if (_this.hasAttached()) {
                      _this.updatePosition();
                  }
              });
              // Enable pointer events for the overlay pane element.
              this._togglePointerEvents(true);
              if (this._config.hasBackdrop) {
                  this._attachBackdrop();
              }
              if (this._config.panelClass) {
                  this._toggleClasses(this._pane, this._config.panelClass, true);
              }
              // Only emit the `attachments` event once all other setup is done.
              this._attachments.next();
              // Track this overlay by the keyboard dispatcher
              this._keyboardDispatcher.add(this);
              // @breaking-change 8.0.0 remove the null check for `_location`
              // once the constructor parameter is made required.
              if (this._config.disposeOnNavigation && this._location) {
                  this._locationChanges = this._location.subscribe(function () { return _this.dispose(); });
              }
              return attachResult;
          };
      /**
       * Detaches an overlay from a portal.
       * @returns The portal detachment result.
       */
      /**
       * Detaches an overlay from a portal.
       * @return {?} The portal detachment result.
       */
      OverlayRef.prototype.detach = /**
       * Detaches an overlay from a portal.
       * @return {?} The portal detachment result.
       */
          function () {
              if (!this.hasAttached()) {
                  return;
              }
              this.detachBackdrop();
              // When the overlay is detached, the pane element should disable pointer events.
              // This is necessary because otherwise the pane element will cover the page and disable
              // pointer events therefore. Depends on the position strategy and the applied pane boundaries.
              this._togglePointerEvents(false);
              if (this._positionStrategy && this._positionStrategy.detach) {
                  this._positionStrategy.detach();
              }
              if (this._config.scrollStrategy) {
                  this._config.scrollStrategy.disable();
              }
              /** @type {?} */
              var detachmentResult = this._portalOutlet.detach();
              // Only emit after everything is detached.
              this._detachments.next();
              // Remove this overlay from keyboard dispatcher tracking.
              this._keyboardDispatcher.remove(this);
              // Keeping the host element in DOM the can cause scroll jank, because it still gets
              // rendered, even though it's transparent and unclickable which is why we remove it.
              this._detachContentWhenStable();
              // Stop listening for location changes.
              this._locationChanges.unsubscribe();
              return detachmentResult;
          };
      /** Cleans up the overlay from the DOM. */
      /**
       * Cleans up the overlay from the DOM.
       * @return {?}
       */
      OverlayRef.prototype.dispose = /**
       * Cleans up the overlay from the DOM.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var isAttached = this.hasAttached();
              if (this._positionStrategy) {
                  this._positionStrategy.dispose();
              }
              if (this._config.scrollStrategy) {
                  this._config.scrollStrategy.disable();
              }
              this.detachBackdrop();
              this._locationChanges.unsubscribe();
              this._keyboardDispatcher.remove(this);
              this._portalOutlet.dispose();
              this._attachments.complete();
              this._backdropClick.complete();
              this._keydownEvents.complete();
              if (this._host && this._host.parentNode) {
                  this._host.parentNode.removeChild(this._host);
                  this._host = ( /** @type {?} */(null));
              }
              this._previousHostParent = this._pane = ( /** @type {?} */(null));
              if (isAttached) {
                  this._detachments.next();
              }
              this._detachments.complete();
          };
      /** Whether the overlay has attached content. */
      /**
       * Whether the overlay has attached content.
       * @return {?}
       */
      OverlayRef.prototype.hasAttached = /**
       * Whether the overlay has attached content.
       * @return {?}
       */
          function () {
              return this._portalOutlet.hasAttached();
          };
      /** Gets an observable that emits when the backdrop has been clicked. */
      /**
       * Gets an observable that emits when the backdrop has been clicked.
       * @return {?}
       */
      OverlayRef.prototype.backdropClick = /**
       * Gets an observable that emits when the backdrop has been clicked.
       * @return {?}
       */
          function () {
              return this._backdropClick.asObservable();
          };
      /** Gets an observable that emits when the overlay has been attached. */
      /**
       * Gets an observable that emits when the overlay has been attached.
       * @return {?}
       */
      OverlayRef.prototype.attachments = /**
       * Gets an observable that emits when the overlay has been attached.
       * @return {?}
       */
          function () {
              return this._attachments.asObservable();
          };
      /** Gets an observable that emits when the overlay has been detached. */
      /**
       * Gets an observable that emits when the overlay has been detached.
       * @return {?}
       */
      OverlayRef.prototype.detachments = /**
       * Gets an observable that emits when the overlay has been detached.
       * @return {?}
       */
          function () {
              return this._detachments.asObservable();
          };
      /** Gets an observable of keydown events targeted to this overlay. */
      /**
       * Gets an observable of keydown events targeted to this overlay.
       * @return {?}
       */
      OverlayRef.prototype.keydownEvents = /**
       * Gets an observable of keydown events targeted to this overlay.
       * @return {?}
       */
          function () {
              return this._keydownEventsObservable;
          };
      /** Gets the current overlay configuration, which is immutable. */
      /**
       * Gets the current overlay configuration, which is immutable.
       * @return {?}
       */
      OverlayRef.prototype.getConfig = /**
       * Gets the current overlay configuration, which is immutable.
       * @return {?}
       */
          function () {
              return this._config;
          };
      /** Updates the position of the overlay based on the position strategy. */
      /**
       * Updates the position of the overlay based on the position strategy.
       * @return {?}
       */
      OverlayRef.prototype.updatePosition = /**
       * Updates the position of the overlay based on the position strategy.
       * @return {?}
       */
          function () {
              if (this._positionStrategy) {
                  this._positionStrategy.apply();
              }
          };
      /** Switches to a new position strategy and updates the overlay position. */
      /**
       * Switches to a new position strategy and updates the overlay position.
       * @param {?} strategy
       * @return {?}
       */
      OverlayRef.prototype.updatePositionStrategy = /**
       * Switches to a new position strategy and updates the overlay position.
       * @param {?} strategy
       * @return {?}
       */
          function (strategy) {
              if (strategy === this._positionStrategy) {
                  return;
              }
              if (this._positionStrategy) {
                  this._positionStrategy.dispose();
              }
              this._positionStrategy = strategy;
              if (this.hasAttached()) {
                  strategy.attach(this);
                  this.updatePosition();
              }
          };
      /** Update the size properties of the overlay. */
      /**
       * Update the size properties of the overlay.
       * @param {?} sizeConfig
       * @return {?}
       */
      OverlayRef.prototype.updateSize = /**
       * Update the size properties of the overlay.
       * @param {?} sizeConfig
       * @return {?}
       */
          function (sizeConfig) {
              this._config = tslib_1.__assign({}, this._config, sizeConfig);
              this._updateElementSize();
          };
      /** Sets the LTR/RTL direction for the overlay. */
      /**
       * Sets the LTR/RTL direction for the overlay.
       * @param {?} dir
       * @return {?}
       */
      OverlayRef.prototype.setDirection = /**
       * Sets the LTR/RTL direction for the overlay.
       * @param {?} dir
       * @return {?}
       */
          function (dir) {
              this._config = tslib_1.__assign({}, this._config, { direction: dir });
              this._updateElementDirection();
          };
      /** Add a CSS class or an array of classes to the overlay pane. */
      /**
       * Add a CSS class or an array of classes to the overlay pane.
       * @param {?} classes
       * @return {?}
       */
      OverlayRef.prototype.addPanelClass = /**
       * Add a CSS class or an array of classes to the overlay pane.
       * @param {?} classes
       * @return {?}
       */
          function (classes) {
              if (this._pane) {
                  this._toggleClasses(this._pane, classes, true);
              }
          };
      /** Remove a CSS class or an array of classes from the overlay pane. */
      /**
       * Remove a CSS class or an array of classes from the overlay pane.
       * @param {?} classes
       * @return {?}
       */
      OverlayRef.prototype.removePanelClass = /**
       * Remove a CSS class or an array of classes from the overlay pane.
       * @param {?} classes
       * @return {?}
       */
          function (classes) {
              if (this._pane) {
                  this._toggleClasses(this._pane, classes, false);
              }
          };
      /**
       * Returns the layout direction of the overlay panel.
       */
      /**
       * Returns the layout direction of the overlay panel.
       * @return {?}
       */
      OverlayRef.prototype.getDirection = /**
       * Returns the layout direction of the overlay panel.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var direction = this._config.direction;
              if (!direction) {
                  return 'ltr';
              }
              return typeof direction === 'string' ? direction : direction.value;
          };
      /** Updates the text direction of the overlay panel. */
      /**
       * Updates the text direction of the overlay panel.
       * @private
       * @return {?}
       */
      OverlayRef.prototype._updateElementDirection = /**
       * Updates the text direction of the overlay panel.
       * @private
       * @return {?}
       */
          function () {
              this._host.setAttribute('dir', this.getDirection());
          };
      /** Updates the size of the overlay element based on the overlay config. */
      /**
       * Updates the size of the overlay element based on the overlay config.
       * @private
       * @return {?}
       */
      OverlayRef.prototype._updateElementSize = /**
       * Updates the size of the overlay element based on the overlay config.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var style = this._pane.style;
              style.width = coerceCssPixelValue(this._config.width);
              style.height = coerceCssPixelValue(this._config.height);
              style.minWidth = coerceCssPixelValue(this._config.minWidth);
              style.minHeight = coerceCssPixelValue(this._config.minHeight);
              style.maxWidth = coerceCssPixelValue(this._config.maxWidth);
              style.maxHeight = coerceCssPixelValue(this._config.maxHeight);
          };
      /** Toggles the pointer events for the overlay pane element. */
      /**
       * Toggles the pointer events for the overlay pane element.
       * @private
       * @param {?} enablePointer
       * @return {?}
       */
      OverlayRef.prototype._togglePointerEvents = /**
       * Toggles the pointer events for the overlay pane element.
       * @private
       * @param {?} enablePointer
       * @return {?}
       */
          function (enablePointer) {
              this._pane.style.pointerEvents = enablePointer ? 'auto' : 'none';
          };
      /** Attaches a backdrop for this overlay. */
      /**
       * Attaches a backdrop for this overlay.
       * @private
       * @return {?}
       */
      OverlayRef.prototype._attachBackdrop = /**
       * Attaches a backdrop for this overlay.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var showingClass = 'cdk-overlay-backdrop-showing';
              this._backdropElement = this._document.createElement('div');
              this._backdropElement.classList.add('cdk-overlay-backdrop');
              if (this._config.backdropClass) {
                  this._toggleClasses(this._backdropElement, this._config.backdropClass, true);
              }
              // Insert the backdrop before the pane in the DOM order,
              // in order to handle stacked overlays properly.
              ( /** @type {?} */(this._host.parentElement)).insertBefore(this._backdropElement, this._host);
              // Forward backdrop clicks such that the consumer of the overlay can perform whatever
              // action desired when such a click occurs (usually closing the overlay).
              this._backdropElement.addEventListener('click', function (event) { return _this._backdropClick.next(event); });
              // Add class to fade-in the backdrop after one frame.
              if (typeof requestAnimationFrame !== 'undefined') {
                  this._ngZone.runOutsideAngular(function () {
                      requestAnimationFrame(function () {
                          if (_this._backdropElement) {
                              _this._backdropElement.classList.add(showingClass);
                          }
                      });
                  });
              }
              else {
                  this._backdropElement.classList.add(showingClass);
              }
          };
      /**
       * Updates the stacking order of the element, moving it to the top if necessary.
       * This is required in cases where one overlay was detached, while another one,
       * that should be behind it, was destroyed. The next time both of them are opened,
       * the stacking will be wrong, because the detached element's pane will still be
       * in its original DOM position.
       */
      /**
       * Updates the stacking order of the element, moving it to the top if necessary.
       * This is required in cases where one overlay was detached, while another one,
       * that should be behind it, was destroyed. The next time both of them are opened,
       * the stacking will be wrong, because the detached element's pane will still be
       * in its original DOM position.
       * @private
       * @return {?}
       */
      OverlayRef.prototype._updateStackingOrder = /**
       * Updates the stacking order of the element, moving it to the top if necessary.
       * This is required in cases where one overlay was detached, while another one,
       * that should be behind it, was destroyed. The next time both of them are opened,
       * the stacking will be wrong, because the detached element's pane will still be
       * in its original DOM position.
       * @private
       * @return {?}
       */
          function () {
              if (this._host.nextSibling) {
                  ( /** @type {?} */(this._host.parentNode)).appendChild(this._host);
              }
          };
      /** Detaches the backdrop (if any) associated with the overlay. */
      /**
       * Detaches the backdrop (if any) associated with the overlay.
       * @return {?}
       */
      OverlayRef.prototype.detachBackdrop = /**
       * Detaches the backdrop (if any) associated with the overlay.
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var backdropToDetach = this._backdropElement;
              if (!backdropToDetach) {
                  return;
              }
              /** @type {?} */
              var timeoutId;
              /** @type {?} */
              var finishDetach = function () {
                  // It may not be attached to anything in certain cases (e.g. unit tests).
                  if (backdropToDetach && backdropToDetach.parentNode) {
                      backdropToDetach.parentNode.removeChild(backdropToDetach);
                  }
                  // It is possible that a new portal has been attached to this overlay since we started
                  // removing the backdrop. If that is the case, only clear the backdrop reference if it
                  // is still the same instance that we started to remove.
                  if (_this._backdropElement == backdropToDetach) {
                      _this._backdropElement = null;
                  }
                  if (_this._config.backdropClass) {
                      _this._toggleClasses(( /** @type {?} */(backdropToDetach)), _this._config.backdropClass, false);
                  }
                  clearTimeout(timeoutId);
              };
              backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');
              this._ngZone.runOutsideAngular(function () {
                  ( /** @type {?} */(backdropToDetach)).addEventListener('transitionend', finishDetach);
              });
              // If the backdrop doesn't have a transition, the `transitionend` event won't fire.
              // In this case we make it unclickable and we try to remove it after a delay.
              backdropToDetach.style.pointerEvents = 'none';
              // Run this outside the Angular zone because there's nothing that Angular cares about.
              // If it were to run inside the Angular zone, every test that used Overlay would have to be
              // either async or fakeAsync.
              timeoutId = this._ngZone.runOutsideAngular(function () { return setTimeout(finishDetach, 500); });
          };
      /** Toggles a single CSS class or an array of classes on an element. */
      /**
       * Toggles a single CSS class or an array of classes on an element.
       * @private
       * @param {?} element
       * @param {?} cssClasses
       * @param {?} isAdd
       * @return {?}
       */
      OverlayRef.prototype._toggleClasses = /**
       * Toggles a single CSS class or an array of classes on an element.
       * @private
       * @param {?} element
       * @param {?} cssClasses
       * @param {?} isAdd
       * @return {?}
       */
          function (element, cssClasses, isAdd) {
              /** @type {?} */
              var classList = element.classList;
              coerceArray(cssClasses).forEach(function (cssClass) {
                  // We can't do a spread here, because IE doesn't support setting multiple classes.
                  isAdd ? classList.add(cssClass) : classList.remove(cssClass);
              });
          };
      /** Detaches the overlay content next time the zone stabilizes. */
      /**
       * Detaches the overlay content next time the zone stabilizes.
       * @private
       * @return {?}
       */
      OverlayRef.prototype._detachContentWhenStable = /**
       * Detaches the overlay content next time the zone stabilizes.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              // Normally we wouldn't have to explicitly run this outside the `NgZone`, however
              // if the consumer is using `zone-patch-rxjs`, the `Subscription.unsubscribe` call will
              // be patched to run inside the zone, which will throw us into an infinite loop.
              this._ngZone.runOutsideAngular(function () {
                  // We can't remove the host here immediately, because the overlay pane's content
                  // might still be animating. This stream helps us avoid interrupting the animation
                  // by waiting for the pane to become empty.
                  /** @type {?} */
                  var subscription = _this._ngZone.onStable
                      .asObservable()
                      .pipe(operators.takeUntil(rxjs.merge(_this._attachments, _this._detachments)))
                      .subscribe(function () {
                      // Needs a couple of checks for the pane and host, because
                      // they may have been removed by the time the zone stabilizes.
                      if (!_this._pane || !_this._host || _this._pane.children.length === 0) {
                          if (_this._pane && _this._config.panelClass) {
                              _this._toggleClasses(_this._pane, _this._config.panelClass, false);
                          }
                          if (_this._host && _this._host.parentElement) {
                              _this._previousHostParent = _this._host.parentElement;
                              _this._previousHostParent.removeChild(_this._host);
                          }
                          subscription.unsubscribe();
                      }
                  });
              });
          };
      return OverlayRef;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // TODO: refactor clipping detection into a separate thing (part of scrolling module)
  // TODO: doesn't handle both flexible width and height when it has to scroll along both axis.
  /**
   * Class to be added to the overlay bounding box.
   * @type {?}
   */
  var boundingBoxClass = 'cdk-overlay-connected-position-bounding-box';
  /**
   * A strategy for positioning overlays. Using this strategy, an overlay is given an
   * implicit position relative some origin element. The relative position is defined in terms of
   * a point on the origin element that is connected to a point on the overlay element. For example,
   * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner
   * of the overlay.
   */
  var /**
   * A strategy for positioning overlays. Using this strategy, an overlay is given an
   * implicit position relative some origin element. The relative position is defined in terms of
   * a point on the origin element that is connected to a point on the overlay element. For example,
   * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner
   * of the overlay.
   */ FlexibleConnectedPositionStrategy = /** @class */ (function () {
      function FlexibleConnectedPositionStrategy(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {
          var _this = this;
          this._viewportRuler = _viewportRuler;
          this._document = _document;
          this._platform = _platform;
          this._overlayContainer = _overlayContainer;
          /**
           * Last size used for the bounding box. Used to avoid resizing the overlay after open.
           */
          this._lastBoundingBoxSize = { width: 0, height: 0 };
          /**
           * Whether the overlay was pushed in a previous positioning.
           */
          this._isPushed = false;
          /**
           * Whether the overlay can be pushed on-screen on the initial open.
           */
          this._canPush = true;
          /**
           * Whether the overlay can grow via flexible width/height after the initial open.
           */
          this._growAfterOpen = false;
          /**
           * Whether the overlay's width and height can be constrained to fit within the viewport.
           */
          this._hasFlexibleDimensions = true;
          /**
           * Whether the overlay position is locked.
           */
          this._positionLocked = false;
          /**
           * Amount of space that must be maintained between the overlay and the edge of the viewport.
           */
          this._viewportMargin = 0;
          /**
           * The Scrollable containers used to check scrollable view properties on position change.
           */
          this.scrollables = [];
          /**
           * Ordered list of preferred positions, from most to least desirable.
           */
          this._preferredPositions = [];
          /**
           * Subject that emits whenever the position changes.
           */
          this._positionChanges = new rxjs.Subject();
          /**
           * Subscription to viewport size changes.
           */
          this._resizeSubscription = rxjs.Subscription.EMPTY;
          /**
           * Default offset for the overlay along the x axis.
           */
          this._offsetX = 0;
          /**
           * Default offset for the overlay along the y axis.
           */
          this._offsetY = 0;
          /**
           * Amount of subscribers to the `positionChanges` stream.
           */
          this._positionChangeSubscriptions = 0;
          /**
           * Keeps track of the CSS classes that the position strategy has applied on the overlay panel.
           */
          this._appliedPanelClasses = [];
          /**
           * Observable sequence of position changes.
           */
          this.positionChanges = new rxjs.Observable(function (observer) {
              /** @type {?} */
              var subscription = _this._positionChanges.subscribe(observer);
              _this._positionChangeSubscriptions++;
              return function () {
                  subscription.unsubscribe();
                  _this._positionChangeSubscriptions--;
              };
          });
          this.setOrigin(connectedTo);
      }
      Object.defineProperty(FlexibleConnectedPositionStrategy.prototype, "positions", {
          /** Ordered list of preferred positions, from most to least desirable. */
          get: /**
           * Ordered list of preferred positions, from most to least desirable.
           * @return {?}
           */ function () {
              return this._preferredPositions;
          },
          enumerable: true,
          configurable: true
      });
      /** Attaches this position strategy to an overlay. */
      /**
       * Attaches this position strategy to an overlay.
       * @param {?} overlayRef
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype.attach = /**
       * Attaches this position strategy to an overlay.
       * @param {?} overlayRef
       * @return {?}
       */
          function (overlayRef) {
              var _this = this;
              if (this._overlayRef && overlayRef !== this._overlayRef) {
                  throw Error('This position strategy is already attached to an overlay');
              }
              this._validatePositions();
              overlayRef.hostElement.classList.add(boundingBoxClass);
              this._overlayRef = overlayRef;
              this._boundingBox = overlayRef.hostElement;
              this._pane = overlayRef.overlayElement;
              this._isDisposed = false;
              this._isInitialRender = true;
              this._lastPosition = null;
              this._resizeSubscription.unsubscribe();
              this._resizeSubscription = this._viewportRuler.change().subscribe(function () {
                  // When the window is resized, we want to trigger the next reposition as if it
                  // was an initial render, in order for the strategy to pick a new optimal position,
                  // otherwise position locking will cause it to stay at the old one.
                  _this._isInitialRender = true;
                  _this.apply();
              });
          };
      /**
       * Updates the position of the overlay element, using whichever preferred position relative
       * to the origin best fits on-screen.
       *
       * The selection of a position goes as follows:
       *  - If any positions fit completely within the viewport as-is,
       *      choose the first position that does so.
       *  - If flexible dimensions are enabled and at least one satifies the given minimum width/height,
       *      choose the position with the greatest available size modified by the positions' weight.
       *  - If pushing is enabled, take the position that went off-screen the least and push it
       *      on-screen.
       *  - If none of the previous criteria were met, use the position that goes off-screen the least.
       * @docs-private
       */
      /**
       * Updates the position of the overlay element, using whichever preferred position relative
       * to the origin best fits on-screen.
       *
       * The selection of a position goes as follows:
       *  - If any positions fit completely within the viewport as-is,
       *      choose the first position that does so.
       *  - If flexible dimensions are enabled and at least one satifies the given minimum width/height,
       *      choose the position with the greatest available size modified by the positions' weight.
       *  - If pushing is enabled, take the position that went off-screen the least and push it
       *      on-screen.
       *  - If none of the previous criteria were met, use the position that goes off-screen the least.
       * \@docs-private
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype.apply = /**
       * Updates the position of the overlay element, using whichever preferred position relative
       * to the origin best fits on-screen.
       *
       * The selection of a position goes as follows:
       *  - If any positions fit completely within the viewport as-is,
       *      choose the first position that does so.
       *  - If flexible dimensions are enabled and at least one satifies the given minimum width/height,
       *      choose the position with the greatest available size modified by the positions' weight.
       *  - If pushing is enabled, take the position that went off-screen the least and push it
       *      on-screen.
       *  - If none of the previous criteria were met, use the position that goes off-screen the least.
       * \@docs-private
       * @return {?}
       */
          function () {
              // We shouldn't do anything if the strategy was disposed or we're on the server.
              // @breaking-change 8.0.0 Remove `_platform` null check once it's guaranteed to be defined.
              if (this._isDisposed || (this._platform && !this._platform.isBrowser)) {
                  return;
              }
              // If the position has been applied already (e.g. when the overlay was opened) and the
              // consumer opted into locking in the position, re-use the old position, in order to
              // prevent the overlay from jumping around.
              if (!this._isInitialRender && this._positionLocked && this._lastPosition) {
                  this.reapplyLastPosition();
                  return;
              }
              this._clearPanelClasses();
              this._resetOverlayElementStyles();
              this._resetBoundingBoxStyles();
              // We need the bounding rects for the origin and the overlay to determine how to position
              // the overlay relative to the origin.
              // We use the viewport rect to determine whether a position would go off-screen.
              this._viewportRect = this._getNarrowedViewportRect();
              this._originRect = this._getOriginRect();
              this._overlayRect = this._pane.getBoundingClientRect();
              /** @type {?} */
              var originRect = this._originRect;
              /** @type {?} */
              var overlayRect = this._overlayRect;
              /** @type {?} */
              var viewportRect = this._viewportRect;
              // Positions where the overlay will fit with flexible dimensions.
              /** @type {?} */
              var flexibleFits = [];
              // Fallback if none of the preferred positions fit within the viewport.
              /** @type {?} */
              var fallback;
              // Go through each of the preferred positions looking for a good fit.
              // If a good fit is found, it will be applied immediately.
              for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {
                  var pos = _a[_i];
                  // Get the exact (x, y) coordinate for the point-of-origin on the origin element.
                  /** @type {?} */
                  var originPoint = this._getOriginPoint(originRect, pos);
                  // From that point-of-origin, get the exact (x, y) coordinate for the top-left corner of the
                  // overlay in this position. We use the top-left corner for calculations and later translate
                  // this into an appropriate (top, left, bottom, right) style.
                  /** @type {?} */
                  var overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);
                  // Calculate how well the overlay would fit into the viewport with this point.
                  /** @type {?} */
                  var overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);
                  // If the overlay, without any further work, fits into the viewport, use this position.
                  if (overlayFit.isCompletelyWithinViewport) {
                      this._isPushed = false;
                      this._applyPosition(pos, originPoint);
                      return;
                  }
                  // If the overlay has flexible dimensions, we can use this position
                  // so long as there's enough space for the minimum dimensions.
                  if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {
                      // Save positions where the overlay will fit with flexible dimensions. We will use these
                      // if none of the positions fit *without* flexible dimensions.
                      flexibleFits.push({
                          position: pos,
                          origin: originPoint,
                          overlayRect: overlayRect,
                          boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)
                      });
                      continue;
                  }
                  // If the current preferred position does not fit on the screen, remember the position
                  // if it has more visible area on-screen than we've seen and move onto the next preferred
                  // position.
                  if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {
                      fallback = { overlayFit: overlayFit, overlayPoint: overlayPoint, originPoint: originPoint, position: pos, overlayRect: overlayRect };
                  }
              }
              // If there are any positions where the overlay would fit with flexible dimensions, choose the
              // one that has the greatest area available modified by the position's weight
              if (flexibleFits.length) {
                  /** @type {?} */
                  var bestFit = null;
                  /** @type {?} */
                  var bestScore = -1;
                  for (var _b = 0, flexibleFits_1 = flexibleFits; _b < flexibleFits_1.length; _b++) {
                      var fit = flexibleFits_1[_b];
                      /** @type {?} */
                      var score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);
                      if (score > bestScore) {
                          bestScore = score;
                          bestFit = fit;
                      }
                  }
                  this._isPushed = false;
                  this._applyPosition(( /** @type {?} */(bestFit)).position, ( /** @type {?} */(bestFit)).origin);
                  return;
              }
              // When none of the preferred positions fit within the viewport, take the position
              // that went off-screen the least and attempt to push it on-screen.
              if (this._canPush) {
                  // TODO(jelbourn): after pushing, the opening "direction" of the overlay might not make sense.
                  this._isPushed = true;
                  this._applyPosition(( /** @type {?} */(fallback)).position, ( /** @type {?} */(fallback)).originPoint);
                  return;
              }
              // All options for getting the overlay within the viewport have been exhausted, so go with the
              // position that went off-screen the least.
              this._applyPosition(( /** @type {?} */(fallback)).position, ( /** @type {?} */(fallback)).originPoint);
          };
      /**
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype.detach = /**
       * @return {?}
       */
          function () {
              this._clearPanelClasses();
              this._lastPosition = null;
              this._previousPushAmount = null;
              this._resizeSubscription.unsubscribe();
          };
      /** Cleanup after the element gets destroyed. */
      /**
       * Cleanup after the element gets destroyed.
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype.dispose = /**
       * Cleanup after the element gets destroyed.
       * @return {?}
       */
          function () {
              if (this._isDisposed) {
                  return;
              }
              // We can't use `_resetBoundingBoxStyles` here, because it resets
              // some properties to zero, rather than removing them.
              if (this._boundingBox) {
                  extendStyles(this._boundingBox.style, ( /** @type {?} */({
                      top: '',
                      left: '',
                      right: '',
                      bottom: '',
                      height: '',
                      width: '',
                      alignItems: '',
                      justifyContent: '',
                  })));
              }
              if (this._pane) {
                  this._resetOverlayElementStyles();
              }
              if (this._overlayRef) {
                  this._overlayRef.hostElement.classList.remove(boundingBoxClass);
              }
              this.detach();
              this._positionChanges.complete();
              this._overlayRef = this._boundingBox = ( /** @type {?} */(null));
              this._isDisposed = true;
          };
      /**
       * This re-aligns the overlay element with the trigger in its last calculated position,
       * even if a position higher in the "preferred positions" list would now fit. This
       * allows one to re-align the panel without changing the orientation of the panel.
       */
      /**
       * This re-aligns the overlay element with the trigger in its last calculated position,
       * even if a position higher in the "preferred positions" list would now fit. This
       * allows one to re-align the panel without changing the orientation of the panel.
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype.reapplyLastPosition = /**
       * This re-aligns the overlay element with the trigger in its last calculated position,
       * even if a position higher in the "preferred positions" list would now fit. This
       * allows one to re-align the panel without changing the orientation of the panel.
       * @return {?}
       */
          function () {
              if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) {
                  this._originRect = this._getOriginRect();
                  this._overlayRect = this._pane.getBoundingClientRect();
                  this._viewportRect = this._getNarrowedViewportRect();
                  /** @type {?} */
                  var lastPosition = this._lastPosition || this._preferredPositions[0];
                  /** @type {?} */
                  var originPoint = this._getOriginPoint(this._originRect, lastPosition);
                  this._applyPosition(lastPosition, originPoint);
              }
          };
      /**
       * Sets the list of Scrollable containers that host the origin element so that
       * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
       * Scrollable must be an ancestor element of the strategy's origin element.
       */
      /**
       * Sets the list of Scrollable containers that host the origin element so that
       * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
       * Scrollable must be an ancestor element of the strategy's origin element.
       * @param {?} scrollables
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype.withScrollableContainers = /**
       * Sets the list of Scrollable containers that host the origin element so that
       * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
       * Scrollable must be an ancestor element of the strategy's origin element.
       * @param {?} scrollables
       * @return {?}
       */
          function (scrollables) {
              this.scrollables = scrollables;
          };
      /**
       * Adds new preferred positions.
       * @param positions List of positions options for this overlay.
       */
      /**
       * Adds new preferred positions.
       * @template THIS
       * @this {THIS}
       * @param {?} positions List of positions options for this overlay.
       * @return {THIS}
       */
      FlexibleConnectedPositionStrategy.prototype.withPositions = /**
       * Adds new preferred positions.
       * @template THIS
       * @this {THIS}
       * @param {?} positions List of positions options for this overlay.
       * @return {THIS}
       */
          function (positions) {
              ( /** @type {?} */(this))._preferredPositions = positions;
              // If the last calculated position object isn't part of the positions anymore, clear
              // it in order to avoid it being picked up if the consumer tries to re-apply.
              if (positions.indexOf(( /** @type {?} */(( /** @type {?} */(this))._lastPosition))) === -1) {
                  ( /** @type {?} */(this))._lastPosition = null;
              }
              ( /** @type {?} */(this))._validatePositions();
              return ( /** @type {?} */(this));
          };
      /**
       * Sets a minimum distance the overlay may be positioned to the edge of the viewport.
       * @param margin Required margin between the overlay and the viewport edge in pixels.
       */
      /**
       * Sets a minimum distance the overlay may be positioned to the edge of the viewport.
       * @template THIS
       * @this {THIS}
       * @param {?} margin Required margin between the overlay and the viewport edge in pixels.
       * @return {THIS}
       */
      FlexibleConnectedPositionStrategy.prototype.withViewportMargin = /**
       * Sets a minimum distance the overlay may be positioned to the edge of the viewport.
       * @template THIS
       * @this {THIS}
       * @param {?} margin Required margin between the overlay and the viewport edge in pixels.
       * @return {THIS}
       */
          function (margin) {
              ( /** @type {?} */(this))._viewportMargin = margin;
              return ( /** @type {?} */(this));
          };
      /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */
      /**
       * Sets whether the overlay's width and height can be constrained to fit within the viewport.
       * @template THIS
       * @this {THIS}
       * @param {?=} flexibleDimensions
       * @return {THIS}
       */
      FlexibleConnectedPositionStrategy.prototype.withFlexibleDimensions = /**
       * Sets whether the overlay's width and height can be constrained to fit within the viewport.
       * @template THIS
       * @this {THIS}
       * @param {?=} flexibleDimensions
       * @return {THIS}
       */
          function (flexibleDimensions) {
              if (flexibleDimensions === void 0) {
                  flexibleDimensions = true;
              }
              ( /** @type {?} */(this))._hasFlexibleDimensions = flexibleDimensions;
              return ( /** @type {?} */(this));
          };
      /** Sets whether the overlay can grow after the initial open via flexible width/height. */
      /**
       * Sets whether the overlay can grow after the initial open via flexible width/height.
       * @template THIS
       * @this {THIS}
       * @param {?=} growAfterOpen
       * @return {THIS}
       */
      FlexibleConnectedPositionStrategy.prototype.withGrowAfterOpen = /**
       * Sets whether the overlay can grow after the initial open via flexible width/height.
       * @template THIS
       * @this {THIS}
       * @param {?=} growAfterOpen
       * @return {THIS}
       */
          function (growAfterOpen) {
              if (growAfterOpen === void 0) {
                  growAfterOpen = true;
              }
              ( /** @type {?} */(this))._growAfterOpen = growAfterOpen;
              return ( /** @type {?} */(this));
          };
      /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */
      /**
       * Sets whether the overlay can be pushed on-screen if none of the provided positions fit.
       * @template THIS
       * @this {THIS}
       * @param {?=} canPush
       * @return {THIS}
       */
      FlexibleConnectedPositionStrategy.prototype.withPush = /**
       * Sets whether the overlay can be pushed on-screen if none of the provided positions fit.
       * @template THIS
       * @this {THIS}
       * @param {?=} canPush
       * @return {THIS}
       */
          function (canPush) {
              if (canPush === void 0) {
                  canPush = true;
              }
              ( /** @type {?} */(this))._canPush = canPush;
              return ( /** @type {?} */(this));
          };
      /**
       * Sets whether the overlay's position should be locked in after it is positioned
       * initially. When an overlay is locked in, it won't attempt to reposition itself
       * when the position is re-applied (e.g. when the user scrolls away).
       * @param isLocked Whether the overlay should locked in.
       */
      /**
       * Sets whether the overlay's position should be locked in after it is positioned
       * initially. When an overlay is locked in, it won't attempt to reposition itself
       * when the position is re-applied (e.g. when the user scrolls away).
       * @template THIS
       * @this {THIS}
       * @param {?=} isLocked Whether the overlay should locked in.
       * @return {THIS}
       */
      FlexibleConnectedPositionStrategy.prototype.withLockedPosition = /**
       * Sets whether the overlay's position should be locked in after it is positioned
       * initially. When an overlay is locked in, it won't attempt to reposition itself
       * when the position is re-applied (e.g. when the user scrolls away).
       * @template THIS
       * @this {THIS}
       * @param {?=} isLocked Whether the overlay should locked in.
       * @return {THIS}
       */
          function (isLocked) {
              if (isLocked === void 0) {
                  isLocked = true;
              }
              ( /** @type {?} */(this))._positionLocked = isLocked;
              return ( /** @type {?} */(this));
          };
      /**
       * Sets the origin, relative to which to position the overlay.
       * Using an element origin is useful for building components that need to be positioned
       * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be
       * used for cases like contextual menus which open relative to the user's pointer.
       * @param origin Reference to the new origin.
       */
      /**
       * Sets the origin, relative to which to position the overlay.
       * Using an element origin is useful for building components that need to be positioned
       * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be
       * used for cases like contextual menus which open relative to the user's pointer.
       * @template THIS
       * @this {THIS}
       * @param {?} origin Reference to the new origin.
       * @return {THIS}
       */
      FlexibleConnectedPositionStrategy.prototype.setOrigin = /**
       * Sets the origin, relative to which to position the overlay.
       * Using an element origin is useful for building components that need to be positioned
       * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be
       * used for cases like contextual menus which open relative to the user's pointer.
       * @template THIS
       * @this {THIS}
       * @param {?} origin Reference to the new origin.
       * @return {THIS}
       */
          function (origin) {
              ( /** @type {?} */(this))._origin = origin;
              return ( /** @type {?} */(this));
          };
      /**
       * Sets the default offset for the overlay's connection point on the x-axis.
       * @param offset New offset in the X axis.
       */
      /**
       * Sets the default offset for the overlay's connection point on the x-axis.
       * @template THIS
       * @this {THIS}
       * @param {?} offset New offset in the X axis.
       * @return {THIS}
       */
      FlexibleConnectedPositionStrategy.prototype.withDefaultOffsetX = /**
       * Sets the default offset for the overlay's connection point on the x-axis.
       * @template THIS
       * @this {THIS}
       * @param {?} offset New offset in the X axis.
       * @return {THIS}
       */
          function (offset) {
              ( /** @type {?} */(this))._offsetX = offset;
              return ( /** @type {?} */(this));
          };
      /**
       * Sets the default offset for the overlay's connection point on the y-axis.
       * @param offset New offset in the Y axis.
       */
      /**
       * Sets the default offset for the overlay's connection point on the y-axis.
       * @template THIS
       * @this {THIS}
       * @param {?} offset New offset in the Y axis.
       * @return {THIS}
       */
      FlexibleConnectedPositionStrategy.prototype.withDefaultOffsetY = /**
       * Sets the default offset for the overlay's connection point on the y-axis.
       * @template THIS
       * @this {THIS}
       * @param {?} offset New offset in the Y axis.
       * @return {THIS}
       */
          function (offset) {
              ( /** @type {?} */(this))._offsetY = offset;
              return ( /** @type {?} */(this));
          };
      /**
       * Configures that the position strategy should set a `transform-origin` on some elements
       * inside the overlay, depending on the current position that is being applied. This is
       * useful for the cases where the origin of an animation can change depending on the
       * alignment of the overlay.
       * @param selector CSS selector that will be used to find the target
       *    elements onto which to set the transform origin.
       */
      /**
       * Configures that the position strategy should set a `transform-origin` on some elements
       * inside the overlay, depending on the current position that is being applied. This is
       * useful for the cases where the origin of an animation can change depending on the
       * alignment of the overlay.
       * @template THIS
       * @this {THIS}
       * @param {?} selector CSS selector that will be used to find the target
       *    elements onto which to set the transform origin.
       * @return {THIS}
       */
      FlexibleConnectedPositionStrategy.prototype.withTransformOriginOn = /**
       * Configures that the position strategy should set a `transform-origin` on some elements
       * inside the overlay, depending on the current position that is being applied. This is
       * useful for the cases where the origin of an animation can change depending on the
       * alignment of the overlay.
       * @template THIS
       * @this {THIS}
       * @param {?} selector CSS selector that will be used to find the target
       *    elements onto which to set the transform origin.
       * @return {THIS}
       */
          function (selector) {
              ( /** @type {?} */(this))._transformOriginSelector = selector;
              return ( /** @type {?} */(this));
          };
      /**
       * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.
       */
      /**
       * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.
       * @private
       * @param {?} originRect
       * @param {?} pos
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._getOriginPoint = /**
       * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.
       * @private
       * @param {?} originRect
       * @param {?} pos
       * @return {?}
       */
          function (originRect, pos) {
              /** @type {?} */
              var x;
              if (pos.originX == 'center') {
                  // Note: when centering we should always use the `left`
                  // offset, otherwise the position will be wrong in RTL.
                  x = originRect.left + (originRect.width / 2);
              }
              else {
                  /** @type {?} */
                  var startX = this._isRtl() ? originRect.right : originRect.left;
                  /** @type {?} */
                  var endX = this._isRtl() ? originRect.left : originRect.right;
                  x = pos.originX == 'start' ? startX : endX;
              }
              /** @type {?} */
              var y;
              if (pos.originY == 'center') {
                  y = originRect.top + (originRect.height / 2);
              }
              else {
                  y = pos.originY == 'top' ? originRect.top : originRect.bottom;
              }
              return { x: x, y: y };
          };
      /**
       * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and
       * origin point to which the overlay should be connected.
       */
      /**
       * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and
       * origin point to which the overlay should be connected.
       * @private
       * @param {?} originPoint
       * @param {?} overlayRect
       * @param {?} pos
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._getOverlayPoint = /**
       * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and
       * origin point to which the overlay should be connected.
       * @private
       * @param {?} originPoint
       * @param {?} overlayRect
       * @param {?} pos
       * @return {?}
       */
          function (originPoint, overlayRect, pos) {
              // Calculate the (overlayStartX, overlayStartY), the start of the
              // potential overlay position relative to the origin point.
              /** @type {?} */
              var overlayStartX;
              if (pos.overlayX == 'center') {
                  overlayStartX = -overlayRect.width / 2;
              }
              else if (pos.overlayX === 'start') {
                  overlayStartX = this._isRtl() ? -overlayRect.width : 0;
              }
              else {
                  overlayStartX = this._isRtl() ? 0 : -overlayRect.width;
              }
              /** @type {?} */
              var overlayStartY;
              if (pos.overlayY == 'center') {
                  overlayStartY = -overlayRect.height / 2;
              }
              else {
                  overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;
              }
              // The (x, y) coordinates of the overlay.
              return {
                  x: originPoint.x + overlayStartX,
                  y: originPoint.y + overlayStartY,
              };
          };
      /** Gets how well an overlay at the given point will fit within the viewport. */
      /**
       * Gets how well an overlay at the given point will fit within the viewport.
       * @private
       * @param {?} point
       * @param {?} overlay
       * @param {?} viewport
       * @param {?} position
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._getOverlayFit = /**
       * Gets how well an overlay at the given point will fit within the viewport.
       * @private
       * @param {?} point
       * @param {?} overlay
       * @param {?} viewport
       * @param {?} position
       * @return {?}
       */
          function (point, overlay, viewport, position) {
              var x = point.x, y = point.y;
              /** @type {?} */
              var offsetX = this._getOffset(position, 'x');
              /** @type {?} */
              var offsetY = this._getOffset(position, 'y');
              // Account for the offsets since they could push the overlay out of the viewport.
              if (offsetX) {
                  x += offsetX;
              }
              if (offsetY) {
                  y += offsetY;
              }
              // How much the overlay would overflow at this position, on each side.
              /** @type {?} */
              var leftOverflow = 0 - x;
              /** @type {?} */
              var rightOverflow = (x + overlay.width) - viewport.width;
              /** @type {?} */
              var topOverflow = 0 - y;
              /** @type {?} */
              var bottomOverflow = (y + overlay.height) - viewport.height;
              // Visible parts of the element on each axis.
              /** @type {?} */
              var visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);
              /** @type {?} */
              var visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);
              /** @type {?} */
              var visibleArea = visibleWidth * visibleHeight;
              return {
                  visibleArea: visibleArea,
                  isCompletelyWithinViewport: (overlay.width * overlay.height) === visibleArea,
                  fitsInViewportVertically: visibleHeight === overlay.height,
                  fitsInViewportHorizontally: visibleWidth == overlay.width,
              };
          };
      /**
       * Whether the overlay can fit within the viewport when it may resize either its width or height.
       * @param fit How well the overlay fits in the viewport at some position.
       * @param point The (x, y) coordinates of the overlat at some position.
       * @param viewport The geometry of the viewport.
       */
      /**
       * Whether the overlay can fit within the viewport when it may resize either its width or height.
       * @private
       * @param {?} fit How well the overlay fits in the viewport at some position.
       * @param {?} point The (x, y) coordinates of the overlat at some position.
       * @param {?} viewport The geometry of the viewport.
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._canFitWithFlexibleDimensions = /**
       * Whether the overlay can fit within the viewport when it may resize either its width or height.
       * @private
       * @param {?} fit How well the overlay fits in the viewport at some position.
       * @param {?} point The (x, y) coordinates of the overlat at some position.
       * @param {?} viewport The geometry of the viewport.
       * @return {?}
       */
          function (fit, point, viewport) {
              if (this._hasFlexibleDimensions) {
                  /** @type {?} */
                  var availableHeight = viewport.bottom - point.y;
                  /** @type {?} */
                  var availableWidth = viewport.right - point.x;
                  /** @type {?} */
                  var minHeight = this._overlayRef.getConfig().minHeight;
                  /** @type {?} */
                  var minWidth = this._overlayRef.getConfig().minWidth;
                  /** @type {?} */
                  var verticalFit = fit.fitsInViewportVertically ||
                      (minHeight != null && minHeight <= availableHeight);
                  /** @type {?} */
                  var horizontalFit = fit.fitsInViewportHorizontally ||
                      (minWidth != null && minWidth <= availableWidth);
                  return verticalFit && horizontalFit;
              }
          };
      /**
       * Gets the point at which the overlay can be "pushed" on-screen. If the overlay is larger than
       * the viewport, the top-left corner will be pushed on-screen (with overflow occuring on the
       * right and bottom).
       *
       * @param start Starting point from which the overlay is pushed.
       * @param overlay Dimensions of the overlay.
       * @param scrollPosition Current viewport scroll position.
       * @returns The point at which to position the overlay after pushing. This is effectively a new
       *     originPoint.
       */
      /**
       * Gets the point at which the overlay can be "pushed" on-screen. If the overlay is larger than
       * the viewport, the top-left corner will be pushed on-screen (with overflow occuring on the
       * right and bottom).
       *
       * @private
       * @param {?} start Starting point from which the overlay is pushed.
       * @param {?} overlay Dimensions of the overlay.
       * @param {?} scrollPosition Current viewport scroll position.
       * @return {?} The point at which to position the overlay after pushing. This is effectively a new
       *     originPoint.
       */
      FlexibleConnectedPositionStrategy.prototype._pushOverlayOnScreen = /**
       * Gets the point at which the overlay can be "pushed" on-screen. If the overlay is larger than
       * the viewport, the top-left corner will be pushed on-screen (with overflow occuring on the
       * right and bottom).
       *
       * @private
       * @param {?} start Starting point from which the overlay is pushed.
       * @param {?} overlay Dimensions of the overlay.
       * @param {?} scrollPosition Current viewport scroll position.
       * @return {?} The point at which to position the overlay after pushing. This is effectively a new
       *     originPoint.
       */
          function (start, overlay, scrollPosition) {
              // If the position is locked and we've pushed the overlay already, reuse the previous push
              // amount, rather than pushing it again. If we were to continue pushing, the element would
              // remain in the viewport, which goes against the expectations when position locking is enabled.
              if (this._previousPushAmount && this._positionLocked) {
                  return {
                      x: start.x + this._previousPushAmount.x,
                      y: start.y + this._previousPushAmount.y
                  };
              }
              /** @type {?} */
              var viewport = this._viewportRect;
              // Determine how much the overlay goes outside the viewport on each
              // side, which we'll use to decide which direction to push it.
              /** @type {?} */
              var overflowRight = Math.max(start.x + overlay.width - viewport.right, 0);
              /** @type {?} */
              var overflowBottom = Math.max(start.y + overlay.height - viewport.bottom, 0);
              /** @type {?} */
              var overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);
              /** @type {?} */
              var overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);
              // Amount by which to push the overlay in each axis such that it remains on-screen.
              /** @type {?} */
              var pushX = 0;
              /** @type {?} */
              var pushY = 0;
              // If the overlay fits completely within the bounds of the viewport, push it from whichever
              // direction is goes off-screen. Otherwise, push the top-left corner such that its in the
              // viewport and allow for the trailing end of the overlay to go out of bounds.
              if (overlay.width <= viewport.width) {
                  pushX = overflowLeft || -overflowRight;
              }
              else {
                  pushX = start.x < this._viewportMargin ? (viewport.left - scrollPosition.left) - start.x : 0;
              }
              if (overlay.height <= viewport.height) {
                  pushY = overflowTop || -overflowBottom;
              }
              else {
                  pushY = start.y < this._viewportMargin ? (viewport.top - scrollPosition.top) - start.y : 0;
              }
              this._previousPushAmount = { x: pushX, y: pushY };
              return {
                  x: start.x + pushX,
                  y: start.y + pushY,
              };
          };
      /**
       * Applies a computed position to the overlay and emits a position change.
       * @param position The position preference
       * @param originPoint The point on the origin element where the overlay is connected.
       */
      /**
       * Applies a computed position to the overlay and emits a position change.
       * @private
       * @param {?} position The position preference
       * @param {?} originPoint The point on the origin element where the overlay is connected.
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._applyPosition = /**
       * Applies a computed position to the overlay and emits a position change.
       * @private
       * @param {?} position The position preference
       * @param {?} originPoint The point on the origin element where the overlay is connected.
       * @return {?}
       */
          function (position, originPoint) {
              this._setTransformOrigin(position);
              this._setOverlayElementStyles(originPoint, position);
              this._setBoundingBoxStyles(originPoint, position);
              if (position.panelClass) {
                  this._addPanelClasses(position.panelClass);
              }
              // Save the last connected position in case the position needs to be re-calculated.
              this._lastPosition = position;
              // Notify that the position has been changed along with its change properties.
              // We only emit if we've got any subscriptions, because the scroll visibility
              // calculcations can be somewhat expensive.
              if (this._positionChangeSubscriptions > 0) {
                  /** @type {?} */
                  var scrollableViewProperties = this._getScrollVisibility();
                  /** @type {?} */
                  var changeEvent = new ConnectedOverlayPositionChange(position, scrollableViewProperties);
                  this._positionChanges.next(changeEvent);
              }
              this._isInitialRender = false;
          };
      /** Sets the transform origin based on the configured selector and the passed-in position.  */
      /**
       * Sets the transform origin based on the configured selector and the passed-in position.
       * @private
       * @param {?} position
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._setTransformOrigin = /**
       * Sets the transform origin based on the configured selector and the passed-in position.
       * @private
       * @param {?} position
       * @return {?}
       */
          function (position) {
              if (!this._transformOriginSelector) {
                  return;
              }
              /** @type {?} */
              var elements = ( /** @type {?} */(this._boundingBox)).querySelectorAll(this._transformOriginSelector);
              /** @type {?} */
              var xOrigin;
              /** @type {?} */
              var yOrigin = position.overlayY;
              if (position.overlayX === 'center') {
                  xOrigin = 'center';
              }
              else if (this._isRtl()) {
                  xOrigin = position.overlayX === 'start' ? 'right' : 'left';
              }
              else {
                  xOrigin = position.overlayX === 'start' ? 'left' : 'right';
              }
              for (var i = 0; i < elements.length; i++) {
                  elements[i].style.transformOrigin = xOrigin + " " + yOrigin;
              }
          };
      /**
       * Gets the position and size of the overlay's sizing container.
       *
       * This method does no measuring and applies no styles so that we can cheaply compute the
       * bounds for all positions and choose the best fit based on these results.
       */
      /**
       * Gets the position and size of the overlay's sizing container.
       *
       * This method does no measuring and applies no styles so that we can cheaply compute the
       * bounds for all positions and choose the best fit based on these results.
       * @private
       * @param {?} origin
       * @param {?} position
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._calculateBoundingBoxRect = /**
       * Gets the position and size of the overlay's sizing container.
       *
       * This method does no measuring and applies no styles so that we can cheaply compute the
       * bounds for all positions and choose the best fit based on these results.
       * @private
       * @param {?} origin
       * @param {?} position
       * @return {?}
       */
          function (origin, position) {
              /** @type {?} */
              var viewport = this._viewportRect;
              /** @type {?} */
              var isRtl = this._isRtl();
              /** @type {?} */
              var height;
              /** @type {?} */
              var top;
              /** @type {?} */
              var bottom;
              if (position.overlayY === 'top') {
                  // Overlay is opening "downward" and thus is bound by the bottom viewport edge.
                  top = origin.y;
                  height = viewport.height - top + this._viewportMargin;
              }
              else if (position.overlayY === 'bottom') {
                  // Overlay is opening "upward" and thus is bound by the top viewport edge. We need to add
                  // the viewport margin back in, because the viewport rect is narrowed down to remove the
                  // margin, whereas the `origin` position is calculated based on its `ClientRect`.
                  bottom = viewport.height - origin.y + this._viewportMargin * 2;
                  height = viewport.height - bottom + this._viewportMargin;
              }
              else {
                  // If neither top nor bottom, it means that the overlay is vertically centered on the
                  // origin point. Note that we want the position relative to the viewport, rather than
                  // the page, which is why we don't use something like `viewport.bottom - origin.y` and
                  // `origin.y - viewport.top`.
                  /** @type {?} */
                  var smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y);
                  /** @type {?} */
                  var previousHeight = this._lastBoundingBoxSize.height;
                  height = smallestDistanceToViewportEdge * 2;
                  top = origin.y - smallestDistanceToViewportEdge;
                  if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {
                      top = origin.y - (previousHeight / 2);
                  }
              }
              // The overlay is opening 'right-ward' (the content flows to the right).
              /** @type {?} */
              var isBoundedByRightViewportEdge = (position.overlayX === 'start' && !isRtl) ||
                  (position.overlayX === 'end' && isRtl);
              // The overlay is opening 'left-ward' (the content flows to the left).
              /** @type {?} */
              var isBoundedByLeftViewportEdge = (position.overlayX === 'end' && !isRtl) ||
                  (position.overlayX === 'start' && isRtl);
              /** @type {?} */
              var width;
              /** @type {?} */
              var left;
              /** @type {?} */
              var right;
              if (isBoundedByLeftViewportEdge) {
                  right = viewport.right - origin.x + this._viewportMargin;
                  width = origin.x - viewport.left;
              }
              else if (isBoundedByRightViewportEdge) {
                  left = origin.x;
                  width = viewport.right - origin.x;
              }
              else {
                  // If neither start nor end, it means that the overlay is horizontally centered on the
                  // origin point. Note that we want the position relative to the viewport, rather than
                  // the page, which is why we don't use something like `viewport.right - origin.x` and
                  // `origin.x - viewport.left`.
                  /** @type {?} */
                  var smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x);
                  /** @type {?} */
                  var previousWidth = this._lastBoundingBoxSize.width;
                  width = smallestDistanceToViewportEdge * 2;
                  left = origin.x - smallestDistanceToViewportEdge;
                  if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {
                      left = origin.x - (previousWidth / 2);
                  }
              }
              return { top: ( /** @type {?} */(top)), left: ( /** @type {?} */(left)), bottom: ( /** @type {?} */(bottom)), right: ( /** @type {?} */(right)), width: width, height: height };
          };
      /**
       * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the
       * origin's connection point and stetches to the bounds of the viewport.
       *
       * @param origin The point on the origin element where the overlay is connected.
       * @param position The position preference
       */
      /**
       * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the
       * origin's connection point and stetches to the bounds of the viewport.
       *
       * @private
       * @param {?} origin The point on the origin element where the overlay is connected.
       * @param {?} position The position preference
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._setBoundingBoxStyles = /**
       * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the
       * origin's connection point and stetches to the bounds of the viewport.
       *
       * @private
       * @param {?} origin The point on the origin element where the overlay is connected.
       * @param {?} position The position preference
       * @return {?}
       */
          function (origin, position) {
              /** @type {?} */
              var boundingBoxRect = this._calculateBoundingBoxRect(origin, position);
              // It's weird if the overlay *grows* while scrolling, so we take the last size into account
              // when applying a new size.
              if (!this._isInitialRender && !this._growAfterOpen) {
                  boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);
                  boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);
              }
              /** @type {?} */
              var styles = ( /** @type {?} */({}));
              if (this._hasExactPosition()) {
                  styles.top = styles.left = '0';
                  styles.bottom = styles.right = '';
                  styles.width = styles.height = '100%';
              }
              else {
                  /** @type {?} */
                  var maxHeight = this._overlayRef.getConfig().maxHeight;
                  /** @type {?} */
                  var maxWidth = this._overlayRef.getConfig().maxWidth;
                  styles.height = coerceCssPixelValue(boundingBoxRect.height);
                  styles.top = coerceCssPixelValue(boundingBoxRect.top);
                  styles.bottom = coerceCssPixelValue(boundingBoxRect.bottom);
                  styles.width = coerceCssPixelValue(boundingBoxRect.width);
                  styles.left = coerceCssPixelValue(boundingBoxRect.left);
                  styles.right = coerceCssPixelValue(boundingBoxRect.right);
                  // Push the pane content towards the proper direction.
                  if (position.overlayX === 'center') {
                      styles.alignItems = 'center';
                  }
                  else {
                      styles.alignItems = position.overlayX === 'end' ? 'flex-end' : 'flex-start';
                  }
                  if (position.overlayY === 'center') {
                      styles.justifyContent = 'center';
                  }
                  else {
                      styles.justifyContent = position.overlayY === 'bottom' ? 'flex-end' : 'flex-start';
                  }
                  if (maxHeight) {
                      styles.maxHeight = coerceCssPixelValue(maxHeight);
                  }
                  if (maxWidth) {
                      styles.maxWidth = coerceCssPixelValue(maxWidth);
                  }
              }
              this._lastBoundingBoxSize = boundingBoxRect;
              extendStyles(( /** @type {?} */(this._boundingBox)).style, styles);
          };
      /** Resets the styles for the bounding box so that a new positioning can be computed. */
      /**
       * Resets the styles for the bounding box so that a new positioning can be computed.
       * @private
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._resetBoundingBoxStyles = /**
       * Resets the styles for the bounding box so that a new positioning can be computed.
       * @private
       * @return {?}
       */
          function () {
              extendStyles(( /** @type {?} */(this._boundingBox)).style, ( /** @type {?} */({
                  top: '0',
                  left: '0',
                  right: '0',
                  bottom: '0',
                  height: '',
                  width: '',
                  alignItems: '',
                  justifyContent: '',
              })));
          };
      /** Resets the styles for the overlay pane so that a new positioning can be computed. */
      /**
       * Resets the styles for the overlay pane so that a new positioning can be computed.
       * @private
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._resetOverlayElementStyles = /**
       * Resets the styles for the overlay pane so that a new positioning can be computed.
       * @private
       * @return {?}
       */
          function () {
              extendStyles(this._pane.style, ( /** @type {?} */({
                  top: '',
                  left: '',
                  bottom: '',
                  right: '',
                  position: '',
                  transform: '',
              })));
          };
      /** Sets positioning styles to the overlay element. */
      /**
       * Sets positioning styles to the overlay element.
       * @private
       * @param {?} originPoint
       * @param {?} position
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._setOverlayElementStyles = /**
       * Sets positioning styles to the overlay element.
       * @private
       * @param {?} originPoint
       * @param {?} position
       * @return {?}
       */
          function (originPoint, position) {
              /** @type {?} */
              var styles = ( /** @type {?} */({}));
              if (this._hasExactPosition()) {
                  /** @type {?} */
                  var scrollPosition = this._viewportRuler.getViewportScrollPosition();
                  extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));
                  extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));
              }
              else {
                  styles.position = 'static';
              }
              // Use a transform to apply the offsets. We do this because the `center` positions rely on
              // being in the normal flex flow and setting a `top` / `left` at all will completely throw
              // off the position. We also can't use margins, because they won't have an effect in some
              // cases where the element doesn't have anything to "push off of". Finally, this works
              // better both with flexible and non-flexible positioning.
              /** @type {?} */
              var transformString = '';
              /** @type {?} */
              var offsetX = this._getOffset(position, 'x');
              /** @type {?} */
              var offsetY = this._getOffset(position, 'y');
              if (offsetX) {
                  transformString += "translateX(" + offsetX + "px) ";
              }
              if (offsetY) {
                  transformString += "translateY(" + offsetY + "px)";
              }
              styles.transform = transformString.trim();
              // If a maxWidth or maxHeight is specified on the overlay, we remove them. We do this because
              // we need these values to both be set to "100%" for the automatic flexible sizing to work.
              // The maxHeight and maxWidth are set on the boundingBox in order to enforce the constraint.
              if (this._hasFlexibleDimensions && this._overlayRef.getConfig().maxHeight) {
                  styles.maxHeight = '';
              }
              if (this._hasFlexibleDimensions && this._overlayRef.getConfig().maxWidth) {
                  styles.maxWidth = '';
              }
              extendStyles(this._pane.style, styles);
          };
      /** Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing. */
      /**
       * Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing.
       * @private
       * @param {?} position
       * @param {?} originPoint
       * @param {?} scrollPosition
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._getExactOverlayY = /**
       * Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing.
       * @private
       * @param {?} position
       * @param {?} originPoint
       * @param {?} scrollPosition
       * @return {?}
       */
          function (position, originPoint, scrollPosition) {
              // Reset any existing styles. This is necessary in case the
              // preferred position has changed since the last `apply`.
              /** @type {?} */
              var styles = ( /** @type {?} */({ top: null, bottom: null }));
              /** @type {?} */
              var overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
              if (this._isPushed) {
                  overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);
              }
              // @breaking-change 8.0.0 Currently the `_overlayContainer` is optional in order to avoid a
              // breaking change. The null check here can be removed once the `_overlayContainer` becomes
              // a required parameter.
              /** @type {?} */
              var virtualKeyboardOffset = this._overlayContainer ?
                  this._overlayContainer.getContainerElement().getBoundingClientRect().top : 0;
              // Normally this would be zero, however when the overlay is attached to an input (e.g. in an
              // autocomplete), mobile browsers will shift everything in order to put the input in the middle
              // of the screen and to make space for the virtual keyboard. We need to account for this offset,
              // otherwise our positioning will be thrown off.
              overlayPoint.y -= virtualKeyboardOffset;
              // We want to set either `top` or `bottom` based on whether the overlay wants to appear
              // above or below the origin and the direction in which the element will expand.
              if (position.overlayY === 'bottom') {
                  // When using `bottom`, we adjust the y position such that it is the distance
                  // from the bottom of the viewport rather than the top.
                  /** @type {?} */
                  var documentHeight = ( /** @type {?} */(this._document.documentElement)).clientHeight;
                  styles.bottom = documentHeight - (overlayPoint.y + this._overlayRect.height) + "px";
              }
              else {
                  styles.top = coerceCssPixelValue(overlayPoint.y);
              }
              return styles;
          };
      /** Gets the exact left/right for the overlay when not using flexible sizing or when pushing. */
      /**
       * Gets the exact left/right for the overlay when not using flexible sizing or when pushing.
       * @private
       * @param {?} position
       * @param {?} originPoint
       * @param {?} scrollPosition
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._getExactOverlayX = /**
       * Gets the exact left/right for the overlay when not using flexible sizing or when pushing.
       * @private
       * @param {?} position
       * @param {?} originPoint
       * @param {?} scrollPosition
       * @return {?}
       */
          function (position, originPoint, scrollPosition) {
              // Reset any existing styles. This is necessary in case the preferred position has
              // changed since the last `apply`.
              /** @type {?} */
              var styles = ( /** @type {?} */({ left: null, right: null }));
              /** @type {?} */
              var overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
              if (this._isPushed) {
                  overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);
              }
              // We want to set either `left` or `right` based on whether the overlay wants to appear "before"
              // or "after" the origin, which determines the direction in which the element will expand.
              // For the horizontal axis, the meaning of "before" and "after" change based on whether the
              // page is in RTL or LTR.
              /** @type {?} */
              var horizontalStyleProperty;
              if (this._isRtl()) {
                  horizontalStyleProperty = position.overlayX === 'end' ? 'left' : 'right';
              }
              else {
                  horizontalStyleProperty = position.overlayX === 'end' ? 'right' : 'left';
              }
              // When we're setting `right`, we adjust the x position such that it is the distance
              // from the right edge of the viewport rather than the left edge.
              if (horizontalStyleProperty === 'right') {
                  /** @type {?} */
                  var documentWidth = ( /** @type {?} */(this._document.documentElement)).clientWidth;
                  styles.right = documentWidth - (overlayPoint.x + this._overlayRect.width) + "px";
              }
              else {
                  styles.left = coerceCssPixelValue(overlayPoint.x);
              }
              return styles;
          };
      /**
       * Gets the view properties of the trigger and overlay, including whether they are clipped
       * or completely outside the view of any of the strategy's scrollables.
       */
      /**
       * Gets the view properties of the trigger and overlay, including whether they are clipped
       * or completely outside the view of any of the strategy's scrollables.
       * @private
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._getScrollVisibility = /**
       * Gets the view properties of the trigger and overlay, including whether they are clipped
       * or completely outside the view of any of the strategy's scrollables.
       * @private
       * @return {?}
       */
          function () {
              // Note: needs fresh rects since the position could've changed.
              /** @type {?} */
              var originBounds = this._getOriginRect();
              /** @type {?} */
              var overlayBounds = this._pane.getBoundingClientRect();
              // TODO(jelbourn): instead of needing all of the client rects for these scrolling containers
              // every time, we should be able to use the scrollTop of the containers if the size of those
              // containers hasn't changed.
              /** @type {?} */
              var scrollContainerBounds = this.scrollables.map(function (scrollable) {
                  return scrollable.getElementRef().nativeElement.getBoundingClientRect();
              });
              return {
                  isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),
                  isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),
                  isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),
                  isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),
              };
          };
      /** Subtracts the amount that an element is overflowing on an axis from it's length. */
      /**
       * Subtracts the amount that an element is overflowing on an axis from it's length.
       * @private
       * @param {?} length
       * @param {...?} overflows
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._subtractOverflows = /**
       * Subtracts the amount that an element is overflowing on an axis from it's length.
       * @private
       * @param {?} length
       * @param {...?} overflows
       * @return {?}
       */
          function (length) {
              var overflows = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                  overflows[_i - 1] = arguments[_i];
              }
              return overflows.reduce(function (currentValue, currentOverflow) {
                  return currentValue - Math.max(currentOverflow, 0);
              }, length);
          };
      /** Narrows the given viewport rect by the current _viewportMargin. */
      /**
       * Narrows the given viewport rect by the current _viewportMargin.
       * @private
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._getNarrowedViewportRect = /**
       * Narrows the given viewport rect by the current _viewportMargin.
       * @private
       * @return {?}
       */
          function () {
              // We recalculate the viewport rect here ourselves, rather than using the ViewportRuler,
              // because we want to use the `clientWidth` and `clientHeight` as the base. The difference
              // being that the client properties don't include the scrollbar, as opposed to `innerWidth`
              // and `innerHeight` that do. This is necessary, because the overlay container uses
              // 100% `width` and `height` which don't include the scrollbar either.
              /** @type {?} */
              var width = ( /** @type {?} */(this._document.documentElement)).clientWidth;
              /** @type {?} */
              var height = ( /** @type {?} */(this._document.documentElement)).clientHeight;
              /** @type {?} */
              var scrollPosition = this._viewportRuler.getViewportScrollPosition();
              return {
                  top: scrollPosition.top + this._viewportMargin,
                  left: scrollPosition.left + this._viewportMargin,
                  right: scrollPosition.left + width - this._viewportMargin,
                  bottom: scrollPosition.top + height - this._viewportMargin,
                  width: width - (2 * this._viewportMargin),
                  height: height - (2 * this._viewportMargin),
              };
          };
      /** Whether the we're dealing with an RTL context */
      /**
       * Whether the we're dealing with an RTL context
       * @private
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._isRtl = /**
       * Whether the we're dealing with an RTL context
       * @private
       * @return {?}
       */
          function () {
              return this._overlayRef.getDirection() === 'rtl';
          };
      /** Determines whether the overlay uses exact or flexible positioning. */
      /**
       * Determines whether the overlay uses exact or flexible positioning.
       * @private
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._hasExactPosition = /**
       * Determines whether the overlay uses exact or flexible positioning.
       * @private
       * @return {?}
       */
          function () {
              return !this._hasFlexibleDimensions || this._isPushed;
          };
      /** Retrieves the offset of a position along the x or y axis. */
      /**
       * Retrieves the offset of a position along the x or y axis.
       * @private
       * @param {?} position
       * @param {?} axis
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._getOffset = /**
       * Retrieves the offset of a position along the x or y axis.
       * @private
       * @param {?} position
       * @param {?} axis
       * @return {?}
       */
          function (position, axis) {
              if (axis === 'x') {
                  // We don't do something like `position['offset' + axis]` in
                  // order to avoid breking minifiers that rename properties.
                  return position.offsetX == null ? this._offsetX : position.offsetX;
              }
              return position.offsetY == null ? this._offsetY : position.offsetY;
          };
      /** Validates that the current position match the expected values. */
      /**
       * Validates that the current position match the expected values.
       * @private
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._validatePositions = /**
       * Validates that the current position match the expected values.
       * @private
       * @return {?}
       */
          function () {
              if (!this._preferredPositions.length) {
                  throw Error('FlexibleConnectedPositionStrategy: At least one position is required.');
              }
              // TODO(crisbeto): remove these once Angular's template type
              // checking is advanced enough to catch these cases.
              this._preferredPositions.forEach(function (pair) {
                  validateHorizontalPosition('originX', pair.originX);
                  validateVerticalPosition('originY', pair.originY);
                  validateHorizontalPosition('overlayX', pair.overlayX);
                  validateVerticalPosition('overlayY', pair.overlayY);
              });
          };
      /** Adds a single CSS class or an array of classes on the overlay panel. */
      /**
       * Adds a single CSS class or an array of classes on the overlay panel.
       * @private
       * @param {?} cssClasses
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._addPanelClasses = /**
       * Adds a single CSS class or an array of classes on the overlay panel.
       * @private
       * @param {?} cssClasses
       * @return {?}
       */
          function (cssClasses) {
              var _this = this;
              if (this._pane) {
                  coerceArray(cssClasses).forEach(function (cssClass) {
                      if (_this._appliedPanelClasses.indexOf(cssClass) === -1) {
                          _this._appliedPanelClasses.push(cssClass);
                          _this._pane.classList.add(cssClass);
                      }
                  });
              }
          };
      /** Clears the classes that the position strategy has applied from the overlay panel. */
      /**
       * Clears the classes that the position strategy has applied from the overlay panel.
       * @private
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._clearPanelClasses = /**
       * Clears the classes that the position strategy has applied from the overlay panel.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._pane) {
                  this._appliedPanelClasses.forEach(function (cssClass) { return _this._pane.classList.remove(cssClass); });
                  this._appliedPanelClasses = [];
              }
          };
      /** Returns the ClientRect of the current origin. */
      /**
       * Returns the ClientRect of the current origin.
       * @private
       * @return {?}
       */
      FlexibleConnectedPositionStrategy.prototype._getOriginRect = /**
       * Returns the ClientRect of the current origin.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var origin = this._origin;
              if (origin instanceof core.ElementRef) {
                  return origin.nativeElement.getBoundingClientRect();
              }
              if (origin instanceof HTMLElement) {
                  return origin.getBoundingClientRect();
              }
              // If the origin is a point, return a client rect as if it was a 0x0 element at the point.
              return {
                  top: origin.y,
                  bottom: origin.y,
                  left: origin.x,
                  right: origin.x,
                  height: 0,
                  width: 0
              };
          };
      return FlexibleConnectedPositionStrategy;
  }());
  /**
   * Shallow-extends a stylesheet object with another stylesheet object.
   * @param {?} dest
   * @param {?} source
   * @return {?}
   */
  function extendStyles(dest, source) {
      for (var key in source) {
          if (source.hasOwnProperty(key)) {
              dest[key] = source[key];
          }
      }
      return dest;
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * A strategy for positioning overlays. Using this strategy, an overlay is given an
   * implicit position relative to some origin element. The relative position is defined in terms of
   * a point on the origin element that is connected to a point on the overlay element. For example,
   * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner
   * of the overlay.
   * @deprecated Use `FlexibleConnectedPositionStrategy` instead.
   * \@breaking-change 8.0.0
   */
  var /**
   * A strategy for positioning overlays. Using this strategy, an overlay is given an
   * implicit position relative to some origin element. The relative position is defined in terms of
   * a point on the origin element that is connected to a point on the overlay element. For example,
   * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner
   * of the overlay.
   * @deprecated Use `FlexibleConnectedPositionStrategy` instead.
   * \@breaking-change 8.0.0
   */ ConnectedPositionStrategy = /** @class */ (function () {
      function ConnectedPositionStrategy(originPos, overlayPos, connectedTo, viewportRuler, document, 
      // @breaking-change 8.0.0 `platform` parameter to be made required.
      platform) {
          /**
           * Ordered list of preferred positions, from most to least desirable.
           */
          this._preferredPositions = [];
          // Since the `ConnectedPositionStrategy` is deprecated and we don't want to maintain
          // the extra logic, we create an instance of the positioning strategy that has some
          // defaults that make it behave as the old position strategy and to which we'll
          // proxy all of the API calls.
          this._positionStrategy =
              new FlexibleConnectedPositionStrategy(connectedTo, viewportRuler, document, platform)
                  .withFlexibleDimensions(false)
                  .withPush(false)
                  .withViewportMargin(0);
          this.withFallbackPosition(originPos, overlayPos);
      }
      Object.defineProperty(ConnectedPositionStrategy.prototype, "_isRtl", {
          /** Whether the we're dealing with an RTL context */
          get: /**
           * Whether the we're dealing with an RTL context
           * @return {?}
           */ function () {
              return this._overlayRef.getDirection() === 'rtl';
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(ConnectedPositionStrategy.prototype, "onPositionChange", {
          /** Emits an event when the connection point changes. */
          get: /**
           * Emits an event when the connection point changes.
           * @return {?}
           */ function () {
              return this._positionStrategy.positionChanges;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(ConnectedPositionStrategy.prototype, "positions", {
          /** Ordered list of preferred positions, from most to least desirable. */
          get: /**
           * Ordered list of preferred positions, from most to least desirable.
           * @return {?}
           */ function () {
              return this._preferredPositions;
          },
          enumerable: true,
          configurable: true
      });
      /** Attach this position strategy to an overlay. */
      /**
       * Attach this position strategy to an overlay.
       * @param {?} overlayRef
       * @return {?}
       */
      ConnectedPositionStrategy.prototype.attach = /**
       * Attach this position strategy to an overlay.
       * @param {?} overlayRef
       * @return {?}
       */
          function (overlayRef) {
              this._overlayRef = overlayRef;
              this._positionStrategy.attach(overlayRef);
              if (this._direction) {
                  overlayRef.setDirection(this._direction);
                  this._direction = null;
              }
          };
      /** Disposes all resources used by the position strategy. */
      /**
       * Disposes all resources used by the position strategy.
       * @return {?}
       */
      ConnectedPositionStrategy.prototype.dispose = /**
       * Disposes all resources used by the position strategy.
       * @return {?}
       */
          function () {
              this._positionStrategy.dispose();
          };
      /** @docs-private */
      /**
       * \@docs-private
       * @return {?}
       */
      ConnectedPositionStrategy.prototype.detach = /**
       * \@docs-private
       * @return {?}
       */
          function () {
              this._positionStrategy.detach();
          };
      /**
       * Updates the position of the overlay element, using whichever preferred position relative
       * to the origin fits on-screen.
       * @docs-private
       */
      /**
       * Updates the position of the overlay element, using whichever preferred position relative
       * to the origin fits on-screen.
       * \@docs-private
       * @return {?}
       */
      ConnectedPositionStrategy.prototype.apply = /**
       * Updates the position of the overlay element, using whichever preferred position relative
       * to the origin fits on-screen.
       * \@docs-private
       * @return {?}
       */
          function () {
              this._positionStrategy.apply();
          };
      /**
       * Re-positions the overlay element with the trigger in its last calculated position,
       * even if a position higher in the "preferred positions" list would now fit. This
       * allows one to re-align the panel without changing the orientation of the panel.
       */
      /**
       * Re-positions the overlay element with the trigger in its last calculated position,
       * even if a position higher in the "preferred positions" list would now fit. This
       * allows one to re-align the panel without changing the orientation of the panel.
       * @return {?}
       */
      ConnectedPositionStrategy.prototype.recalculateLastPosition = /**
       * Re-positions the overlay element with the trigger in its last calculated position,
       * even if a position higher in the "preferred positions" list would now fit. This
       * allows one to re-align the panel without changing the orientation of the panel.
       * @return {?}
       */
          function () {
              this._positionStrategy.reapplyLastPosition();
          };
      /**
       * Sets the list of Scrollable containers that host the origin element so that
       * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
       * Scrollable must be an ancestor element of the strategy's origin element.
       */
      /**
       * Sets the list of Scrollable containers that host the origin element so that
       * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
       * Scrollable must be an ancestor element of the strategy's origin element.
       * @param {?} scrollables
       * @return {?}
       */
      ConnectedPositionStrategy.prototype.withScrollableContainers = /**
       * Sets the list of Scrollable containers that host the origin element so that
       * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
       * Scrollable must be an ancestor element of the strategy's origin element.
       * @param {?} scrollables
       * @return {?}
       */
          function (scrollables) {
              this._positionStrategy.withScrollableContainers(scrollables);
          };
      /**
       * Adds a new preferred fallback position.
       * @param originPos
       * @param overlayPos
       */
      /**
       * Adds a new preferred fallback position.
       * @template THIS
       * @this {THIS}
       * @param {?} originPos
       * @param {?} overlayPos
       * @param {?=} offsetX
       * @param {?=} offsetY
       * @return {THIS}
       */
      ConnectedPositionStrategy.prototype.withFallbackPosition = /**
       * Adds a new preferred fallback position.
       * @template THIS
       * @this {THIS}
       * @param {?} originPos
       * @param {?} overlayPos
       * @param {?=} offsetX
       * @param {?=} offsetY
       * @return {THIS}
       */
          function (originPos, overlayPos, offsetX, offsetY) {
              /** @type {?} */
              var position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);
              ( /** @type {?} */(this))._preferredPositions.push(position);
              ( /** @type {?} */(this))._positionStrategy.withPositions(( /** @type {?} */(this))._preferredPositions);
              return ( /** @type {?} */(this));
          };
      /**
       * Sets the layout direction so the overlay's position can be adjusted to match.
       * @param dir New layout direction.
       */
      /**
       * Sets the layout direction so the overlay's position can be adjusted to match.
       * @template THIS
       * @this {THIS}
       * @param {?} dir New layout direction.
       * @return {THIS}
       */
      ConnectedPositionStrategy.prototype.withDirection = /**
       * Sets the layout direction so the overlay's position can be adjusted to match.
       * @template THIS
       * @this {THIS}
       * @param {?} dir New layout direction.
       * @return {THIS}
       */
          function (dir) {
              // Since the direction might be declared before the strategy is attached,
              // we save the value in a temporary property and we'll transfer it to the
              // overlay ref on attachment.
              if (( /** @type {?} */(this))._overlayRef) {
                  ( /** @type {?} */(this))._overlayRef.setDirection(dir);
              }
              else {
                  ( /** @type {?} */(this))._direction = dir;
              }
              return ( /** @type {?} */(this));
          };
      /**
       * Sets an offset for the overlay's connection point on the x-axis
       * @param offset New offset in the X axis.
       */
      /**
       * Sets an offset for the overlay's connection point on the x-axis
       * @template THIS
       * @this {THIS}
       * @param {?} offset New offset in the X axis.
       * @return {THIS}
       */
      ConnectedPositionStrategy.prototype.withOffsetX = /**
       * Sets an offset for the overlay's connection point on the x-axis
       * @template THIS
       * @this {THIS}
       * @param {?} offset New offset in the X axis.
       * @return {THIS}
       */
          function (offset) {
              ( /** @type {?} */(this))._positionStrategy.withDefaultOffsetX(offset);
              return ( /** @type {?} */(this));
          };
      /**
       * Sets an offset for the overlay's connection point on the y-axis
       * @param  offset New offset in the Y axis.
       */
      /**
       * Sets an offset for the overlay's connection point on the y-axis
       * @template THIS
       * @this {THIS}
       * @param {?} offset New offset in the Y axis.
       * @return {THIS}
       */
      ConnectedPositionStrategy.prototype.withOffsetY = /**
       * Sets an offset for the overlay's connection point on the y-axis
       * @template THIS
       * @this {THIS}
       * @param {?} offset New offset in the Y axis.
       * @return {THIS}
       */
          function (offset) {
              ( /** @type {?} */(this))._positionStrategy.withDefaultOffsetY(offset);
              return ( /** @type {?} */(this));
          };
      /**
       * Sets whether the overlay's position should be locked in after it is positioned
       * initially. When an overlay is locked in, it won't attempt to reposition itself
       * when the position is re-applied (e.g. when the user scrolls away).
       * @param isLocked Whether the overlay should locked in.
       */
      /**
       * Sets whether the overlay's position should be locked in after it is positioned
       * initially. When an overlay is locked in, it won't attempt to reposition itself
       * when the position is re-applied (e.g. when the user scrolls away).
       * @template THIS
       * @this {THIS}
       * @param {?} isLocked Whether the overlay should locked in.
       * @return {THIS}
       */
      ConnectedPositionStrategy.prototype.withLockedPosition = /**
       * Sets whether the overlay's position should be locked in after it is positioned
       * initially. When an overlay is locked in, it won't attempt to reposition itself
       * when the position is re-applied (e.g. when the user scrolls away).
       * @template THIS
       * @this {THIS}
       * @param {?} isLocked Whether the overlay should locked in.
       * @return {THIS}
       */
          function (isLocked) {
              ( /** @type {?} */(this))._positionStrategy.withLockedPosition(isLocked);
              return ( /** @type {?} */(this));
          };
      /**
       * Overwrites the current set of positions with an array of new ones.
       * @param positions Position pairs to be set on the strategy.
       */
      /**
       * Overwrites the current set of positions with an array of new ones.
       * @template THIS
       * @this {THIS}
       * @param {?} positions Position pairs to be set on the strategy.
       * @return {THIS}
       */
      ConnectedPositionStrategy.prototype.withPositions = /**
       * Overwrites the current set of positions with an array of new ones.
       * @template THIS
       * @this {THIS}
       * @param {?} positions Position pairs to be set on the strategy.
       * @return {THIS}
       */
          function (positions) {
              ( /** @type {?} */(this))._preferredPositions = positions.slice();
              ( /** @type {?} */(this))._positionStrategy.withPositions(( /** @type {?} */(this))._preferredPositions);
              return ( /** @type {?} */(this));
          };
      /**
       * Sets the origin element, relative to which to position the overlay.
       * @param origin Reference to the new origin element.
       */
      /**
       * Sets the origin element, relative to which to position the overlay.
       * @template THIS
       * @this {THIS}
       * @param {?} origin Reference to the new origin element.
       * @return {THIS}
       */
      ConnectedPositionStrategy.prototype.setOrigin = /**
       * Sets the origin element, relative to which to position the overlay.
       * @template THIS
       * @this {THIS}
       * @param {?} origin Reference to the new origin element.
       * @return {THIS}
       */
          function (origin) {
              ( /** @type {?} */(this))._positionStrategy.setOrigin(origin);
              return ( /** @type {?} */(this));
          };
      return ConnectedPositionStrategy;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Class to be added to the overlay pane wrapper.
   * @type {?}
   */
  var wrapperClass = 'cdk-global-overlay-wrapper';
  /**
   * A strategy for positioning overlays. Using this strategy, an overlay is given an
   * explicit position relative to the browser's viewport. We use flexbox, instead of
   * transforms, in order to avoid issues with subpixel rendering which can cause the
   * element to become blurry.
   */
  var /**
   * A strategy for positioning overlays. Using this strategy, an overlay is given an
   * explicit position relative to the browser's viewport. We use flexbox, instead of
   * transforms, in order to avoid issues with subpixel rendering which can cause the
   * element to become blurry.
   */ GlobalPositionStrategy = /** @class */ (function () {
      function GlobalPositionStrategy() {
          this._cssPosition = 'static';
          this._topOffset = '';
          this._bottomOffset = '';
          this._leftOffset = '';
          this._rightOffset = '';
          this._alignItems = '';
          this._justifyContent = '';
          this._width = '';
          this._height = '';
      }
      /**
       * @param {?} overlayRef
       * @return {?}
       */
      GlobalPositionStrategy.prototype.attach = /**
       * @param {?} overlayRef
       * @return {?}
       */
          function (overlayRef) {
              /** @type {?} */
              var config = overlayRef.getConfig();
              this._overlayRef = overlayRef;
              if (this._width && !config.width) {
                  overlayRef.updateSize({ width: this._width });
              }
              if (this._height && !config.height) {
                  overlayRef.updateSize({ height: this._height });
              }
              overlayRef.hostElement.classList.add(wrapperClass);
              this._isDisposed = false;
          };
      /**
       * Sets the top position of the overlay. Clears any previously set vertical position.
       * @param value New top offset.
       */
      /**
       * Sets the top position of the overlay. Clears any previously set vertical position.
       * @template THIS
       * @this {THIS}
       * @param {?=} value New top offset.
       * @return {THIS}
       */
      GlobalPositionStrategy.prototype.top = /**
       * Sets the top position of the overlay. Clears any previously set vertical position.
       * @template THIS
       * @this {THIS}
       * @param {?=} value New top offset.
       * @return {THIS}
       */
          function (value) {
              if (value === void 0) {
                  value = '';
              }
              ( /** @type {?} */(this))._bottomOffset = '';
              ( /** @type {?} */(this))._topOffset = value;
              ( /** @type {?} */(this))._alignItems = 'flex-start';
              return ( /** @type {?} */(this));
          };
      /**
       * Sets the left position of the overlay. Clears any previously set horizontal position.
       * @param value New left offset.
       */
      /**
       * Sets the left position of the overlay. Clears any previously set horizontal position.
       * @template THIS
       * @this {THIS}
       * @param {?=} value New left offset.
       * @return {THIS}
       */
      GlobalPositionStrategy.prototype.left = /**
       * Sets the left position of the overlay. Clears any previously set horizontal position.
       * @template THIS
       * @this {THIS}
       * @param {?=} value New left offset.
       * @return {THIS}
       */
          function (value) {
              if (value === void 0) {
                  value = '';
              }
              ( /** @type {?} */(this))._rightOffset = '';
              ( /** @type {?} */(this))._leftOffset = value;
              ( /** @type {?} */(this))._justifyContent = 'flex-start';
              return ( /** @type {?} */(this));
          };
      /**
       * Sets the bottom position of the overlay. Clears any previously set vertical position.
       * @param value New bottom offset.
       */
      /**
       * Sets the bottom position of the overlay. Clears any previously set vertical position.
       * @template THIS
       * @this {THIS}
       * @param {?=} value New bottom offset.
       * @return {THIS}
       */
      GlobalPositionStrategy.prototype.bottom = /**
       * Sets the bottom position of the overlay. Clears any previously set vertical position.
       * @template THIS
       * @this {THIS}
       * @param {?=} value New bottom offset.
       * @return {THIS}
       */
          function (value) {
              if (value === void 0) {
                  value = '';
              }
              ( /** @type {?} */(this))._topOffset = '';
              ( /** @type {?} */(this))._bottomOffset = value;
              ( /** @type {?} */(this))._alignItems = 'flex-end';
              return ( /** @type {?} */(this));
          };
      /**
       * Sets the right position of the overlay. Clears any previously set horizontal position.
       * @param value New right offset.
       */
      /**
       * Sets the right position of the overlay. Clears any previously set horizontal position.
       * @template THIS
       * @this {THIS}
       * @param {?=} value New right offset.
       * @return {THIS}
       */
      GlobalPositionStrategy.prototype.right = /**
       * Sets the right position of the overlay. Clears any previously set horizontal position.
       * @template THIS
       * @this {THIS}
       * @param {?=} value New right offset.
       * @return {THIS}
       */
          function (value) {
              if (value === void 0) {
                  value = '';
              }
              ( /** @type {?} */(this))._leftOffset = '';
              ( /** @type {?} */(this))._rightOffset = value;
              ( /** @type {?} */(this))._justifyContent = 'flex-end';
              return ( /** @type {?} */(this));
          };
      /**
       * Sets the overlay width and clears any previously set width.
       * @param value New width for the overlay
       * @deprecated Pass the `width` through the `OverlayConfig`.
       * @breaking-change 8.0.0
       */
      /**
       * Sets the overlay width and clears any previously set width.
       * @deprecated Pass the `width` through the `OverlayConfig`.
       * \@breaking-change 8.0.0
       * @template THIS
       * @this {THIS}
       * @param {?=} value New width for the overlay
       * @return {THIS}
       */
      GlobalPositionStrategy.prototype.width = /**
       * Sets the overlay width and clears any previously set width.
       * @deprecated Pass the `width` through the `OverlayConfig`.
       * \@breaking-change 8.0.0
       * @template THIS
       * @this {THIS}
       * @param {?=} value New width for the overlay
       * @return {THIS}
       */
          function (value) {
              if (value === void 0) {
                  value = '';
              }
              if (( /** @type {?} */(this))._overlayRef) {
                  ( /** @type {?} */(this))._overlayRef.updateSize({ width: value });
              }
              else {
                  ( /** @type {?} */(this))._width = value;
              }
              return ( /** @type {?} */(this));
          };
      /**
       * Sets the overlay height and clears any previously set height.
       * @param value New height for the overlay
       * @deprecated Pass the `height` through the `OverlayConfig`.
       * @breaking-change 8.0.0
       */
      /**
       * Sets the overlay height and clears any previously set height.
       * @deprecated Pass the `height` through the `OverlayConfig`.
       * \@breaking-change 8.0.0
       * @template THIS
       * @this {THIS}
       * @param {?=} value New height for the overlay
       * @return {THIS}
       */
      GlobalPositionStrategy.prototype.height = /**
       * Sets the overlay height and clears any previously set height.
       * @deprecated Pass the `height` through the `OverlayConfig`.
       * \@breaking-change 8.0.0
       * @template THIS
       * @this {THIS}
       * @param {?=} value New height for the overlay
       * @return {THIS}
       */
          function (value) {
              if (value === void 0) {
                  value = '';
              }
              if (( /** @type {?} */(this))._overlayRef) {
                  ( /** @type {?} */(this))._overlayRef.updateSize({ height: value });
              }
              else {
                  ( /** @type {?} */(this))._height = value;
              }
              return ( /** @type {?} */(this));
          };
      /**
       * Centers the overlay horizontally with an optional offset.
       * Clears any previously set horizontal position.
       *
       * @param offset Overlay offset from the horizontal center.
       */
      /**
       * Centers the overlay horizontally with an optional offset.
       * Clears any previously set horizontal position.
       *
       * @template THIS
       * @this {THIS}
       * @param {?=} offset Overlay offset from the horizontal center.
       * @return {THIS}
       */
      GlobalPositionStrategy.prototype.centerHorizontally = /**
       * Centers the overlay horizontally with an optional offset.
       * Clears any previously set horizontal position.
       *
       * @template THIS
       * @this {THIS}
       * @param {?=} offset Overlay offset from the horizontal center.
       * @return {THIS}
       */
          function (offset) {
              if (offset === void 0) {
                  offset = '';
              }
              ( /** @type {?} */(this)).left(offset);
              ( /** @type {?} */(this))._justifyContent = 'center';
              return ( /** @type {?} */(this));
          };
      /**
       * Centers the overlay vertically with an optional offset.
       * Clears any previously set vertical position.
       *
       * @param offset Overlay offset from the vertical center.
       */
      /**
       * Centers the overlay vertically with an optional offset.
       * Clears any previously set vertical position.
       *
       * @template THIS
       * @this {THIS}
       * @param {?=} offset Overlay offset from the vertical center.
       * @return {THIS}
       */
      GlobalPositionStrategy.prototype.centerVertically = /**
       * Centers the overlay vertically with an optional offset.
       * Clears any previously set vertical position.
       *
       * @template THIS
       * @this {THIS}
       * @param {?=} offset Overlay offset from the vertical center.
       * @return {THIS}
       */
          function (offset) {
              if (offset === void 0) {
                  offset = '';
              }
              ( /** @type {?} */(this)).top(offset);
              ( /** @type {?} */(this))._alignItems = 'center';
              return ( /** @type {?} */(this));
          };
      /**
       * Apply the position to the element.
       * @docs-private
       */
      /**
       * Apply the position to the element.
       * \@docs-private
       * @return {?}
       */
      GlobalPositionStrategy.prototype.apply = /**
       * Apply the position to the element.
       * \@docs-private
       * @return {?}
       */
          function () {
              // Since the overlay ref applies the strategy asynchronously, it could
              // have been disposed before it ends up being applied. If that is the
              // case, we shouldn't do anything.
              if (!this._overlayRef || !this._overlayRef.hasAttached()) {
                  return;
              }
              /** @type {?} */
              var styles = this._overlayRef.overlayElement.style;
              /** @type {?} */
              var parentStyles = this._overlayRef.hostElement.style;
              /** @type {?} */
              var config = this._overlayRef.getConfig();
              styles.position = this._cssPosition;
              styles.marginLeft = config.width === '100%' ? '0' : this._leftOffset;
              styles.marginTop = config.height === '100%' ? '0' : this._topOffset;
              styles.marginBottom = this._bottomOffset;
              styles.marginRight = this._rightOffset;
              if (config.width === '100%') {
                  parentStyles.justifyContent = 'flex-start';
              }
              else if (this._justifyContent === 'center') {
                  parentStyles.justifyContent = 'center';
              }
              else if (this._overlayRef.getConfig().direction === 'rtl') {
                  // In RTL the browser will invert `flex-start` and `flex-end` automatically, but we
                  // don't want that because our positioning is explicitly `left` and `right`, hence
                  // why we do another inversion to ensure that the overlay stays in the same position.
                  // TODO: reconsider this if we add `start` and `end` methods.
                  if (this._justifyContent === 'flex-start') {
                      parentStyles.justifyContent = 'flex-end';
                  }
                  else if (this._justifyContent === 'flex-end') {
                      parentStyles.justifyContent = 'flex-start';
                  }
              }
              else {
                  parentStyles.justifyContent = this._justifyContent;
              }
              parentStyles.alignItems = config.height === '100%' ? 'flex-start' : this._alignItems;
          };
      /**
       * Cleans up the DOM changes from the position strategy.
       * @docs-private
       */
      /**
       * Cleans up the DOM changes from the position strategy.
       * \@docs-private
       * @return {?}
       */
      GlobalPositionStrategy.prototype.dispose = /**
       * Cleans up the DOM changes from the position strategy.
       * \@docs-private
       * @return {?}
       */
          function () {
              if (this._isDisposed || !this._overlayRef) {
                  return;
              }
              /** @type {?} */
              var styles = this._overlayRef.overlayElement.style;
              /** @type {?} */
              var parent = this._overlayRef.hostElement;
              /** @type {?} */
              var parentStyles = parent.style;
              parent.classList.remove(wrapperClass);
              parentStyles.justifyContent = parentStyles.alignItems = styles.marginTop =
                  styles.marginBottom = styles.marginLeft = styles.marginRight = styles.position = '';
              this._overlayRef = ( /** @type {?} */(null));
              this._isDisposed = true;
          };
      return GlobalPositionStrategy;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Builder for overlay position strategy.
   */
  var OverlayPositionBuilder = /** @class */ (function () {
      function OverlayPositionBuilder(_viewportRuler, _document, _platform, _overlayContainer) {
          this._viewportRuler = _viewportRuler;
          this._document = _document;
          this._platform = _platform;
          this._overlayContainer = _overlayContainer;
      }
      /**
       * Creates a global position strategy.
       */
      /**
       * Creates a global position strategy.
       * @return {?}
       */
      OverlayPositionBuilder.prototype.global = /**
       * Creates a global position strategy.
       * @return {?}
       */
          function () {
              return new GlobalPositionStrategy();
          };
      /**
       * Creates a relative position strategy.
       * @param elementRef
       * @param originPos
       * @param overlayPos
       * @deprecated Use `flexibleConnectedTo` instead.
       * @breaking-change 8.0.0
       */
      /**
       * Creates a relative position strategy.
       * @deprecated Use `flexibleConnectedTo` instead.
       * \@breaking-change 8.0.0
       * @param {?} elementRef
       * @param {?} originPos
       * @param {?} overlayPos
       * @return {?}
       */
      OverlayPositionBuilder.prototype.connectedTo = /**
       * Creates a relative position strategy.
       * @deprecated Use `flexibleConnectedTo` instead.
       * \@breaking-change 8.0.0
       * @param {?} elementRef
       * @param {?} originPos
       * @param {?} overlayPos
       * @return {?}
       */
          function (elementRef, originPos, overlayPos) {
              return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document);
          };
      /**
       * Creates a flexible position strategy.
       * @param origin Origin relative to which to position the overlay.
       */
      /**
       * Creates a flexible position strategy.
       * @param {?} origin Origin relative to which to position the overlay.
       * @return {?}
       */
      OverlayPositionBuilder.prototype.flexibleConnectedTo = /**
       * Creates a flexible position strategy.
       * @param {?} origin Origin relative to which to position the overlay.
       * @return {?}
       */
          function (origin) {
              return new FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);
          };
      OverlayPositionBuilder.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */
      OverlayPositionBuilder.ctorParameters = function () {
          return [
              { type: ViewportRuler },
              { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
              { type: Platform, decorators: [{ type: core.Optional }] },
              { type: OverlayContainer, decorators: [{ type: core.Optional }] }
          ];
      };
      /** @nocollapse */ OverlayPositionBuilder.ngInjectableDef = core.defineInjectable({ factory: function OverlayPositionBuilder_Factory() { return new OverlayPositionBuilder(core.inject(ViewportRuler), core.inject(common.DOCUMENT), core.inject(Platform, 8), core.inject(OverlayContainer, 8)); }, token: OverlayPositionBuilder, providedIn: "root" });
      return OverlayPositionBuilder;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Next overlay unique ID.
   * @type {?}
   */
  var nextUniqueId = 0;
  // Note that Overlay is *not* scoped to the app root because the ComponentFactoryResolver
  // it needs is different based on where OverlayModule is imported.
  /**
   * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be
   * used as a low-level building block for other components. Dialogs, tooltips, menus,
   * selects, etc. can all be built using overlays. The service should primarily be used by authors
   * of re-usable components rather than developers building end-user applications.
   *
   * An overlay *is* a PortalOutlet, so any kind of Portal can be loaded into one.
   */
  var Overlay = /** @class */ (function () {
      function Overlay(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _injector, _ngZone, _document, _directionality, _location) {
          this.scrollStrategies = scrollStrategies;
          this._overlayContainer = _overlayContainer;
          this._componentFactoryResolver = _componentFactoryResolver;
          this._positionBuilder = _positionBuilder;
          this._keyboardDispatcher = _keyboardDispatcher;
          this._injector = _injector;
          this._ngZone = _ngZone;
          this._document = _document;
          this._directionality = _directionality;
          this._location = _location;
      }
      /**
       * Creates an overlay.
       * @param config Configuration applied to the overlay.
       * @returns Reference to the created overlay.
       */
      /**
       * Creates an overlay.
       * @param {?=} config Configuration applied to the overlay.
       * @return {?} Reference to the created overlay.
       */
      Overlay.prototype.create = /**
       * Creates an overlay.
       * @param {?=} config Configuration applied to the overlay.
       * @return {?} Reference to the created overlay.
       */
          function (config) {
              /** @type {?} */
              var host = this._createHostElement();
              /** @type {?} */
              var pane = this._createPaneElement(host);
              /** @type {?} */
              var portalOutlet = this._createPortalOutlet(pane);
              /** @type {?} */
              var overlayConfig = new OverlayConfig(config);
              overlayConfig.direction = overlayConfig.direction || this._directionality.value;
              return new OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._keyboardDispatcher, this._document, this._location);
          };
      /**
       * Gets a position builder that can be used, via fluent API,
       * to construct and configure a position strategy.
       * @returns An overlay position builder.
       */
      /**
       * Gets a position builder that can be used, via fluent API,
       * to construct and configure a position strategy.
       * @return {?} An overlay position builder.
       */
      Overlay.prototype.position = /**
       * Gets a position builder that can be used, via fluent API,
       * to construct and configure a position strategy.
       * @return {?} An overlay position builder.
       */
          function () {
              return this._positionBuilder;
          };
      /**
       * Creates the DOM element for an overlay and appends it to the overlay container.
       * @returns Newly-created pane element
       */
      /**
       * Creates the DOM element for an overlay and appends it to the overlay container.
       * @private
       * @param {?} host
       * @return {?} Newly-created pane element
       */
      Overlay.prototype._createPaneElement = /**
       * Creates the DOM element for an overlay and appends it to the overlay container.
       * @private
       * @param {?} host
       * @return {?} Newly-created pane element
       */
          function (host) {
              /** @type {?} */
              var pane = this._document.createElement('div');
              pane.id = "cdk-overlay-" + nextUniqueId++;
              pane.classList.add('cdk-overlay-pane');
              host.appendChild(pane);
              return pane;
          };
      /**
       * Creates the host element that wraps around an overlay
       * and can be used for advanced positioning.
       * @returns Newly-create host element.
       */
      /**
       * Creates the host element that wraps around an overlay
       * and can be used for advanced positioning.
       * @private
       * @return {?} Newly-create host element.
       */
      Overlay.prototype._createHostElement = /**
       * Creates the host element that wraps around an overlay
       * and can be used for advanced positioning.
       * @private
       * @return {?} Newly-create host element.
       */
          function () {
              /** @type {?} */
              var host = this._document.createElement('div');
              this._overlayContainer.getContainerElement().appendChild(host);
              return host;
          };
      /**
       * Create a DomPortalOutlet into which the overlay content can be loaded.
       * @param pane The DOM element to turn into a portal outlet.
       * @returns A portal outlet for the given DOM element.
       */
      /**
       * Create a DomPortalOutlet into which the overlay content can be loaded.
       * @private
       * @param {?} pane The DOM element to turn into a portal outlet.
       * @return {?} A portal outlet for the given DOM element.
       */
      Overlay.prototype._createPortalOutlet = /**
       * Create a DomPortalOutlet into which the overlay content can be loaded.
       * @private
       * @param {?} pane The DOM element to turn into a portal outlet.
       * @return {?} A portal outlet for the given DOM element.
       */
          function (pane) {
              // We have to resolve the ApplicationRef later in order to allow people
              // to use overlay-based providers during app initialization.
              if (!this._appRef) {
                  this._appRef = this._injector.get(core.ApplicationRef);
              }
              return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector);
          };
      Overlay.decorators = [
          { type: core.Injectable },
      ];
      /** @nocollapse */
      Overlay.ctorParameters = function () {
          return [
              { type: ScrollStrategyOptions },
              { type: OverlayContainer },
              { type: core.ComponentFactoryResolver },
              { type: OverlayPositionBuilder },
              { type: OverlayKeyboardDispatcher },
              { type: core.Injector },
              { type: core.NgZone },
              { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
              { type: Directionality },
              { type: common.Location, decorators: [{ type: core.Optional }] }
          ];
      };
      return Overlay;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Default set of positions for the overlay. Follows the behavior of a dropdown.
   * @type {?}
   */
  var defaultPositionList = [
      {
          originX: 'start',
          originY: 'bottom',
          overlayX: 'start',
          overlayY: 'top'
      },
      {
          originX: 'start',
          originY: 'top',
          overlayX: 'start',
          overlayY: 'bottom'
      },
      {
          originX: 'end',
          originY: 'top',
          overlayX: 'end',
          overlayY: 'bottom'
      },
      {
          originX: 'end',
          originY: 'bottom',
          overlayX: 'end',
          overlayY: 'top'
      }
  ];
  /**
   * Injection token that determines the scroll handling while the connected overlay is open.
   * @type {?}
   */
  var CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new core.InjectionToken('cdk-connected-overlay-scroll-strategy');
  /**
   * Directive applied to an element to make it usable as an origin for an Overlay using a
   * ConnectedPositionStrategy.
   */
  var CdkOverlayOrigin = /** @class */ (function () {
      function CdkOverlayOrigin(elementRef) {
          this.elementRef = elementRef;
      }
      CdkOverlayOrigin.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]',
                      exportAs: 'cdkOverlayOrigin',
                  },] },
      ];
      /** @nocollapse */
      CdkOverlayOrigin.ctorParameters = function () {
          return [
              { type: core.ElementRef }
          ];
      };
      return CdkOverlayOrigin;
  }());
  /**
   * Directive to facilitate declarative creation of an
   * Overlay using a FlexibleConnectedPositionStrategy.
   */
  var CdkConnectedOverlay = /** @class */ (function () {
      // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.
      function CdkConnectedOverlay(_overlay, templateRef, viewContainerRef, scrollStrategyFactory, _dir) {
          this._overlay = _overlay;
          this._dir = _dir;
          this._hasBackdrop = false;
          this._lockPosition = false;
          this._growAfterOpen = false;
          this._flexibleDimensions = false;
          this._push = false;
          this._backdropSubscription = rxjs.Subscription.EMPTY;
          /**
           * Margin between the overlay and the viewport edges.
           */
          this.viewportMargin = 0;
          /**
           * Whether the overlay is open.
           */
          this.open = false;
          /**
           * Event emitted when the backdrop is clicked.
           */
          this.backdropClick = new core.EventEmitter();
          /**
           * Event emitted when the position has changed.
           */
          this.positionChange = new core.EventEmitter();
          /**
           * Event emitted when the overlay has been attached.
           */
          this.attach = new core.EventEmitter();
          /**
           * Event emitted when the overlay has been detached.
           */
          this.detach = new core.EventEmitter();
          /**
           * Emits when there are keyboard events that are targeted at the overlay.
           */
          this.overlayKeydown = new core.EventEmitter();
          this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);
          this._scrollStrategyFactory = scrollStrategyFactory;
          this.scrollStrategy = this._scrollStrategyFactory();
      }
      Object.defineProperty(CdkConnectedOverlay.prototype, "offsetX", {
          /** The offset in pixels for the overlay connection point on the x-axis */
          get: /**
           * The offset in pixels for the overlay connection point on the x-axis
           * @return {?}
           */ function () { return this._offsetX; },
          set: /**
           * @param {?} offsetX
           * @return {?}
           */ function (offsetX) {
              this._offsetX = offsetX;
              if (this._position) {
                  this._updatePositionStrategy(this._position);
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkConnectedOverlay.prototype, "offsetY", {
          /** The offset in pixels for the overlay connection point on the y-axis */
          get: /**
           * The offset in pixels for the overlay connection point on the y-axis
           * @return {?}
           */ function () { return this._offsetY; },
          set: /**
           * @param {?} offsetY
           * @return {?}
           */ function (offsetY) {
              this._offsetY = offsetY;
              if (this._position) {
                  this._updatePositionStrategy(this._position);
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkConnectedOverlay.prototype, "hasBackdrop", {
          /** Whether or not the overlay should attach a backdrop. */
          get: /**
           * Whether or not the overlay should attach a backdrop.
           * @return {?}
           */ function () { return this._hasBackdrop; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._hasBackdrop = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkConnectedOverlay.prototype, "lockPosition", {
          /** Whether or not the overlay should be locked when scrolling. */
          get: /**
           * Whether or not the overlay should be locked when scrolling.
           * @return {?}
           */ function () { return this._lockPosition; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._lockPosition = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkConnectedOverlay.prototype, "flexibleDimensions", {
          /** Whether the overlay's width and height can be constrained to fit within the viewport. */
          get: /**
           * Whether the overlay's width and height can be constrained to fit within the viewport.
           * @return {?}
           */ function () { return this._flexibleDimensions; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._flexibleDimensions = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkConnectedOverlay.prototype, "growAfterOpen", {
          /** Whether the overlay can grow after the initial open when flexible positioning is turned on. */
          get: /**
           * Whether the overlay can grow after the initial open when flexible positioning is turned on.
           * @return {?}
           */ function () { return this._growAfterOpen; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._growAfterOpen = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkConnectedOverlay.prototype, "push", {
          /** Whether the overlay can be pushed on-screen if none of the provided positions fit. */
          get: /**
           * Whether the overlay can be pushed on-screen if none of the provided positions fit.
           * @return {?}
           */ function () { return this._push; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._push = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkConnectedOverlay.prototype, "overlayRef", {
          /** The associated overlay reference. */
          get: /**
           * The associated overlay reference.
           * @return {?}
           */ function () {
              return this._overlayRef;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkConnectedOverlay.prototype, "dir", {
          /** The element's layout direction. */
          get: /**
           * The element's layout direction.
           * @return {?}
           */ function () {
              return this._dir ? this._dir.value : 'ltr';
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      CdkConnectedOverlay.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              if (this._overlayRef) {
                  this._overlayRef.dispose();
              }
              this._backdropSubscription.unsubscribe();
          };
      /**
       * @param {?} changes
       * @return {?}
       */
      CdkConnectedOverlay.prototype.ngOnChanges = /**
       * @param {?} changes
       * @return {?}
       */
          function (changes) {
              if (this._position) {
                  this._updatePositionStrategy(this._position);
                  this._overlayRef.updateSize({
                      width: this.width,
                      minWidth: this.minWidth,
                      height: this.height,
                      minHeight: this.minHeight,
                  });
                  if (changes['origin'] && this.open) {
                      this._position.apply();
                  }
              }
              if (changes['open']) {
                  this.open ? this._attachOverlay() : this._detachOverlay();
              }
          };
      /** Creates an overlay */
      /**
       * Creates an overlay
       * @private
       * @return {?}
       */
      CdkConnectedOverlay.prototype._createOverlay = /**
       * Creates an overlay
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this.positions || !this.positions.length) {
                  this.positions = defaultPositionList;
              }
              this._overlayRef = this._overlay.create(this._buildConfig());
              this._overlayRef.keydownEvents().subscribe(function (event) {
                  _this.overlayKeydown.next(event);
                  if (event.keyCode === ESCAPE) {
                      _this._detachOverlay();
                  }
              });
          };
      /** Builds the overlay config based on the directive's inputs */
      /**
       * Builds the overlay config based on the directive's inputs
       * @private
       * @return {?}
       */
      CdkConnectedOverlay.prototype._buildConfig = /**
       * Builds the overlay config based on the directive's inputs
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var positionStrategy = this._position = this._createPositionStrategy();
              /** @type {?} */
              var overlayConfig = new OverlayConfig({
                  direction: this._dir,
                  positionStrategy: positionStrategy,
                  scrollStrategy: this.scrollStrategy,
                  hasBackdrop: this.hasBackdrop
              });
              if (this.width || this.width === 0) {
                  overlayConfig.width = this.width;
              }
              if (this.height || this.height === 0) {
                  overlayConfig.height = this.height;
              }
              if (this.minWidth || this.minWidth === 0) {
                  overlayConfig.minWidth = this.minWidth;
              }
              if (this.minHeight || this.minHeight === 0) {
                  overlayConfig.minHeight = this.minHeight;
              }
              if (this.backdropClass) {
                  overlayConfig.backdropClass = this.backdropClass;
              }
              if (this.panelClass) {
                  overlayConfig.panelClass = this.panelClass;
              }
              return overlayConfig;
          };
      /** Updates the state of a position strategy, based on the values of the directive inputs. */
      /**
       * Updates the state of a position strategy, based on the values of the directive inputs.
       * @private
       * @param {?} positionStrategy
       * @return {?}
       */
      CdkConnectedOverlay.prototype._updatePositionStrategy = /**
       * Updates the state of a position strategy, based on the values of the directive inputs.
       * @private
       * @param {?} positionStrategy
       * @return {?}
       */
          function (positionStrategy) {
              var _this = this;
              /** @type {?} */
              var positions = this.positions.map(function (currentPosition) {
                  return ({
                      originX: currentPosition.originX,
                      originY: currentPosition.originY,
                      overlayX: currentPosition.overlayX,
                      overlayY: currentPosition.overlayY,
                      offsetX: currentPosition.offsetX || _this.offsetX,
                      offsetY: currentPosition.offsetY || _this.offsetY
                  });
              });
              return positionStrategy
                  .setOrigin(this.origin.elementRef)
                  .withPositions(positions)
                  .withFlexibleDimensions(this.flexibleDimensions)
                  .withPush(this.push)
                  .withGrowAfterOpen(this.growAfterOpen)
                  .withViewportMargin(this.viewportMargin)
                  .withLockedPosition(this.lockPosition);
          };
      /** Returns the position strategy of the overlay to be set on the overlay config */
      /**
       * Returns the position strategy of the overlay to be set on the overlay config
       * @private
       * @return {?}
       */
      CdkConnectedOverlay.prototype._createPositionStrategy = /**
       * Returns the position strategy of the overlay to be set on the overlay config
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var strategy = this._overlay.position().flexibleConnectedTo(this.origin.elementRef);
              this._updatePositionStrategy(strategy);
              strategy.positionChanges.subscribe(function (p) { return _this.positionChange.emit(p); });
              return strategy;
          };
      /** Attaches the overlay and subscribes to backdrop clicks if backdrop exists */
      /**
       * Attaches the overlay and subscribes to backdrop clicks if backdrop exists
       * @private
       * @return {?}
       */
      CdkConnectedOverlay.prototype._attachOverlay = /**
       * Attaches the overlay and subscribes to backdrop clicks if backdrop exists
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this._overlayRef) {
                  this._createOverlay();
              }
              else {
                  // Update the overlay size, in case the directive's inputs have changed
                  this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop;
              }
              if (!this._overlayRef.hasAttached()) {
                  this._overlayRef.attach(this._templatePortal);
                  this.attach.emit();
              }
              if (this.hasBackdrop) {
                  this._backdropSubscription = this._overlayRef.backdropClick().subscribe(function (event) {
                      _this.backdropClick.emit(event);
                  });
              }
              else {
                  this._backdropSubscription.unsubscribe();
              }
          };
      /** Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists */
      /**
       * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists
       * @private
       * @return {?}
       */
      CdkConnectedOverlay.prototype._detachOverlay = /**
       * Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists
       * @private
       * @return {?}
       */
          function () {
              if (this._overlayRef) {
                  this._overlayRef.detach();
                  this.detach.emit();
              }
              this._backdropSubscription.unsubscribe();
          };
      CdkConnectedOverlay.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]',
                      exportAs: 'cdkConnectedOverlay'
                  },] },
      ];
      /** @nocollapse */
      CdkConnectedOverlay.ctorParameters = function () {
          return [
              { type: Overlay },
              { type: core.TemplateRef },
              { type: core.ViewContainerRef },
              { type: undefined, decorators: [{ type: core.Inject, args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,] }] },
              { type: Directionality, decorators: [{ type: core.Optional }] }
          ];
      };
      CdkConnectedOverlay.propDecorators = {
          origin: [{ type: core.Input, args: ['cdkConnectedOverlayOrigin',] }],
          positions: [{ type: core.Input, args: ['cdkConnectedOverlayPositions',] }],
          offsetX: [{ type: core.Input, args: ['cdkConnectedOverlayOffsetX',] }],
          offsetY: [{ type: core.Input, args: ['cdkConnectedOverlayOffsetY',] }],
          width: [{ type: core.Input, args: ['cdkConnectedOverlayWidth',] }],
          height: [{ type: core.Input, args: ['cdkConnectedOverlayHeight',] }],
          minWidth: [{ type: core.Input, args: ['cdkConnectedOverlayMinWidth',] }],
          minHeight: [{ type: core.Input, args: ['cdkConnectedOverlayMinHeight',] }],
          backdropClass: [{ type: core.Input, args: ['cdkConnectedOverlayBackdropClass',] }],
          panelClass: [{ type: core.Input, args: ['cdkConnectedOverlayPanelClass',] }],
          viewportMargin: [{ type: core.Input, args: ['cdkConnectedOverlayViewportMargin',] }],
          scrollStrategy: [{ type: core.Input, args: ['cdkConnectedOverlayScrollStrategy',] }],
          open: [{ type: core.Input, args: ['cdkConnectedOverlayOpen',] }],
          hasBackdrop: [{ type: core.Input, args: ['cdkConnectedOverlayHasBackdrop',] }],
          lockPosition: [{ type: core.Input, args: ['cdkConnectedOverlayLockPosition',] }],
          flexibleDimensions: [{ type: core.Input, args: ['cdkConnectedOverlayFlexibleDimensions',] }],
          growAfterOpen: [{ type: core.Input, args: ['cdkConnectedOverlayGrowAfterOpen',] }],
          push: [{ type: core.Input, args: ['cdkConnectedOverlayPush',] }],
          backdropClick: [{ type: core.Output }],
          positionChange: [{ type: core.Output }],
          attach: [{ type: core.Output }],
          detach: [{ type: core.Output }],
          overlayKeydown: [{ type: core.Output }]
      };
      return CdkConnectedOverlay;
  }());
  /**
   * \@docs-private
   * @param {?} overlay
   * @return {?}
   */
  function CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
      return function () { return overlay.scrollStrategies.reposition(); };
  }
  /**
   * \@docs-private
   * @type {?}
   */
  var CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {
      provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,
      deps: [Overlay],
      useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var OverlayModule = /** @class */ (function () {
      function OverlayModule() {
      }
      OverlayModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [BidiModule, PortalModule, ScrollingModule],
                      exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule],
                      declarations: [CdkConnectedOverlay, CdkOverlayOrigin],
                      providers: [
                          Overlay,
                          CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,
                      ],
                  },] },
      ];
      return OverlayModule;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Alternative to OverlayContainer that supports correct displaying of overlay elements in
   * Fullscreen mode
   * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen
   *
   * Should be provided in the root component.
   */
  var FullscreenOverlayContainer = /** @class */ (function (_super) {
      tslib_1.__extends(FullscreenOverlayContainer, _super);
      function FullscreenOverlayContainer(_document) {
          return _super.call(this, _document) || this;
      }
      /**
       * @return {?}
       */
      FullscreenOverlayContainer.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              _super.prototype.ngOnDestroy.call(this);
              if (this._fullScreenEventName && this._fullScreenListener) {
                  this._document.removeEventListener(this._fullScreenEventName, this._fullScreenListener);
              }
          };
      /**
       * @protected
       * @return {?}
       */
      FullscreenOverlayContainer.prototype._createContainer = /**
       * @protected
       * @return {?}
       */
          function () {
              var _this = this;
              _super.prototype._createContainer.call(this);
              this._adjustParentForFullscreenChange();
              this._addFullscreenChangeListener(function () { return _this._adjustParentForFullscreenChange(); });
          };
      /**
       * @private
       * @return {?}
       */
      FullscreenOverlayContainer.prototype._adjustParentForFullscreenChange = /**
       * @private
       * @return {?}
       */
          function () {
              if (!this._containerElement) {
                  return;
              }
              /** @type {?} */
              var fullscreenElement = this.getFullscreenElement();
              /** @type {?} */
              var parent = fullscreenElement || this._document.body;
              parent.appendChild(this._containerElement);
          };
      /**
       * @private
       * @param {?} fn
       * @return {?}
       */
      FullscreenOverlayContainer.prototype._addFullscreenChangeListener = /**
       * @private
       * @param {?} fn
       * @return {?}
       */
          function (fn) {
              /** @type {?} */
              var eventName = this._getEventName();
              if (eventName) {
                  if (this._fullScreenListener) {
                      this._document.removeEventListener(eventName, this._fullScreenListener);
                  }
                  this._document.addEventListener(eventName, fn);
                  this._fullScreenListener = fn;
              }
          };
      /**
       * @private
       * @return {?}
       */
      FullscreenOverlayContainer.prototype._getEventName = /**
       * @private
       * @return {?}
       */
          function () {
              if (!this._fullScreenEventName) {
                  if (this._document.fullscreenEnabled) {
                      this._fullScreenEventName = 'fullscreenchange';
                  }
                  else if (this._document.webkitFullscreenEnabled) {
                      this._fullScreenEventName = 'webkitfullscreenchange';
                  }
                  else if ((( /** @type {?} */(this._document))).mozFullScreenEnabled) {
                      this._fullScreenEventName = 'mozfullscreenchange';
                  }
                  else if ((( /** @type {?} */(this._document))).msFullscreenEnabled) {
                      this._fullScreenEventName = 'MSFullscreenChange';
                  }
              }
              return this._fullScreenEventName;
          };
      /**
       * When the page is put into fullscreen mode, a specific element is specified.
       * Only that element and its children are visible when in fullscreen mode.
       */
      /**
       * When the page is put into fullscreen mode, a specific element is specified.
       * Only that element and its children are visible when in fullscreen mode.
       * @return {?}
       */
      FullscreenOverlayContainer.prototype.getFullscreenElement = /**
       * When the page is put into fullscreen mode, a specific element is specified.
       * Only that element and its children are visible when in fullscreen mode.
       * @return {?}
       */
          function () {
              return this._document.fullscreenElement ||
                  this._document.webkitFullscreenElement ||
                  (( /** @type {?} */(this._document))).mozFullScreenElement ||
                  (( /** @type {?} */(this._document))).msFullscreenElement ||
                  null;
          };
      FullscreenOverlayContainer.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */
      FullscreenOverlayContainer.ctorParameters = function () {
          return [
              { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
          ];
      };
      /** @nocollapse */ FullscreenOverlayContainer.ngInjectableDef = core.defineInjectable({ factory: function FullscreenOverlayContainer_Factory() { return new FullscreenOverlayContainer(core.inject(common.DOCUMENT)); }, token: FullscreenOverlayContainer, providedIn: "root" });
      return FullscreenOverlayContainer;
  }(OverlayContainer));

  /**
   * @license Angular v7.2.0
   * (c) 2010-2018 Google, Inc. https://angular.io/
   * License: MIT
   */
  /**
   * Creates a named animation trigger, containing a  list of `state()`
   * and `transition()` entries to be evaluated when the expression
   * bound to the trigger changes.
   *
   * @param name An identifying string.
   * @param definitions  An animation definition object, containing an array of `state()`
   * and `transition()` declarations.
   *
   * @return An object that encapsulates the trigger data.
   *
   * @usageNotes
   * Define an animation trigger in the `animations` section of `@Component` metadata.
   * In the template, reference the trigger by name and bind it to a trigger expression that
   * evaluates to a defined animation state, using the following format:
   *
   * `[@triggerName]="expression"`
   *
   * Animation trigger bindings convert all values to strings, and then match the
   * previous and current values against any linked transitions.
   * Booleans can be specified as `1` or `true` and `0` or `false`.
   *
   * ### Usage Example
   *
   * The following example creates an animation trigger reference based on the provided
   * name value.
   * The provided animation value is expected to be an array consisting of state and
   * transition declarations.
   *
   * ```typescript
   * @Component({
   *   selector: "my-component",
   *   templateUrl: "my-component-tpl.html",
   *   animations: [
   *     trigger("myAnimationTrigger", [
   *       state(...),
   *       state(...),
   *       transition(...),
   *       transition(...)
   *     ])
   *   ]
   * })
   * class MyComponent {
   *   myStatusExp = "something";
   * }
   * ```
   *
   * The template associated with this component makes use of the defined trigger
   * by binding to an element within its template code.
   *
   * ```html
   * <!-- somewhere inside of my-component-tpl.html -->
   * <div [@myAnimationTrigger]="myStatusExp">...</div>
   * ```
   *
   * ### Using an inline function
   * The `transition` animation method also supports reading an inline function which can decide
   * if its associated animation should be run.
   *
   * ```typescript
   * // this method is run each time the `myAnimationTrigger` trigger value changes.
   * function myInlineMatcherFn(fromState: string, toState: string, element: any, params: {[key:
   string]: any}): boolean {
   *   // notice that `element` and `params` are also available here
   *   return toState == 'yes-please-animate';
   * }
   *
   * @Component({
   *   selector: 'my-component',
   *   templateUrl: 'my-component-tpl.html',
   *   animations: [
   *     trigger('myAnimationTrigger', [
   *       transition(myInlineMatcherFn, [
   *         // the animation sequence code
   *       ]),
   *     ])
   *   ]
   * })
   * class MyComponent {
   *   myStatusExp = "yes-please-animate";
   * }
   * ```
   *
   * ### Disabling Animations
   * When true, the special animation control binding `@.disabled` binding prevents
   * all animations from rendering.
   * Place the  `@.disabled` binding on an element to disable
   * animations on the element itself, as well as any inner animation triggers
   * within the element.
   *
   * The following example shows how to use this feature:
   *
   * ```typescript
   * @Component({
   *   selector: 'my-component',
   *   template: `
   *     <div [@.disabled]="isDisabled">
   *       <div [@childAnimation]="exp"></div>
   *     </div>
   *   `,
   *   animations: [
   *     trigger("childAnimation", [
   *       // ...
   *     ])
   *   ]
   * })
   * class MyComponent {
   *   isDisabled = true;
   *   exp = '...';
   * }
   * ```
   *
   * When `@.disabled` is true, it prevents the `@childAnimation` trigger from animating,
   * along with any inner animations.
   *
   * ### Disable animations application-wide
   * When an area of the template is set to have animations disabled,
   * **all** inner components have their animations disabled as well.
   * This means that you can disable all animations for an app
   * by placing a host binding set on `@.disabled` on the topmost Angular component.
   *
   * ```typescript
   * import {Component, HostBinding} from '@angular/core';
   *
   * @Component({
   *   selector: 'app-component',
   *   templateUrl: 'app.component.html',
   * })
   * class AppComponent {
   *   @HostBinding('@.disabled')
   *   public animationsDisabled = true;
   * }
   * ```
   *
   * ### Overriding disablement of inner animations
   * Despite inner animations being disabled, a parent animation can `query()`
   * for inner elements located in disabled areas of the template and still animate
   * them if needed. This is also the case for when a sub animation is
   * queried by a parent and then later animated using `animateChild()`.
   *
   * ### Detecting when an animation is disabled
   * If a region of the DOM (or the entire application) has its animations disabled, the animation
   * trigger callbacks still fire, but for zero seconds. When the callback fires, it provides
   * an instance of an `AnimationEvent`. If animations are disabled,
   * the `.disabled` flag on the event is true.
   *
   * @publicApi
   */
  function trigger(name, definitions) {
      return { type: 7 /* Trigger */, name: name, definitions: definitions, options: {} };
  }
  /**
   * Defines an animation step that combines styling information with timing information.
   *
   * @param timings Sets `AnimateTimings` for the parent animation.
   * A string in the format "duration [delay] [easing]".
   *  - Duration and delay are expressed as a number and optional time unit,
   * such as "1s" or "10ms" for one second and 10 milliseconds, respectively.
   * The default unit is milliseconds.
   *  - The easing value controls how the animation accelerates and decelerates
   * during its runtime. Value is one of  `ease`, `ease-in`, `ease-out`,
   * `ease-in-out`, or a `cubic-bezier()` function call.
   * If not supplied, no easing is applied.
   *
   * For example, the string "1s 100ms ease-out" specifies a duration of
   * 1000 milliseconds, and delay of 100 ms, and the "ease-out" easing style,
   * which decelerates near the end of the duration.
   * @param styles Sets AnimationStyles for the parent animation.
   * A function call to either `style()` or `keyframes()`
   * that returns a collection of CSS style entries to be applied to the parent animation.
   * When null, uses the styles from the destination state.
   * This is useful when describing an animation step that will complete an animation;
   * see "Animating to the final state" in `transitions()`.
   * @returns An object that encapsulates the animation step.
   *
   * @usageNotes
   * Call within an animation `sequence()`, `{@link animations/group group()}`, or
   * `transition()` call to specify an animation step
   * that applies given style data to the parent animation for a given amount of time.
   *
   * ### Syntax Examples
   * **Timing examples**
   *
   * The following examples show various `timings` specifications.
   * - `animate(500)` : Duration is 500 milliseconds.
   * - `animate("1s")` : Duration is 1000 milliseconds.
   * - `animate("100ms 0.5s")` : Duration is 100 milliseconds, delay is 500 milliseconds.
   * - `animate("5s ease-in")` : Duration is 5000 milliseconds, easing in.
   * - `animate("5s 10ms cubic-bezier(.17,.67,.88,.1)")` : Duration is 5000 milliseconds, delay is 10
   * milliseconds, easing according to a bezier curve.
   *
   * **Style examples**
   *
   * The following example calls `style()` to set a single CSS style.
   * ```typescript
   * animate(500, style({ background: "red" }))
   * ```
   * The following example calls `keyframes()` to set a CSS style
   * to different values for successive keyframes.
   * ```typescript
   * animate(500, keyframes(
   *  [
   *   style({ background: "blue" })),
   *   style({ background: "red" }))
   *  ])
   * ```
   *
   * @publicApi
   */
  function animate(timings, styles) {
      if (styles === void 0) {
          styles = null;
      }
      return { type: 4 /* Animate */, styles: styles, timings: timings };
  }
  /**
   * @description Defines a list of animation steps to be run in parallel.
   *
   * @param steps An array of animation step objects.
   * - When steps are defined by `style()` or `animate()`
   * function calls, each call within the group is executed instantly.
   * - To specify offset styles to be applied at a later time, define steps with
   * `keyframes()`, or use `animate()` calls with a delay value.
   * For example:
   *
   * ```typescript
   * group([
   *   animate("1s", { background: "black" }))
   *   animate("2s", { color: "white" }))
   * ])
   * ```
   *
   * @param options An options object containing a delay and
   * developer-defined parameters that provide styling defaults and
   * can be overridden on invocation.
   *
   * @return An object that encapsulates the group data.
   *
   * @usageNotes
   * Grouped animations are useful when a series of styles must be
   * animated at different starting times and closed off at different ending times.
   *
   * When called within a `sequence()` or a
   * `transition()` call, does not continue to the next
   * instruction until all of the inner animation steps have completed.
   *
   * @publicApi
   */
  function group(steps, options) {
      if (options === void 0) {
          options = null;
      }
      return { type: 3 /* Group */, steps: steps, options: options };
  }
  /**
   * Declares a key/value object containing CSS properties/styles that
   * can then be used for an animation `state`, within an animation `sequence`,
   * or as styling data for calls to `animate()` and `keyframes()`.
   *
   * @param tokens A set of CSS styles or HTML styles associated with an animation state.
   * The value can be any of the following:
   * - A key-value style pair associating a CSS property with a value.
   * - An array of key-value style pairs.
   * - An asterisk (*), to use auto-styling, where styles are derived from the element
   * being animated and applied to the animation when it starts.
   *
   * Auto-styling can be used to define a state that depends on layout or other
   * environmental factors.
   *
   * @return An object that encapsulates the style data.
   *
   * @usageNotes
   * The following examples create animation styles that collect a set of
   * CSS property values:
   *
   * ```typescript
   * // string values for CSS properties
   * style({ background: "red", color: "blue" })
   *
   * // numerical pixel values
   * style({ width: 100, height: 0 })
   * ```
   *
   * The following example uses auto-styling to allow a component to animate from
   * a height of 0 up to the height of the parent element:
   *
   * ```
   * style({ height: 0 }),
   * animate("1s", style({ height: "*" }))
   * ```
   *
   * @publicApi
   **/
  function style(tokens) {
      return { type: 6 /* Style */, styles: tokens, offset: null };
  }
  /**
   * Declares an animation state within a trigger attached to an element.
   *
   * @param name One or more names for the defined state in a comma-separated string.
   * The following reserved state names can be supplied to define a style for specific use
   * cases:
   *
   * - `void` You can associate styles with this name to be used when
   * the element is detached from the application. For example, when an `ngIf` evaluates
   * to false, the state of the associated element is void.
   *  - `*` (asterisk) Indicates the default state. You can associate styles with this name
   * to be used as the fallback when the state that is being animated is not declared
   * within the trigger.
   *
   * @param styles A set of CSS styles associated with this state, created using the
   * `style()` function.
   * This set of styles persists on the element once the state has been reached.
   * @param options Parameters that can be passed to the state when it is invoked.
   * 0 or more key-value pairs.
   * @return An object that encapsulates the new state data.
   *
   * @usageNotes
   * Use the `trigger()` function to register states to an animation trigger.
   * Use the `transition()` function to animate between states.
   * When a state is active within a component, its associated styles persist on the element,
   * even when the animation ends.
   *
   * @publicApi
   **/
  function state(name, styles, options) {
      return { type: 0 /* State */, name: name, styles: styles, options: options };
  }
  /**
   * Defines a set of animation styles, associating each style with an optional `offset` value.
   *
   * @param steps A set of animation styles with optional offset data.
   * The optional `offset` value for a style specifies a percentage of the total animation
   * time at which that style is applied.
   * @returns An object that encapsulates the keyframes data.
   *
   * @usageNotes
   * Use with the `animate()` call. Instead of applying animations
   * from the current state
   * to the destination state, keyframes describe how each style entry is applied and at what point
   * within the animation arc.
   * Compare [CSS Keyframe Animations](https://www.w3schools.com/css/css3_animations.asp).
   *
   * ### Usage
   *
   * In the following example, the offset values describe
   * when each `backgroundColor` value is applied. The color is red at the start, and changes to
   * blue when 20% of the total time has elapsed.
   *
   * ```typescript
   * // the provided offset values
   * animate("5s", keyframes([
   *   style({ backgroundColor: "red", offset: 0 }),
   *   style({ backgroundColor: "blue", offset: 0.2 }),
   *   style({ backgroundColor: "orange", offset: 0.3 }),
   *   style({ backgroundColor: "black", offset: 1 })
   * ]))
   * ```
   *
   * If there are no `offset` values specified in the style entries, the offsets
   * are calculated automatically.
   *
   * ```typescript
   * animate("5s", keyframes([
   *   style({ backgroundColor: "red" }) // offset = 0
   *   style({ backgroundColor: "blue" }) // offset = 0.33
   *   style({ backgroundColor: "orange" }) // offset = 0.66
   *   style({ backgroundColor: "black" }) // offset = 1
   * ]))
   *```

   * @publicApi
   */
  function keyframes(steps) {
      return { type: 5 /* Keyframes */, steps: steps };
  }
  /**
   * Declares an animation transition as a sequence of animation steps to run when a given
   * condition is satisfied. The condition is a Boolean expression or function that compares
   * the previous and current animation states, and returns true if this transition should occur.
   * When the state criteria of a defined transition are met, the associated animation is
   * triggered.
   *
   * @param stateChangeExpr A Boolean expression or function that compares the previous and current
   * animation states, and returns true if this transition should occur. Note that  "true" and "false"
   * match 1 and 0, respectively. An expression is evaluated each time a state change occurs in the
   * animation trigger element.
   * The animation steps run when the expression evaluates to true.
   *
   * - A state-change string takes the form "state1 => state2", where each side is a defined animation
   * state, or an asterix (*) to refer to a dynamic start or end state.
   *   - The expression string can contain multiple comma-separated statements;
   * for example "state1 => state2, state3 => state4".
   *   - Special values `:enter` and `:leave` initiate a transition on the entry and exit states,
   * equivalent to  "void => *"  and "* => void".
   *   - Special values `:increment` and `:decrement` initiate a transition when a numeric value has
   * increased or decreased in value.
   * - A function is executed each time a state change occurs in the animation trigger element.
   * The animation steps run when the function returns true.
   *
   * @param steps One or more animation objects, as returned by the `animate()` or
   * `sequence()` function, that form a transformation from one state to another.
   * A sequence is used by default when you pass an array.
   * @param options An options object that can contain a delay value for the start of the animation,
   * and additional developer-defined parameters. Provided values for additional parameters are used
   * as defaults, and override values can be passed to the caller on invocation.
   * @returns An object that encapsulates the transition data.
   *
   * @usageNotes
   * The template associated with a component binds an animation trigger to an element.
   *
   * ```HTML
   * <!-- somewhere inside of my-component-tpl.html -->
   * <div [@myAnimationTrigger]="myStatusExp">...</div>
   * ```
   *
   * All transitions are defined within an animation trigger,
   * along with named states that the transitions change to and from.
   *
   * ```typescript
   * trigger("myAnimationTrigger", [
   *  // define states
   *  state("on", style({ background: "green" })),
   *  state("off", style({ background: "grey" })),
   *  ...]
   * ```
   *
   * Note that when you call the `sequence()` function within a `{@link animations/group group()}`
   * or a `transition()` call, execution does not continue to the next instruction
   * until each of the inner animation steps have completed.
   *
   * ### Syntax examples
   *
   * The following examples define transitions between the two defined states (and default states),
   * using various options:
   *
   * ```typescript
   * // Transition occurs when the state value
   * // bound to "myAnimationTrigger" changes from "on" to "off"
   * transition("on => off", animate(500))
   * // Run the same animation for both directions
   * transition("on <=> off", animate(500))
   * // Define multiple state-change pairs separated by commas
   * transition("on => off, off => void", animate(500))
   * ```
   *
   * ### Special values for state-change expressions
   *
   * - Catch-all state change for when an element is inserted into the page and the
   * destination state is unknown:
   *
   * ```typescript
   * transition("void => *", [
   *  style({ opacity: 0 }),
   *  animate(500)
   *  ])
   * ```
   *
   * - Capture a state change between any states:
   *
   *  `transition("* => *", animate("1s 0s"))`
   *
   * - Entry and exit transitions:
   *
   * ```typescript
   * transition(":enter", [
   *   style({ opacity: 0 }),
   *   animate(500, style({ opacity: 1 }))
   *   ]),
   * transition(":leave", [
   *   animate(500, style({ opacity: 0 }))
   *   ])
   * ```
   *
   * - Use `:increment` and `:decrement` to initiate transitions:
   *
   * ```typescript
   * transition(":increment", group([
   *  query(':enter', [
   *     style({ left: '100%' }),
   *     animate('0.5s ease-out', style('*'))
   *   ]),
   *  query(':leave', [
   *     animate('0.5s ease-out', style({ left: '-100%' }))
   *  ])
   * ]))
   *
   * transition(":decrement", group([
   *  query(':enter', [
   *     style({ left: '100%' }),
   *     animate('0.5s ease-out', style('*'))
   *   ]),
   *  query(':leave', [
   *     animate('0.5s ease-out', style({ left: '-100%' }))
   *  ])
   * ]))
   * ```
   *
   * ### State-change functions
   *
   * Here is an example of a `fromState` specified as a state-change function that invokes an
   * animation when true:
   *
   * ```typescript
   * transition((fromState, toState) =>
   *  {
   *   return fromState == "off" && toState == "on";
   *  },
   *  animate("1s 0s"))
   * ```
   *
   * ### Animating to the final state
   *
   * If the final step in a transition is a call to `animate()` that uses a timing value
   * with no style data, that step is automatically considered the final animation arc,
   * for the element to reach the final state. Angular automatically adds or removes
   * CSS styles to ensure that the element is in the correct final state.
   *
   * The following example defines a transition that starts by hiding the element,
   * then makes sure that it animates properly to whatever state is currently active for trigger:
   *
   * ```typescript
   * transition("void => *", [
   *   style({ opacity: 0 }),
   *   animate(500)
   *  ])
   * ```
   * ### Boolean value matching
   * If a trigger binding value is a Boolean, it can be matched using a transition expression
   * that compares true and false or 1 and 0. For example:
   *
   * ```
   * // in the template
   * <div [@openClose]="open ? true : false">...</div>
   * // in the component metadata
   * trigger('openClose', [
   *   state('true', style({ height: '*' })),
   *   state('false', style({ height: '0px' })),
   *   transition('false <=> true', animate(500))
   * ])
   * ```
   *
   * @publicApi
   **/
  function transition(stateChangeExpr, steps, options) {
      if (options === void 0) {
          options = null;
      }
      return { type: 1 /* Transition */, expr: stateChangeExpr, animation: steps, options: options };
  }
  /**
   * Executes a queried inner animation element within an animation sequence.
   *
   * @param options An options object that can contain a delay value for the start of the
   * animation, and additional override values for developer-defined parameters.
   * @return An object that encapsulates the child animation data.
   *
   * @usageNotes
   * Each time an animation is triggered in Angular, the parent animation
   * has priority and any child animations are blocked. In order
   * for a child animation to run, the parent animation must query each of the elements
   * containing child animations, and run them using this function.
   *
   * Note that this feature designed to be used with `query()` and it will only work
   * with animations that are assigned using the Angular animation library. CSS keyframes
   * and transitions are not handled by this API.
   *
   * @publicApi
   */
  function animateChild(options) {
      if (options === void 0) {
          options = null;
      }
      return { type: 9 /* AnimateChild */, options: options };
  }
  /**
   * Finds one or more inner elements within the current element that is
   * being animated within a sequence. Use with `animate()`.
   *
   * @param selector The element to query, or a set of elements that contain Angular-specific
   * characteristics, specified with one or more of the following tokens.
   *  - `query(":enter")` or `query(":leave")` : Query for newly inserted/removed elements.
   *  - `query(":animating")` : Query all currently animating elements.
   *  - `query("@triggerName")` : Query elements that contain an animation trigger.
   *  - `query("@*")` : Query all elements that contain an animation triggers.
   *  - `query(":self")` : Include the current element into the animation sequence.
   *
   * @param animation One or more animation steps to apply to the queried element or elements.
   * An array is treated as an animation sequence.
   * @param options An options object. Use the 'limit' field to limit the total number of
   * items to collect.
   * @return An object that encapsulates the query data.
   *
   * @usageNotes
   * Tokens can be merged into a combined query selector string. For example:
   *
   * ```typescript
   *  query(':self, .record:enter, .record:leave, @subTrigger', [...])
   * ```
   *
   * The `query()` function collects multiple elements and works internally by using
   * `element.querySelectorAll`. Use the `limit` field of an options object to limit
   * the total number of items to be collected. For example:
   *
   * ```js
   * query('div', [
   *   animate(...),
   *   animate(...)
   * ], { limit: 1 })
   * ```
   *
   * By default, throws an error when zero items are found. Set the
   * `optional` flag to ignore this error. For example:
   *
   * ```js
   * query('.some-element-that-may-not-be-there', [
   *   animate(...),
   *   animate(...)
   * ], { optional: true })
   * ```
   *
   * ### Usage Example
   *
   * The following example queries for inner elements and animates them
   * individually using `animate()`.
   *
   * ```typescript
   * @Component({
   *   selector: 'inner',
   *   template: `
   *     <div [@queryAnimation]="exp">
   *       <h1>Title</h1>
   *       <div class="content">
   *         Blah blah blah
   *       </div>
   *     </div>
   *   `,
   *   animations: [
   *    trigger('queryAnimation', [
   *      transition('* => goAnimate', [
   *        // hide the inner elements
   *        query('h1', style({ opacity: 0 })),
   *        query('.content', style({ opacity: 0 })),
   *
   *        // animate the inner elements in, one by one
   *        query('h1', animate(1000, style({ opacity: 1 })),
   *        query('.content', animate(1000, style({ opacity: 1 })),
   *      ])
   *    ])
   *  ]
   * })
   * class Cmp {
   *   exp = '';
   *
   *   goAnimate() {
   *     this.exp = 'goAnimate';
   *   }
   * }
   * ```
   *
   * @publicApi
   */
  function query(selector, animation, options) {
      if (options === void 0) {
          options = null;
      }
      return { type: 11 /* Query */, selector: selector, animation: animation, options: options };
  }

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var nextUniqueId$1 = 0;
  /**
   * Single error message to be shown underneath the form field.
   */
  var MatError = /** @class */ (function () {
      function MatError() {
          this.id = "mat-error-" + nextUniqueId$1++;
      }
      MatError.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-error',
                      host: {
                          'class': 'mat-error',
                          'role': 'alert',
                          '[attr.id]': 'id',
                      }
                  },] },
      ];
      MatError.propDecorators = {
          id: [{ type: core.Input }]
      };
      return MatError;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Animations used by the MatFormField.
   * \@docs-private
   * @type {?}
   */
  var matFormFieldAnimations = {
      /**
       * Animation that transitions the form field's error and hint messages.
       */
      transitionMessages: trigger('transitionMessages', [
          // TODO(mmalerba): Use angular animations for label animation as well.
          state('enter', style({ opacity: 1, transform: 'translateY(0%)' })),
          transition('void => enter', [
              style({ opacity: 0, transform: 'translateY(-100%)' }),
              animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)'),
          ]),
      ])
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * An interface which allows a control to work inside of a `MatFormField`.
   * @abstract
   * @template T
   */
  var /**
   * An interface which allows a control to work inside of a `MatFormField`.
   * @abstract
   * @template T
   */ MatFormFieldControl = /** @class */ (function () {
      function MatFormFieldControl() {
      }
      return MatFormFieldControl;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@docs-private
   * @return {?}
   */
  function getMatFormFieldPlaceholderConflictError() {
      return Error('Placeholder attribute and child element were both specified.');
  }
  /**
   * \@docs-private
   * @param {?} align
   * @return {?}
   */
  function getMatFormFieldDuplicatedHintError(align) {
      return Error("A hint was already declared for 'align=\"" + align + "\"'.");
  }
  /**
   * \@docs-private
   * @return {?}
   */
  function getMatFormFieldMissingControlError() {
      return Error('mat-form-field must contain a MatFormFieldControl.');
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var nextUniqueId$1$1 = 0;
  /**
   * Hint text to be shown underneath the form field control.
   */
  var MatHint = /** @class */ (function () {
      function MatHint() {
          /**
           * Whether to align the hint label at the start or end of the line.
           */
          this.align = 'start';
          /**
           * Unique ID for the hint. Used for the aria-describedby on the form field control.
           */
          this.id = "mat-hint-" + nextUniqueId$1$1++;
      }
      MatHint.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-hint',
                      host: {
                          'class': 'mat-hint',
                          '[class.mat-right]': 'align == "end"',
                          '[attr.id]': 'id',
                          // Remove align attribute to prevent it from interfering with layout.
                          '[attr.align]': 'null',
                      }
                  },] },
      ];
      MatHint.propDecorators = {
          align: [{ type: core.Input }],
          id: [{ type: core.Input }]
      };
      return MatHint;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * The floating label for a `mat-form-field`.
   */
  var MatLabel = /** @class */ (function () {
      function MatLabel() {
      }
      MatLabel.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-label'
                  },] },
      ];
      return MatLabel;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * The placeholder text for an `MatFormField`.
   * @deprecated Use `<mat-label>` to specify the label and the `placeholder` attribute to specify the
   *     placeholder.
   * \@breaking-change 8.0.0
   */
  var MatPlaceholder = /** @class */ (function () {
      function MatPlaceholder() {
      }
      MatPlaceholder.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-placeholder'
                  },] },
      ];
      return MatPlaceholder;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Prefix to be placed in front of the form field.
   */
  var MatPrefix = /** @class */ (function () {
      function MatPrefix() {
      }
      MatPrefix.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matPrefix]',
                  },] },
      ];
      return MatPrefix;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Suffix to be placed at the end of the form field.
   */
  var MatSuffix = /** @class */ (function () {
      function MatSuffix() {
      }
      MatSuffix.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matSuffix]',
                  },] },
      ];
      return MatSuffix;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var nextUniqueId$2 = 0;
  /** @type {?} */
  var floatingLabelScale = 0.75;
  /** @type {?} */
  var outlineGapPadding = 5;
  /**
   * Boilerplate for applying mixins to MatFormField.
   * \@docs-private
   */
  var /**
   * Boilerplate for applying mixins to MatFormField.
   * \@docs-private
   */ MatFormFieldBase = /** @class */ (function () {
      function MatFormFieldBase(_elementRef) {
          this._elementRef = _elementRef;
      }
      return MatFormFieldBase;
  }());
  /**
   * Base class to which we're applying the form field mixins.
   * \@docs-private
   * @type {?}
   */
  var _MatFormFieldMixinBase = mixinColor(MatFormFieldBase, 'primary');
  /**
   * Injection token that can be used to configure the
   * default options for all form field within an app.
   * @type {?}
   */
  var MAT_FORM_FIELD_DEFAULT_OPTIONS = new core.InjectionToken('MAT_FORM_FIELD_DEFAULT_OPTIONS');
  /**
   * Container for form controls that applies Material Design styling and behavior.
   */
  var MatFormField = /** @class */ (function (_super) {
      tslib_1.__extends(MatFormField, _super);
      function MatFormField(_elementRef, _changeDetectorRef, labelOptions, _dir, _defaults, _platform, _ngZone, _animationMode) {
          var _this = _super.call(this, _elementRef) || this;
          _this._elementRef = _elementRef;
          _this._changeDetectorRef = _changeDetectorRef;
          _this._dir = _dir;
          _this._defaults = _defaults;
          _this._platform = _platform;
          _this._ngZone = _ngZone;
          /**
           * Whether the outline gap needs to be calculated
           * immediately on the next change detection run.
           */
          _this._outlineGapCalculationNeededImmediately = false;
          /**
           * Whether the outline gap needs to be calculated next time the zone has stabilized.
           */
          _this._outlineGapCalculationNeededOnStable = false;
          _this._destroyed = new rxjs.Subject();
          /**
           * Override for the logic that disables the label animation in certain cases.
           */
          _this._showAlwaysAnimate = false;
          /**
           * State of the mat-hint and mat-error animations.
           */
          _this._subscriptAnimationState = '';
          _this._hintLabel = '';
          // Unique id for the hint label.
          _this._hintLabelId = "mat-hint-" + nextUniqueId$2++;
          // Unique id for the internal form field label.
          _this._labelId = "mat-form-field-label-" + nextUniqueId$2++;
          _this._labelOptions = labelOptions ? labelOptions : {};
          _this.floatLabel = _this._labelOptions.float || 'auto';
          _this._animationsEnabled = _animationMode !== 'NoopAnimations';
          // Set the default through here so we invoke the setter on the first run.
          _this.appearance = (_defaults && _defaults.appearance) ? _defaults.appearance : 'legacy';
          return _this;
      }
      Object.defineProperty(MatFormField.prototype, "appearance", {
          /** The form-field appearance style. */
          get: /**
           * The form-field appearance style.
           * @return {?}
           */ function () { return this._appearance; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var oldValue = this._appearance;
              this._appearance = value || (this._defaults && this._defaults.appearance) || 'legacy';
              if (this._appearance === 'outline' && oldValue !== value) {
                  this._updateOutlineGapOnStable();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatFormField.prototype, "hideRequiredMarker", {
          /** Whether the required marker should be hidden. */
          get: /**
           * Whether the required marker should be hidden.
           * @return {?}
           */ function () { return this._hideRequiredMarker; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._hideRequiredMarker = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatFormField.prototype, "_shouldAlwaysFloat", {
          /** Whether the floating label should always float or not. */
          get: /**
           * Whether the floating label should always float or not.
           * @return {?}
           */ function () {
              return this.floatLabel === 'always' && !this._showAlwaysAnimate;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatFormField.prototype, "_canLabelFloat", {
          /** Whether the label can float or not. */
          get: /**
           * Whether the label can float or not.
           * @return {?}
           */ function () { return this.floatLabel !== 'never'; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatFormField.prototype, "hintLabel", {
          /** Text for the form field hint. */
          get: /**
           * Text for the form field hint.
           * @return {?}
           */ function () { return this._hintLabel; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._hintLabel = value;
              this._processHints();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatFormField.prototype, "floatLabel", {
          /**
           * Whether the label should always float, never float or float as the user types.
           *
           * Note: only the legacy appearance supports the `never` option. `never` was originally added as a
           * way to make the floating label emulate the behavior of a standard input placeholder. However
           * the form field now supports both floating labels and placeholders. Therefore in the non-legacy
           * appearances the `never` option has been disabled in favor of just using the placeholder.
           */
          get: /**
           * Whether the label should always float, never float or float as the user types.
           *
           * Note: only the legacy appearance supports the `never` option. `never` was originally added as a
           * way to make the floating label emulate the behavior of a standard input placeholder. However
           * the form field now supports both floating labels and placeholders. Therefore in the non-legacy
           * appearances the `never` option has been disabled in favor of just using the placeholder.
           * @return {?}
           */ function () {
              return this.appearance !== 'legacy' && this._floatLabel === 'never' ? 'auto' : this._floatLabel;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (value !== this._floatLabel) {
                  this._floatLabel = value || this._labelOptions.float || 'auto';
                  this._changeDetectorRef.markForCheck();
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Gets an ElementRef for the element that a overlay attached to the form-field should be
       * positioned relative to.
       */
      /**
       * Gets an ElementRef for the element that a overlay attached to the form-field should be
       * positioned relative to.
       * @return {?}
       */
      MatFormField.prototype.getConnectedOverlayOrigin = /**
       * Gets an ElementRef for the element that a overlay attached to the form-field should be
       * positioned relative to.
       * @return {?}
       */
          function () {
              return this._connectionContainerRef || this._elementRef;
          };
      /**
       * @return {?}
       */
      MatFormField.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._validateControlChild();
              /** @type {?} */
              var control = this._control;
              if (control.controlType) {
                  this._elementRef.nativeElement.classList.add("mat-form-field-type-" + control.controlType);
              }
              // Subscribe to changes in the child control state in order to update the form field UI.
              control.stateChanges.pipe(operators.startWith(( /** @type {?} */(null)))).subscribe(function () {
                  _this._validatePlaceholders();
                  _this._syncDescribedByIds();
                  _this._changeDetectorRef.markForCheck();
              });
              // Run change detection if the value changes.
              if (control.ngControl && control.ngControl.valueChanges) {
                  control.ngControl.valueChanges
                      .pipe(operators.takeUntil(this._destroyed))
                      .subscribe(function () { return _this._changeDetectorRef.markForCheck(); });
              }
              // @breaking-change 7.0.0 Remove this check once _ngZone is required. Also reconsider
              // whether the `ngAfterContentChecked` below is still necessary.
              if (this._ngZone) {
                  this._ngZone.onStable.asObservable().pipe(operators.takeUntil(this._destroyed)).subscribe(function () {
                      if (_this._outlineGapCalculationNeededOnStable) {
                          _this.updateOutlineGap();
                      }
                  });
              }
              // Run change detection and update the outline if the suffix or prefix changes.
              rxjs.merge(this._prefixChildren.changes, this._suffixChildren.changes).subscribe(function () {
                  _this._updateOutlineGapOnStable();
                  _this._changeDetectorRef.markForCheck();
              });
              // Re-validate when the number of hints changes.
              this._hintChildren.changes.pipe(operators.startWith(null)).subscribe(function () {
                  _this._processHints();
                  _this._changeDetectorRef.markForCheck();
              });
              // Update the aria-described by when the number of errors changes.
              this._errorChildren.changes.pipe(operators.startWith(null)).subscribe(function () {
                  _this._syncDescribedByIds();
                  _this._changeDetectorRef.markForCheck();
              });
              if (this._dir) {
                  this._dir.change.pipe(operators.takeUntil(this._destroyed)).subscribe(function () { return _this.updateOutlineGap(); });
              }
          };
      /**
       * @return {?}
       */
      MatFormField.prototype.ngAfterContentChecked = /**
       * @return {?}
       */
          function () {
              this._validateControlChild();
              if (this._outlineGapCalculationNeededImmediately) {
                  this.updateOutlineGap();
              }
          };
      /**
       * @return {?}
       */
      MatFormField.prototype.ngAfterViewInit = /**
       * @return {?}
       */
          function () {
              // Avoid animations on load.
              this._subscriptAnimationState = 'enter';
              this._changeDetectorRef.detectChanges();
          };
      /**
       * @return {?}
       */
      MatFormField.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._destroyed.next();
              this._destroyed.complete();
          };
      /** Determines whether a class from the NgControl should be forwarded to the host element. */
      /**
       * Determines whether a class from the NgControl should be forwarded to the host element.
       * @param {?} prop
       * @return {?}
       */
      MatFormField.prototype._shouldForward = /**
       * Determines whether a class from the NgControl should be forwarded to the host element.
       * @param {?} prop
       * @return {?}
       */
          function (prop) {
              /** @type {?} */
              var ngControl = this._control ? this._control.ngControl : null;
              return ngControl && ngControl[prop];
          };
      /**
       * @return {?}
       */
      MatFormField.prototype._hasPlaceholder = /**
       * @return {?}
       */
          function () {
              return !!(this._control && this._control.placeholder || this._placeholderChild);
          };
      /**
       * @return {?}
       */
      MatFormField.prototype._hasLabel = /**
       * @return {?}
       */
          function () {
              return !!this._labelChild;
          };
      /**
       * @return {?}
       */
      MatFormField.prototype._shouldLabelFloat = /**
       * @return {?}
       */
          function () {
              return this._canLabelFloat && (this._control.shouldLabelFloat || this._shouldAlwaysFloat);
          };
      /**
       * @return {?}
       */
      MatFormField.prototype._hideControlPlaceholder = /**
       * @return {?}
       */
          function () {
              // In the legacy appearance the placeholder is promoted to a label if no label is given.
              return this.appearance === 'legacy' && !this._hasLabel() ||
                  this._hasLabel() && !this._shouldLabelFloat();
          };
      /**
       * @return {?}
       */
      MatFormField.prototype._hasFloatingLabel = /**
       * @return {?}
       */
          function () {
              // In the legacy appearance the placeholder is promoted to a label if no label is given.
              return this._hasLabel() || this.appearance === 'legacy' && this._hasPlaceholder();
          };
      /** Determines whether to display hints or errors. */
      /**
       * Determines whether to display hints or errors.
       * @return {?}
       */
      MatFormField.prototype._getDisplayedMessages = /**
       * Determines whether to display hints or errors.
       * @return {?}
       */
          function () {
              return (this._errorChildren && this._errorChildren.length > 0 &&
                  this._control.errorState) ? 'error' : 'hint';
          };
      /** Animates the placeholder up and locks it in position. */
      /**
       * Animates the placeholder up and locks it in position.
       * @return {?}
       */
      MatFormField.prototype._animateAndLockLabel = /**
       * Animates the placeholder up and locks it in position.
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._hasFloatingLabel() && this._canLabelFloat) {
                  // If animations are disabled, we shouldn't go in here,
                  // because the `transitionend` will never fire.
                  if (this._animationsEnabled) {
                      this._showAlwaysAnimate = true;
                      rxjs.fromEvent(this._label.nativeElement, 'transitionend').pipe(operators.take(1)).subscribe(function () {
                          _this._showAlwaysAnimate = false;
                      });
                  }
                  this.floatLabel = 'always';
                  this._changeDetectorRef.markForCheck();
              }
          };
      /**
       * Ensure that there is only one placeholder (either `placeholder` attribute on the child control
       * or child element with the `mat-placeholder` directive).
       */
      /**
       * Ensure that there is only one placeholder (either `placeholder` attribute on the child control
       * or child element with the `mat-placeholder` directive).
       * @private
       * @return {?}
       */
      MatFormField.prototype._validatePlaceholders = /**
       * Ensure that there is only one placeholder (either `placeholder` attribute on the child control
       * or child element with the `mat-placeholder` directive).
       * @private
       * @return {?}
       */
          function () {
              if (this._control.placeholder && this._placeholderChild) {
                  throw getMatFormFieldPlaceholderConflictError();
              }
          };
      /** Does any extra processing that is required when handling the hints. */
      /**
       * Does any extra processing that is required when handling the hints.
       * @private
       * @return {?}
       */
      MatFormField.prototype._processHints = /**
       * Does any extra processing that is required when handling the hints.
       * @private
       * @return {?}
       */
          function () {
              this._validateHints();
              this._syncDescribedByIds();
          };
      /**
       * Ensure that there is a maximum of one of each `<mat-hint>` alignment specified, with the
       * attribute being considered as `align="start"`.
       */
      /**
       * Ensure that there is a maximum of one of each `<mat-hint>` alignment specified, with the
       * attribute being considered as `align="start"`.
       * @private
       * @return {?}
       */
      MatFormField.prototype._validateHints = /**
       * Ensure that there is a maximum of one of each `<mat-hint>` alignment specified, with the
       * attribute being considered as `align="start"`.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._hintChildren) {
                  /** @type {?} */
                  var startHint_1;
                  /** @type {?} */
                  var endHint_1;
                  this._hintChildren.forEach(function (hint) {
                      if (hint.align === 'start') {
                          if (startHint_1 || _this.hintLabel) {
                              throw getMatFormFieldDuplicatedHintError('start');
                          }
                          startHint_1 = hint;
                      }
                      else if (hint.align === 'end') {
                          if (endHint_1) {
                              throw getMatFormFieldDuplicatedHintError('end');
                          }
                          endHint_1 = hint;
                      }
                  });
              }
          };
      /**
       * Sets the list of element IDs that describe the child control. This allows the control to update
       * its `aria-describedby` attribute accordingly.
       */
      /**
       * Sets the list of element IDs that describe the child control. This allows the control to update
       * its `aria-describedby` attribute accordingly.
       * @private
       * @return {?}
       */
      MatFormField.prototype._syncDescribedByIds = /**
       * Sets the list of element IDs that describe the child control. This allows the control to update
       * its `aria-describedby` attribute accordingly.
       * @private
       * @return {?}
       */
          function () {
              if (this._control) {
                  /** @type {?} */
                  var ids = [];
                  if (this._getDisplayedMessages() === 'hint') {
                      /** @type {?} */
                      var startHint = this._hintChildren ?
                          this._hintChildren.find(function (hint) { return hint.align === 'start'; }) : null;
                      /** @type {?} */
                      var endHint = this._hintChildren ?
                          this._hintChildren.find(function (hint) { return hint.align === 'end'; }) : null;
                      if (startHint) {
                          ids.push(startHint.id);
                      }
                      else if (this._hintLabel) {
                          ids.push(this._hintLabelId);
                      }
                      if (endHint) {
                          ids.push(endHint.id);
                      }
                  }
                  else if (this._errorChildren) {
                      ids = this._errorChildren.map(function (error) { return error.id; });
                  }
                  this._control.setDescribedByIds(ids);
              }
          };
      /** Throws an error if the form field's control is missing. */
      /**
       * Throws an error if the form field's control is missing.
       * @protected
       * @return {?}
       */
      MatFormField.prototype._validateControlChild = /**
       * Throws an error if the form field's control is missing.
       * @protected
       * @return {?}
       */
          function () {
              if (!this._control) {
                  throw getMatFormFieldMissingControlError();
              }
          };
      /**
       * Updates the width and position of the gap in the outline. Only relevant for the outline
       * appearance.
       */
      /**
       * Updates the width and position of the gap in the outline. Only relevant for the outline
       * appearance.
       * @return {?}
       */
      MatFormField.prototype.updateOutlineGap = /**
       * Updates the width and position of the gap in the outline. Only relevant for the outline
       * appearance.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var labelEl = this._label ? this._label.nativeElement : null;
              if (this.appearance !== 'outline' || !labelEl || !labelEl.children.length ||
                  !labelEl.textContent.trim()) {
                  return;
              }
              if (this._platform && !this._platform.isBrowser) {
                  // getBoundingClientRect isn't available on the server.
                  return;
              }
              // If the element is not present in the DOM, the outline gap will need to be calculated
              // the next time it is checked and in the DOM.
              if (!( /** @type {?} */(document.documentElement)).contains(this._elementRef.nativeElement)) {
                  this._outlineGapCalculationNeededImmediately = true;
                  return;
              }
              /** @type {?} */
              var startWidth = 0;
              /** @type {?} */
              var gapWidth = 0;
              /** @type {?} */
              var container = this._connectionContainerRef.nativeElement;
              /** @type {?} */
              var startEls = container.querySelectorAll('.mat-form-field-outline-start');
              /** @type {?} */
              var gapEls = container.querySelectorAll('.mat-form-field-outline-gap');
              if (this._label && this._label.nativeElement.children.length) {
                  /** @type {?} */
                  var containerRect = container.getBoundingClientRect();
                  // If the container's width and height are zero, it means that the element is
                  // invisible and we can't calculate the outline gap. Mark the element as needing
                  // to be checked the next time the zone stabilizes. We can't do this immediately
                  // on the next change detection, because even if the element becomes visible,
                  // the `ClientRect` won't be reclaculated immediately. We reset the
                  // `_outlineGapCalculationNeededImmediately` flag some we don't run the checks twice.
                  if (containerRect.width === 0 && containerRect.height === 0) {
                      this._outlineGapCalculationNeededOnStable = true;
                      this._outlineGapCalculationNeededImmediately = false;
                      return;
                  }
                  /** @type {?} */
                  var containerStart = this._getStartEnd(containerRect);
                  /** @type {?} */
                  var labelStart = this._getStartEnd(labelEl.children[0].getBoundingClientRect());
                  /** @type {?} */
                  var labelWidth = 0;
                  for (var _i = 0, _a = labelEl.children; _i < _a.length; _i++) {
                      var child = _a[_i];
                      labelWidth += child.offsetWidth;
                  }
                  startWidth = labelStart - containerStart - outlineGapPadding;
                  gapWidth = labelWidth > 0 ? labelWidth * floatingLabelScale + outlineGapPadding * 2 : 0;
              }
              for (var i = 0; i < startEls.length; i++) {
                  startEls.item(i).style.width = startWidth + "px";
              }
              for (var i = 0; i < gapEls.length; i++) {
                  gapEls.item(i).style.width = gapWidth + "px";
              }
              this._outlineGapCalculationNeededOnStable =
                  this._outlineGapCalculationNeededImmediately = false;
          };
      /** Gets the start end of the rect considering the current directionality. */
      /**
       * Gets the start end of the rect considering the current directionality.
       * @private
       * @param {?} rect
       * @return {?}
       */
      MatFormField.prototype._getStartEnd = /**
       * Gets the start end of the rect considering the current directionality.
       * @private
       * @param {?} rect
       * @return {?}
       */
          function (rect) {
              return this._dir && this._dir.value === 'rtl' ? rect.right : rect.left;
          };
      /**
       * Updates the outline gap the new time the zone stabilizes.
       * @breaking-change 7.0.0 Remove this method and only set the property once `_ngZone` is required.
       */
      /**
       * Updates the outline gap the new time the zone stabilizes.
       * \@breaking-change 7.0.0 Remove this method and only set the property once `_ngZone` is required.
       * @private
       * @return {?}
       */
      MatFormField.prototype._updateOutlineGapOnStable = /**
       * Updates the outline gap the new time the zone stabilizes.
       * \@breaking-change 7.0.0 Remove this method and only set the property once `_ngZone` is required.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              // @breaking-change 8.0.0 Remove this check and else block once _ngZone is required.
              if (this._ngZone) {
                  this._outlineGapCalculationNeededOnStable = true;
              }
              else {
                  Promise.resolve().then(function () { return _this.updateOutlineGap(); });
              }
          };
      MatFormField.decorators = [
          { type: core.Component, args: [{ selector: 'mat-form-field',
                      exportAs: 'matFormField',
                      template: "<div class=\"mat-form-field-wrapper\"><div class=\"mat-form-field-flex\" #connectionContainer (click)=\"_control.onContainerClick && _control.onContainerClick($event)\"><ng-container *ngIf=\"appearance == 'outline'\"><div class=\"mat-form-field-outline\"><div class=\"mat-form-field-outline-start\"></div><div class=\"mat-form-field-outline-gap\"></div><div class=\"mat-form-field-outline-end\"></div></div><div class=\"mat-form-field-outline mat-form-field-outline-thick\"><div class=\"mat-form-field-outline-start\"></div><div class=\"mat-form-field-outline-gap\"></div><div class=\"mat-form-field-outline-end\"></div></div></ng-container><div class=\"mat-form-field-prefix\" *ngIf=\"_prefixChildren.length\"><ng-content select=\"[matPrefix]\"></ng-content></div><div class=\"mat-form-field-infix\" #inputContainer><ng-content></ng-content><span class=\"mat-form-field-label-wrapper\"><label class=\"mat-form-field-label\" (cdkObserveContent)=\"updateOutlineGap()\" [cdkObserveContentDisabled]=\"appearance != 'outline'\" [id]=\"_labelId\" [attr.for]=\"_control.id\" [attr.aria-owns]=\"_control.id\" [class.mat-empty]=\"_control.empty && !_shouldAlwaysFloat\" [class.mat-form-field-empty]=\"_control.empty && !_shouldAlwaysFloat\" [class.mat-accent]=\"color == 'accent'\" [class.mat-warn]=\"color == 'warn'\" #label *ngIf=\"_hasFloatingLabel()\" [ngSwitch]=\"_hasLabel()\"><ng-container *ngSwitchCase=\"false\"><ng-content select=\"mat-placeholder\"></ng-content>{{_control.placeholder}}</ng-container><ng-content select=\"mat-label\" *ngSwitchCase=\"true\"></ng-content><span class=\"mat-placeholder-required mat-form-field-required-marker\" aria-hidden=\"true\" *ngIf=\"!hideRequiredMarker && _control.required && !_control.disabled\">&nbsp;*</span></label></span></div><div class=\"mat-form-field-suffix\" *ngIf=\"_suffixChildren.length\"><ng-content select=\"[matSuffix]\"></ng-content></div></div><div class=\"mat-form-field-underline\" #underline *ngIf=\"appearance != 'outline'\"><span class=\"mat-form-field-ripple\" [class.mat-accent]=\"color == 'accent'\" [class.mat-warn]=\"color == 'warn'\"></span></div><div class=\"mat-form-field-subscript-wrapper\" [ngSwitch]=\"_getDisplayedMessages()\"><div *ngSwitchCase=\"'error'\" [@transitionMessages]=\"_subscriptAnimationState\"><ng-content select=\"mat-error\"></ng-content></div><div class=\"mat-form-field-hint-wrapper\" *ngSwitchCase=\"'hint'\" [@transitionMessages]=\"_subscriptAnimationState\"><div *ngIf=\"hintLabel\" [id]=\"_hintLabelId\" class=\"mat-hint\">{{hintLabel}}</div><ng-content select=\"mat-hint:not([align='end'])\"></ng-content><div class=\"mat-form-field-hint-spacer\"></div><ng-content select=\"mat-hint[align='end']\"></ng-content></div></div></div>",
                      // MatInput is a directive and can't have styles, so we need to include its styles here
                      // in form-field-input.css. The MatInput styles are fairly minimal so it shouldn't be a
                      // big deal for people who aren't using MatInput.
                      styles: [".mat-form-field{display:inline-block;position:relative;text-align:left}[dir=rtl] .mat-form-field{text-align:right}.mat-form-field-wrapper{position:relative}.mat-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-form-field-prefix,.mat-form-field-suffix{white-space:nowrap;flex:none;position:relative}.mat-form-field-infix{display:block;position:relative;flex:auto;min-width:0;width:180px}@media (-ms-high-contrast:active){.mat-form-field-infix{border-image:linear-gradient(transparent,transparent)}}.mat-form-field-label-wrapper{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;overflow:hidden;pointer-events:none}[dir=rtl] .mat-form-field-label-wrapper{left:auto;right:0}.mat-form-field-label{position:absolute;left:0;font:inherit;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform-origin:0 0;transition:transform .4s cubic-bezier(.25,.8,.25,1),color .4s cubic-bezier(.25,.8,.25,1),width .4s cubic-bezier(.25,.8,.25,1);display:none}[dir=rtl] .mat-form-field-label{transform-origin:100% 0;left:auto;right:0}.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-empty.mat-form-field-label{display:block}.mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:block;transition:none}.mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-can-float .mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:block}.mat-form-field-label:not(.mat-form-field-empty){transition:none}.mat-form-field-underline{position:absolute;width:100%;pointer-events:none;transform:scaleY(1.0001)}.mat-form-field-ripple{position:absolute;left:0;width:100%;transform-origin:50%;transform:scaleX(.5);opacity:0;transition:background-color .3s cubic-bezier(.55,0,.55,.2)}.mat-form-field.mat-focused .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple{opacity:1;transform:scaleX(1);transition:transform .3s cubic-bezier(.25,.8,.25,1),opacity .1s cubic-bezier(.25,.8,.25,1),background-color .3s cubic-bezier(.25,.8,.25,1)}.mat-form-field-subscript-wrapper{position:absolute;box-sizing:border-box;width:100%;overflow:hidden}.mat-form-field-label-wrapper .mat-icon,.mat-form-field-subscript-wrapper .mat-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.mat-form-field-hint-wrapper{display:flex}.mat-form-field-hint-spacer{flex:1 0 1em}.mat-error{display:block}.mat-form-field-control-wrapper{position:relative}.mat-form-field._mat-animation-noopable .mat-form-field-label,.mat-form-field._mat-animation-noopable .mat-form-field-ripple{transition:none} .mat-form-field-appearance-fill .mat-form-field-flex{border-radius:4px 4px 0 0;padding:.75em .75em 0 .75em}@media (-ms-high-contrast:active){.mat-form-field-appearance-fill .mat-form-field-flex{outline:solid 1px}}.mat-form-field-appearance-fill .mat-form-field-underline::before{content:'';display:block;position:absolute;bottom:0;height:1px;width:100%}.mat-form-field-appearance-fill .mat-form-field-ripple{bottom:0;height:2px}@media (-ms-high-contrast:active){.mat-form-field-appearance-fill .mat-form-field-ripple{height:0;border-top:solid 2px}}.mat-form-field-appearance-fill:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity .6s cubic-bezier(.25,.8,.25,1)}.mat-form-field-appearance-fill._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}.mat-form-field-appearance-fill .mat-form-field-subscript-wrapper{padding:0 1em} .mat-input-element{font:inherit;background:0 0;color:currentColor;border:none;outline:0;padding:0;margin:0;width:100%;max-width:100%;vertical-align:bottom;text-align:inherit}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element::-ms-clear,.mat-input-element::-ms-reveal{display:none}.mat-input-element,.mat-input-element::-webkit-search-cancel-button,.mat-input-element::-webkit-search-decoration,.mat-input-element::-webkit-search-results-button,.mat-input-element::-webkit-search-results-decoration{-webkit-appearance:none}.mat-input-element::-webkit-caps-lock-indicator,.mat-input-element::-webkit-contacts-auto-fill-button,.mat-input-element::-webkit-credentials-auto-fill-button{visibility:hidden}.mat-input-element[type=date]::after,.mat-input-element[type=datetime-local]::after,.mat-input-element[type=datetime]::after,.mat-input-element[type=month]::after,.mat-input-element[type=time]::after,.mat-input-element[type=week]::after{content:' ';white-space:pre;width:1px}.mat-input-element::-webkit-calendar-picker-indicator,.mat-input-element::-webkit-clear-button,.mat-input-element::-webkit-inner-spin-button{font-size:.75em}.mat-input-element::placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color .4s .133s cubic-bezier(.25,.8,.25,1)}.mat-input-element::-moz-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color .4s .133s cubic-bezier(.25,.8,.25,1)}.mat-input-element::-webkit-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color .4s .133s cubic-bezier(.25,.8,.25,1)}.mat-input-element:-ms-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color .4s .133s cubic-bezier(.25,.8,.25,1)}.mat-form-field-hide-placeholder .mat-input-element::placeholder{color:transparent!important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{color:transparent!important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{color:transparent!important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{color:transparent!important;-webkit-text-fill-color:transparent;transition:none}textarea.mat-input-element{resize:vertical;overflow:auto}textarea.mat-input-element.cdk-textarea-autosize{resize:none}textarea.mat-input-element{padding:2px 0;margin:-2px 0}select.mat-input-element{-moz-appearance:none;-webkit-appearance:none;position:relative;background-color:transparent;display:inline-flex;box-sizing:border-box;padding-top:1em;top:-1em;margin-bottom:-1em}select.mat-input-element::-ms-expand{display:none}select.mat-input-element::-moz-focus-inner{border:0}select.mat-input-element:not(:disabled){cursor:pointer}select.mat-input-element::-ms-value{color:inherit;background:0 0}.mat-form-field-type-mat-native-select .mat-form-field-infix::after{content:'';width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;position:absolute;top:50%;right:0;margin-top:-2.5px}[dir=rtl] .mat-form-field-type-mat-native-select .mat-form-field-infix::after{right:auto;left:0}.mat-form-field-type-mat-native-select .mat-input-element{padding-right:15px}[dir=rtl] .mat-form-field-type-mat-native-select .mat-input-element{padding-right:0;padding-left:15px}.mat-form-field-type-mat-native-select .mat-form-field-label-wrapper{max-width:calc(100% - 10px)}.mat-form-field-type-mat-native-select.mat-form-field-appearance-outline .mat-form-field-infix::after{margin-top:-5px}.mat-form-field-type-mat-native-select.mat-form-field-appearance-fill .mat-form-field-infix::after{margin-top:-10px} .mat-form-field-appearance-legacy .mat-form-field-label{transform:perspective(100px);-ms-transform:none}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon{width:1em}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button{font:inherit;vertical-align:baseline}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button .mat-icon{font-size:inherit}.mat-form-field-appearance-legacy .mat-form-field-underline{height:1px}@media (-ms-high-contrast:active){.mat-form-field-appearance-legacy .mat-form-field-underline{height:0;border-top:solid 1px}}.mat-form-field-appearance-legacy .mat-form-field-ripple{top:0;height:2px;overflow:hidden}@media (-ms-high-contrast:active){.mat-form-field-appearance-legacy .mat-form-field-ripple{height:0;border-top:solid 2px}}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}@media (-ms-high-contrast:active){.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}}.mat-form-field-appearance-legacy.mat-form-field-invalid:not(.mat-focused) .mat-form-field-ripple{height:1px} .mat-form-field-appearance-outline .mat-form-field-wrapper{margin:.25em 0}.mat-form-field-appearance-outline .mat-form-field-flex{padding:0 .75em 0 .75em;margin-top:-.25em;position:relative}.mat-form-field-appearance-outline .mat-form-field-prefix,.mat-form-field-appearance-outline .mat-form-field-suffix{top:.25em}.mat-form-field-appearance-outline .mat-form-field-outline{display:flex;position:absolute;top:.25em;left:0;right:0;bottom:0;pointer-events:none}.mat-form-field-appearance-outline .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-start{border:1px solid currentColor;min-width:5px}.mat-form-field-appearance-outline .mat-form-field-outline-start{border-radius:5px 0 0 5px;border-right-style:none}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-start{border-right-style:solid;border-left-style:none;border-radius:0 5px 5px 0}.mat-form-field-appearance-outline .mat-form-field-outline-end{border-radius:0 5px 5px 0;border-left-style:none;flex-grow:1}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-end{border-left-style:solid;border-right-style:none;border-radius:5px 0 0 5px}.mat-form-field-appearance-outline .mat-form-field-outline-gap{border-radius:.000001px;border:1px solid currentColor;border-left-style:none;border-right-style:none}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-outline-gap{border-top-color:transparent}.mat-form-field-appearance-outline .mat-form-field-outline-thick{opacity:0}.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-gap,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-start{border-width:2px;transition:border-color .3s cubic-bezier(.25,.8,.25,1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline{opacity:0;transition:opacity .1s cubic-bezier(.25,.8,.25,1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline{opacity:0;transition:opacity .6s cubic-bezier(.25,.8,.25,1)}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{padding:0 1em}.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-end,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-gap,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-start,.mat-form-field-appearance-outline._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-outline{transition:none} .mat-form-field-appearance-standard .mat-form-field-flex{padding-top:.75em}.mat-form-field-appearance-standard .mat-form-field-underline{height:1px}@media (-ms-high-contrast:active){.mat-form-field-appearance-standard .mat-form-field-underline{height:0;border-top:solid 1px}}.mat-form-field-appearance-standard .mat-form-field-ripple{bottom:0;height:2px}@media (-ms-high-contrast:active){.mat-form-field-appearance-standard .mat-form-field-ripple{height:0;border-top:2px}}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}@media (-ms-high-contrast:active){.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}}.mat-form-field-appearance-standard:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity .6s cubic-bezier(.25,.8,.25,1)}.mat-form-field-appearance-standard._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}"],
                      animations: [matFormFieldAnimations.transitionMessages],
                      host: {
                          'class': 'mat-form-field',
                          '[class.mat-form-field-appearance-standard]': 'appearance == "standard"',
                          '[class.mat-form-field-appearance-fill]': 'appearance == "fill"',
                          '[class.mat-form-field-appearance-outline]': 'appearance == "outline"',
                          '[class.mat-form-field-appearance-legacy]': 'appearance == "legacy"',
                          '[class.mat-form-field-invalid]': '_control.errorState',
                          '[class.mat-form-field-can-float]': '_canLabelFloat',
                          '[class.mat-form-field-should-float]': '_shouldLabelFloat()',
                          '[class.mat-form-field-has-label]': '_hasFloatingLabel()',
                          '[class.mat-form-field-hide-placeholder]': '_hideControlPlaceholder()',
                          '[class.mat-form-field-disabled]': '_control.disabled',
                          '[class.mat-form-field-autofilled]': '_control.autofilled',
                          '[class.mat-focused]': '_control.focused',
                          '[class.mat-accent]': 'color == "accent"',
                          '[class.mat-warn]': 'color == "warn"',
                          '[class.ng-untouched]': '_shouldForward("untouched")',
                          '[class.ng-touched]': '_shouldForward("touched")',
                          '[class.ng-pristine]': '_shouldForward("pristine")',
                          '[class.ng-dirty]': '_shouldForward("dirty")',
                          '[class.ng-valid]': '_shouldForward("valid")',
                          '[class.ng-invalid]': '_shouldForward("invalid")',
                          '[class.ng-pending]': '_shouldForward("pending")',
                          '[class._mat-animation-noopable]': '!_animationsEnabled',
                      },
                      inputs: ['color'],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatFormField.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.ChangeDetectorRef },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_LABEL_GLOBAL_OPTIONS,] }] },
              { type: Directionality, decorators: [{ type: core.Optional }] },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_FORM_FIELD_DEFAULT_OPTIONS,] }] },
              { type: Platform },
              { type: core.NgZone },
              { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] }
          ];
      };
      MatFormField.propDecorators = {
          appearance: [{ type: core.Input }],
          hideRequiredMarker: [{ type: core.Input }],
          hintLabel: [{ type: core.Input }],
          floatLabel: [{ type: core.Input }],
          underlineRef: [{ type: core.ViewChild, args: ['underline',] }],
          _connectionContainerRef: [{ type: core.ViewChild, args: ['connectionContainer',] }],
          _inputContainerRef: [{ type: core.ViewChild, args: ['inputContainer',] }],
          _label: [{ type: core.ViewChild, args: ['label',] }],
          _control: [{ type: core.ContentChild, args: [MatFormFieldControl,] }],
          _placeholderChild: [{ type: core.ContentChild, args: [MatPlaceholder,] }],
          _labelChild: [{ type: core.ContentChild, args: [MatLabel,] }],
          _errorChildren: [{ type: core.ContentChildren, args: [MatError,] }],
          _hintChildren: [{ type: core.ContentChildren, args: [MatHint,] }],
          _prefixChildren: [{ type: core.ContentChildren, args: [MatPrefix,] }],
          _suffixChildren: [{ type: core.ContentChildren, args: [MatSuffix,] }]
      };
      return MatFormField;
  }(_MatFormFieldMixinBase));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Autocomplete IDs need to be unique across components, so this counter exists outside of
   * the component definition.
   * @type {?}
   */
  var _uniqueAutocompleteIdCounter = 0;
  /**
   * Event object that is emitted when an autocomplete option is selected.
   */
  var /**
   * Event object that is emitted when an autocomplete option is selected.
   */ MatAutocompleteSelectedEvent = /** @class */ (function () {
      function MatAutocompleteSelectedEvent(source, option) {
          this.source = source;
          this.option = option;
      }
      return MatAutocompleteSelectedEvent;
  }());
  // Boilerplate for applying mixins to MatAutocomplete.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatAutocomplete.
  /**
   * \@docs-private
   */
  MatAutocompleteBase = /** @class */ (function () {
      function MatAutocompleteBase() {
      }
      return MatAutocompleteBase;
  }());
  /** @type {?} */
  var _MatAutocompleteMixinBase = mixinDisableRipple(MatAutocompleteBase);
  /**
   * Injection token to be used to override the default options for `mat-autocomplete`.
   * @type {?}
   */
  var MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new core.InjectionToken('mat-autocomplete-default-options', {
      providedIn: 'root',
      factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY,
  });
  /**
   * \@docs-private
   * @return {?}
   */
  function MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {
      return { autoActiveFirstOption: false };
  }
  var MatAutocomplete = /** @class */ (function (_super) {
      tslib_1.__extends(MatAutocomplete, _super);
      function MatAutocomplete(_changeDetectorRef, _elementRef, defaults) {
          var _this = _super.call(this) || this;
          _this._changeDetectorRef = _changeDetectorRef;
          _this._elementRef = _elementRef;
          /**
           * Whether the autocomplete panel should be visible, depending on option length.
           */
          _this.showPanel = false;
          _this._isOpen = false;
          /**
           * Function that maps an option's control value to its display value in the trigger.
           */
          _this.displayWith = null;
          /**
           * Event that is emitted whenever an option from the list is selected.
           */
          _this.optionSelected = new core.EventEmitter();
          /**
           * Event that is emitted when the autocomplete panel is opened.
           */
          _this.opened = new core.EventEmitter();
          /**
           * Event that is emitted when the autocomplete panel is closed.
           */
          _this.closed = new core.EventEmitter();
          _this._classList = {};
          /**
           * Unique ID to be used by autocomplete trigger's "aria-owns" property.
           */
          _this.id = "mat-autocomplete-" + _uniqueAutocompleteIdCounter++;
          _this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;
          return _this;
      }
      Object.defineProperty(MatAutocomplete.prototype, "isOpen", {
          /** Whether the autocomplete panel is open. */
          get: /**
           * Whether the autocomplete panel is open.
           * @return {?}
           */ function () { return this._isOpen && this.showPanel; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatAutocomplete.prototype, "autoActiveFirstOption", {
          /**
           * Whether the first option should be highlighted when the autocomplete panel is opened.
           * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.
           */
          get: /**
           * Whether the first option should be highlighted when the autocomplete panel is opened.
           * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.
           * @return {?}
           */ function () { return this._autoActiveFirstOption; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._autoActiveFirstOption = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatAutocomplete.prototype, "classList", {
          /**
           * Takes classes set on the host mat-autocomplete element and applies them to the panel
           * inside the overlay container to allow for easy styling.
           */
          set: /**
           * Takes classes set on the host mat-autocomplete element and applies them to the panel
           * inside the overlay container to allow for easy styling.
           * @param {?} value
           * @return {?}
           */ function (value) {
              var _this = this;
              if (value && value.length) {
                  value.split(' ').forEach(function (className) { return _this._classList[className.trim()] = true; });
                  this._elementRef.nativeElement.className = '';
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatAutocomplete.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this._keyManager = new ActiveDescendantKeyManager(this.options).withWrap();
              // Set the initial visibility state.
              this._setVisibility();
          };
      /**
       * Sets the panel scrollTop. This allows us to manually scroll to display options
       * above or below the fold, as they are not actually being focused when active.
       */
      /**
       * Sets the panel scrollTop. This allows us to manually scroll to display options
       * above or below the fold, as they are not actually being focused when active.
       * @param {?} scrollTop
       * @return {?}
       */
      MatAutocomplete.prototype._setScrollTop = /**
       * Sets the panel scrollTop. This allows us to manually scroll to display options
       * above or below the fold, as they are not actually being focused when active.
       * @param {?} scrollTop
       * @return {?}
       */
          function (scrollTop) {
              if (this.panel) {
                  this.panel.nativeElement.scrollTop = scrollTop;
              }
          };
      /** Returns the panel's scrollTop. */
      /**
       * Returns the panel's scrollTop.
       * @return {?}
       */
      MatAutocomplete.prototype._getScrollTop = /**
       * Returns the panel's scrollTop.
       * @return {?}
       */
          function () {
              return this.panel ? this.panel.nativeElement.scrollTop : 0;
          };
      /** Panel should hide itself when the option list is empty. */
      /**
       * Panel should hide itself when the option list is empty.
       * @return {?}
       */
      MatAutocomplete.prototype._setVisibility = /**
       * Panel should hide itself when the option list is empty.
       * @return {?}
       */
          function () {
              this.showPanel = !!this.options.length;
              this._classList['mat-autocomplete-visible'] = this.showPanel;
              this._classList['mat-autocomplete-hidden'] = !this.showPanel;
              this._changeDetectorRef.markForCheck();
          };
      /** Emits the `select` event. */
      /**
       * Emits the `select` event.
       * @param {?} option
       * @return {?}
       */
      MatAutocomplete.prototype._emitSelectEvent = /**
       * Emits the `select` event.
       * @param {?} option
       * @return {?}
       */
          function (option) {
              /** @type {?} */
              var event = new MatAutocompleteSelectedEvent(this, option);
              this.optionSelected.emit(event);
          };
      MatAutocomplete.decorators = [
          { type: core.Component, args: [{ selector: 'mat-autocomplete',
                      template: "<ng-template><div class=\"mat-autocomplete-panel\" role=\"listbox\" [id]=\"id\" [ngClass]=\"_classList\" #panel><ng-content></ng-content></div></ng-template>",
                      styles: [".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}@media (-ms-high-contrast:active){.mat-autocomplete-panel{outline:solid 1px}}"],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      exportAs: 'matAutocomplete',
                      inputs: ['disableRipple'],
                      host: {
                          'class': 'mat-autocomplete'
                      },
                      providers: [
                          { provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatAutocomplete }
                      ]
                  },] },
      ];
      /** @nocollapse */
      MatAutocomplete.ctorParameters = function () {
          return [
              { type: core.ChangeDetectorRef },
              { type: core.ElementRef },
              { type: undefined, decorators: [{ type: core.Inject, args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,] }] }
          ];
      };
      MatAutocomplete.propDecorators = {
          template: [{ type: core.ViewChild, args: [core.TemplateRef,] }],
          panel: [{ type: core.ViewChild, args: ['panel',] }],
          options: [{ type: core.ContentChildren, args: [MatOption, { descendants: true },] }],
          optionGroups: [{ type: core.ContentChildren, args: [MatOptgroup,] }],
          displayWith: [{ type: core.Input }],
          autoActiveFirstOption: [{ type: core.Input }],
          panelWidth: [{ type: core.Input }],
          optionSelected: [{ type: core.Output }],
          opened: [{ type: core.Output }],
          closed: [{ type: core.Output }],
          classList: [{ type: core.Input, args: ['class',] }]
      };
      return MatAutocomplete;
  }(_MatAutocompleteMixinBase));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * The height of each autocomplete option.
   * @type {?}
   */
  var AUTOCOMPLETE_OPTION_HEIGHT = 48;
  /**
   * The total height of the autocomplete panel.
   * @type {?}
   */
  var AUTOCOMPLETE_PANEL_HEIGHT = 256;
  /**
   * Injection token that determines the scroll handling while the autocomplete panel is open.
   * @type {?}
   */
  var MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new core.InjectionToken('mat-autocomplete-scroll-strategy');
  /**
   * Provider that allows the autocomplete to register as a ControlValueAccessor.
   * \@docs-private
   * @type {?}
   */
  var MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {
      provide: forms.NG_VALUE_ACCESSOR,
      useExisting: core.forwardRef(function () { return MatAutocompleteTrigger; }),
      multi: true
  };
  /**
   * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.
   * \@docs-private
   * @return {?}
   */
  function getMatAutocompleteMissingPanelError() {
      return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' +
          'Make sure that the id passed to the `matAutocomplete` is correct and that ' +
          'you\'re attempting to open it after the ngAfterContentInit hook.');
  }
  var MatAutocompleteTrigger = /** @class */ (function () {
      function MatAutocompleteTrigger(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, _viewportRuler) {
          var _this = this;
          this._element = _element;
          this._overlay = _overlay;
          this._viewContainerRef = _viewContainerRef;
          this._zone = _zone;
          this._changeDetectorRef = _changeDetectorRef;
          this._dir = _dir;
          this._formField = _formField;
          this._document = _document;
          this._viewportRuler = _viewportRuler;
          this._componentDestroyed = false;
          this._autocompleteDisabled = false;
          /**
           * Whether or not the label state is being overridden.
           */
          this._manuallyFloatingLabel = false;
          /**
           * Subscription to viewport size changes.
           */
          this._viewportSubscription = rxjs.Subscription.EMPTY;
          /**
           * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,
           * closed autocomplete from being reopened if the user switches to another browser tab and then
           * comes back.
           */
          this._canOpenOnNextFocus = true;
          /**
           * Stream of keyboard events that can close the panel.
           */
          this._closeKeyEventStream = new rxjs.Subject();
          /**
           * Event handler for when the window is blurred. Needs to be an
           * arrow function in order to preserve the context.
           */
          this._windowBlurHandler = function () {
              // If the user blurred the window while the autocomplete is focused, it means that it'll be
              // refocused when they come back. In this case we want to skip the first focus event, if the
              // pane was closed, in order to avoid reopening it unintentionally.
              _this._canOpenOnNextFocus =
                  document.activeElement !== _this._element.nativeElement || _this.panelOpen;
          };
          /**
           * `View -> model callback called when value changes`
           */
          this._onChange = function () { };
          /**
           * `View -> model callback called when autocomplete has been touched`
           */
          this._onTouched = function () { };
          /**
           * `autocomplete` attribute to be set on the input element.
           * \@docs-private
           */
          this.autocompleteAttribute = 'off';
          this._overlayAttached = false;
          /**
           * Stream of autocomplete option selections.
           */
          this.optionSelections = rxjs.defer(function () {
              if (_this.autocomplete && _this.autocomplete.options) {
                  return rxjs.merge.apply(void 0, _this.autocomplete.options.map(function (option) { return option.onSelectionChange; }));
              }
              // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.
              // Return a stream that we'll replace with the real one once everything is in place.
              return _this._zone.onStable
                  .asObservable()
                  .pipe(operators.take(1), operators.switchMap(function () { return _this.optionSelections; }));
          });
          if (typeof window !== 'undefined') {
              _zone.runOutsideAngular(function () {
                  window.addEventListener('blur', _this._windowBlurHandler);
              });
          }
          this._scrollStrategy = scrollStrategy;
      }
      Object.defineProperty(MatAutocompleteTrigger.prototype, "autocompleteDisabled", {
          /**
           * Whether the autocomplete is disabled. When disabled, the element will
           * act as a regular input and the user won't be able to open the panel.
           */
          get: /**
           * Whether the autocomplete is disabled. When disabled, the element will
           * act as a regular input and the user won't be able to open the panel.
           * @return {?}
           */ function () { return this._autocompleteDisabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._autocompleteDisabled = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatAutocompleteTrigger.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              if (typeof window !== 'undefined') {
                  window.removeEventListener('blur', this._windowBlurHandler);
              }
              this._viewportSubscription.unsubscribe();
              this._componentDestroyed = true;
              this._destroyPanel();
              this._closeKeyEventStream.complete();
          };
      Object.defineProperty(MatAutocompleteTrigger.prototype, "panelOpen", {
          /** Whether or not the autocomplete panel is open. */
          get: /**
           * Whether or not the autocomplete panel is open.
           * @return {?}
           */ function () {
              return this._overlayAttached && this.autocomplete.showPanel;
          },
          enumerable: true,
          configurable: true
      });
      /** Opens the autocomplete suggestion panel. */
      /**
       * Opens the autocomplete suggestion panel.
       * @return {?}
       */
      MatAutocompleteTrigger.prototype.openPanel = /**
       * Opens the autocomplete suggestion panel.
       * @return {?}
       */
          function () {
              this._attachOverlay();
              this._floatLabel();
          };
      /** Closes the autocomplete suggestion panel. */
      /**
       * Closes the autocomplete suggestion panel.
       * @return {?}
       */
      MatAutocompleteTrigger.prototype.closePanel = /**
       * Closes the autocomplete suggestion panel.
       * @return {?}
       */
          function () {
              this._resetLabel();
              if (!this._overlayAttached) {
                  return;
              }
              if (this.panelOpen) {
                  // Only emit if the panel was visible.
                  this.autocomplete.closed.emit();
              }
              this.autocomplete._isOpen = this._overlayAttached = false;
              if (this._overlayRef && this._overlayRef.hasAttached()) {
                  this._overlayRef.detach();
                  this._closingActionsSubscription.unsubscribe();
              }
              // Note that in some cases this can end up being called after the component is destroyed.
              // Add a check to ensure that we don't try to run change detection on a destroyed view.
              if (!this._componentDestroyed) {
                  // We need to trigger change detection manually, because
                  // `fromEvent` doesn't seem to do it at the proper time.
                  // This ensures that the label is reset when the
                  // user clicks outside.
                  this._changeDetectorRef.detectChanges();
              }
          };
      /**
       * Updates the position of the autocomplete suggestion panel to ensure that it fits all options
       * within the viewport.
       */
      /**
       * Updates the position of the autocomplete suggestion panel to ensure that it fits all options
       * within the viewport.
       * @return {?}
       */
      MatAutocompleteTrigger.prototype.updatePosition = /**
       * Updates the position of the autocomplete suggestion panel to ensure that it fits all options
       * within the viewport.
       * @return {?}
       */
          function () {
              if (this._overlayAttached) {
                  ( /** @type {?} */(this._overlayRef)).updatePosition();
              }
          };
      Object.defineProperty(MatAutocompleteTrigger.prototype, "panelClosingActions", {
          /**
           * A stream of actions that should close the autocomplete panel, including
           * when an option is selected, on blur, and when TAB is pressed.
           */
          get: /**
           * A stream of actions that should close the autocomplete panel, including
           * when an option is selected, on blur, and when TAB is pressed.
           * @return {?}
           */ function () {
              var _this = this;
              return rxjs.merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(operators.filter(function () { return _this._overlayAttached; })), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ?
                  this._overlayRef.detachments().pipe(operators.filter(function () { return _this._overlayAttached; })) :
                  rxjs.of()).pipe(
              // Normalize the output so we return a consistent type.
              operators.map(function (event) { return event instanceof MatOptionSelectionChange ? event : null; }));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatAutocompleteTrigger.prototype, "activeOption", {
          /** The currently active option, coerced to MatOption type. */
          get: /**
           * The currently active option, coerced to MatOption type.
           * @return {?}
           */ function () {
              if (this.autocomplete && this.autocomplete._keyManager) {
                  return this.autocomplete._keyManager.activeItem;
              }
              return null;
          },
          enumerable: true,
          configurable: true
      });
      /** Stream of clicks outside of the autocomplete panel. */
      /**
       * Stream of clicks outside of the autocomplete panel.
       * @private
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._getOutsideClickStream = /**
       * Stream of clicks outside of the autocomplete panel.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this._document) {
                  return rxjs.of(null);
              }
              return rxjs.merge(rxjs.fromEvent(this._document, 'click'), rxjs.fromEvent(this._document, 'touchend'))
                  .pipe(operators.filter(function (event) {
                  /** @type {?} */
                  var clickTarget = ( /** @type {?} */(event.target));
                  /** @type {?} */
                  var formField = _this._formField ?
                      _this._formField._elementRef.nativeElement : null;
                  return _this._overlayAttached &&
                      clickTarget !== _this._element.nativeElement &&
                      (!formField || !formField.contains(clickTarget)) &&
                      (!!_this._overlayRef && !_this._overlayRef.overlayElement.contains(clickTarget));
              }));
          };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} value
       * @return {?}
       */
      MatAutocompleteTrigger.prototype.writeValue =
          // Implemented as part of ControlValueAccessor.
          /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              var _this = this;
              Promise.resolve(null).then(function () { return _this._setTriggerValue(value); });
          };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} fn
       * @return {?}
       */
      MatAutocompleteTrigger.prototype.registerOnChange =
          // Implemented as part of ControlValueAccessor.
          /**
           * @param {?} fn
           * @return {?}
           */
          function (fn) {
              this._onChange = fn;
          };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} fn
       * @return {?}
       */
      MatAutocompleteTrigger.prototype.registerOnTouched =
          // Implemented as part of ControlValueAccessor.
          /**
           * @param {?} fn
           * @return {?}
           */
          function (fn) {
              this._onTouched = fn;
          };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} isDisabled
       * @return {?}
       */
      MatAutocompleteTrigger.prototype.setDisabledState =
          // Implemented as part of ControlValueAccessor.
          /**
           * @param {?} isDisabled
           * @return {?}
           */
          function (isDisabled) {
              this._element.nativeElement.disabled = isDisabled;
          };
      /**
       * @param {?} event
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._handleKeydown = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var keyCode = event.keyCode;
              // Prevent the default action on all escape key presses. This is here primarily to bring IE
              // in line with other browsers. By default, pressing escape on IE will cause it to revert
              // the input value to the one that it had on focus, however it won't dispatch any events
              // which means that the model value will be out of sync with the view.
              if (keyCode === ESCAPE) {
                  event.preventDefault();
              }
              if (this.activeOption && keyCode === ENTER && this.panelOpen) {
                  this.activeOption._selectViaInteraction();
                  this._resetActiveItem();
                  event.preventDefault();
              }
              else if (this.autocomplete) {
                  /** @type {?} */
                  var prevActiveItem = this.autocomplete._keyManager.activeItem;
                  /** @type {?} */
                  var isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;
                  if (this.panelOpen || keyCode === TAB) {
                      this.autocomplete._keyManager.onKeydown(event);
                  }
                  else if (isArrowKey && this._canOpen()) {
                      this.openPanel();
                  }
                  if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {
                      this._scrollToOption();
                  }
              }
          };
      /**
       * @param {?} event
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._handleInput = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var target = ( /** @type {?} */(event.target));
              /** @type {?} */
              var value = target.value;
              // Based on `NumberValueAccessor` from forms.
              if (target.type === 'number') {
                  value = value == '' ? null : parseFloat(value);
              }
              // If the input has a placeholder, IE will fire the `input` event on page load,
              // focus and blur, in addition to when the user actually changed the value. To
              // filter out all of the extra events, we save the value on focus and between
              // `input` events, and we check whether it changed.
              // See: https://connect.microsoft.com/IE/feedback/details/885747/
              if (this._previousValue !== value) {
                  this._previousValue = value;
                  this._onChange(value);
                  if (this._canOpen() && document.activeElement === event.target) {
                      this.openPanel();
                  }
              }
          };
      /**
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._handleFocus = /**
       * @return {?}
       */
          function () {
              if (!this._canOpenOnNextFocus) {
                  this._canOpenOnNextFocus = true;
              }
              else if (this._canOpen()) {
                  this._previousValue = this._element.nativeElement.value;
                  this._attachOverlay();
                  this._floatLabel(true);
              }
          };
      /**
       * In "auto" mode, the label will animate down as soon as focus is lost.
       * This causes the value to jump when selecting an option with the mouse.
       * This method manually floats the label until the panel can be closed.
       * @param shouldAnimate Whether the label should be animated when it is floated.
       */
      /**
       * In "auto" mode, the label will animate down as soon as focus is lost.
       * This causes the value to jump when selecting an option with the mouse.
       * This method manually floats the label until the panel can be closed.
       * @private
       * @param {?=} shouldAnimate Whether the label should be animated when it is floated.
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._floatLabel = /**
       * In "auto" mode, the label will animate down as soon as focus is lost.
       * This causes the value to jump when selecting an option with the mouse.
       * This method manually floats the label until the panel can be closed.
       * @private
       * @param {?=} shouldAnimate Whether the label should be animated when it is floated.
       * @return {?}
       */
          function (shouldAnimate) {
              if (shouldAnimate === void 0) {
                  shouldAnimate = false;
              }
              if (this._formField && this._formField.floatLabel === 'auto') {
                  if (shouldAnimate) {
                      this._formField._animateAndLockLabel();
                  }
                  else {
                      this._formField.floatLabel = 'always';
                  }
                  this._manuallyFloatingLabel = true;
              }
          };
      /** If the label has been manually elevated, return it to its normal state. */
      /**
       * If the label has been manually elevated, return it to its normal state.
       * @private
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._resetLabel = /**
       * If the label has been manually elevated, return it to its normal state.
       * @private
       * @return {?}
       */
          function () {
              if (this._manuallyFloatingLabel) {
                  this._formField.floatLabel = 'auto';
                  this._manuallyFloatingLabel = false;
              }
          };
      /**
       * Given that we are not actually focusing active options, we must manually adjust scroll
       * to reveal options below the fold. First, we find the offset of the option from the top
       * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
       * the panel height + the option height, so the active option will be just visible at the
       * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
       * will become the offset. If that offset is visible within the panel already, the scrollTop is
       * not adjusted.
       */
      /**
       * Given that we are not actually focusing active options, we must manually adjust scroll
       * to reveal options below the fold. First, we find the offset of the option from the top
       * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
       * the panel height + the option height, so the active option will be just visible at the
       * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
       * will become the offset. If that offset is visible within the panel already, the scrollTop is
       * not adjusted.
       * @private
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._scrollToOption = /**
       * Given that we are not actually focusing active options, we must manually adjust scroll
       * to reveal options below the fold. First, we find the offset of the option from the top
       * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
       * the panel height + the option height, so the active option will be just visible at the
       * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
       * will become the offset. If that offset is visible within the panel already, the scrollTop is
       * not adjusted.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var index = this.autocomplete._keyManager.activeItemIndex || 0;
              /** @type {?} */
              var labelCount = _countGroupLabelsBeforeOption(index, this.autocomplete.options, this.autocomplete.optionGroups);
              /** @type {?} */
              var newScrollPosition = _getOptionScrollPosition(index + labelCount, AUTOCOMPLETE_OPTION_HEIGHT, this.autocomplete._getScrollTop(), AUTOCOMPLETE_PANEL_HEIGHT);
              this.autocomplete._setScrollTop(newScrollPosition);
          };
      /**
       * This method listens to a stream of panel closing actions and resets the
       * stream every time the option list changes.
       */
      /**
       * This method listens to a stream of panel closing actions and resets the
       * stream every time the option list changes.
       * @private
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._subscribeToClosingActions = /**
       * This method listens to a stream of panel closing actions and resets the
       * stream every time the option list changes.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var firstStable = this._zone.onStable.asObservable().pipe(operators.take(1));
              /** @type {?} */
              var optionChanges = this.autocomplete.options.changes.pipe(operators.tap(function () { return _this._positionStrategy.reapplyLastPosition(); }), 
              // Defer emitting to the stream until the next tick, because changing
              // bindings in here will cause "changed after checked" errors.
              operators.delay(0));
              // When the zone is stable initially, and when the option list changes...
              return rxjs.merge(firstStable, optionChanges)
                  .pipe(
              // create a new stream of panelClosingActions, replacing any previous streams
              // that were created, and flatten it so our stream only emits closing events...
              operators.switchMap(function () {
                  _this._resetActiveItem();
                  _this.autocomplete._setVisibility();
                  if (_this.panelOpen) {
                      ( /** @type {?} */(_this._overlayRef)).updatePosition();
                  }
                  return _this.panelClosingActions;
              }), 
              // when the first closing event occurs...
              operators.take(1))
                  // set the value, close the panel, and complete.
                  .subscribe(function (event) { return _this._setValueAndClose(event); });
          };
      /** Destroys the autocomplete suggestion panel. */
      /**
       * Destroys the autocomplete suggestion panel.
       * @private
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._destroyPanel = /**
       * Destroys the autocomplete suggestion panel.
       * @private
       * @return {?}
       */
          function () {
              if (this._overlayRef) {
                  this.closePanel();
                  this._overlayRef.dispose();
                  this._overlayRef = null;
              }
          };
      /**
       * @private
       * @param {?} value
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._setTriggerValue = /**
       * @private
       * @param {?} value
       * @return {?}
       */
          function (value) {
              /** @type {?} */
              var toDisplay = this.autocomplete && this.autocomplete.displayWith ?
                  this.autocomplete.displayWith(value) :
                  value;
              // Simply falling back to an empty string if the display value is falsy does not work properly.
              // The display value can also be the number zero and shouldn't fall back to an empty string.
              /** @type {?} */
              var inputValue = toDisplay != null ? toDisplay : '';
              // If it's used within a `MatFormField`, we should set it through the property so it can go
              // through change detection.
              if (this._formField) {
                  this._formField._control.value = inputValue;
              }
              else {
                  this._element.nativeElement.value = inputValue;
              }
              this._previousValue = inputValue;
          };
      /**
       * This method closes the panel, and if a value is specified, also sets the associated
       * control to that value. It will also mark the control as dirty if this interaction
       * stemmed from the user.
       */
      /**
       * This method closes the panel, and if a value is specified, also sets the associated
       * control to that value. It will also mark the control as dirty if this interaction
       * stemmed from the user.
       * @private
       * @param {?} event
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._setValueAndClose = /**
       * This method closes the panel, and if a value is specified, also sets the associated
       * control to that value. It will also mark the control as dirty if this interaction
       * stemmed from the user.
       * @private
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (event && event.source) {
                  this._clearPreviousSelectedOption(event.source);
                  this._setTriggerValue(event.source.value);
                  this._onChange(event.source.value);
                  this._element.nativeElement.focus();
                  this.autocomplete._emitSelectEvent(event.source);
              }
              this.closePanel();
          };
      /**
       * Clear any previous selected option and emit a selection change event for this option
       */
      /**
       * Clear any previous selected option and emit a selection change event for this option
       * @private
       * @param {?} skip
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._clearPreviousSelectedOption = /**
       * Clear any previous selected option and emit a selection change event for this option
       * @private
       * @param {?} skip
       * @return {?}
       */
          function (skip) {
              this.autocomplete.options.forEach(function (option) {
                  if (option != skip && option.selected) {
                      option.deselect();
                  }
              });
          };
      /**
       * @private
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._attachOverlay = /**
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this.autocomplete) {
                  throw getMatAutocompleteMissingPanelError();
              }
              /** @type {?} */
              var overlayRef = this._overlayRef;
              if (!overlayRef) {
                  this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef);
                  overlayRef = this._overlay.create(this._getOverlayConfig());
                  this._overlayRef = overlayRef;
                  // Use the `keydownEvents` in order to take advantage of
                  // the overlay event targeting provided by the CDK overlay.
                  overlayRef.keydownEvents().subscribe(function (event) {
                      // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.
                      // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction
                      if (event.keyCode === ESCAPE || (event.keyCode === UP_ARROW && event.altKey)) {
                          _this._resetActiveItem();
                          _this._closeKeyEventStream.next();
                      }
                  });
                  if (this._viewportRuler) {
                      this._viewportSubscription = this._viewportRuler.change().subscribe(function () {
                          if (_this.panelOpen && overlayRef) {
                              overlayRef.updateSize({ width: _this._getPanelWidth() });
                          }
                      });
                  }
              }
              else {
                  /** @type {?} */
                  var position = ( /** @type {?} */(overlayRef.getConfig().positionStrategy));
                  // Update the trigger, panel width and direction, in case anything has changed.
                  position.setOrigin(this._getConnectedElement());
                  overlayRef.updateSize({ width: this._getPanelWidth() });
              }
              if (overlayRef && !overlayRef.hasAttached()) {
                  overlayRef.attach(this._portal);
                  this._closingActionsSubscription = this._subscribeToClosingActions();
              }
              /** @type {?} */
              var wasOpen = this.panelOpen;
              this.autocomplete._setVisibility();
              this.autocomplete._isOpen = this._overlayAttached = true;
              // We need to do an extra `panelOpen` check in here, because the
              // autocomplete won't be shown if there are no options.
              if (this.panelOpen && wasOpen !== this.panelOpen) {
                  this.autocomplete.opened.emit();
              }
          };
      /**
       * @private
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._getOverlayConfig = /**
       * @private
       * @return {?}
       */
          function () {
              return new OverlayConfig({
                  positionStrategy: this._getOverlayPosition(),
                  scrollStrategy: this._scrollStrategy(),
                  width: this._getPanelWidth(),
                  direction: this._dir
              });
          };
      /**
       * @private
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._getOverlayPosition = /**
       * @private
       * @return {?}
       */
          function () {
              this._positionStrategy = this._overlay.position()
                  .flexibleConnectedTo(this._getConnectedElement())
                  .withFlexibleDimensions(false)
                  .withPush(false)
                  .withPositions([
                  {
                      originX: 'start',
                      originY: 'bottom',
                      overlayX: 'start',
                      overlayY: 'top'
                  },
                  {
                      originX: 'start',
                      originY: 'top',
                      overlayX: 'start',
                      overlayY: 'bottom',
                      // The overlay edge connected to the trigger should have squared corners, while
                      // the opposite end has rounded corners. We apply a CSS class to swap the
                      // border-radius based on the overlay position.
                      panelClass: 'mat-autocomplete-panel-above'
                  }
              ]);
              return this._positionStrategy;
          };
      /**
       * @private
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._getConnectedElement = /**
       * @private
       * @return {?}
       */
          function () {
              if (this.connectedTo) {
                  return this.connectedTo.elementRef;
              }
              return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;
          };
      /**
       * @private
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._getPanelWidth = /**
       * @private
       * @return {?}
       */
          function () {
              return this.autocomplete.panelWidth || this._getHostWidth();
          };
      /** Returns the width of the input element, so the panel width can match it. */
      /**
       * Returns the width of the input element, so the panel width can match it.
       * @private
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._getHostWidth = /**
       * Returns the width of the input element, so the panel width can match it.
       * @private
       * @return {?}
       */
          function () {
              return this._getConnectedElement().nativeElement.getBoundingClientRect().width;
          };
      /**
       * Resets the active item to -1 so arrow events will activate the
       * correct options, or to 0 if the consumer opted into it.
       */
      /**
       * Resets the active item to -1 so arrow events will activate the
       * correct options, or to 0 if the consumer opted into it.
       * @private
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._resetActiveItem = /**
       * Resets the active item to -1 so arrow events will activate the
       * correct options, or to 0 if the consumer opted into it.
       * @private
       * @return {?}
       */
          function () {
              this.autocomplete._keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption ? 0 : -1);
          };
      /** Determines whether the panel can be opened. */
      /**
       * Determines whether the panel can be opened.
       * @private
       * @return {?}
       */
      MatAutocompleteTrigger.prototype._canOpen = /**
       * Determines whether the panel can be opened.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var element = this._element.nativeElement;
              return !element.readOnly && !element.disabled && !this._autocompleteDisabled;
          };
      MatAutocompleteTrigger.decorators = [
          { type: core.Directive, args: [{
                      selector: "input[matAutocomplete], textarea[matAutocomplete]",
                      host: {
                          '[attr.autocomplete]': 'autocompleteAttribute',
                          '[attr.role]': 'autocompleteDisabled ? null : "combobox"',
                          '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : "list"',
                          '[attr.aria-activedescendant]': '(panelOpen && activeOption) ? activeOption.id : null',
                          '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',
                          '[attr.aria-owns]': '(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id',
                          '[attr.aria-haspopup]': '!autocompleteDisabled',
                          // Note: we use `focusin`, as opposed to `focus`, in order to open the panel
                          // a little earlier. This avoids issues where IE delays the focusing of the input.
                          '(focusin)': '_handleFocus()',
                          '(blur)': '_onTouched()',
                          '(input)': '_handleInput($event)',
                          '(keydown)': '_handleKeydown($event)',
                      },
                      exportAs: 'matAutocompleteTrigger',
                      providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR]
                  },] },
      ];
      /** @nocollapse */
      MatAutocompleteTrigger.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: Overlay },
              { type: core.ViewContainerRef },
              { type: core.NgZone },
              { type: core.ChangeDetectorRef },
              { type: undefined, decorators: [{ type: core.Inject, args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY,] }] },
              { type: Directionality, decorators: [{ type: core.Optional }] },
              { type: MatFormField, decorators: [{ type: core.Optional }, { type: core.Host }] },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] },
              { type: ViewportRuler }
          ];
      };
      MatAutocompleteTrigger.propDecorators = {
          autocomplete: [{ type: core.Input, args: ['matAutocomplete',] }],
          connectedTo: [{ type: core.Input, args: ['matAutocompleteConnectedTo',] }],
          autocompleteAttribute: [{ type: core.Input, args: ['autocomplete',] }],
          autocompleteDisabled: [{ type: core.Input, args: ['matAutocompleteDisabled',] }]
      };
      return MatAutocompleteTrigger;
  }());

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var nextId$1 = 0;
  // Boilerplate for applying mixins to MatBadge.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatBadge.
  /**
   * \@docs-private
   */
  MatBadgeBase = /** @class */ (function () {
      function MatBadgeBase() {
      }
      return MatBadgeBase;
  }());
  /** @type {?} */
  var _MatBadgeMixinBase = mixinDisabled(MatBadgeBase);
  /**
   * Directive to display a text badge.
   */
  var MatBadge = /** @class */ (function (_super) {
      tslib_1.__extends(MatBadge, _super);
      function MatBadge(_document, _ngZone, _elementRef, _ariaDescriber, _renderer) {
          var _this = _super.call(this) || this;
          _this._document = _document;
          _this._ngZone = _ngZone;
          _this._elementRef = _elementRef;
          _this._ariaDescriber = _ariaDescriber;
          _this._renderer = _renderer;
          /**
           * Whether the badge has any content.
           */
          _this._hasContent = false;
          _this._color = 'primary';
          _this._overlap = true;
          /**
           * Position the badge should reside.
           * Accepts any combination of 'above'|'below' and 'before'|'after'
           */
          _this.position = 'above after';
          /**
           * Size of the badge. Can be 'small', 'medium', or 'large'.
           */
          _this.size = 'medium';
          /**
           * Unique id for the badge
           */
          _this._id = nextId$1++;
          return _this;
      }
      Object.defineProperty(MatBadge.prototype, "color", {
          /** The color of the badge. Can be `primary`, `accent`, or `warn`. */
          get: /**
           * The color of the badge. Can be `primary`, `accent`, or `warn`.
           * @return {?}
           */ function () { return this._color; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._setColor(value);
              this._color = value;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatBadge.prototype, "overlap", {
          /** Whether the badge should overlap its contents or not */
          get: /**
           * Whether the badge should overlap its contents or not
           * @return {?}
           */ function () { return this._overlap; },
          set: /**
           * @param {?} val
           * @return {?}
           */ function (val) {
              this._overlap = coerceBooleanProperty(val);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatBadge.prototype, "content", {
          /** The content for the badge */
          get: /**
           * The content for the badge
           * @return {?}
           */ function () { return this._content; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._content = value;
              this._hasContent = value != null && ("" + value).trim().length > 0;
              this._updateTextContent();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatBadge.prototype, "description", {
          /** Message used to describe the decorated element via aria-describedby */
          get: /**
           * Message used to describe the decorated element via aria-describedby
           * @return {?}
           */ function () { return this._description; },
          set: /**
           * @param {?} newDescription
           * @return {?}
           */ function (newDescription) {
              if (newDescription !== this._description) {
                  /** @type {?} */
                  var badgeElement = this._badgeElement;
                  this._updateHostAriaDescription(newDescription, this._description);
                  this._description = newDescription;
                  if (badgeElement) {
                      newDescription ? badgeElement.setAttribute('aria-label', newDescription) :
                          badgeElement.removeAttribute('aria-label');
                  }
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatBadge.prototype, "hidden", {
          /** Whether the badge is hidden. */
          get: /**
           * Whether the badge is hidden.
           * @return {?}
           */ function () { return this._hidden; },
          set: /**
           * @param {?} val
           * @return {?}
           */ function (val) {
              this._hidden = coerceBooleanProperty(val);
          },
          enumerable: true,
          configurable: true
      });
      /** Whether the badge is above the host or not */
      /**
       * Whether the badge is above the host or not
       * @return {?}
       */
      MatBadge.prototype.isAbove = /**
       * Whether the badge is above the host or not
       * @return {?}
       */
          function () {
              return this.position.indexOf('below') === -1;
          };
      /** Whether the badge is after the host or not */
      /**
       * Whether the badge is after the host or not
       * @return {?}
       */
      MatBadge.prototype.isAfter = /**
       * Whether the badge is after the host or not
       * @return {?}
       */
          function () {
              return this.position.indexOf('before') === -1;
          };
      /**
       * @return {?}
       */
      MatBadge.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              /** @type {?} */
              var badgeElement = this._badgeElement;
              if (badgeElement) {
                  if (this.description) {
                      this._ariaDescriber.removeDescription(badgeElement, this.description);
                  }
                  // When creating a badge through the Renderer, Angular will keep it in an index.
                  // We have to destroy it ourselves, otherwise it'll be retained in memory.
                  // @breaking-change 8.0.0 remove _renderer from null.
                  if (this._renderer && this._renderer.destroyNode) {
                      this._renderer.destroyNode(badgeElement);
                  }
              }
          };
      /** Injects a span element into the DOM with the content. */
      /**
       * Injects a span element into the DOM with the content.
       * @private
       * @return {?}
       */
      MatBadge.prototype._updateTextContent = /**
       * Injects a span element into the DOM with the content.
       * @private
       * @return {?}
       */
          function () {
              if (!this._badgeElement) {
                  this._badgeElement = this._createBadgeElement();
              }
              else {
                  this._badgeElement.textContent = this.content;
              }
              return this._badgeElement;
          };
      /** Creates the badge element */
      /**
       * Creates the badge element
       * @private
       * @return {?}
       */
      MatBadge.prototype._createBadgeElement = /**
       * Creates the badge element
       * @private
       * @return {?}
       */
          function () {
              // @breaking-change 8.0.0 Remove null check for _renderer
              /** @type {?} */
              var rootNode = this._renderer || this._document;
              /** @type {?} */
              var badgeElement = rootNode.createElement('span');
              /** @type {?} */
              var activeClass = 'mat-badge-active';
              badgeElement.setAttribute('id', "mat-badge-content-" + this._id);
              badgeElement.classList.add('mat-badge-content');
              badgeElement.textContent = this.content;
              if (this.description) {
                  badgeElement.setAttribute('aria-label', this.description);
              }
              this._elementRef.nativeElement.appendChild(badgeElement);
              // animate in after insertion
              if (typeof requestAnimationFrame === 'function') {
                  this._ngZone.runOutsideAngular(function () {
                      requestAnimationFrame(function () {
                          badgeElement.classList.add(activeClass);
                      });
                  });
              }
              else {
                  badgeElement.classList.add(activeClass);
              }
              return badgeElement;
          };
      /** Sets the aria-label property on the element */
      /**
       * Sets the aria-label property on the element
       * @private
       * @param {?} newDescription
       * @param {?} oldDescription
       * @return {?}
       */
      MatBadge.prototype._updateHostAriaDescription = /**
       * Sets the aria-label property on the element
       * @private
       * @param {?} newDescription
       * @param {?} oldDescription
       * @return {?}
       */
          function (newDescription, oldDescription) {
              // ensure content available before setting label
              /** @type {?} */
              var content = this._updateTextContent();
              if (oldDescription) {
                  this._ariaDescriber.removeDescription(content, oldDescription);
              }
              if (newDescription) {
                  this._ariaDescriber.describe(content, newDescription);
              }
          };
      /** Adds css theme class given the color to the component host */
      /**
       * Adds css theme class given the color to the component host
       * @private
       * @param {?} colorPalette
       * @return {?}
       */
      MatBadge.prototype._setColor = /**
       * Adds css theme class given the color to the component host
       * @private
       * @param {?} colorPalette
       * @return {?}
       */
          function (colorPalette) {
              if (colorPalette !== this._color) {
                  if (this._color) {
                      this._elementRef.nativeElement.classList.remove("mat-badge-" + this._color);
                  }
                  if (colorPalette) {
                      this._elementRef.nativeElement.classList.add("mat-badge-" + colorPalette);
                  }
              }
          };
      MatBadge.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matBadge]',
                      inputs: ['disabled: matBadgeDisabled'],
                      host: {
                          'class': 'mat-badge',
                          '[class.mat-badge-overlap]': 'overlap',
                          '[class.mat-badge-above]': 'isAbove()',
                          '[class.mat-badge-below]': '!isAbove()',
                          '[class.mat-badge-before]': '!isAfter()',
                          '[class.mat-badge-after]': 'isAfter()',
                          '[class.mat-badge-small]': 'size === "small"',
                          '[class.mat-badge-medium]': 'size === "medium"',
                          '[class.mat-badge-large]': 'size === "large"',
                          '[class.mat-badge-hidden]': 'hidden || !_hasContent',
                          '[class.mat-badge-disabled]': 'disabled',
                      },
                  },] },
      ];
      /** @nocollapse */
      MatBadge.ctorParameters = function () {
          return [
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] },
              { type: core.NgZone },
              { type: core.ElementRef },
              { type: AriaDescriber },
              { type: core.Renderer2 }
          ];
      };
      MatBadge.propDecorators = {
          color: [{ type: core.Input, args: ['matBadgeColor',] }],
          overlap: [{ type: core.Input, args: ['matBadgeOverlap',] }],
          position: [{ type: core.Input, args: ['matBadgePosition',] }],
          content: [{ type: core.Input, args: ['matBadge',] }],
          description: [{ type: core.Input, args: ['matBadgeDescription',] }],
          size: [{ type: core.Input, args: ['matBadgeSize',] }],
          hidden: [{ type: core.Input, args: ['matBadgeHidden',] }]
      };
      return MatBadge;
  }(_MatBadgeMixinBase));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Global registry for all dynamically-created, injected media queries.
   * @type {?}
   */
  var mediaQueriesForWebkitCompatibility = new Set();
  /**
   * Style tag that holds all of the dynamically-created media queries.
   * @type {?}
   */
  var mediaQueryStyleNode;
  /**
   * A utility for calling matchMedia queries.
   */
  var MediaMatcher = /** @class */ (function () {
      function MediaMatcher(platform) {
          this.platform = platform;
          this._matchMedia = this.platform.isBrowser && window.matchMedia ?
              // matchMedia is bound to the window scope intentionally as it is an illegal invocation to
              // call it from a different scope.
              window.matchMedia.bind(window) :
              noopMatchMedia;
      }
      /**
       * Evaluates the given media query and returns the native MediaQueryList from which results
       * can be retrieved.
       * Confirms the layout engine will trigger for the selector query provided and returns the
       * MediaQueryList for the query provided.
       */
      /**
       * Evaluates the given media query and returns the native MediaQueryList from which results
       * can be retrieved.
       * Confirms the layout engine will trigger for the selector query provided and returns the
       * MediaQueryList for the query provided.
       * @param {?} query
       * @return {?}
       */
      MediaMatcher.prototype.matchMedia = /**
       * Evaluates the given media query and returns the native MediaQueryList from which results
       * can be retrieved.
       * Confirms the layout engine will trigger for the selector query provided and returns the
       * MediaQueryList for the query provided.
       * @param {?} query
       * @return {?}
       */
          function (query) {
              if (this.platform.WEBKIT) {
                  createEmptyStyleRule(query);
              }
              return this._matchMedia(query);
          };
      MediaMatcher.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */
      MediaMatcher.ctorParameters = function () {
          return [
              { type: Platform }
          ];
      };
      /** @nocollapse */ MediaMatcher.ngInjectableDef = core.defineInjectable({ factory: function MediaMatcher_Factory() { return new MediaMatcher(core.inject(Platform)); }, token: MediaMatcher, providedIn: "root" });
      return MediaMatcher;
  }());
  /**
   * For Webkit engines that only trigger the MediaQueryListListener when
   * there is at least one CSS selector for the respective media query.
   * @param {?} query
   * @return {?}
   */
  function createEmptyStyleRule(query) {
      if (mediaQueriesForWebkitCompatibility.has(query)) {
          return;
      }
      try {
          if (!mediaQueryStyleNode) {
              mediaQueryStyleNode = document.createElement('style');
              mediaQueryStyleNode.setAttribute('type', 'text/css');
              ( /** @type {?} */(document.head)).appendChild(mediaQueryStyleNode);
          }
          if (mediaQueryStyleNode.sheet) {
              (( /** @type {?} */(mediaQueryStyleNode.sheet)))
                  .insertRule("@media " + query + " {.fx-query-test{ }}", 0);
              mediaQueriesForWebkitCompatibility.add(query);
          }
      }
      catch (e) {
          console.error(e);
      }
  }
  /**
   * No-op matchMedia replacement for non-browser platforms.
   * @param {?} query
   * @return {?}
   */
  function noopMatchMedia(query) {
      // Use `as any` here to avoid adding additional necessary properties for
      // the noop matcher.
      return ( /** @type {?} */({
          matches: query === 'all' || query === '',
          media: query,
          addListener: function () { },
          removeListener: function () { }
      }));
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Utility for checking the matching state of \@media queries.
   */
  var BreakpointObserver = /** @class */ (function () {
      function BreakpointObserver(mediaMatcher, zone) {
          this.mediaMatcher = mediaMatcher;
          this.zone = zone;
          /**
           * A map of all media queries currently being listened for.
           */
          this._queries = new Map();
          /**
           * A subject for all other observables to takeUntil based on.
           */
          this._destroySubject = new rxjs.Subject();
      }
      /** Completes the active subject, signalling to all other observables to complete. */
      /**
       * Completes the active subject, signalling to all other observables to complete.
       * @return {?}
       */
      BreakpointObserver.prototype.ngOnDestroy = /**
       * Completes the active subject, signalling to all other observables to complete.
       * @return {?}
       */
          function () {
              this._destroySubject.next();
              this._destroySubject.complete();
          };
      /**
       * Whether one or more media queries match the current viewport size.
       * @param value One or more media queries to check.
       * @returns Whether any of the media queries match.
       */
      /**
       * Whether one or more media queries match the current viewport size.
       * @param {?} value One or more media queries to check.
       * @return {?} Whether any of the media queries match.
       */
      BreakpointObserver.prototype.isMatched = /**
       * Whether one or more media queries match the current viewport size.
       * @param {?} value One or more media queries to check.
       * @return {?} Whether any of the media queries match.
       */
          function (value) {
              var _this = this;
              /** @type {?} */
              var queries = splitQueries(coerceArray(value));
              return queries.some(function (mediaQuery) { return _this._registerQuery(mediaQuery).mql.matches; });
          };
      /**
       * Gets an observable of results for the given queries that will emit new results for any changes
       * in matching of the given queries.
       * @param value One or more media queries to check.
       * @returns A stream of matches for the given queries.
       */
      /**
       * Gets an observable of results for the given queries that will emit new results for any changes
       * in matching of the given queries.
       * @param {?} value One or more media queries to check.
       * @return {?} A stream of matches for the given queries.
       */
      BreakpointObserver.prototype.observe = /**
       * Gets an observable of results for the given queries that will emit new results for any changes
       * in matching of the given queries.
       * @param {?} value One or more media queries to check.
       * @return {?} A stream of matches for the given queries.
       */
          function (value) {
              var _this = this;
              /** @type {?} */
              var queries = splitQueries(coerceArray(value));
              /** @type {?} */
              var observables = queries.map(function (query) { return _this._registerQuery(query).observable; });
              return rxjs.combineLatest(observables).pipe(operators.debounceTime(0, rxjs.asapScheduler), operators.map(function (breakpointStates) {
                  /** @type {?} */
                  var response = {
                      matches: false,
                      breakpoints: {},
                  };
                  breakpointStates.forEach(function (state) {
                      response.matches = response.matches || state.matches;
                      response.breakpoints[state.query] = state.matches;
                  });
                  return response;
              }));
          };
      /** Registers a specific query to be listened for. */
      /**
       * Registers a specific query to be listened for.
       * @private
       * @param {?} query
       * @return {?}
       */
      BreakpointObserver.prototype._registerQuery = /**
       * Registers a specific query to be listened for.
       * @private
       * @param {?} query
       * @return {?}
       */
          function (query) {
              var _this = this;
              // Only set up a new MediaQueryList if it is not already being listened for.
              if (this._queries.has(query)) {
                  return ( /** @type {?} */(this._queries.get(query)));
              }
              /** @type {?} */
              var mql = this.mediaMatcher.matchMedia(query);
              // TODO(jelbourn): change this `any` to `MediaQueryListEvent` once Google has upgraded to
              // TypeScript 3.1 (the type is unavailable before then).
              /** @type {?} */
              var queryListener;
              // Create callback for match changes and add it is as a listener.
              /** @type {?} */
              var queryObservable = rxjs.fromEventPattern(
              // Listener callback methods are wrapped to be placed back in ngZone. Callbacks must be placed
              // back into the zone because matchMedia is only included in Zone.js by loading the
              // webapis-media-query.js file alongside the zone.js file.  Additionally, some browsers do not
              // have MediaQueryList inherit from EventTarget, which causes inconsistencies in how Zone.js
              // patches it.
              function (listener) {
                  queryListener = function (e) { return _this.zone.run(function () { return listener(e); }); };
                  mql.addListener(queryListener);
              }, function () { return mql.removeListener(queryListener); })
                  .pipe(operators.startWith(mql), operators.map(function (nextMql) { return ({ query: query, matches: nextMql.matches }); }), operators.takeUntil(this._destroySubject));
              // Add the MediaQueryList to the set of queries.
              /** @type {?} */
              var output = { observable: queryObservable, mql: mql };
              this._queries.set(query, output);
              return output;
          };
      BreakpointObserver.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */
      BreakpointObserver.ctorParameters = function () {
          return [
              { type: MediaMatcher },
              { type: core.NgZone }
          ];
      };
      /** @nocollapse */ BreakpointObserver.ngInjectableDef = core.defineInjectable({ factory: function BreakpointObserver_Factory() { return new BreakpointObserver(core.inject(MediaMatcher), core.inject(core.NgZone)); }, token: BreakpointObserver, providedIn: "root" });
      return BreakpointObserver;
  }());
  /**
   * Split each query string into separate query strings if two queries are provided as comma
   * separated.
   * @param {?} queries
   * @return {?}
   */
  function splitQueries(queries) {
      return queries.map(function (query) { return query.split(','); })
          .reduce(function (a1, a2) { return a1.concat(a2); })
          .map(function (query) { return query.trim(); });
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // PascalCase is being used as Breakpoints is used like an enum.
  // tslint:disable-next-line:variable-name
  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   * @type {?}
   */
  var Breakpoints = {
      XSmall: '(max-width: 599.99px)',
      Small: '(min-width: 600px) and (max-width: 959.99px)',
      Medium: '(min-width: 960px) and (max-width: 1279.99px)',
      Large: '(min-width: 1280px) and (max-width: 1919.99px)',
      XLarge: '(min-width: 1920px)',
      Handset: '(max-width: 599.99px) and (orientation: portrait), ' +
          '(max-width: 959.99px) and (orientation: landscape)',
      Tablet: '(min-width: 600px) and (max-width: 839.99px) and (orientation: portrait), ' +
          '(min-width: 960px) and (max-width: 1279.99px) and (orientation: landscape)',
      Web: '(min-width: 840px) and (orientation: portrait), ' +
          '(min-width: 1280px) and (orientation: landscape)',
      HandsetPortrait: '(max-width: 599.99px) and (orientation: portrait)',
      TabletPortrait: '(min-width: 600px) and (max-width: 839.99px) and (orientation: portrait)',
      WebPortrait: '(min-width: 840px) and (orientation: portrait)',
      HandsetLandscape: '(max-width: 959.99px) and (orientation: landscape)',
      TabletLandscape: '(min-width: 960px) and (max-width: 1279.99px) and (orientation: landscape)',
      WebLandscape: '(min-width: 1280px) and (orientation: landscape)',
  };

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token that can be used to access the data that was passed in to a bottom sheet.
   * @type {?}
   */
  var MAT_BOTTOM_SHEET_DATA = new core.InjectionToken('MatBottomSheetData');
  /**
   * Configuration used when opening a bottom sheet.
   * @template D
   */
  var /**
   * Configuration used when opening a bottom sheet.
   * @template D
   */ MatBottomSheetConfig = /** @class */ (function () {
      function MatBottomSheetConfig() {
          /**
           * Data being injected into the child component.
           */
          this.data = null;
          /**
           * Whether the bottom sheet has a backdrop.
           */
          this.hasBackdrop = true;
          /**
           * Whether the user can use escape or clicking outside to close the bottom sheet.
           */
          this.disableClose = false;
          /**
           * Aria label to assign to the bottom sheet element.
           */
          this.ariaLabel = null;
          /**
           * Whether the bottom sheet should close when the user goes backwards/forwards in history.
           * Note that this usually doesn't include clicking on links (unless the user is using
           * the `HashLocationStrategy`).
           */
          this.closeOnNavigation = true;
          // Note that this is disabled by default, because while the a11y recommendations are to focus
          // the first focusable element, doing so prevents screen readers from reading out the
          // rest of the bottom sheet content.
          /**
           * Whether the bottom sheet should focus the first focusable element on open.
           */
          this.autoFocus = false;
          /**
           * Whether the bottom sheet should restore focus to the
           * previously-focused element, after it's closed.
           */
          this.restoreFocus = true;
      }
      return MatBottomSheetConfig;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Animations used by the Material bottom sheet.
   * @type {?}
   */
  var matBottomSheetAnimations = {
      /**
       * Animation that shows and hides a bottom sheet.
       */
      bottomSheetState: trigger('state', [
          state('void, hidden', style({ transform: 'translateY(100%)' })),
          state('visible', style({ transform: 'translateY(0%)' })),
          transition('visible => void, visible => hidden', animate(AnimationDurations.COMPLEX + " " + AnimationCurves.ACCELERATION_CURVE)),
          transition('void => visible', animate(AnimationDurations.EXITING + " " + AnimationCurves.DECELERATION_CURVE)),
      ])
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // TODO(crisbeto): consolidate some logic between this, MatDialog and MatSnackBar
  /**
   * Internal component that wraps user-provided bottom sheet content.
   * \@docs-private
   */
  var MatBottomSheetContainer = /** @class */ (function (_super) {
      tslib_1.__extends(MatBottomSheetContainer, _super);
      function MatBottomSheetContainer(_elementRef, _changeDetectorRef, _focusTrapFactory, breakpointObserver, document, bottomSheetConfig) {
          var _this = _super.call(this) || this;
          _this._elementRef = _elementRef;
          _this._changeDetectorRef = _changeDetectorRef;
          _this._focusTrapFactory = _focusTrapFactory;
          _this.bottomSheetConfig = bottomSheetConfig;
          /**
           * The state of the bottom sheet animations.
           */
          _this._animationState = 'void';
          /**
           * Emits whenever the state of the animation changes.
           */
          _this._animationStateChanged = new core.EventEmitter();
          /**
           * Element that was focused before the bottom sheet was opened.
           */
          _this._elementFocusedBeforeOpened = null;
          _this._document = document;
          _this._breakpointSubscription = breakpointObserver
              .observe([Breakpoints.Medium, Breakpoints.Large, Breakpoints.XLarge])
              .subscribe(function () {
              _this._toggleClass('mat-bottom-sheet-container-medium', breakpointObserver.isMatched(Breakpoints.Medium));
              _this._toggleClass('mat-bottom-sheet-container-large', breakpointObserver.isMatched(Breakpoints.Large));
              _this._toggleClass('mat-bottom-sheet-container-xlarge', breakpointObserver.isMatched(Breakpoints.XLarge));
          });
          return _this;
      }
      /** Attach a component portal as content to this bottom sheet container. */
      /**
       * Attach a component portal as content to this bottom sheet container.
       * @template T
       * @param {?} portal
       * @return {?}
       */
      MatBottomSheetContainer.prototype.attachComponentPortal = /**
       * Attach a component portal as content to this bottom sheet container.
       * @template T
       * @param {?} portal
       * @return {?}
       */
          function (portal) {
              this._validatePortalAttached();
              this._setPanelClass();
              this._savePreviouslyFocusedElement();
              return this._portalOutlet.attachComponentPortal(portal);
          };
      /** Attach a template portal as content to this bottom sheet container. */
      /**
       * Attach a template portal as content to this bottom sheet container.
       * @template C
       * @param {?} portal
       * @return {?}
       */
      MatBottomSheetContainer.prototype.attachTemplatePortal = /**
       * Attach a template portal as content to this bottom sheet container.
       * @template C
       * @param {?} portal
       * @return {?}
       */
          function (portal) {
              this._validatePortalAttached();
              this._setPanelClass();
              this._savePreviouslyFocusedElement();
              return this._portalOutlet.attachTemplatePortal(portal);
          };
      /** Begin animation of bottom sheet entrance into view. */
      /**
       * Begin animation of bottom sheet entrance into view.
       * @return {?}
       */
      MatBottomSheetContainer.prototype.enter = /**
       * Begin animation of bottom sheet entrance into view.
       * @return {?}
       */
          function () {
              if (!this._destroyed) {
                  this._animationState = 'visible';
                  this._changeDetectorRef.detectChanges();
              }
          };
      /** Begin animation of the bottom sheet exiting from view. */
      /**
       * Begin animation of the bottom sheet exiting from view.
       * @return {?}
       */
      MatBottomSheetContainer.prototype.exit = /**
       * Begin animation of the bottom sheet exiting from view.
       * @return {?}
       */
          function () {
              if (!this._destroyed) {
                  this._animationState = 'hidden';
                  this._changeDetectorRef.markForCheck();
              }
          };
      /**
       * @return {?}
       */
      MatBottomSheetContainer.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._breakpointSubscription.unsubscribe();
              this._destroyed = true;
          };
      /**
       * @param {?} event
       * @return {?}
       */
      MatBottomSheetContainer.prototype._onAnimationDone = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (event.toState === 'hidden') {
                  this._restoreFocus();
              }
              else if (event.toState === 'visible' && this.bottomSheetConfig.autoFocus) {
                  this._trapFocus();
              }
              this._animationStateChanged.emit(event);
          };
      /**
       * @param {?} event
       * @return {?}
       */
      MatBottomSheetContainer.prototype._onAnimationStart = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              this._animationStateChanged.emit(event);
          };
      /**
       * @private
       * @param {?} cssClass
       * @param {?} add
       * @return {?}
       */
      MatBottomSheetContainer.prototype._toggleClass = /**
       * @private
       * @param {?} cssClass
       * @param {?} add
       * @return {?}
       */
          function (cssClass, add) {
              /** @type {?} */
              var classList = this._elementRef.nativeElement.classList;
              add ? classList.add(cssClass) : classList.remove(cssClass);
          };
      /**
       * @private
       * @return {?}
       */
      MatBottomSheetContainer.prototype._validatePortalAttached = /**
       * @private
       * @return {?}
       */
          function () {
              if (this._portalOutlet.hasAttached()) {
                  throw Error('Attempting to attach bottom sheet content after content is already attached');
              }
          };
      /**
       * @private
       * @return {?}
       */
      MatBottomSheetContainer.prototype._setPanelClass = /**
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var element = this._elementRef.nativeElement;
              /** @type {?} */
              var panelClass = this.bottomSheetConfig.panelClass;
              if (Array.isArray(panelClass)) {
                  // Note that we can't use a spread here, because IE doesn't support multiple arguments.
                  panelClass.forEach(function (cssClass) { return element.classList.add(cssClass); });
              }
              else if (panelClass) {
                  element.classList.add(panelClass);
              }
          };
      /** Moves the focus inside the focus trap. */
      /**
       * Moves the focus inside the focus trap.
       * @private
       * @return {?}
       */
      MatBottomSheetContainer.prototype._trapFocus = /**
       * Moves the focus inside the focus trap.
       * @private
       * @return {?}
       */
          function () {
              if (!this._focusTrap) {
                  this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);
              }
              this._focusTrap.focusInitialElementWhenReady();
          };
      /** Restores focus to the element that was focused before the bottom sheet was opened. */
      /**
       * Restores focus to the element that was focused before the bottom sheet was opened.
       * @private
       * @return {?}
       */
      MatBottomSheetContainer.prototype._restoreFocus = /**
       * Restores focus to the element that was focused before the bottom sheet was opened.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var toFocus = this._elementFocusedBeforeOpened;
              // We need the extra check, because IE can set the `activeElement` to null in some cases.
              if (this.bottomSheetConfig.restoreFocus && toFocus && typeof toFocus.focus === 'function') {
                  toFocus.focus();
              }
              if (this._focusTrap) {
                  this._focusTrap.destroy();
              }
          };
      /** Saves a reference to the element that was focused before the bottom sheet was opened. */
      /**
       * Saves a reference to the element that was focused before the bottom sheet was opened.
       * @private
       * @return {?}
       */
      MatBottomSheetContainer.prototype._savePreviouslyFocusedElement = /**
       * Saves a reference to the element that was focused before the bottom sheet was opened.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              this._elementFocusedBeforeOpened = ( /** @type {?} */(this._document.activeElement));
              // The `focus` method isn't available during server-side rendering.
              if (this._elementRef.nativeElement.focus) {
                  Promise.resolve().then(function () { return _this._elementRef.nativeElement.focus(); });
              }
          };
      MatBottomSheetContainer.decorators = [
          { type: core.Component, args: [{ selector: 'mat-bottom-sheet-container',
                      template: "<ng-template cdkPortalOutlet></ng-template>",
                      styles: [".mat-bottom-sheet-container{padding:8px 16px;min-width:100vw;box-sizing:border-box;display:block;outline:0;max-height:80vh;overflow:auto}@media (-ms-high-contrast:active){.mat-bottom-sheet-container{outline:1px solid}}.mat-bottom-sheet-container-large,.mat-bottom-sheet-container-medium,.mat-bottom-sheet-container-xlarge{border-top-left-radius:4px;border-top-right-radius:4px}.mat-bottom-sheet-container-medium{min-width:384px;max-width:calc(100vw - 128px)}.mat-bottom-sheet-container-large{min-width:512px;max-width:calc(100vw - 256px)}.mat-bottom-sheet-container-xlarge{min-width:576px;max-width:calc(100vw - 384px)}"],
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                      animations: [matBottomSheetAnimations.bottomSheetState],
                      host: {
                          'class': 'mat-bottom-sheet-container',
                          'tabindex': '-1',
                          'role': 'dialog',
                          'aria-modal': 'true',
                          '[attr.aria-label]': 'bottomSheetConfig?.ariaLabel',
                          '[@state]': '_animationState',
                          '(@state.start)': '_onAnimationStart($event)',
                          '(@state.done)': '_onAnimationDone($event)'
                      },
                  },] },
      ];
      /** @nocollapse */
      MatBottomSheetContainer.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.ChangeDetectorRef },
              { type: FocusTrapFactory },
              { type: BreakpointObserver },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] },
              { type: MatBottomSheetConfig }
          ];
      };
      MatBottomSheetContainer.propDecorators = {
          _portalOutlet: [{ type: core.ViewChild, args: [CdkPortalOutlet,] }]
      };
      return MatBottomSheetContainer;
  }(BasePortalOutlet));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var MatBottomSheetModule = /** @class */ (function () {
      function MatBottomSheetModule() {
      }
      MatBottomSheetModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [
                          common.CommonModule,
                          OverlayModule,
                          MatCommonModule,
                          PortalModule,
                      ],
                      exports: [MatBottomSheetContainer, MatCommonModule],
                      declarations: [MatBottomSheetContainer],
                      entryComponents: [MatBottomSheetContainer],
                  },] },
      ];
      return MatBottomSheetModule;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Reference to a bottom sheet dispatched from the bottom sheet service.
   * @template T, R
   */
  var /**
   * Reference to a bottom sheet dispatched from the bottom sheet service.
   * @template T, R
   */ MatBottomSheetRef = /** @class */ (function () {
      function MatBottomSheetRef(containerInstance, _overlayRef, 
      // @breaking-change 8.0.0 `_location` parameter to be removed.
      _location) {
          var _this = this;
          this._overlayRef = _overlayRef;
          /**
           * Subject for notifying the user that the bottom sheet has been dismissed.
           */
          this._afterDismissed = new rxjs.Subject();
          /**
           * Subject for notifying the user that the bottom sheet has opened and appeared.
           */
          this._afterOpened = new rxjs.Subject();
          this.containerInstance = containerInstance;
          this.disableClose = containerInstance.bottomSheetConfig.disableClose;
          // Emit when opening animation completes
          containerInstance._animationStateChanged.pipe(operators.filter(function (event) { return event.phaseName === 'done' && event.toState === 'visible'; }), operators.take(1))
              .subscribe(function () {
              _this._afterOpened.next();
              _this._afterOpened.complete();
          });
          // Dispose overlay when closing animation is complete
          containerInstance._animationStateChanged.pipe(operators.filter(function (event) { return event.phaseName === 'done' && event.toState === 'hidden'; }), operators.take(1))
              .subscribe(function () {
              _this._overlayRef.dispose();
              _this._afterDismissed.next(_this._result);
              _this._afterDismissed.complete();
          });
          rxjs.merge(_overlayRef.backdropClick(), _overlayRef.keydownEvents().pipe(operators.filter(function (event) { return event.keyCode === ESCAPE; }))).subscribe(function () {
              if (!_this.disableClose) {
                  _this.dismiss();
              }
          });
      }
      /**
       * Dismisses the bottom sheet.
       * @param result Data to be passed back to the bottom sheet opener.
       */
      /**
       * Dismisses the bottom sheet.
       * @param {?=} result Data to be passed back to the bottom sheet opener.
       * @return {?}
       */
      MatBottomSheetRef.prototype.dismiss = /**
       * Dismisses the bottom sheet.
       * @param {?=} result Data to be passed back to the bottom sheet opener.
       * @return {?}
       */
          function (result) {
              var _this = this;
              if (!this._afterDismissed.closed) {
                  // Transition the backdrop in parallel to the bottom sheet.
                  this.containerInstance._animationStateChanged.pipe(operators.filter(function (event) { return event.phaseName === 'start'; }), operators.take(1)).subscribe(function () { return _this._overlayRef.detachBackdrop(); });
                  this._result = result;
                  this.containerInstance.exit();
              }
          };
      /** Gets an observable that is notified when the bottom sheet is finished closing. */
      /**
       * Gets an observable that is notified when the bottom sheet is finished closing.
       * @return {?}
       */
      MatBottomSheetRef.prototype.afterDismissed = /**
       * Gets an observable that is notified when the bottom sheet is finished closing.
       * @return {?}
       */
          function () {
              return this._afterDismissed.asObservable();
          };
      /** Gets an observable that is notified when the bottom sheet has opened and appeared. */
      /**
       * Gets an observable that is notified when the bottom sheet has opened and appeared.
       * @return {?}
       */
      MatBottomSheetRef.prototype.afterOpened = /**
       * Gets an observable that is notified when the bottom sheet has opened and appeared.
       * @return {?}
       */
          function () {
              return this._afterOpened.asObservable();
          };
      /**
       * Gets an observable that emits when the overlay's backdrop has been clicked.
       */
      /**
       * Gets an observable that emits when the overlay's backdrop has been clicked.
       * @return {?}
       */
      MatBottomSheetRef.prototype.backdropClick = /**
       * Gets an observable that emits when the overlay's backdrop has been clicked.
       * @return {?}
       */
          function () {
              return this._overlayRef.backdropClick();
          };
      /**
       * Gets an observable that emits when keydown events are targeted on the overlay.
       */
      /**
       * Gets an observable that emits when keydown events are targeted on the overlay.
       * @return {?}
       */
      MatBottomSheetRef.prototype.keydownEvents = /**
       * Gets an observable that emits when keydown events are targeted on the overlay.
       * @return {?}
       */
          function () {
              return this._overlayRef.keydownEvents();
          };
      return MatBottomSheetRef;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token that can be used to specify default bottom sheet options.
   * @type {?}
   */
  var MAT_BOTTOM_SHEET_DEFAULT_OPTIONS = new core.InjectionToken('mat-bottom-sheet-default-options');
  /**
   * Service to trigger Material Design bottom sheets.
   */
  var MatBottomSheet = /** @class */ (function () {
      function MatBottomSheet(_overlay, _injector, _parentBottomSheet, _location, _defaultOptions) {
          this._overlay = _overlay;
          this._injector = _injector;
          this._parentBottomSheet = _parentBottomSheet;
          this._location = _location;
          this._defaultOptions = _defaultOptions;
          this._bottomSheetRefAtThisLevel = null;
      }
      Object.defineProperty(MatBottomSheet.prototype, "_openedBottomSheetRef", {
          /** Reference to the currently opened bottom sheet. */
          get: /**
           * Reference to the currently opened bottom sheet.
           * @return {?}
           */ function () {
              /** @type {?} */
              var parent = this._parentBottomSheet;
              return parent ? parent._openedBottomSheetRef : this._bottomSheetRefAtThisLevel;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (this._parentBottomSheet) {
                  this._parentBottomSheet._openedBottomSheetRef = value;
              }
              else {
                  this._bottomSheetRefAtThisLevel = value;
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @template T, D, R
       * @param {?} componentOrTemplateRef
       * @param {?=} config
       * @return {?}
       */
      MatBottomSheet.prototype.open = /**
       * @template T, D, R
       * @param {?} componentOrTemplateRef
       * @param {?=} config
       * @return {?}
       */
          function (componentOrTemplateRef, config) {
              var _this = this;
              /** @type {?} */
              var _config = _applyConfigDefaults(this._defaultOptions || new MatBottomSheetConfig(), config);
              /** @type {?} */
              var overlayRef = this._createOverlay(_config);
              /** @type {?} */
              var container = this._attachContainer(overlayRef, _config);
              /** @type {?} */
              var ref = new MatBottomSheetRef(container, overlayRef, this._location);
              if (componentOrTemplateRef instanceof core.TemplateRef) {
                  container.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef, ( /** @type {?} */(null)), ( /** @type {?} */({
                      $implicit: _config.data,
                      bottomSheetRef: ref
                  }))));
              }
              else {
                  /** @type {?} */
                  var portal = new ComponentPortal(componentOrTemplateRef, undefined, this._createInjector(_config, ref));
                  /** @type {?} */
                  var contentRef = container.attachComponentPortal(portal);
                  ref.instance = contentRef.instance;
              }
              // When the bottom sheet is dismissed, clear the reference to it.
              ref.afterDismissed().subscribe(function () {
                  // Clear the bottom sheet ref if it hasn't already been replaced by a newer one.
                  if (_this._openedBottomSheetRef == ref) {
                      _this._openedBottomSheetRef = null;
                  }
              });
              if (this._openedBottomSheetRef) {
                  // If a bottom sheet is already in view, dismiss it and enter the
                  // new bottom sheet after exit animation is complete.
                  this._openedBottomSheetRef.afterDismissed().subscribe(function () { return ref.containerInstance.enter(); });
                  this._openedBottomSheetRef.dismiss();
              }
              else {
                  // If no bottom sheet is in view, enter the new bottom sheet.
                  ref.containerInstance.enter();
              }
              this._openedBottomSheetRef = ref;
              return ref;
          };
      /**
       * Dismisses the currently-visible bottom sheet.
       */
      /**
       * Dismisses the currently-visible bottom sheet.
       * @return {?}
       */
      MatBottomSheet.prototype.dismiss = /**
       * Dismisses the currently-visible bottom sheet.
       * @return {?}
       */
          function () {
              if (this._openedBottomSheetRef) {
                  this._openedBottomSheetRef.dismiss();
              }
          };
      /**
       * @return {?}
       */
      MatBottomSheet.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              if (this._bottomSheetRefAtThisLevel) {
                  this._bottomSheetRefAtThisLevel.dismiss();
              }
          };
      /**
       * Attaches the bottom sheet container component to the overlay.
       */
      /**
       * Attaches the bottom sheet container component to the overlay.
       * @private
       * @param {?} overlayRef
       * @param {?} config
       * @return {?}
       */
      MatBottomSheet.prototype._attachContainer = /**
       * Attaches the bottom sheet container component to the overlay.
       * @private
       * @param {?} overlayRef
       * @param {?} config
       * @return {?}
       */
          function (overlayRef, config) {
              /** @type {?} */
              var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
              /** @type {?} */
              var injector = new PortalInjector(userInjector || this._injector, new WeakMap([
                  [MatBottomSheetConfig, config]
              ]));
              /** @type {?} */
              var containerPortal = new ComponentPortal(MatBottomSheetContainer, config.viewContainerRef, injector);
              /** @type {?} */
              var containerRef = overlayRef.attach(containerPortal);
              return containerRef.instance;
          };
      /**
       * Creates a new overlay and places it in the correct location.
       * @param config The user-specified bottom sheet config.
       */
      /**
       * Creates a new overlay and places it in the correct location.
       * @private
       * @param {?} config The user-specified bottom sheet config.
       * @return {?}
       */
      MatBottomSheet.prototype._createOverlay = /**
       * Creates a new overlay and places it in the correct location.
       * @private
       * @param {?} config The user-specified bottom sheet config.
       * @return {?}
       */
          function (config) {
              /** @type {?} */
              var overlayConfig = new OverlayConfig({
                  direction: config.direction,
                  hasBackdrop: config.hasBackdrop,
                  disposeOnNavigation: config.closeOnNavigation,
                  maxWidth: '100%',
                  scrollStrategy: this._overlay.scrollStrategies.block(),
                  positionStrategy: this._overlay.position()
                      .global()
                      .centerHorizontally()
                      .bottom('0')
              });
              if (config.backdropClass) {
                  overlayConfig.backdropClass = config.backdropClass;
              }
              return this._overlay.create(overlayConfig);
          };
      /**
       * Creates an injector to be used inside of a bottom sheet component.
       * @param config Config that was used to create the bottom sheet.
       * @param bottomSheetRef Reference to the bottom sheet.
       */
      /**
       * Creates an injector to be used inside of a bottom sheet component.
       * @private
       * @template T
       * @param {?} config Config that was used to create the bottom sheet.
       * @param {?} bottomSheetRef Reference to the bottom sheet.
       * @return {?}
       */
      MatBottomSheet.prototype._createInjector = /**
       * Creates an injector to be used inside of a bottom sheet component.
       * @private
       * @template T
       * @param {?} config Config that was used to create the bottom sheet.
       * @param {?} bottomSheetRef Reference to the bottom sheet.
       * @return {?}
       */
          function (config, bottomSheetRef) {
              /** @type {?} */
              var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
              /** @type {?} */
              var injectionTokens = new WeakMap([
                  [MatBottomSheetRef, bottomSheetRef],
                  [MAT_BOTTOM_SHEET_DATA, config.data]
              ]);
              if (config.direction &&
                  (!userInjector || !userInjector.get(Directionality, null))) {
                  injectionTokens.set(Directionality, {
                      value: config.direction,
                      change: rxjs.of()
                  });
              }
              return new PortalInjector(userInjector || this._injector, injectionTokens);
          };
      MatBottomSheet.decorators = [
          { type: core.Injectable, args: [{ providedIn: MatBottomSheetModule },] },
      ];
      /** @nocollapse */
      MatBottomSheet.ctorParameters = function () {
          return [
              { type: Overlay },
              { type: core.Injector },
              { type: MatBottomSheet, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
              { type: common.Location, decorators: [{ type: core.Optional }] },
              { type: MatBottomSheetConfig, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_BOTTOM_SHEET_DEFAULT_OPTIONS,] }] }
          ];
      };
      /** @nocollapse */ MatBottomSheet.ngInjectableDef = core.defineInjectable({ factory: function MatBottomSheet_Factory() { return new MatBottomSheet(core.inject(Overlay), core.inject(core.INJECTOR), core.inject(MatBottomSheet, 12), core.inject(common.Location, 8), core.inject(MAT_BOTTOM_SHEET_DEFAULT_OPTIONS, 8)); }, token: MatBottomSheet, providedIn: MatBottomSheetModule });
      return MatBottomSheet;
  }());
  /**
   * Applies default options to the bottom sheet config.
   * @param {?} defaults Object containing the default values to which to fall back.
   * @param {?=} config The configuration to which the defaults will be applied.
   * @return {?} The new configuration object with defaults applied.
   */
  function _applyConfigDefaults(defaults, config) {
      return tslib_1.__assign({}, defaults, config);
  }

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Default color palette for round buttons (mat-fab and mat-mini-fab)
   * @type {?}
   */
  var DEFAULT_ROUND_BUTTON_COLOR = 'accent';
  /**
   * List of classes to add to MatButton instances based on host attributes to
   * style as different variants.
   * @type {?}
   */
  var BUTTON_HOST_ATTRIBUTES = [
      'mat-button',
      'mat-flat-button',
      'mat-icon-button',
      'mat-raised-button',
      'mat-stroked-button',
      'mat-mini-fab',
      'mat-fab',
  ];
  // Boilerplate for applying mixins to MatButton.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatButton.
  /**
   * \@docs-private
   */
  MatButtonBase = /** @class */ (function () {
      function MatButtonBase(_elementRef) {
          this._elementRef = _elementRef;
      }
      return MatButtonBase;
  }());
  /** @type {?} */
  var _MatButtonMixinBase = mixinColor(mixinDisabled(mixinDisableRipple(MatButtonBase)));
  /**
   * Material design button.
   */
  var MatButton = /** @class */ (function (_super) {
      tslib_1.__extends(MatButton, _super);
      function MatButton(elementRef, 
      /**
       * @deprecated Platform checks for SSR are no longer needed
       * @breaking-change 8.0.0
       */
      _platform, _focusMonitor, _animationMode) {
          var _this = _super.call(this, elementRef) || this;
          _this._focusMonitor = _focusMonitor;
          _this._animationMode = _animationMode;
          /**
           * Whether the button is round.
           */
          _this.isRoundButton = _this._hasHostAttributes('mat-fab', 'mat-mini-fab');
          /**
           * Whether the button is icon button.
           */
          _this.isIconButton = _this._hasHostAttributes('mat-icon-button');
          // For each of the variant selectors that is prevent in the button's host
          // attributes, add the correct corresponding class.
          for (var _i = 0, BUTTON_HOST_ATTRIBUTES_1 = BUTTON_HOST_ATTRIBUTES; _i < BUTTON_HOST_ATTRIBUTES_1.length; _i++) {
              var attr = BUTTON_HOST_ATTRIBUTES_1[_i];
              if (_this._hasHostAttributes(attr)) {
                  (( /** @type {?} */(elementRef.nativeElement))).classList.add(attr);
              }
          }
          _this._focusMonitor.monitor(_this._elementRef, true);
          if (_this.isRoundButton) {
              _this.color = DEFAULT_ROUND_BUTTON_COLOR;
          }
          return _this;
      }
      /**
       * @return {?}
       */
      MatButton.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._focusMonitor.stopMonitoring(this._elementRef);
          };
      /** Focuses the button. */
      /**
       * Focuses the button.
       * @return {?}
       */
      MatButton.prototype.focus = /**
       * Focuses the button.
       * @return {?}
       */
          function () {
              this._getHostElement().focus();
          };
      /**
       * @return {?}
       */
      MatButton.prototype._getHostElement = /**
       * @return {?}
       */
          function () {
              return this._elementRef.nativeElement;
          };
      /**
       * @return {?}
       */
      MatButton.prototype._isRippleDisabled = /**
       * @return {?}
       */
          function () {
              return this.disableRipple || this.disabled;
          };
      /** Gets whether the button has one of the given attributes. */
      /**
       * Gets whether the button has one of the given attributes.
       * @param {...?} attributes
       * @return {?}
       */
      MatButton.prototype._hasHostAttributes = /**
       * Gets whether the button has one of the given attributes.
       * @param {...?} attributes
       * @return {?}
       */
          function () {
              var _this = this;
              var attributes = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  attributes[_i] = arguments[_i];
              }
              return attributes.some(function (attribute) { return _this._getHostElement().hasAttribute(attribute); });
          };
      MatButton.decorators = [
          { type: core.Component, args: [{ selector: "button[mat-button], button[mat-raised-button], button[mat-icon-button],\n             button[mat-fab], button[mat-mini-fab], button[mat-stroked-button],\n             button[mat-flat-button]",
                      exportAs: 'matButton',
                      host: {
                          '[disabled]': 'disabled || null',
                          '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                      },
                      template: "<span class=\"mat-button-wrapper\"><ng-content></ng-content></span><div matRipple class=\"mat-button-ripple\" [class.mat-button-ripple-round]=\"isRoundButton || isIconButton\" [matRippleDisabled]=\"_isRippleDisabled()\" [matRippleCentered]=\"isIconButton\" [matRippleTrigger]=\"_getHostElement()\"></div><div class=\"mat-button-focus-overlay\"></div>",
                      styles: [".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:.04}@media (hover:none){.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-flat-button,.mat-icon-button,.mat-stroked-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner{border:0}.mat-button[disabled],.mat-flat-button[disabled],.mat-icon-button[disabled],.mat-stroked-button[disabled]{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button[disabled]{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-focus-overlay,.mat-stroked-button .mat-button-ripple.mat-ripple{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab[disabled]{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab[disabled]{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button .mat-icon,.mat-icon-button i{line-height:24px}.mat-button-focus-overlay,.mat-button-ripple.mat-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-focus-overlay{opacity:0;transition:opacity .2s cubic-bezier(.35,0,.25,1),background-color .2s cubic-bezier(.35,0,.25,1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}@media (-ms-high-contrast:active){.mat-button-focus-overlay{background-color:#fff}}@media (-ms-high-contrast:black-on-white){.mat-button-focus-overlay{background-color:#000}}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:block;font-size:inherit;width:2.5em;height:2.5em}@media (-ms-high-contrast:active){.mat-button,.mat-fab,.mat-flat-button,.mat-icon-button,.mat-mini-fab,.mat-raised-button{outline:solid 1px}}"],
                      inputs: ['disabled', 'disableRipple', 'color'],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatButton.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: Platform },
              { type: FocusMonitor },
              { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] }
          ];
      };
      MatButton.propDecorators = {
          ripple: [{ type: core.ViewChild, args: [MatRipple,] }]
      };
      return MatButton;
  }(_MatButtonMixinBase));
  /**
   * Raised Material design button.
   */
  var MatAnchor = /** @class */ (function (_super) {
      tslib_1.__extends(MatAnchor, _super);
      function MatAnchor(platform, focusMonitor, elementRef, 
      // @breaking-change 8.0.0 `animationMode` parameter to be made required.
      animationMode) {
          return _super.call(this, elementRef, platform, focusMonitor, animationMode) || this;
      }
      /**
       * @param {?} event
       * @return {?}
       */
      MatAnchor.prototype._haltDisabledEvents = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              // A disabled button shouldn't apply any actions
              if (this.disabled) {
                  event.preventDefault();
                  event.stopImmediatePropagation();
              }
          };
      MatAnchor.decorators = [
          { type: core.Component, args: [{ selector: "a[mat-button], a[mat-raised-button], a[mat-icon-button], a[mat-fab],\n             a[mat-mini-fab], a[mat-stroked-button], a[mat-flat-button]",
                      exportAs: 'matButton, matAnchor',
                      host: {
                          // Note that we ignore the user-specified tabindex when it's disabled for
                          // consistency with the `mat-button` applied on native buttons where even
                          // though they have an index, they're not tabbable.
                          '[attr.tabindex]': 'disabled ? -1 : (tabIndex || 0)',
                          '[attr.disabled]': 'disabled || null',
                          '[attr.aria-disabled]': 'disabled.toString()',
                          '(click)': '_haltDisabledEvents($event)',
                          '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                      },
                      inputs: ['disabled', 'disableRipple', 'color'],
                      template: "<span class=\"mat-button-wrapper\"><ng-content></ng-content></span><div matRipple class=\"mat-button-ripple\" [class.mat-button-ripple-round]=\"isRoundButton || isIconButton\" [matRippleDisabled]=\"_isRippleDisabled()\" [matRippleCentered]=\"isIconButton\" [matRippleTrigger]=\"_getHostElement()\"></div><div class=\"mat-button-focus-overlay\"></div>",
                      styles: [".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:.04}@media (hover:none){.mat-button:hover .mat-button-focus-overlay,.mat-stroked-button:hover .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-flat-button,.mat-icon-button,.mat-stroked-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner{border:0}.mat-button[disabled],.mat-flat-button[disabled],.mat-icon-button[disabled],.mat-stroked-button[disabled]{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button[disabled]{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-focus-overlay,.mat-stroked-button .mat-button-ripple.mat-ripple{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab[disabled]{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0,0,0);transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab[disabled]{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button .mat-icon,.mat-icon-button i{line-height:24px}.mat-button-focus-overlay,.mat-button-ripple.mat-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-focus-overlay{opacity:0;transition:opacity .2s cubic-bezier(.35,0,.25,1),background-color .2s cubic-bezier(.35,0,.25,1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}@media (-ms-high-contrast:active){.mat-button-focus-overlay{background-color:#fff}}@media (-ms-high-contrast:black-on-white){.mat-button-focus-overlay{background-color:#000}}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:block;font-size:inherit;width:2.5em;height:2.5em}@media (-ms-high-contrast:active){.mat-button,.mat-fab,.mat-flat-button,.mat-icon-button,.mat-mini-fab,.mat-raised-button{outline:solid 1px}}"],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatAnchor.ctorParameters = function () {
          return [
              { type: Platform },
              { type: FocusMonitor },
              { type: core.ElementRef },
              { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] }
          ];
      };
      MatAnchor.propDecorators = {
          tabIndex: [{ type: core.Input }]
      };
      return MatAnchor;
  }(MatButton));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var MatButtonModule = /** @class */ (function () {
      function MatButtonModule() {
      }
      MatButtonModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [
                          common.CommonModule,
                          MatRippleModule,
                          MatCommonModule,
                      ],
                      exports: [
                          MatButton,
                          MatAnchor,
                          MatCommonModule,
                      ],
                      declarations: [
                          MatButton,
                          MatAnchor,
                      ],
                  },] },
      ];
      return MatButtonModule;
  }());

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token that can be used to configure the
   * default options for all button toggles within an app.
   * @type {?}
   */
  var MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS = new core.InjectionToken('MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS');
  /**
   * Provider Expression that allows mat-button-toggle-group to register as a ControlValueAccessor.
   * This allows it to support [(ngModel)].
   * \@docs-private
   * @type {?}
   */
  var MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR = {
      provide: forms.NG_VALUE_ACCESSOR,
      useExisting: core.forwardRef(function () { return MatButtonToggleGroup; }),
      multi: true
  };
  /**
   * @deprecated Use `MatButtonToggleGroup` instead.
   * \@breaking-change 8.0.0
   */
  var /**
   * @deprecated Use `MatButtonToggleGroup` instead.
   * \@breaking-change 8.0.0
   */ MatButtonToggleGroupMultiple = /** @class */ (function () {
      function MatButtonToggleGroupMultiple() {
      }
      return MatButtonToggleGroupMultiple;
  }());
  /** @type {?} */
  var _uniqueIdCounter$1 = 0;
  /**
   * Change event object emitted by MatButtonToggle.
   */
  var /**
   * Change event object emitted by MatButtonToggle.
   */ MatButtonToggleChange = /** @class */ (function () {
      function MatButtonToggleChange(source, value) {
          this.source = source;
          this.value = value;
      }
      return MatButtonToggleChange;
  }());
  /**
   * Exclusive selection button toggle group that behaves like a radio-button group.
   */
  var MatButtonToggleGroup = /** @class */ (function () {
      function MatButtonToggleGroup(_changeDetector, defaultOptions) {
          this._changeDetector = _changeDetector;
          this._vertical = false;
          this._multiple = false;
          this._disabled = false;
          /**
           * The method to be called in order to update ngModel.
           * Now `ngModel` binding is not supported in multiple selection mode.
           */
          this._controlValueAccessorChangeFn = function () { };
          /**
           * onTouch function registered via registerOnTouch (ControlValueAccessor).
           */
          this._onTouched = function () { };
          this._name = "mat-button-toggle-group-" + _uniqueIdCounter$1++;
          /**
           * Event that emits whenever the value of the group changes.
           * Used to facilitate two-way data binding.
           * \@docs-private
           */
          this.valueChange = new core.EventEmitter();
          /**
           * Event emitted when the group's value changes.
           */
          this.change = new core.EventEmitter();
          this.appearance =
              defaultOptions && defaultOptions.appearance ? defaultOptions.appearance : 'standard';
      }
      Object.defineProperty(MatButtonToggleGroup.prototype, "name", {
          /** `name` attribute for the underlying `input` element. */
          get: /**
           * `name` attribute for the underlying `input` element.
           * @return {?}
           */ function () { return this._name; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              var _this = this;
              this._name = value;
              if (this._buttonToggles) {
                  this._buttonToggles.forEach(function (toggle) {
                      toggle.name = _this._name;
                      toggle._markForCheck();
                  });
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatButtonToggleGroup.prototype, "vertical", {
          /** Whether the toggle group is vertical. */
          get: /**
           * Whether the toggle group is vertical.
           * @return {?}
           */ function () { return this._vertical; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._vertical = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatButtonToggleGroup.prototype, "value", {
          /** Value of the toggle group. */
          get: /**
           * Value of the toggle group.
           * @return {?}
           */ function () {
              /** @type {?} */
              var selected = this._selectionModel ? this._selectionModel.selected : [];
              if (this.multiple) {
                  return selected.map(function (toggle) { return toggle.value; });
              }
              return selected[0] ? selected[0].value : undefined;
          },
          set: /**
           * @param {?} newValue
           * @return {?}
           */ function (newValue) {
              this._setSelectionByValue(newValue);
              this.valueChange.emit(this.value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatButtonToggleGroup.prototype, "selected", {
          /** Selected button toggles in the group. */
          get: /**
           * Selected button toggles in the group.
           * @return {?}
           */ function () {
              /** @type {?} */
              var selected = this._selectionModel.selected;
              return this.multiple ? selected : (selected[0] || null);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatButtonToggleGroup.prototype, "multiple", {
          /** Whether multiple button toggles can be selected. */
          get: /**
           * Whether multiple button toggles can be selected.
           * @return {?}
           */ function () { return this._multiple; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._multiple = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatButtonToggleGroup.prototype, "disabled", {
          /** Whether multiple button toggle group is disabled. */
          get: /**
           * Whether multiple button toggle group is disabled.
           * @return {?}
           */ function () { return this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._disabled = coerceBooleanProperty(value);
              if (this._buttonToggles) {
                  this._buttonToggles.forEach(function (toggle) { return toggle._markForCheck(); });
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatButtonToggleGroup.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              this._selectionModel = new SelectionModel(this.multiple, undefined, false);
          };
      /**
       * @return {?}
       */
      MatButtonToggleGroup.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              var _a;
              (_a = this._selectionModel).select.apply(_a, this._buttonToggles.filter(function (toggle) { return toggle.checked; }));
          };
      /**
       * Sets the model value. Implemented as part of ControlValueAccessor.
       * @param value Value to be set to the model.
       */
      /**
       * Sets the model value. Implemented as part of ControlValueAccessor.
       * @param {?} value Value to be set to the model.
       * @return {?}
       */
      MatButtonToggleGroup.prototype.writeValue = /**
       * Sets the model value. Implemented as part of ControlValueAccessor.
       * @param {?} value Value to be set to the model.
       * @return {?}
       */
          function (value) {
              this.value = value;
              this._changeDetector.markForCheck();
          };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} fn
       * @return {?}
       */
      MatButtonToggleGroup.prototype.registerOnChange =
          // Implemented as part of ControlValueAccessor.
          /**
           * @param {?} fn
           * @return {?}
           */
          function (fn) {
              this._controlValueAccessorChangeFn = fn;
          };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} fn
       * @return {?}
       */
      MatButtonToggleGroup.prototype.registerOnTouched =
          // Implemented as part of ControlValueAccessor.
          /**
           * @param {?} fn
           * @return {?}
           */
          function (fn) {
              this._onTouched = fn;
          };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} isDisabled
       * @return {?}
       */
      MatButtonToggleGroup.prototype.setDisabledState =
          // Implemented as part of ControlValueAccessor.
          /**
           * @param {?} isDisabled
           * @return {?}
           */
          function (isDisabled) {
              this.disabled = isDisabled;
          };
      /** Dispatch change event with current selection and group value. */
      /**
       * Dispatch change event with current selection and group value.
       * @return {?}
       */
      MatButtonToggleGroup.prototype._emitChangeEvent = /**
       * Dispatch change event with current selection and group value.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var selected = this.selected;
              /** @type {?} */
              var source = Array.isArray(selected) ? selected[selected.length - 1] : selected;
              /** @type {?} */
              var event = new MatButtonToggleChange(( /** @type {?} */(source)), this.value);
              this._controlValueAccessorChangeFn(event.value);
              this.change.emit(event);
          };
      /**
       * Syncs a button toggle's selected state with the model value.
       * @param toggle Toggle to be synced.
       * @param select Whether the toggle should be selected.
       * @param isUserInput Whether the change was a result of a user interaction.
       */
      /**
       * Syncs a button toggle's selected state with the model value.
       * @param {?} toggle Toggle to be synced.
       * @param {?} select Whether the toggle should be selected.
       * @param {?=} isUserInput Whether the change was a result of a user interaction.
       * @return {?}
       */
      MatButtonToggleGroup.prototype._syncButtonToggle = /**
       * Syncs a button toggle's selected state with the model value.
       * @param {?} toggle Toggle to be synced.
       * @param {?} select Whether the toggle should be selected.
       * @param {?=} isUserInput Whether the change was a result of a user interaction.
       * @return {?}
       */
          function (toggle, select, isUserInput) {
              if (isUserInput === void 0) {
                  isUserInput = false;
              }
              // Deselect the currently-selected toggle, if we're in single-selection
              // mode and the button being toggled isn't selected at the moment.
              if (!this.multiple && this.selected && !toggle.checked) {
                  (( /** @type {?} */(this.selected))).checked = false;
              }
              if (select) {
                  this._selectionModel.select(toggle);
              }
              else {
                  this._selectionModel.deselect(toggle);
              }
              // Only emit the change event for user input.
              if (isUserInput) {
                  this._emitChangeEvent();
              }
              // Note: we emit this one no matter whether it was a user interaction, because
              // it is used by Angular to sync up the two-way data binding.
              this.valueChange.emit(this.value);
          };
      /** Checks whether a button toggle is selected. */
      /**
       * Checks whether a button toggle is selected.
       * @param {?} toggle
       * @return {?}
       */
      MatButtonToggleGroup.prototype._isSelected = /**
       * Checks whether a button toggle is selected.
       * @param {?} toggle
       * @return {?}
       */
          function (toggle) {
              return this._selectionModel.isSelected(toggle);
          };
      /** Determines whether a button toggle should be checked on init. */
      /**
       * Determines whether a button toggle should be checked on init.
       * @param {?} toggle
       * @return {?}
       */
      MatButtonToggleGroup.prototype._isPrechecked = /**
       * Determines whether a button toggle should be checked on init.
       * @param {?} toggle
       * @return {?}
       */
          function (toggle) {
              if (typeof this._rawValue === 'undefined') {
                  return false;
              }
              if (this.multiple && Array.isArray(this._rawValue)) {
                  return this._rawValue.some(function (value) { return toggle.value != null && value === toggle.value; });
              }
              return toggle.value === this._rawValue;
          };
      /** Updates the selection state of the toggles in the group based on a value. */
      /**
       * Updates the selection state of the toggles in the group based on a value.
       * @private
       * @param {?} value
       * @return {?}
       */
      MatButtonToggleGroup.prototype._setSelectionByValue = /**
       * Updates the selection state of the toggles in the group based on a value.
       * @private
       * @param {?} value
       * @return {?}
       */
          function (value) {
              var _this = this;
              this._rawValue = value;
              if (!this._buttonToggles) {
                  return;
              }
              if (this.multiple && value) {
                  if (!Array.isArray(value)) {
                      throw Error('Value must be an array in multiple-selection mode.');
                  }
                  this._clearSelection();
                  value.forEach(function (currentValue) { return _this._selectValue(currentValue); });
              }
              else {
                  this._clearSelection();
                  this._selectValue(value);
              }
          };
      /** Clears the selected toggles. */
      /**
       * Clears the selected toggles.
       * @private
       * @return {?}
       */
      MatButtonToggleGroup.prototype._clearSelection = /**
       * Clears the selected toggles.
       * @private
       * @return {?}
       */
          function () {
              this._selectionModel.clear();
              this._buttonToggles.forEach(function (toggle) { return toggle.checked = false; });
          };
      /** Selects a value if there's a toggle that corresponds to it. */
      /**
       * Selects a value if there's a toggle that corresponds to it.
       * @private
       * @param {?} value
       * @return {?}
       */
      MatButtonToggleGroup.prototype._selectValue = /**
       * Selects a value if there's a toggle that corresponds to it.
       * @private
       * @param {?} value
       * @return {?}
       */
          function (value) {
              /** @type {?} */
              var correspondingOption = this._buttonToggles.find(function (toggle) {
                  return toggle.value != null && toggle.value === value;
              });
              if (correspondingOption) {
                  correspondingOption.checked = true;
                  this._selectionModel.select(correspondingOption);
              }
          };
      MatButtonToggleGroup.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-button-toggle-group',
                      providers: [
                          MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR,
                          { provide: MatButtonToggleGroupMultiple, useExisting: MatButtonToggleGroup },
                      ],
                      host: {
                          'role': 'group',
                          'class': 'mat-button-toggle-group',
                          '[attr.aria-disabled]': 'disabled',
                          '[class.mat-button-toggle-vertical]': 'vertical',
                          '[class.mat-button-toggle-group-appearance-standard]': 'appearance === "standard"',
                      },
                      exportAs: 'matButtonToggleGroup',
                  },] },
      ];
      /** @nocollapse */
      MatButtonToggleGroup.ctorParameters = function () {
          return [
              { type: core.ChangeDetectorRef },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS,] }] }
          ];
      };
      MatButtonToggleGroup.propDecorators = {
          _buttonToggles: [{ type: core.ContentChildren, args: [core.forwardRef(function () { return MatButtonToggle; }),] }],
          appearance: [{ type: core.Input }],
          name: [{ type: core.Input }],
          vertical: [{ type: core.Input }],
          value: [{ type: core.Input }],
          valueChange: [{ type: core.Output }],
          multiple: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          change: [{ type: core.Output }]
      };
      return MatButtonToggleGroup;
  }());
  // Boilerplate for applying mixins to the MatButtonToggle class.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to the MatButtonToggle class.
  /**
   * \@docs-private
   */
  MatButtonToggleBase = /** @class */ (function () {
      function MatButtonToggleBase() {
      }
      return MatButtonToggleBase;
  }());
  /** @type {?} */
  var _MatButtonToggleMixinBase = mixinDisableRipple(MatButtonToggleBase);
  /**
   * Single button inside of a toggle group.
   */
  var MatButtonToggle = /** @class */ (function (_super) {
      tslib_1.__extends(MatButtonToggle, _super);
      function MatButtonToggle(toggleGroup, _changeDetectorRef, _elementRef, _focusMonitor, 
      // @breaking-change 8.0.0 `defaultTabIndex` to be made a required parameter.
      defaultTabIndex, defaultOptions) {
          var _this = _super.call(this) || this;
          _this._changeDetectorRef = _changeDetectorRef;
          _this._elementRef = _elementRef;
          _this._focusMonitor = _focusMonitor;
          _this._isSingleSelector = false;
          _this._checked = false;
          /**
           * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
           */
          _this.ariaLabelledby = null;
          _this._disabled = false;
          /**
           * Event emitted when the group value changes.
           */
          _this.change = new core.EventEmitter();
          /** @type {?} */
          var parsedTabIndex = Number(defaultTabIndex);
          _this.tabIndex = (parsedTabIndex || parsedTabIndex === 0) ? parsedTabIndex : null;
          _this.buttonToggleGroup = toggleGroup;
          _this.appearance =
              defaultOptions && defaultOptions.appearance ? defaultOptions.appearance : 'standard';
          return _this;
      }
      Object.defineProperty(MatButtonToggle.prototype, "buttonId", {
          /** Unique ID for the underlying `button` element. */
          get: /**
           * Unique ID for the underlying `button` element.
           * @return {?}
           */ function () { return this.id + "-button"; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatButtonToggle.prototype, "appearance", {
          /** The appearance style of the button. */
          get: /**
           * The appearance style of the button.
           * @return {?}
           */ function () {
              return this.buttonToggleGroup ? this.buttonToggleGroup.appearance : this._appearance;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._appearance = value;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatButtonToggle.prototype, "checked", {
          /** Whether the button is checked. */
          get: /**
           * Whether the button is checked.
           * @return {?}
           */ function () {
              return this.buttonToggleGroup ? this.buttonToggleGroup._isSelected(this) : this._checked;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var newValue = coerceBooleanProperty(value);
              if (newValue !== this._checked) {
                  this._checked = newValue;
                  if (this.buttonToggleGroup) {
                      this.buttonToggleGroup._syncButtonToggle(this, this._checked);
                  }
                  this._changeDetectorRef.markForCheck();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatButtonToggle.prototype, "disabled", {
          /** Whether the button is disabled. */
          get: /**
           * Whether the button is disabled.
           * @return {?}
           */ function () {
              return this._disabled || (this.buttonToggleGroup && this.buttonToggleGroup.disabled);
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._disabled = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatButtonToggle.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              this._isSingleSelector = this.buttonToggleGroup && !this.buttonToggleGroup.multiple;
              this._type = this._isSingleSelector ? 'radio' : 'checkbox';
              this.id = this.id || "mat-button-toggle-" + _uniqueIdCounter$1++;
              if (this._isSingleSelector) {
                  this.name = this.buttonToggleGroup.name;
              }
              if (this.buttonToggleGroup && this.buttonToggleGroup._isPrechecked(this)) {
                  this.checked = true;
              }
              this._focusMonitor.monitor(this._elementRef, true);
          };
      /**
       * @return {?}
       */
      MatButtonToggle.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var group = this.buttonToggleGroup;
              this._focusMonitor.stopMonitoring(this._elementRef);
              // Remove the toggle from the selection once it's destroyed. Needs to happen
              // on the next tick in order to avoid "changed after checked" errors.
              if (group && group._isSelected(this)) {
                  Promise.resolve().then(function () { return group._syncButtonToggle(_this, false); });
              }
          };
      /** Focuses the button. */
      /**
       * Focuses the button.
       * @return {?}
       */
      MatButtonToggle.prototype.focus = /**
       * Focuses the button.
       * @return {?}
       */
          function () {
              this._buttonElement.nativeElement.focus();
          };
      /** Checks the button toggle due to an interaction with the underlying native button. */
      /**
       * Checks the button toggle due to an interaction with the underlying native button.
       * @return {?}
       */
      MatButtonToggle.prototype._onButtonClick = /**
       * Checks the button toggle due to an interaction with the underlying native button.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var newChecked = this._isSingleSelector ? true : !this._checked;
              if (newChecked !== this._checked) {
                  this._checked = newChecked;
                  if (this.buttonToggleGroup) {
                      this.buttonToggleGroup._syncButtonToggle(this, this._checked, true);
                      this.buttonToggleGroup._onTouched();
                  }
              }
              // Emit a change event when it's the single selector
              this.change.emit(new MatButtonToggleChange(this, this.value));
          };
      /**
       * Marks the button toggle as needing checking for change detection.
       * This method is exposed because the parent button toggle group will directly
       * update bound properties of the radio button.
       */
      /**
       * Marks the button toggle as needing checking for change detection.
       * This method is exposed because the parent button toggle group will directly
       * update bound properties of the radio button.
       * @return {?}
       */
      MatButtonToggle.prototype._markForCheck = /**
       * Marks the button toggle as needing checking for change detection.
       * This method is exposed because the parent button toggle group will directly
       * update bound properties of the radio button.
       * @return {?}
       */
          function () {
              // When the group value changes, the button will not be notified.
              // Use `markForCheck` to explicit update button toggle's status.
              this._changeDetectorRef.markForCheck();
          };
      MatButtonToggle.decorators = [
          { type: core.Component, args: [{ selector: 'mat-button-toggle',
                      template: "<button #button class=\"mat-button-toggle-button\" type=\"button\" [id]=\"buttonId\" [attr.tabindex]=\"disabled ? -1 : tabIndex\" [attr.aria-pressed]=\"checked\" [disabled]=\"disabled || null\" [attr.name]=\"name || null\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledby\" (click)=\"_onButtonClick()\"><div class=\"mat-button-toggle-label-content\"><ng-content></ng-content></div></button><div class=\"mat-button-toggle-focus-overlay\"></div><div class=\"mat-button-toggle-ripple\" matRipple [matRippleTrigger]=\"button\" [matRippleDisabled]=\"this.disableRipple || this.disabled\"></div>",
                      styles: [".mat-button-toggle-group,.mat-button-toggle-standalone{position:relative;display:inline-flex;flex-direction:row;white-space:nowrap;overflow:hidden;border-radius:2px;-webkit-tap-highlight-color:transparent}@media (-ms-high-contrast:active){.mat-button-toggle-group,.mat-button-toggle-standalone{outline:solid 1px}}.mat-button-toggle-group-appearance-standard,.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{border-radius:4px}@media (-ms-high-contrast:active){.mat-button-toggle-group-appearance-standard,.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{outline:0}}.mat-button-toggle-vertical{flex-direction:column}.mat-button-toggle-vertical .mat-button-toggle-label-content{display:block}.mat-button-toggle{white-space:nowrap;position:relative}.mat-button-toggle .mat-icon svg{vertical-align:top}.mat-button-toggle.cdk-keyboard-focused .mat-button-toggle-focus-overlay{opacity:1}@media (-ms-high-contrast:active){.mat-button-toggle.cdk-keyboard-focused .mat-button-toggle-focus-overlay{opacity:.5}}.mat-button-toggle-appearance-standard:not(.mat-button-toggle-disabled):hover .mat-button-toggle-focus-overlay{opacity:.04}.mat-button-toggle-appearance-standard.cdk-keyboard-focused:not(.mat-button-toggle-disabled) .mat-button-toggle-focus-overlay{opacity:.12}@media (-ms-high-contrast:active){.mat-button-toggle-appearance-standard.cdk-keyboard-focused:not(.mat-button-toggle-disabled) .mat-button-toggle-focus-overlay{opacity:.5}}@media (hover:none){.mat-button-toggle-appearance-standard:not(.mat-button-toggle-disabled):hover .mat-button-toggle-focus-overlay{display:none}}.mat-button-toggle-label-content{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:inline-block;line-height:36px;padding:0 16px;position:relative}.mat-button-toggle-appearance-standard .mat-button-toggle-label-content{line-height:48px;padding:0 12px}.mat-button-toggle-label-content>*{vertical-align:middle}.mat-button-toggle-focus-overlay{border-radius:inherit;pointer-events:none;opacity:0;top:0;left:0;right:0;bottom:0;position:absolute}.mat-button-toggle-checked .mat-button-toggle-focus-overlay{border-bottom:solid 36px}@media (-ms-high-contrast:active){.mat-button-toggle-checked .mat-button-toggle-focus-overlay{opacity:.5;height:0}}@media (-ms-high-contrast:active){.mat-button-toggle-checked.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{border-bottom:solid 48px}}.mat-button-toggle .mat-button-toggle-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-button-toggle-button{border:0;background:0 0;color:inherit;padding:0;margin:0;font:inherit;outline:0;width:100%;cursor:pointer}.mat-button-toggle-disabled .mat-button-toggle-button{cursor:default}.mat-button-toggle-button::-moz-focus-inner{border:0}"],
                      encapsulation: core.ViewEncapsulation.None,
                      exportAs: 'matButtonToggle',
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      inputs: ['disableRipple'],
                      host: {
                          '[class.mat-button-toggle-standalone]': '!buttonToggleGroup',
                          '[class.mat-button-toggle-checked]': 'checked',
                          '[class.mat-button-toggle-disabled]': 'disabled',
                          '[class.mat-button-toggle-appearance-standard]': 'appearance === "standard"',
                          'class': 'mat-button-toggle',
                          // Always reset the tabindex to -1 so it doesn't conflict with the one on the `button`,
                          // but can still receive focus from things like cdkFocusInitial.
                          '[attr.tabindex]': '-1',
                          '[attr.id]': 'id',
                          '(focus)': 'focus()',
                      }
                  },] },
      ];
      /** @nocollapse */
      MatButtonToggle.ctorParameters = function () {
          return [
              { type: MatButtonToggleGroup, decorators: [{ type: core.Optional }] },
              { type: core.ChangeDetectorRef },
              { type: core.ElementRef },
              { type: FocusMonitor },
              { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS,] }] }
          ];
      };
      MatButtonToggle.propDecorators = {
          ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
          ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],
          _buttonElement: [{ type: core.ViewChild, args: ['button',] }],
          id: [{ type: core.Input }],
          name: [{ type: core.Input }],
          value: [{ type: core.Input }],
          tabIndex: [{ type: core.Input }],
          appearance: [{ type: core.Input }],
          checked: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          change: [{ type: core.Output }]
      };
      return MatButtonToggle;
  }(_MatButtonToggleMixinBase));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Content of a card, needed as it's used as a selector in the API.
   * \@docs-private
   */
  var MatCardContent = /** @class */ (function () {
      function MatCardContent() {
      }
      MatCardContent.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-card-content',
                      host: { 'class': 'mat-card-content' }
                  },] },
      ];
      return MatCardContent;
  }());
  /**
   * Title of a card, needed as it's used as a selector in the API.
   * \@docs-private
   */
  var MatCardTitle = /** @class */ (function () {
      function MatCardTitle() {
      }
      MatCardTitle.decorators = [
          { type: core.Directive, args: [{
                      selector: "mat-card-title, [mat-card-title], [matCardTitle]",
                      host: {
                          'class': 'mat-card-title'
                      }
                  },] },
      ];
      return MatCardTitle;
  }());
  /**
   * Sub-title of a card, needed as it's used as a selector in the API.
   * \@docs-private
   */
  var MatCardSubtitle = /** @class */ (function () {
      function MatCardSubtitle() {
      }
      MatCardSubtitle.decorators = [
          { type: core.Directive, args: [{
                      selector: "mat-card-subtitle, [mat-card-subtitle], [matCardSubtitle]",
                      host: {
                          'class': 'mat-card-subtitle'
                      }
                  },] },
      ];
      return MatCardSubtitle;
  }());
  /**
   * Action section of a card, needed as it's used as a selector in the API.
   * \@docs-private
   */
  var MatCardActions = /** @class */ (function () {
      function MatCardActions() {
          /**
           * Position of the actions inside the card.
           */
          this.align = 'start';
      }
      MatCardActions.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-card-actions',
                      exportAs: 'matCardActions',
                      host: {
                          'class': 'mat-card-actions',
                          '[class.mat-card-actions-align-end]': 'align === "end"',
                      }
                  },] },
      ];
      MatCardActions.propDecorators = {
          align: [{ type: core.Input }]
      };
      return MatCardActions;
  }());
  /**
   * Footer of a card, needed as it's used as a selector in the API.
   * \@docs-private
   */
  var MatCardFooter = /** @class */ (function () {
      function MatCardFooter() {
      }
      MatCardFooter.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-card-footer',
                      host: { 'class': 'mat-card-footer' }
                  },] },
      ];
      return MatCardFooter;
  }());
  /**
   * Image used in a card, needed to add the mat- CSS styling.
   * \@docs-private
   */
  var MatCardImage = /** @class */ (function () {
      function MatCardImage() {
      }
      MatCardImage.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mat-card-image], [matCardImage]',
                      host: { 'class': 'mat-card-image' }
                  },] },
      ];
      return MatCardImage;
  }());
  /**
   * Image used in a card, needed to add the mat- CSS styling.
   * \@docs-private
   */
  var MatCardSmImage = /** @class */ (function () {
      function MatCardSmImage() {
      }
      MatCardSmImage.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mat-card-sm-image], [matCardImageSmall]',
                      host: { 'class': 'mat-card-sm-image' }
                  },] },
      ];
      return MatCardSmImage;
  }());
  /**
   * Image used in a card, needed to add the mat- CSS styling.
   * \@docs-private
   */
  var MatCardMdImage = /** @class */ (function () {
      function MatCardMdImage() {
      }
      MatCardMdImage.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mat-card-md-image], [matCardImageMedium]',
                      host: { 'class': 'mat-card-md-image' }
                  },] },
      ];
      return MatCardMdImage;
  }());
  /**
   * Image used in a card, needed to add the mat- CSS styling.
   * \@docs-private
   */
  var MatCardLgImage = /** @class */ (function () {
      function MatCardLgImage() {
      }
      MatCardLgImage.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mat-card-lg-image], [matCardImageLarge]',
                      host: { 'class': 'mat-card-lg-image' }
                  },] },
      ];
      return MatCardLgImage;
  }());
  /**
   * Large image used in a card, needed to add the mat- CSS styling.
   * \@docs-private
   */
  var MatCardXlImage = /** @class */ (function () {
      function MatCardXlImage() {
      }
      MatCardXlImage.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mat-card-xl-image], [matCardImageXLarge]',
                      host: { 'class': 'mat-card-xl-image' }
                  },] },
      ];
      return MatCardXlImage;
  }());
  /**
   * Avatar image used in a card, needed to add the mat- CSS styling.
   * \@docs-private
   */
  var MatCardAvatar = /** @class */ (function () {
      function MatCardAvatar() {
      }
      MatCardAvatar.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mat-card-avatar], [matCardAvatar]',
                      host: { 'class': 'mat-card-avatar' }
                  },] },
      ];
      return MatCardAvatar;
  }());
  /**
   * A basic content container component that adds the styles of a Material design card.
   *
   * While this component can be used alone, it also provides a number
   * of preset styles for common card sections, including:
   * - mat-card-title
   * - mat-card-subtitle
   * - mat-card-content
   * - mat-card-actions
   * - mat-card-footer
   */
  var MatCard = /** @class */ (function () {
      function MatCard() {
      }
      MatCard.decorators = [
          { type: core.Component, args: [{ selector: 'mat-card',
                      exportAs: 'matCard',
                      template: "<ng-content></ng-content><ng-content select=\"mat-card-footer\"></ng-content>",
                      styles: [".mat-card{transition:box-shadow 280ms cubic-bezier(.4,0,.2,1);display:block;position:relative;padding:16px;border-radius:4px}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}@media (-ms-high-contrast:active){.mat-card{outline:solid 1px}}.mat-card-actions,.mat-card-content,.mat-card-subtitle{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px 0}@media (max-width:599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card-content>:first-child,.mat-card>:first-child{margin-top:0}.mat-card-content>:last-child:not(.mat-card-footer),.mat-card>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions .mat-button:first-child,.mat-card-actions .mat-raised-button:first-child{margin-left:0;margin-right:0}.mat-card-subtitle:not(:first-child),.mat-card-title:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}"],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      host: { 'class': 'mat-card' }
                  },] },
      ];
      return MatCard;
  }());
  /**
   * Component intended to be used within the `<mat-card>` component. It adds styles for a
   * preset header section (i.e. a title, subtitle, and avatar layout).
   * \@docs-private
   */
  var MatCardHeader = /** @class */ (function () {
      function MatCardHeader() {
      }
      MatCardHeader.decorators = [
          { type: core.Component, args: [{ selector: 'mat-card-header',
                      template: "<ng-content select=\"[mat-card-avatar], [matCardAvatar]\"></ng-content><div class=\"mat-card-header-text\"><ng-content select=\"mat-card-title, mat-card-subtitle, [mat-card-title], [mat-card-subtitle], [matCardTitle], [matCardSubtitle]\"></ng-content></div><ng-content></ng-content>",
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      host: { 'class': 'mat-card-header' }
                  },] },
      ];
      return MatCardHeader;
  }());
  /**
   * Component intended to be used within the `<mat-card>` component. It adds styles for a preset
   * layout that groups an image with a title section.
   * \@docs-private
   */
  var MatCardTitleGroup = /** @class */ (function () {
      function MatCardTitleGroup() {
      }
      MatCardTitleGroup.decorators = [
          { type: core.Component, args: [{ selector: 'mat-card-title-group',
                      template: "<div><ng-content select=\"mat-card-title, mat-card-subtitle, [mat-card-title], [mat-card-subtitle], [matCardTitle], [matCardSubtitle]\"></ng-content></div><ng-content select=\"img\"></ng-content><ng-content></ng-content>",
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      host: { 'class': 'mat-card-title-group' }
                  },] },
      ];
      return MatCardTitleGroup;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var MatCardModule = /** @class */ (function () {
      function MatCardModule() {
      }
      MatCardModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [MatCommonModule],
                      exports: [
                          MatCard,
                          MatCardHeader,
                          MatCardTitleGroup,
                          MatCardContent,
                          MatCardTitle,
                          MatCardSubtitle,
                          MatCardActions,
                          MatCardFooter,
                          MatCardSmImage,
                          MatCardMdImage,
                          MatCardLgImage,
                          MatCardImage,
                          MatCardXlImage,
                          MatCardAvatar,
                          MatCommonModule,
                      ],
                      declarations: [
                          MatCard, MatCardHeader, MatCardTitleGroup, MatCardContent, MatCardTitle, MatCardSubtitle,
                          MatCardActions, MatCardFooter, MatCardSmImage, MatCardMdImage, MatCardLgImage, MatCardImage,
                          MatCardXlImage, MatCardAvatar,
                      ],
                  },] },
      ];
      return MatCardModule;
  }());

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token that can be used to specify the checkbox click behavior.
   * @type {?}
   */
  var MAT_CHECKBOX_CLICK_ACTION = new core.InjectionToken('mat-checkbox-click-action');
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Increasing integer for generating unique ids for checkbox components.
  /** @type {?} */
  var nextUniqueId$3 = 0;
  /**
   * Provider Expression that allows mat-checkbox to register as a ControlValueAccessor.
   * This allows it to support [(ngModel)].
   * \@docs-private
   * @type {?}
   */
  var MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR = {
      provide: forms.NG_VALUE_ACCESSOR,
      useExisting: core.forwardRef(function () { return MatCheckbox; }),
      multi: true
  };
  /** @enum {number} */
  var TransitionCheckState = {
      /** The initial state of the component before any user interaction. */
      Init: 0,
      /** The state representing the component when it's becoming checked. */
      Checked: 1,
      /** The state representing the component when it's becoming unchecked. */
      Unchecked: 2,
      /** The state representing the component when it's becoming indeterminate. */
      Indeterminate: 3,
  };
  TransitionCheckState[TransitionCheckState.Init] = 'Init';
  TransitionCheckState[TransitionCheckState.Checked] = 'Checked';
  TransitionCheckState[TransitionCheckState.Unchecked] = 'Unchecked';
  TransitionCheckState[TransitionCheckState.Indeterminate] = 'Indeterminate';
  /**
   * Change event object emitted by MatCheckbox.
   */
  var /**
   * Change event object emitted by MatCheckbox.
   */ MatCheckboxChange = /** @class */ (function () {
      function MatCheckboxChange() {
      }
      return MatCheckboxChange;
  }());
  // Boilerplate for applying mixins to MatCheckbox.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatCheckbox.
  /**
   * \@docs-private
   */
  MatCheckboxBase = /** @class */ (function () {
      function MatCheckboxBase(_elementRef) {
          this._elementRef = _elementRef;
      }
      return MatCheckboxBase;
  }());
  /** @type {?} */
  var _MatCheckboxMixinBase = mixinTabIndex(mixinColor(mixinDisableRipple(mixinDisabled(MatCheckboxBase)), 'accent'));
  /**
   * A material design checkbox component. Supports all of the functionality of an HTML5 checkbox,
   * and exposes a similar API. A MatCheckbox can be either checked, unchecked, indeterminate, or
   * disabled. Note that all additional accessibility attributes are taken care of by the component,
   * so there is no need to provide them yourself. However, if you want to omit a label and still
   * have the checkbox be accessible, you may supply an [aria-label] input.
   * See: https://material.io/design/components/selection-controls.html
   */
  var MatCheckbox = /** @class */ (function (_super) {
      tslib_1.__extends(MatCheckbox, _super);
      function MatCheckbox(elementRef, _changeDetectorRef, _focusMonitor, _ngZone, tabIndex, _clickAction, _animationMode) {
          var _this = _super.call(this, elementRef) || this;
          _this._changeDetectorRef = _changeDetectorRef;
          _this._focusMonitor = _focusMonitor;
          _this._ngZone = _ngZone;
          _this._clickAction = _clickAction;
          _this._animationMode = _animationMode;
          /**
           * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will
           * take precedence so this may be omitted.
           */
          _this.ariaLabel = '';
          /**
           * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
           */
          _this.ariaLabelledby = null;
          _this._uniqueId = "mat-checkbox-" + ++nextUniqueId$3;
          /**
           * A unique id for the checkbox input. If none is supplied, it will be auto-generated.
           */
          _this.id = _this._uniqueId;
          /**
           * Whether the label should appear after or before the checkbox. Defaults to 'after'
           */
          _this.labelPosition = 'after';
          /**
           * Name value will be applied to the input element if present
           */
          _this.name = null;
          /**
           * Event emitted when the checkbox's `checked` value changes.
           */
          _this.change = new core.EventEmitter();
          /**
           * Event emitted when the checkbox's `indeterminate` value changes.
           */
          _this.indeterminateChange = new core.EventEmitter();
          /**
           * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.
           * \@docs-private
           */
          _this._onTouched = function () { };
          _this._currentAnimationClass = '';
          _this._currentCheckState = TransitionCheckState.Init;
          _this._controlValueAccessorChangeFn = function () { };
          _this._checked = false;
          _this._disabled = false;
          _this._indeterminate = false;
          _this.tabIndex = parseInt(tabIndex) || 0;
          _this._focusMonitor.monitor(elementRef, true).subscribe(function (focusOrigin) {
              if (!focusOrigin) {
                  // When a focused element becomes disabled, the browser *immediately* fires a blur event.
                  // Angular does not expect events to be raised during change detection, so any state change
                  // (such as a form control's 'ng-touched') will cause a changed-after-checked error.
                  // See https://github.com/angular/angular/issues/17793. To work around this, we defer
                  // telling the form control it has been touched until the next tick.
                  Promise.resolve().then(function () {
                      _this._onTouched();
                      _changeDetectorRef.markForCheck();
                  });
              }
          });
          return _this;
      }
      Object.defineProperty(MatCheckbox.prototype, "inputId", {
          /** Returns the unique id for the visual hidden input. */
          get: /**
           * Returns the unique id for the visual hidden input.
           * @return {?}
           */ function () { return (this.id || this._uniqueId) + "-input"; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatCheckbox.prototype, "required", {
          /** Whether the checkbox is required. */
          get: /**
           * Whether the checkbox is required.
           * @return {?}
           */ function () { return this._required; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._required = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      // TODO: Delete next major revision.
      // TODO: Delete next major revision.
      /**
       * @return {?}
       */
      MatCheckbox.prototype.ngAfterViewChecked =
          // TODO: Delete next major revision.
          /**
           * @return {?}
           */
          function () { };
      /**
       * @return {?}
       */
      MatCheckbox.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._focusMonitor.stopMonitoring(this._elementRef);
          };
      Object.defineProperty(MatCheckbox.prototype, "checked", {
          /**
           * Whether the checkbox is checked.
           */
          get: /**
           * Whether the checkbox is checked.
           * @return {?}
           */ function () { return this._checked; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (value != this.checked) {
                  this._checked = value;
                  this._changeDetectorRef.markForCheck();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatCheckbox.prototype, "disabled", {
          /**
           * Whether the checkbox is disabled. This fully overrides the implementation provided by
           * mixinDisabled, but the mixin is still required because mixinTabIndex requires it.
           */
          get: /**
           * Whether the checkbox is disabled. This fully overrides the implementation provided by
           * mixinDisabled, but the mixin is still required because mixinTabIndex requires it.
           * @return {?}
           */ function () { return this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var newValue = coerceBooleanProperty(value);
              if (newValue !== this.disabled) {
                  this._disabled = newValue;
                  this._changeDetectorRef.markForCheck();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatCheckbox.prototype, "indeterminate", {
          /**
           * Whether the checkbox is indeterminate. This is also known as "mixed" mode and can be used to
           * represent a checkbox with three states, e.g. a checkbox that represents a nested list of
           * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately
           * set to false.
           */
          get: /**
           * Whether the checkbox is indeterminate. This is also known as "mixed" mode and can be used to
           * represent a checkbox with three states, e.g. a checkbox that represents a nested list of
           * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately
           * set to false.
           * @return {?}
           */ function () { return this._indeterminate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var changed = value != this._indeterminate;
              this._indeterminate = value;
              if (changed) {
                  if (this._indeterminate) {
                      this._transitionCheckState(TransitionCheckState.Indeterminate);
                  }
                  else {
                      this._transitionCheckState(this.checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);
                  }
                  this.indeterminateChange.emit(this._indeterminate);
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatCheckbox.prototype._isRippleDisabled = /**
       * @return {?}
       */
          function () {
              return this.disableRipple || this.disabled;
          };
      /** Method being called whenever the label text changes. */
      /**
       * Method being called whenever the label text changes.
       * @return {?}
       */
      MatCheckbox.prototype._onLabelTextChange = /**
       * Method being called whenever the label text changes.
       * @return {?}
       */
          function () {
              // Since the event of the `cdkObserveContent` directive runs outside of the zone, the checkbox
              // component will be only marked for check, but no actual change detection runs automatically.
              // Instead of going back into the zone in order to trigger a change detection which causes
              // *all* components to be checked (if explicitly marked or not using OnPush), we only trigger
              // an explicit change detection for the checkbox view and it's children.
              this._changeDetectorRef.detectChanges();
          };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} value
       * @return {?}
       */
      MatCheckbox.prototype.writeValue =
          // Implemented as part of ControlValueAccessor.
          /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this.checked = !!value;
          };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} fn
       * @return {?}
       */
      MatCheckbox.prototype.registerOnChange =
          // Implemented as part of ControlValueAccessor.
          /**
           * @param {?} fn
           * @return {?}
           */
          function (fn) {
              this._controlValueAccessorChangeFn = fn;
          };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} fn
       * @return {?}
       */
      MatCheckbox.prototype.registerOnTouched =
          // Implemented as part of ControlValueAccessor.
          /**
           * @param {?} fn
           * @return {?}
           */
          function (fn) {
              this._onTouched = fn;
          };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} isDisabled
       * @return {?}
       */
      MatCheckbox.prototype.setDisabledState =
          // Implemented as part of ControlValueAccessor.
          /**
           * @param {?} isDisabled
           * @return {?}
           */
          function (isDisabled) {
              this.disabled = isDisabled;
          };
      /**
       * @return {?}
       */
      MatCheckbox.prototype._getAriaChecked = /**
       * @return {?}
       */
          function () {
              return this.checked ? 'true' : (this.indeterminate ? 'mixed' : 'false');
          };
      /**
       * @private
       * @param {?} newState
       * @return {?}
       */
      MatCheckbox.prototype._transitionCheckState = /**
       * @private
       * @param {?} newState
       * @return {?}
       */
          function (newState) {
              /** @type {?} */
              var oldState = this._currentCheckState;
              /** @type {?} */
              var element = this._elementRef.nativeElement;
              if (oldState === newState) {
                  return;
              }
              if (this._currentAnimationClass.length > 0) {
                  element.classList.remove(this._currentAnimationClass);
              }
              this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(oldState, newState);
              this._currentCheckState = newState;
              if (this._currentAnimationClass.length > 0) {
                  element.classList.add(this._currentAnimationClass);
                  // Remove the animation class to avoid animation when the checkbox is moved between containers
                  /** @type {?} */
                  var animationClass_1 = this._currentAnimationClass;
                  this._ngZone.runOutsideAngular(function () {
                      setTimeout(function () {
                          element.classList.remove(animationClass_1);
                      }, 1000);
                  });
              }
          };
      /**
       * @private
       * @return {?}
       */
      MatCheckbox.prototype._emitChangeEvent = /**
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var event = new MatCheckboxChange();
              event.source = this;
              event.checked = this.checked;
              this._controlValueAccessorChangeFn(this.checked);
              this.change.emit(event);
          };
      /** Toggles the `checked` state of the checkbox. */
      /**
       * Toggles the `checked` state of the checkbox.
       * @return {?}
       */
      MatCheckbox.prototype.toggle = /**
       * Toggles the `checked` state of the checkbox.
       * @return {?}
       */
          function () {
              this.checked = !this.checked;
          };
      /**
       * Event handler for checkbox input element.
       * Toggles checked state if element is not disabled.
       * Do not toggle on (change) event since IE doesn't fire change event when
       *   indeterminate checkbox is clicked.
       * @param event
       */
      /**
       * Event handler for checkbox input element.
       * Toggles checked state if element is not disabled.
       * Do not toggle on (change) event since IE doesn't fire change event when
       *   indeterminate checkbox is clicked.
       * @param {?} event
       * @return {?}
       */
      MatCheckbox.prototype._onInputClick = /**
       * Event handler for checkbox input element.
       * Toggles checked state if element is not disabled.
       * Do not toggle on (change) event since IE doesn't fire change event when
       *   indeterminate checkbox is clicked.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              var _this = this;
              // We have to stop propagation for click events on the visual hidden input element.
              // By default, when a user clicks on a label element, a generated click event will be
              // dispatched on the associated input element. Since we are using a label element as our
              // root container, the click event on the `checkbox` will be executed twice.
              // The real click event will bubble up, and the generated click event also tries to bubble up.
              // This will lead to multiple click events.
              // Preventing bubbling for the second event will solve that issue.
              event.stopPropagation();
              // If resetIndeterminate is false, and the current state is indeterminate, do nothing on click
              if (!this.disabled && this._clickAction !== 'noop') {
                  // When user manually click on the checkbox, `indeterminate` is set to false.
                  if (this.indeterminate && this._clickAction !== 'check') {
                      Promise.resolve().then(function () {
                          _this._indeterminate = false;
                          _this.indeterminateChange.emit(_this._indeterminate);
                      });
                  }
                  this.toggle();
                  this._transitionCheckState(this._checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);
                  // Emit our custom change event if the native input emitted one.
                  // It is important to only emit it, if the native input triggered one, because
                  // we don't want to trigger a change event, when the `checked` variable changes for example.
                  this._emitChangeEvent();
              }
              else if (!this.disabled && this._clickAction === 'noop') {
                  // Reset native input when clicked with noop. The native checkbox becomes checked after
                  // click, reset it to be align with `checked` value of `mat-checkbox`.
                  this._inputElement.nativeElement.checked = this.checked;
                  this._inputElement.nativeElement.indeterminate = this.indeterminate;
              }
          };
      /** Focuses the checkbox. */
      /**
       * Focuses the checkbox.
       * @return {?}
       */
      MatCheckbox.prototype.focus = /**
       * Focuses the checkbox.
       * @return {?}
       */
          function () {
              this._focusMonitor.focusVia(this._inputElement, 'keyboard');
          };
      /**
       * @param {?} event
       * @return {?}
       */
      MatCheckbox.prototype._onInteractionEvent = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              // We always have to stop propagation on the change event.
              // Otherwise the change event, from the input element, will bubble up and
              // emit its event object to the `change` output.
              event.stopPropagation();
          };
      /**
       * @private
       * @param {?} oldState
       * @param {?} newState
       * @return {?}
       */
      MatCheckbox.prototype._getAnimationClassForCheckStateTransition = /**
       * @private
       * @param {?} oldState
       * @param {?} newState
       * @return {?}
       */
          function (oldState, newState) {
              // Don't transition if animations are disabled.
              if (this._animationMode === 'NoopAnimations') {
                  return '';
              }
              /** @type {?} */
              var animSuffix = '';
              switch (oldState) {
                  case TransitionCheckState.Init:
                      // Handle edge case where user interacts with checkbox that does not have [(ngModel)] or
                      // [checked] bound to it.
                      if (newState === TransitionCheckState.Checked) {
                          animSuffix = 'unchecked-checked';
                      }
                      else if (newState == TransitionCheckState.Indeterminate) {
                          animSuffix = 'unchecked-indeterminate';
                      }
                      else {
                          return '';
                      }
                      break;
                  case TransitionCheckState.Unchecked:
                      animSuffix = newState === TransitionCheckState.Checked ?
                          'unchecked-checked' : 'unchecked-indeterminate';
                      break;
                  case TransitionCheckState.Checked:
                      animSuffix = newState === TransitionCheckState.Unchecked ?
                          'checked-unchecked' : 'checked-indeterminate';
                      break;
                  case TransitionCheckState.Indeterminate:
                      animSuffix = newState === TransitionCheckState.Checked ?
                          'indeterminate-checked' : 'indeterminate-unchecked';
                      break;
              }
              return "mat-checkbox-anim-" + animSuffix;
          };
      MatCheckbox.decorators = [
          { type: core.Component, args: [{ selector: 'mat-checkbox',
                      template: "<label [attr.for]=\"inputId\" class=\"mat-checkbox-layout\" #label><div class=\"mat-checkbox-inner-container\" [class.mat-checkbox-inner-container-no-side-margin]=\"!checkboxLabel.textContent || !checkboxLabel.textContent.trim()\"><input #input class=\"mat-checkbox-input cdk-visually-hidden\" type=\"checkbox\" [id]=\"inputId\" [required]=\"required\" [checked]=\"checked\" [attr.value]=\"value\" [disabled]=\"disabled\" [attr.name]=\"name\" [tabIndex]=\"tabIndex\" [indeterminate]=\"indeterminate\" [attr.aria-label]=\"ariaLabel || null\" [attr.aria-labelledby]=\"ariaLabelledby\" [attr.aria-checked]=\"_getAriaChecked()\" (change)=\"_onInteractionEvent($event)\" (click)=\"_onInputClick($event)\"><div matRipple class=\"mat-checkbox-ripple\" [matRippleTrigger]=\"label\" [matRippleDisabled]=\"_isRippleDisabled()\" [matRippleRadius]=\"20\" [matRippleCentered]=\"true\" [matRippleAnimation]=\"{enterDuration: 150}\"><div class=\"mat-ripple-element mat-checkbox-persistent-ripple\"></div></div><div class=\"mat-checkbox-frame\"></div><div class=\"mat-checkbox-background\"><svg version=\"1.1\" focusable=\"false\" class=\"mat-checkbox-checkmark\" viewBox=\"0 0 24 24\" xml:space=\"preserve\"><path class=\"mat-checkbox-checkmark-path\" fill=\"none\" stroke=\"white\" d=\"M4.1,12.7 9,17.6 20.3,6.3\"/></svg><div class=\"mat-checkbox-mixedmark\"></div></div></div><span class=\"mat-checkbox-label\" #checkboxLabel (cdkObserveContent)=\"_onLabelTextChange()\"><span style=\"display:none\">&nbsp;</span><ng-content></ng-content></span></label>",
                      styles: ["@keyframes mat-checkbox-fade-in-background{0%{opacity:0}50%{opacity:1}}@keyframes mat-checkbox-fade-out-background{0%,50%{opacity:1}100%{opacity:0}}@keyframes mat-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:22.91026}50%{animation-timing-function:cubic-bezier(0,0,.2,.1)}100%{stroke-dashoffset:0}}@keyframes mat-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0,0,0,1)}100%{transform:scaleX(1)}}@keyframes mat-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(.4,0,1,1);stroke-dashoffset:0}to{stroke-dashoffset:-22.91026}}@keyframes mat-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0,0,.2,.1);opacity:1;transform:rotate(0)}to{opacity:0;transform:rotate(45deg)}}@keyframes mat-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(.14,0,0,1);opacity:0;transform:rotate(45deg)}to{opacity:1;transform:rotate(360deg)}}@keyframes mat-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0,0,.2,.1);opacity:0;transform:rotate(-45deg)}to{opacity:1;transform:rotate(0)}}@keyframes mat-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(.14,0,0,1);opacity:1;transform:rotate(0)}to{opacity:0;transform:rotate(315deg)}}@keyframes mat-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;opacity:1;transform:scaleX(1)}100%,32.8%{opacity:0;transform:scaleX(0)}}.mat-checkbox-background,.mat-checkbox-frame{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:2px;box-sizing:border-box;pointer-events:none}.mat-checkbox{transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);cursor:pointer;-webkit-tap-highlight-color:transparent}._mat-animation-noopable.mat-checkbox{transition:none;animation:none}.mat-checkbox .mat-ripple-element:not(.mat-checkbox-persistent-ripple){opacity:.16}.mat-checkbox-layout{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:inherit;align-items:baseline;vertical-align:middle;display:inline-flex;white-space:nowrap}.mat-checkbox-label{-webkit-user-select:auto;-moz-user-select:auto;-ms-user-select:auto;user-select:auto}.mat-checkbox-inner-container{display:inline-block;height:16px;line-height:0;margin:auto;margin-right:8px;order:0;position:relative;vertical-align:middle;white-space:nowrap;width:16px;flex-shrink:0}[dir=rtl] .mat-checkbox-inner-container{margin-left:8px;margin-right:auto}.mat-checkbox-inner-container-no-side-margin{margin-left:0;margin-right:0}.mat-checkbox-frame{background-color:transparent;transition:border-color 90ms cubic-bezier(0,0,.2,.1);border-width:2px;border-style:solid}._mat-animation-noopable .mat-checkbox-frame{transition:none}@media (-ms-high-contrast:active){.mat-checkbox.cdk-keyboard-focused .mat-checkbox-frame{border-style:dotted}}.mat-checkbox-background{align-items:center;display:inline-flex;justify-content:center;transition:background-color 90ms cubic-bezier(0,0,.2,.1),opacity 90ms cubic-bezier(0,0,.2,.1)}._mat-animation-noopable .mat-checkbox-background{transition:none}.mat-checkbox-persistent-ripple{width:100%;height:100%;transform:none}.mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:.04}.mat-checkbox.cdk-keyboard-focused .mat-checkbox-persistent-ripple{opacity:.12}.mat-checkbox-persistent-ripple,.mat-checkbox.mat-disabled .mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:0}.mat-checkbox-checkmark{top:0;left:0;right:0;bottom:0;position:absolute;width:100%}.mat-checkbox-checkmark-path{stroke-dashoffset:22.91026;stroke-dasharray:22.91026;stroke-width:2.13333px}.mat-checkbox-mixedmark{width:calc(100% - 6px);height:2px;opacity:0;transform:scaleX(0) rotate(0);border-radius:2px}@media (-ms-high-contrast:active){.mat-checkbox-mixedmark{height:0;border-top:solid 2px;margin-top:2px}}.mat-checkbox-label-before .mat-checkbox-inner-container{order:1;margin-left:8px;margin-right:auto}[dir=rtl] .mat-checkbox-label-before .mat-checkbox-inner-container{margin-left:auto;margin-right:8px}.mat-checkbox-checked .mat-checkbox-checkmark{opacity:1}.mat-checkbox-checked .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-checked .mat-checkbox-mixedmark{transform:scaleX(1) rotate(-45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark{opacity:0;transform:rotate(45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-indeterminate .mat-checkbox-mixedmark{opacity:1;transform:scaleX(1) rotate(0)}.mat-checkbox-unchecked .mat-checkbox-background{background-color:transparent}.mat-checkbox-disabled{cursor:default}.mat-checkbox-anim-unchecked-checked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-checked .mat-checkbox-checkmark-path{animation:180ms linear 0s mat-checkbox-unchecked-checked-checkmark-path}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0s mat-checkbox-unchecked-indeterminate-mixedmark}.mat-checkbox-anim-checked-unchecked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-out-background}.mat-checkbox-anim-checked-unchecked .mat-checkbox-checkmark-path{animation:90ms linear 0s mat-checkbox-checked-unchecked-checkmark-path}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-checkmark{animation:90ms linear 0s mat-checkbox-checked-indeterminate-checkmark}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0s mat-checkbox-checked-indeterminate-mixedmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-checkmark{animation:.5s linear 0s mat-checkbox-indeterminate-checked-checkmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-mixedmark{animation:.5s linear 0s mat-checkbox-indeterminate-checked-mixedmark}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-out-background}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-mixedmark{animation:.3s linear 0s mat-checkbox-indeterminate-unchecked-mixedmark}.mat-checkbox-input{bottom:0;left:50%}.mat-checkbox .mat-checkbox-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}"],
                      exportAs: 'matCheckbox',
                      host: {
                          'class': 'mat-checkbox',
                          '[id]': 'id',
                          '[attr.tabindex]': 'null',
                          '[class.mat-checkbox-indeterminate]': 'indeterminate',
                          '[class.mat-checkbox-checked]': 'checked',
                          '[class.mat-checkbox-disabled]': 'disabled',
                          '[class.mat-checkbox-label-before]': 'labelPosition == "before"',
                          '[class._mat-animation-noopable]': "_animationMode === 'NoopAnimations'",
                      },
                      providers: [MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR],
                      inputs: ['disableRipple', 'color', 'tabIndex'],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      /** @nocollapse */
      MatCheckbox.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.ChangeDetectorRef },
              { type: FocusMonitor },
              { type: core.NgZone },
              { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_CHECKBOX_CLICK_ACTION,] }] },
              { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] }
          ];
      };
      MatCheckbox.propDecorators = {
          ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
          ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],
          id: [{ type: core.Input }],
          required: [{ type: core.Input }],
          labelPosition: [{ type: core.Input }],
          name: [{ type: core.Input }],
          change: [{ type: core.Output }],
          indeterminateChange: [{ type: core.Output }],
          value: [{ type: core.Input }],
          _inputElement: [{ type: core.ViewChild, args: ['input',] }],
          ripple: [{ type: core.ViewChild, args: [MatRipple,] }],
          checked: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          indeterminate: [{ type: core.Input }]
      };
      return MatCheckbox;
  }(_MatCheckboxMixinBase));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var MAT_CHECKBOX_REQUIRED_VALIDATOR = {
      provide: forms.NG_VALIDATORS,
      useExisting: core.forwardRef(function () { return MatCheckboxRequiredValidator; }),
      multi: true
  };
  /**
   * Validator for Material checkbox's required attribute in template-driven checkbox.
   * Current CheckboxRequiredValidator only work with `input type=checkbox` and does not
   * work with `mat-checkbox`.
   */
  var MatCheckboxRequiredValidator = /** @class */ (function (_super) {
      tslib_1.__extends(MatCheckboxRequiredValidator, _super);
      function MatCheckboxRequiredValidator() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MatCheckboxRequiredValidator.decorators = [
          { type: core.Directive, args: [{
                      selector: "mat-checkbox[required][formControlName],\n             mat-checkbox[required][formControl], mat-checkbox[required][ngModel]",
                      providers: [MAT_CHECKBOX_REQUIRED_VALIDATOR],
                      host: { '[attr.required]': 'required ? "" : null' }
                  },] },
      ];
      return MatCheckboxRequiredValidator;
  }(forms.CheckboxRequiredValidator));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  // Boilerplate for applying mixins to MatChip.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatChip.
  /**
   * \@docs-private
   */
  MatChipBase = /** @class */ (function () {
      function MatChipBase(_elementRef) {
          this._elementRef = _elementRef;
      }
      return MatChipBase;
  }());
  /** @type {?} */
  var _MatChipMixinBase = mixinColor(mixinDisableRipple(mixinDisabled(MatChipBase)), 'primary');
  /** @type {?} */
  var CHIP_ATTRIBUTE_NAMES = ['mat-basic-chip'];
  /**
   * Dummy directive to add CSS class to chip avatar.
   * \@docs-private
   */
  var MatChipAvatar = /** @class */ (function () {
      function MatChipAvatar() {
      }
      MatChipAvatar.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-chip-avatar, [matChipAvatar]',
                      host: { 'class': 'mat-chip-avatar' }
                  },] },
      ];
      return MatChipAvatar;
  }());
  /**
   * Dummy directive to add CSS class to chip trailing icon.
   * \@docs-private
   */
  var MatChipTrailingIcon = /** @class */ (function () {
      function MatChipTrailingIcon() {
      }
      MatChipTrailingIcon.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-chip-trailing-icon, [matChipTrailingIcon]',
                      host: { 'class': 'mat-chip-trailing-icon' }
                  },] },
      ];
      return MatChipTrailingIcon;
  }());
  /**
   * Material design styled Chip component. Used inside the MatChipList component.
   */
  var MatChip = /** @class */ (function (_super) {
      tslib_1.__extends(MatChip, _super);
      function MatChip(_elementRef, _ngZone, platform, globalRippleOptions) {
          var _this = _super.call(this, _elementRef) || this;
          _this._elementRef = _elementRef;
          _this._ngZone = _ngZone;
          /**
           * Whether the chip has focus.
           */
          _this._hasFocus = false;
          /**
           * Whether the chip list is selectable
           */
          _this.chipListSelectable = true;
          _this._selected = false;
          _this._selectable = true;
          _this._removable = true;
          /**
           * Emits when the chip is focused.
           */
          _this._onFocus = new rxjs.Subject();
          /**
           * Emits when the chip is blured.
           */
          _this._onBlur = new rxjs.Subject();
          /**
           * Emitted when the chip is selected or deselected.
           */
          _this.selectionChange = new core.EventEmitter();
          /**
           * Emitted when the chip is destroyed.
           */
          _this.destroyed = new core.EventEmitter();
          /**
           * Emitted when a chip is to be removed.
           */
          _this.removed = new core.EventEmitter();
          _this._addHostClassName();
          _this._chipRipple = new RippleRenderer(_this, _ngZone, _elementRef, platform);
          _this._chipRipple.setupTriggerEvents(_elementRef.nativeElement);
          _this.rippleConfig = globalRippleOptions || {};
          return _this;
      }
      Object.defineProperty(MatChip.prototype, "rippleDisabled", {
          /**
           * Whether ripples are disabled on interaction
           * @docs-private
           */
          get: /**
           * Whether ripples are disabled on interaction
           * \@docs-private
           * @return {?}
           */ function () {
              return this.disabled || this.disableRipple || !!this.rippleConfig.disabled;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChip.prototype, "selected", {
          /** Whether the chip is selected. */
          get: /**
           * Whether the chip is selected.
           * @return {?}
           */ function () { return this._selected; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var coercedValue = coerceBooleanProperty(value);
              if (coercedValue !== this._selected) {
                  this._selected = coercedValue;
                  this._dispatchSelectionChange();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChip.prototype, "value", {
          /** The value of the chip. Defaults to the content inside `<mat-chip>` tags. */
          get: /**
           * The value of the chip. Defaults to the content inside `<mat-chip>` tags.
           * @return {?}
           */ function () {
              return this._value != undefined
                  ? this._value
                  : this._elementRef.nativeElement.textContent;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._value = value; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChip.prototype, "selectable", {
          /**
           * Whether or not the chip is selectable. When a chip is not selectable,
           * changes to its selected state are always ignored. By default a chip is
           * selectable, and it becomes non-selectable if its parent chip list is
           * not selectable.
           */
          get: /**
           * Whether or not the chip is selectable. When a chip is not selectable,
           * changes to its selected state are always ignored. By default a chip is
           * selectable, and it becomes non-selectable if its parent chip list is
           * not selectable.
           * @return {?}
           */ function () { return this._selectable && this.chipListSelectable; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._selectable = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChip.prototype, "removable", {
          /**
           * Determines whether or not the chip displays the remove styling and emits (removed) events.
           */
          get: /**
           * Determines whether or not the chip displays the remove styling and emits (removed) events.
           * @return {?}
           */ function () { return this._removable; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._removable = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChip.prototype, "ariaSelected", {
          /** The ARIA selected applied to the chip. */
          get: /**
           * The ARIA selected applied to the chip.
           * @return {?}
           */ function () {
              return this.selectable ? this.selected.toString() : null;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatChip.prototype._addHostClassName = /**
       * @return {?}
       */
          function () {
              // Add class for the different chips
              for (var _i = 0, CHIP_ATTRIBUTE_NAMES_1 = CHIP_ATTRIBUTE_NAMES; _i < CHIP_ATTRIBUTE_NAMES_1.length; _i++) {
                  var attr = CHIP_ATTRIBUTE_NAMES_1[_i];
                  if (this._elementRef.nativeElement.hasAttribute(attr) ||
                      this._elementRef.nativeElement.tagName.toLowerCase() === attr) {
                      (( /** @type {?} */(this._elementRef.nativeElement))).classList.add(attr);
                      return;
                  }
              }
              (( /** @type {?} */(this._elementRef.nativeElement))).classList.add('mat-standard-chip');
          };
      /**
       * @return {?}
       */
      MatChip.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this.destroyed.emit({ chip: this });
              this._chipRipple._removeTriggerEvents();
          };
      /** Selects the chip. */
      /**
       * Selects the chip.
       * @return {?}
       */
      MatChip.prototype.select = /**
       * Selects the chip.
       * @return {?}
       */
          function () {
              if (!this._selected) {
                  this._selected = true;
                  this._dispatchSelectionChange();
              }
          };
      /** Deselects the chip. */
      /**
       * Deselects the chip.
       * @return {?}
       */
      MatChip.prototype.deselect = /**
       * Deselects the chip.
       * @return {?}
       */
          function () {
              if (this._selected) {
                  this._selected = false;
                  this._dispatchSelectionChange();
              }
          };
      /** Select this chip and emit selected event */
      /**
       * Select this chip and emit selected event
       * @return {?}
       */
      MatChip.prototype.selectViaInteraction = /**
       * Select this chip and emit selected event
       * @return {?}
       */
          function () {
              if (!this._selected) {
                  this._selected = true;
                  this._dispatchSelectionChange(true);
              }
          };
      /** Toggles the current selected state of this chip. */
      /**
       * Toggles the current selected state of this chip.
       * @param {?=} isUserInput
       * @return {?}
       */
      MatChip.prototype.toggleSelected = /**
       * Toggles the current selected state of this chip.
       * @param {?=} isUserInput
       * @return {?}
       */
          function (isUserInput) {
              if (isUserInput === void 0) {
                  isUserInput = false;
              }
              this._selected = !this.selected;
              this._dispatchSelectionChange(isUserInput);
              return this.selected;
          };
      /** Allows for programmatic focusing of the chip. */
      /**
       * Allows for programmatic focusing of the chip.
       * @return {?}
       */
      MatChip.prototype.focus = /**
       * Allows for programmatic focusing of the chip.
       * @return {?}
       */
          function () {
              if (!this._hasFocus) {
                  this._elementRef.nativeElement.focus();
                  this._onFocus.next({ chip: this });
              }
              this._hasFocus = true;
          };
      /**
       * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or
       * BACKSPACE keys are pressed.
       *
       * Informs any listeners of the removal request. Does not remove the chip from the DOM.
       */
      /**
       * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or
       * BACKSPACE keys are pressed.
       *
       * Informs any listeners of the removal request. Does not remove the chip from the DOM.
       * @return {?}
       */
      MatChip.prototype.remove = /**
       * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or
       * BACKSPACE keys are pressed.
       *
       * Informs any listeners of the removal request. Does not remove the chip from the DOM.
       * @return {?}
       */
          function () {
              if (this.removable) {
                  this.removed.emit({ chip: this });
              }
          };
      /** Handles click events on the chip. */
      /**
       * Handles click events on the chip.
       * @param {?} event
       * @return {?}
       */
      MatChip.prototype._handleClick = /**
       * Handles click events on the chip.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (this.disabled) {
                  event.preventDefault();
              }
              else {
                  event.stopPropagation();
              }
          };
      /** Handle custom key presses. */
      /**
       * Handle custom key presses.
       * @param {?} event
       * @return {?}
       */
      MatChip.prototype._handleKeydown = /**
       * Handle custom key presses.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (this.disabled) {
                  return;
              }
              switch (event.keyCode) {
                  case DELETE:
                  case BACKSPACE:
                      // If we are removable, remove the focused chip
                      this.remove();
                      // Always prevent so page navigation does not occur
                      event.preventDefault();
                      break;
                  case SPACE:
                      // If we are selectable, toggle the focused chip
                      if (this.selectable) {
                          this.toggleSelected(true);
                      }
                      // Always prevent space from scrolling the page since the list has focus
                      event.preventDefault();
                      break;
              }
          };
      /**
       * @return {?}
       */
      MatChip.prototype._blur = /**
       * @return {?}
       */
          function () {
              var _this = this;
              // When animations are enabled, Angular may end up removing the chip from the DOM a little
              // earlier than usual, causing it to be blurred and throwing off the logic in the chip list
              // that moves focus not the next item. To work around the issue, we defer marking the chip
              // as not focused until the next time the zone stabilizes.
              this._ngZone.onStable
                  .asObservable()
                  .pipe(operators.take(1))
                  .subscribe(function () {
                  _this._ngZone.run(function () {
                      _this._hasFocus = false;
                      _this._onBlur.next({ chip: _this });
                  });
              });
          };
      /**
       * @private
       * @param {?=} isUserInput
       * @return {?}
       */
      MatChip.prototype._dispatchSelectionChange = /**
       * @private
       * @param {?=} isUserInput
       * @return {?}
       */
          function (isUserInput) {
              if (isUserInput === void 0) {
                  isUserInput = false;
              }
              this.selectionChange.emit({
                  source: this,
                  isUserInput: isUserInput,
                  selected: this._selected
              });
          };
      MatChip.decorators = [
          { type: core.Directive, args: [{
                      selector: "mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]",
                      inputs: ['color', 'disabled', 'disableRipple'],
                      exportAs: 'matChip',
                      host: {
                          'class': 'mat-chip',
                          '[attr.tabindex]': 'disabled ? null : -1',
                          'role': 'option',
                          '[class.mat-chip-selected]': 'selected',
                          '[class.mat-chip-with-avatar]': 'avatar',
                          '[class.mat-chip-with-trailing-icon]': 'trailingIcon || removeIcon',
                          '[class.mat-chip-disabled]': 'disabled',
                          '[attr.disabled]': 'disabled || null',
                          '[attr.aria-disabled]': 'disabled.toString()',
                          '[attr.aria-selected]': 'ariaSelected',
                          '(click)': '_handleClick($event)',
                          '(keydown)': '_handleKeydown($event)',
                          '(focus)': 'focus()',
                          '(blur)': '_blur()',
                      },
                  },] },
      ];
      /** @nocollapse */
      MatChip.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.NgZone },
              { type: Platform },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_RIPPLE_GLOBAL_OPTIONS,] }] }
          ];
      };
      MatChip.propDecorators = {
          avatar: [{ type: core.ContentChild, args: [MatChipAvatar,] }],
          trailingIcon: [{ type: core.ContentChild, args: [MatChipTrailingIcon,] }],
          removeIcon: [{ type: core.ContentChild, args: [core.forwardRef(function () { return MatChipRemove; }),] }],
          selected: [{ type: core.Input }],
          value: [{ type: core.Input }],
          selectable: [{ type: core.Input }],
          removable: [{ type: core.Input }],
          selectionChange: [{ type: core.Output }],
          destroyed: [{ type: core.Output }],
          removed: [{ type: core.Output }]
      };
      return MatChip;
  }(_MatChipMixinBase));
  /**
   * Applies proper (click) support and adds styling for use with the Material Design "cancel" icon
   * available at https://material.io/icons/#ic_cancel.
   *
   * Example:
   *
   *     `<mat-chip>
   *       <mat-icon matChipRemove>cancel</mat-icon>
   *     </mat-chip>`
   *
   * You *may* use a custom icon, but you may need to override the `mat-chip-remove` positioning
   * styles to properly center the icon within the chip.
   */
  var MatChipRemove = /** @class */ (function () {
      function MatChipRemove(_parentChip) {
          this._parentChip = _parentChip;
      }
      /** Calls the parent chip's public `remove()` method if applicable. */
      /**
       * Calls the parent chip's public `remove()` method if applicable.
       * @param {?} event
       * @return {?}
       */
      MatChipRemove.prototype._handleClick = /**
       * Calls the parent chip's public `remove()` method if applicable.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (this._parentChip.removable) {
                  this._parentChip.remove();
              }
              // We need to stop event propagation because otherwise the event will bubble up to the
              // form field and cause the `onContainerClick` method to be invoked. This method would then
              // reset the focused chip that has been focused after chip removal. Usually the parent
              // the parent click listener of the `MatChip` would prevent propagation, but it can happen
              // that the chip is being removed before the event bubbles up.
              event.stopPropagation();
          };
      MatChipRemove.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matChipRemove]',
                      host: {
                          'class': 'mat-chip-remove mat-chip-trailing-icon',
                          '(click)': '_handleClick($event)',
                      }
                  },] },
      ];
      /** @nocollapse */
      MatChipRemove.ctorParameters = function () {
          return [
              { type: MatChip }
          ];
      };
      return MatChipRemove;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token to be used to override the default options for the chips module.
   * @type {?}
   */
  var MAT_CHIPS_DEFAULT_OPTIONS = new core.InjectionToken('mat-chips-default-options');
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Boilerplate for applying mixins to MatChipList.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatChipList.
  /**
   * \@docs-private
   */
  MatChipListBase = /** @class */ (function () {
      function MatChipListBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {
          this._defaultErrorStateMatcher = _defaultErrorStateMatcher;
          this._parentForm = _parentForm;
          this._parentFormGroup = _parentFormGroup;
          this.ngControl = ngControl;
      }
      return MatChipListBase;
  }());
  /** @type {?} */
  var _MatChipListMixinBase = mixinErrorState(MatChipListBase);
  // Increasing integer for generating unique ids for chip-list components.
  /** @type {?} */
  var nextUniqueId$4 = 0;
  /**
   * Change event object that is emitted when the chip list value has changed.
   */
  var /**
   * Change event object that is emitted when the chip list value has changed.
   */ MatChipListChange = /** @class */ (function () {
      function MatChipListChange(source, value) {
          this.source = source;
          this.value = value;
      }
      return MatChipListChange;
  }());
  /**
   * A material design chips component (named ChipList for its similarity to the List component).
   */
  var MatChipList = /** @class */ (function (_super) {
      tslib_1.__extends(MatChipList, _super);
      function MatChipList(_elementRef, _changeDetectorRef, _dir, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, ngControl) {
          var _this = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;
          _this._elementRef = _elementRef;
          _this._changeDetectorRef = _changeDetectorRef;
          _this._dir = _dir;
          _this.ngControl = ngControl;
          /**
           * Implemented as part of MatFormFieldControl.
           * \@docs-private
           */
          _this.controlType = 'mat-chip-list';
          /**
           * When a chip is destroyed, we store the index of the destroyed chip until the chips
           * query list notifies about the update. This is necessary because we cannot determine an
           * appropriate chip that should receive focus until the array of chips updated completely.
           */
          _this._lastDestroyedChipIndex = null;
          /**
           * Subject that emits when the component has been destroyed.
           */
          _this._destroyed = new rxjs.Subject();
          /**
           * Uid of the chip list
           */
          _this._uid = "mat-chip-list-" + nextUniqueId$4++;
          /**
           * Tab index for the chip list.
           */
          _this._tabIndex = 0;
          /**
           * User defined tab index.
           * When it is not null, use user defined tab index. Otherwise use _tabIndex
           */
          _this._userTabIndex = null;
          /**
           * Function when touched
           */
          _this._onTouched = function () { };
          /**
           * Function when changed
           */
          _this._onChange = function () { };
          _this._multiple = false;
          _this._compareWith = function (o1, o2) { return o1 === o2; };
          _this._required = false;
          _this._disabled = false;
          /**
           * Orientation of the chip list.
           */
          _this.ariaOrientation = 'horizontal';
          _this._selectable = true;
          /**
           * Event emitted when the selected chip list value has been changed by the user.
           */
          _this.change = new core.EventEmitter();
          /**
           * Event that emits whenever the raw value of the chip-list changes. This is here primarily
           * to facilitate the two-way binding for the `value` input.
           * \@docs-private
           */
          _this.valueChange = new core.EventEmitter();
          if (_this.ngControl) {
              _this.ngControl.valueAccessor = _this;
          }
          return _this;
      }
      Object.defineProperty(MatChipList.prototype, "selected", {
          /** The array of selected chips inside chip list. */
          get: /**
           * The array of selected chips inside chip list.
           * @return {?}
           */ function () {
              return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipList.prototype, "role", {
          /** The ARIA role applied to the chip list. */
          get: /**
           * The ARIA role applied to the chip list.
           * @return {?}
           */ function () { return this.empty ? null : 'listbox'; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipList.prototype, "multiple", {
          /** Whether the user should be allowed to select multiple chips. */
          get: /**
           * Whether the user should be allowed to select multiple chips.
           * @return {?}
           */ function () { return this._multiple; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._multiple = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipList.prototype, "compareWith", {
          /**
           * A function to compare the option values with the selected values. The first argument
           * is a value from an option. The second is a value from the selection. A boolean
           * should be returned.
           */
          get: /**
           * A function to compare the option values with the selected values. The first argument
           * is a value from an option. The second is a value from the selection. A boolean
           * should be returned.
           * @return {?}
           */ function () { return this._compareWith; },
          set: /**
           * @param {?} fn
           * @return {?}
           */ function (fn) {
              this._compareWith = fn;
              if (this._selectionModel) {
                  // A different comparator means the selection could change.
                  this._initializeSelection();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipList.prototype, "value", {
          /**
           * Implemented as part of MatFormFieldControl.
           * @docs-private
           */
          get: /**
           * Implemented as part of MatFormFieldControl.
           * \@docs-private
           * @return {?}
           */ function () { return this._value; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this.writeValue(value);
              this._value = value;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipList.prototype, "id", {
          /**
           * Implemented as part of MatFormFieldControl.
           * @docs-private
           */
          get: /**
           * Implemented as part of MatFormFieldControl.
           * \@docs-private
           * @return {?}
           */ function () {
              return this._chipInput ? this._chipInput.id : this._uid;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipList.prototype, "required", {
          /**
           * Implemented as part of MatFormFieldControl.
           * @docs-private
           */
          get: /**
           * Implemented as part of MatFormFieldControl.
           * \@docs-private
           * @return {?}
           */ function () { return this._required; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._required = coerceBooleanProperty(value);
              this.stateChanges.next();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipList.prototype, "placeholder", {
          /**
           * Implemented as part of MatFormFieldControl.
           * @docs-private
           */
          get: /**
           * Implemented as part of MatFormFieldControl.
           * \@docs-private
           * @return {?}
           */ function () {
              return this._chipInput ? this._chipInput.placeholder : this._placeholder;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._placeholder = value;
              this.stateChanges.next();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipList.prototype, "focused", {
          /** Whether any chips or the matChipInput inside of this chip-list has focus. */
          get: /**
           * Whether any chips or the matChipInput inside of this chip-list has focus.
           * @return {?}
           */ function () {
              return (this._chipInput && this._chipInput.focused) || this._hasFocusedChip();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipList.prototype, "empty", {
          /**
           * Implemented as part of MatFormFieldControl.
           * @docs-private
           */
          get: /**
           * Implemented as part of MatFormFieldControl.
           * \@docs-private
           * @return {?}
           */ function () {
              return (!this._chipInput || this._chipInput.empty) && this.chips.length === 0;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipList.prototype, "shouldLabelFloat", {
          /**
           * Implemented as part of MatFormFieldControl.
           * @docs-private
           */
          get: /**
           * Implemented as part of MatFormFieldControl.
           * \@docs-private
           * @return {?}
           */ function () { return !this.empty || this.focused; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipList.prototype, "disabled", {
          /**
           * Implemented as part of MatFormFieldControl.
           * @docs-private
           */
          get: /**
           * Implemented as part of MatFormFieldControl.
           * \@docs-private
           * @return {?}
           */ function () { return this.ngControl ? !!this.ngControl.disabled : this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._disabled = coerceBooleanProperty(value);
              this._syncChipsDisabledState();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipList.prototype, "selectable", {
          /**
           * Whether or not this chip list is selectable. When a chip list is not selectable,
           * the selected states for all the chips inside the chip list are always ignored.
           */
          get: /**
           * Whether or not this chip list is selectable. When a chip list is not selectable,
           * the selected states for all the chips inside the chip list are always ignored.
           * @return {?}
           */ function () { return this._selectable; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              var _this = this;
              this._selectable = coerceBooleanProperty(value);
              if (this.chips) {
                  this.chips.forEach(function (chip) { return chip.chipListSelectable = _this._selectable; });
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipList.prototype, "tabIndex", {
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._userTabIndex = value;
              this._tabIndex = value;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipList.prototype, "chipSelectionChanges", {
          /** Combined stream of all of the child chips' selection change events. */
          get: /**
           * Combined stream of all of the child chips' selection change events.
           * @return {?}
           */ function () {
              return rxjs.merge.apply(void 0, this.chips.map(function (chip) { return chip.selectionChange; }));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipList.prototype, "chipFocusChanges", {
          /** Combined stream of all of the child chips' focus change events. */
          get: /**
           * Combined stream of all of the child chips' focus change events.
           * @return {?}
           */ function () {
              return rxjs.merge.apply(void 0, this.chips.map(function (chip) { return chip._onFocus; }));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipList.prototype, "chipBlurChanges", {
          /** Combined stream of all of the child chips' blur change events. */
          get: /**
           * Combined stream of all of the child chips' blur change events.
           * @return {?}
           */ function () {
              return rxjs.merge.apply(void 0, this.chips.map(function (chip) { return chip._onBlur; }));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipList.prototype, "chipRemoveChanges", {
          /** Combined stream of all of the child chips' remove change events. */
          get: /**
           * Combined stream of all of the child chips' remove change events.
           * @return {?}
           */ function () {
              return rxjs.merge.apply(void 0, this.chips.map(function (chip) { return chip.destroyed; }));
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatChipList.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._keyManager = new FocusKeyManager(this.chips)
                  .withWrap()
                  .withVerticalOrientation()
                  .withHorizontalOrientation(this._dir ? this._dir.value : 'ltr');
              if (this._dir) {
                  this._dir.change
                      .pipe(operators.takeUntil(this._destroyed))
                      .subscribe(function (dir) { return _this._keyManager.withHorizontalOrientation(dir); });
              }
              // Prevents the chip list from capturing focus and redirecting
              // it back to the first chip when the user tabs out.
              this._keyManager.tabOut.pipe(operators.takeUntil(this._destroyed)).subscribe(function () {
                  _this._tabIndex = -1;
                  setTimeout(function () {
                      _this._tabIndex = _this._userTabIndex || 0;
                      _this._changeDetectorRef.markForCheck();
                  });
              });
              // When the list changes, re-subscribe
              this.chips.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroyed)).subscribe(function () {
                  if (_this.disabled) {
                      // Since this happens after the content has been
                      // checked, we need to defer it to the next tick.
                      Promise.resolve().then(function () {
                          _this._syncChipsDisabledState();
                      });
                  }
                  _this._resetChips();
                  // Reset chips selected/deselected status
                  _this._initializeSelection();
                  // Check to see if we need to update our tab index
                  _this._updateTabIndex();
                  // Check to see if we have a destroyed chip and need to refocus
                  _this._updateFocusForDestroyedChips();
                  _this.stateChanges.next();
              });
          };
      /**
       * @return {?}
       */
      MatChipList.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              this._selectionModel = new SelectionModel(this.multiple, undefined, false);
              this.stateChanges.next();
          };
      /**
       * @return {?}
       */
      MatChipList.prototype.ngDoCheck = /**
       * @return {?}
       */
          function () {
              if (this.ngControl) {
                  // We need to re-evaluate this on every change detection cycle, because there are some
                  // error triggers that we can't subscribe to (e.g. parent form submissions). This means
                  // that whatever logic is in here has to be super lean or we risk destroying the performance.
                  this.updateErrorState();
              }
          };
      /**
       * @return {?}
       */
      MatChipList.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._destroyed.next();
              this._destroyed.complete();
              this.stateChanges.complete();
              this._dropSubscriptions();
          };
      /** Associates an HTML input element with this chip list. */
      /**
       * Associates an HTML input element with this chip list.
       * @param {?} inputElement
       * @return {?}
       */
      MatChipList.prototype.registerInput = /**
       * Associates an HTML input element with this chip list.
       * @param {?} inputElement
       * @return {?}
       */
          function (inputElement) {
              this._chipInput = inputElement;
          };
      /**
       * Implemented as part of MatFormFieldControl.
       * @docs-private
       */
      /**
       * Implemented as part of MatFormFieldControl.
       * \@docs-private
       * @param {?} ids
       * @return {?}
       */
      MatChipList.prototype.setDescribedByIds = /**
       * Implemented as part of MatFormFieldControl.
       * \@docs-private
       * @param {?} ids
       * @return {?}
       */
          function (ids) { this._ariaDescribedby = ids.join(' '); };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} value
       * @return {?}
       */
      MatChipList.prototype.writeValue =
          // Implemented as part of ControlValueAccessor.
          /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              if (this.chips) {
                  this._setSelectionByValue(value, false);
              }
          };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} fn
       * @return {?}
       */
      MatChipList.prototype.registerOnChange =
          // Implemented as part of ControlValueAccessor.
          /**
           * @param {?} fn
           * @return {?}
           */
          function (fn) {
              this._onChange = fn;
          };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} fn
       * @return {?}
       */
      MatChipList.prototype.registerOnTouched =
          // Implemented as part of ControlValueAccessor.
          /**
           * @param {?} fn
           * @return {?}
           */
          function (fn) {
              this._onTouched = fn;
          };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} isDisabled
       * @return {?}
       */
      MatChipList.prototype.setDisabledState =
          // Implemented as part of ControlValueAccessor.
          /**
           * @param {?} isDisabled
           * @return {?}
           */
          function (isDisabled) {
              this.disabled = isDisabled;
              this.stateChanges.next();
          };
      /**
       * Implemented as part of MatFormFieldControl.
       * @docs-private
       */
      /**
       * Implemented as part of MatFormFieldControl.
       * \@docs-private
       * @param {?} event
       * @return {?}
       */
      MatChipList.prototype.onContainerClick = /**
       * Implemented as part of MatFormFieldControl.
       * \@docs-private
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (!this._originatesFromChip(event)) {
                  this.focus();
              }
          };
      /**
       * Focuses the first non-disabled chip in this chip list, or the associated input when there
       * are no eligible chips.
       */
      /**
       * Focuses the first non-disabled chip in this chip list, or the associated input when there
       * are no eligible chips.
       * @return {?}
       */
      MatChipList.prototype.focus = /**
       * Focuses the first non-disabled chip in this chip list, or the associated input when there
       * are no eligible chips.
       * @return {?}
       */
          function () {
              if (this.disabled) {
                  return;
              }
              // TODO: ARIA says this should focus the first `selected` chip if any are selected.
              // Focus on first element if there's no chipInput inside chip-list
              if (this._chipInput && this._chipInput.focused) ;
              else if (this.chips.length > 0) {
                  this._keyManager.setFirstItemActive();
                  this.stateChanges.next();
              }
              else {
                  this._focusInput();
                  this.stateChanges.next();
              }
          };
      /** Attempt to focus an input if we have one. */
      /**
       * Attempt to focus an input if we have one.
       * @return {?}
       */
      MatChipList.prototype._focusInput = /**
       * Attempt to focus an input if we have one.
       * @return {?}
       */
          function () {
              if (this._chipInput) {
                  this._chipInput.focus();
              }
          };
      /**
       * Pass events to the keyboard manager. Available here for tests.
       */
      /**
       * Pass events to the keyboard manager. Available here for tests.
       * @param {?} event
       * @return {?}
       */
      MatChipList.prototype._keydown = /**
       * Pass events to the keyboard manager. Available here for tests.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var target = ( /** @type {?} */(event.target));
              // If they are on an empty input and hit backspace, focus the last chip
              if (event.keyCode === BACKSPACE && this._isInputEmpty(target)) {
                  this._keyManager.setLastItemActive();
                  event.preventDefault();
              }
              else if (target && target.classList.contains('mat-chip')) {
                  if (event.keyCode === HOME) {
                      this._keyManager.setFirstItemActive();
                      event.preventDefault();
                  }
                  else if (event.keyCode === END) {
                      this._keyManager.setLastItemActive();
                      event.preventDefault();
                  }
                  else {
                      this._keyManager.onKeydown(event);
                  }
                  this.stateChanges.next();
              }
          };
      /**
       * Check the tab index as you should not be allowed to focus an empty list.
       */
      /**
       * Check the tab index as you should not be allowed to focus an empty list.
       * @protected
       * @return {?}
       */
      MatChipList.prototype._updateTabIndex = /**
       * Check the tab index as you should not be allowed to focus an empty list.
       * @protected
       * @return {?}
       */
          function () {
              // If we have 0 chips, we should not allow keyboard focus
              this._tabIndex = this._userTabIndex || (this.chips.length === 0 ? -1 : 0);
          };
      /**
       * If the amount of chips changed, we need to update the
       * key manager state and focus the next closest chip.
       */
      /**
       * If the amount of chips changed, we need to update the
       * key manager state and focus the next closest chip.
       * @protected
       * @return {?}
       */
      MatChipList.prototype._updateFocusForDestroyedChips = /**
       * If the amount of chips changed, we need to update the
       * key manager state and focus the next closest chip.
       * @protected
       * @return {?}
       */
          function () {
              if (this._lastDestroyedChipIndex != null && this.chips.length) {
                  /** @type {?} */
                  var newChipIndex = Math.min(this._lastDestroyedChipIndex, this.chips.length - 1);
                  this._keyManager.setActiveItem(newChipIndex);
              }
              this._lastDestroyedChipIndex = null;
          };
      /**
       * Utility to ensure all indexes are valid.
       *
       * @param index The index to be checked.
       * @returns True if the index is valid for our list of chips.
       */
      /**
       * Utility to ensure all indexes are valid.
       *
       * @private
       * @param {?} index The index to be checked.
       * @return {?} True if the index is valid for our list of chips.
       */
      MatChipList.prototype._isValidIndex = /**
       * Utility to ensure all indexes are valid.
       *
       * @private
       * @param {?} index The index to be checked.
       * @return {?} True if the index is valid for our list of chips.
       */
          function (index) {
              return index >= 0 && index < this.chips.length;
          };
      /**
       * @private
       * @param {?} element
       * @return {?}
       */
      MatChipList.prototype._isInputEmpty = /**
       * @private
       * @param {?} element
       * @return {?}
       */
          function (element) {
              if (element && element.nodeName.toLowerCase() === 'input') {
                  /** @type {?} */
                  var input = ( /** @type {?} */(element));
                  return !input.value;
              }
              return false;
          };
      /**
       * @param {?} value
       * @param {?=} isUserInput
       * @return {?}
       */
      MatChipList.prototype._setSelectionByValue = /**
       * @param {?} value
       * @param {?=} isUserInput
       * @return {?}
       */
          function (value, isUserInput) {
              var _this = this;
              if (isUserInput === void 0) {
                  isUserInput = true;
              }
              this._clearSelection();
              this.chips.forEach(function (chip) { return chip.deselect(); });
              if (Array.isArray(value)) {
                  value.forEach(function (currentValue) { return _this._selectValue(currentValue, isUserInput); });
                  this._sortValues();
              }
              else {
                  /** @type {?} */
                  var correspondingChip = this._selectValue(value, isUserInput);
                  // Shift focus to the active item. Note that we shouldn't do this in multiple
                  // mode, because we don't know what chip the user interacted with last.
                  if (correspondingChip) {
                      if (isUserInput) {
                          this._keyManager.setActiveItem(correspondingChip);
                      }
                  }
              }
          };
      /**
       * Finds and selects the chip based on its value.
       * @returns Chip that has the corresponding value.
       */
      /**
       * Finds and selects the chip based on its value.
       * @private
       * @param {?} value
       * @param {?=} isUserInput
       * @return {?} Chip that has the corresponding value.
       */
      MatChipList.prototype._selectValue = /**
       * Finds and selects the chip based on its value.
       * @private
       * @param {?} value
       * @param {?=} isUserInput
       * @return {?} Chip that has the corresponding value.
       */
          function (value, isUserInput) {
              var _this = this;
              if (isUserInput === void 0) {
                  isUserInput = true;
              }
              /** @type {?} */
              var correspondingChip = this.chips.find(function (chip) {
                  return chip.value != null && _this._compareWith(chip.value, value);
              });
              if (correspondingChip) {
                  isUserInput ? correspondingChip.selectViaInteraction() : correspondingChip.select();
                  this._selectionModel.select(correspondingChip);
              }
              return correspondingChip;
          };
      /**
       * @private
       * @return {?}
       */
      MatChipList.prototype._initializeSelection = /**
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              // Defer setting the value in order to avoid the "Expression
              // has changed after it was checked" errors from Angular.
              Promise.resolve().then(function () {
                  if (_this.ngControl || _this._value) {
                      _this._setSelectionByValue(_this.ngControl ? _this.ngControl.value : _this._value, false);
                      _this.stateChanges.next();
                  }
              });
          };
      /**
       * Deselects every chip in the list.
       * @param skip Chip that should not be deselected.
       */
      /**
       * Deselects every chip in the list.
       * @private
       * @param {?=} skip Chip that should not be deselected.
       * @return {?}
       */
      MatChipList.prototype._clearSelection = /**
       * Deselects every chip in the list.
       * @private
       * @param {?=} skip Chip that should not be deselected.
       * @return {?}
       */
          function (skip) {
              this._selectionModel.clear();
              this.chips.forEach(function (chip) {
                  if (chip !== skip) {
                      chip.deselect();
                  }
              });
              this.stateChanges.next();
          };
      /**
       * Sorts the model values, ensuring that they keep the same
       * order that they have in the panel.
       */
      /**
       * Sorts the model values, ensuring that they keep the same
       * order that they have in the panel.
       * @private
       * @return {?}
       */
      MatChipList.prototype._sortValues = /**
       * Sorts the model values, ensuring that they keep the same
       * order that they have in the panel.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._multiple) {
                  this._selectionModel.clear();
                  this.chips.forEach(function (chip) {
                      if (chip.selected) {
                          _this._selectionModel.select(chip);
                      }
                  });
                  this.stateChanges.next();
              }
          };
      /** Emits change event to set the model value. */
      /**
       * Emits change event to set the model value.
       * @private
       * @param {?=} fallbackValue
       * @return {?}
       */
      MatChipList.prototype._propagateChanges = /**
       * Emits change event to set the model value.
       * @private
       * @param {?=} fallbackValue
       * @return {?}
       */
          function (fallbackValue) {
              /** @type {?} */
              var valueToEmit = null;
              if (Array.isArray(this.selected)) {
                  valueToEmit = this.selected.map(function (chip) { return chip.value; });
              }
              else {
                  valueToEmit = this.selected ? this.selected.value : fallbackValue;
              }
              this._value = valueToEmit;
              this.change.emit(new MatChipListChange(this, valueToEmit));
              this.valueChange.emit(valueToEmit);
              this._onChange(valueToEmit);
              this._changeDetectorRef.markForCheck();
          };
      /** When blurred, mark the field as touched when focus moved outside the chip list. */
      /**
       * When blurred, mark the field as touched when focus moved outside the chip list.
       * @return {?}
       */
      MatChipList.prototype._blur = /**
       * When blurred, mark the field as touched when focus moved outside the chip list.
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this._hasFocusedChip()) {
                  this._keyManager.setActiveItem(-1);
              }
              if (!this.disabled) {
                  if (this._chipInput) {
                      // If there's a chip input, we should check whether the focus moved to chip input.
                      // If the focus is not moved to chip input, mark the field as touched. If the focus moved
                      // to chip input, do nothing.
                      // Timeout is needed to wait for the focus() event trigger on chip input.
                      setTimeout(function () {
                          if (!_this.focused) {
                              _this._markAsTouched();
                          }
                      });
                  }
                  else {
                      // If there's no chip input, then mark the field as touched.
                      this._markAsTouched();
                  }
              }
          };
      /** Mark the field as touched */
      /**
       * Mark the field as touched
       * @return {?}
       */
      MatChipList.prototype._markAsTouched = /**
       * Mark the field as touched
       * @return {?}
       */
          function () {
              this._onTouched();
              this._changeDetectorRef.markForCheck();
              this.stateChanges.next();
          };
      /**
       * @private
       * @return {?}
       */
      MatChipList.prototype._resetChips = /**
       * @private
       * @return {?}
       */
          function () {
              this._dropSubscriptions();
              this._listenToChipsFocus();
              this._listenToChipsSelection();
              this._listenToChipsRemoved();
          };
      /**
       * @private
       * @return {?}
       */
      MatChipList.prototype._dropSubscriptions = /**
       * @private
       * @return {?}
       */
          function () {
              if (this._chipFocusSubscription) {
                  this._chipFocusSubscription.unsubscribe();
                  this._chipFocusSubscription = null;
              }
              if (this._chipBlurSubscription) {
                  this._chipBlurSubscription.unsubscribe();
                  this._chipBlurSubscription = null;
              }
              if (this._chipSelectionSubscription) {
                  this._chipSelectionSubscription.unsubscribe();
                  this._chipSelectionSubscription = null;
              }
              if (this._chipRemoveSubscription) {
                  this._chipRemoveSubscription.unsubscribe();
                  this._chipRemoveSubscription = null;
              }
          };
      /** Listens to user-generated selection events on each chip. */
      /**
       * Listens to user-generated selection events on each chip.
       * @private
       * @return {?}
       */
      MatChipList.prototype._listenToChipsSelection = /**
       * Listens to user-generated selection events on each chip.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              this._chipSelectionSubscription = this.chipSelectionChanges.subscribe(function (event) {
                  event.source.selected
                      ? _this._selectionModel.select(event.source)
                      : _this._selectionModel.deselect(event.source);
                  // For single selection chip list, make sure the deselected value is unselected.
                  if (!_this.multiple) {
                      _this.chips.forEach(function (chip) {
                          if (!_this._selectionModel.isSelected(chip) && chip.selected) {
                              chip.deselect();
                          }
                      });
                  }
                  if (event.isUserInput) {
                      _this._propagateChanges();
                  }
              });
          };
      /** Listens to user-generated selection events on each chip. */
      /**
       * Listens to user-generated selection events on each chip.
       * @private
       * @return {?}
       */
      MatChipList.prototype._listenToChipsFocus = /**
       * Listens to user-generated selection events on each chip.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              this._chipFocusSubscription = this.chipFocusChanges.subscribe(function (event) {
                  /** @type {?} */
                  var chipIndex = _this.chips.toArray().indexOf(event.chip);
                  if (_this._isValidIndex(chipIndex)) {
                      _this._keyManager.updateActiveItemIndex(chipIndex);
                  }
                  _this.stateChanges.next();
              });
              this._chipBlurSubscription = this.chipBlurChanges.subscribe(function () {
                  _this._blur();
                  _this.stateChanges.next();
              });
          };
      /**
       * @private
       * @return {?}
       */
      MatChipList.prototype._listenToChipsRemoved = /**
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              this._chipRemoveSubscription = this.chipRemoveChanges.subscribe(function (event) {
                  /** @type {?} */
                  var chip = event.chip;
                  /** @type {?} */
                  var chipIndex = _this.chips.toArray().indexOf(event.chip);
                  // In case the chip that will be removed is currently focused, we temporarily store
                  // the index in order to be able to determine an appropriate sibling chip that will
                  // receive focus.
                  if (_this._isValidIndex(chipIndex) && chip._hasFocus) {
                      _this._lastDestroyedChipIndex = chipIndex;
                  }
              });
          };
      /** Checks whether an event comes from inside a chip element. */
      /**
       * Checks whether an event comes from inside a chip element.
       * @private
       * @param {?} event
       * @return {?}
       */
      MatChipList.prototype._originatesFromChip = /**
       * Checks whether an event comes from inside a chip element.
       * @private
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var currentElement = ( /** @type {?} */(event.target));
              while (currentElement && currentElement !== this._elementRef.nativeElement) {
                  if (currentElement.classList.contains('mat-chip')) {
                      return true;
                  }
                  currentElement = currentElement.parentElement;
              }
              return false;
          };
      /** Checks whether any of the chips is focused. */
      /**
       * Checks whether any of the chips is focused.
       * @private
       * @return {?}
       */
      MatChipList.prototype._hasFocusedChip = /**
       * Checks whether any of the chips is focused.
       * @private
       * @return {?}
       */
          function () {
              return this.chips.some(function (chip) { return chip._hasFocus; });
          };
      /** Syncs the list's disabled state with the individual chips. */
      /**
       * Syncs the list's disabled state with the individual chips.
       * @private
       * @return {?}
       */
      MatChipList.prototype._syncChipsDisabledState = /**
       * Syncs the list's disabled state with the individual chips.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              if (this.chips) {
                  this.chips.forEach(function (chip) {
                      chip.disabled = _this._disabled;
                  });
              }
          };
      MatChipList.decorators = [
          { type: core.Component, args: [{ selector: 'mat-chip-list',
                      template: "<div class=\"mat-chip-list-wrapper\"><ng-content></ng-content></div>",
                      exportAs: 'matChipList',
                      host: {
                          '[attr.tabindex]': 'disabled ? null : _tabIndex',
                          '[attr.aria-describedby]': '_ariaDescribedby || null',
                          '[attr.aria-required]': 'required.toString()',
                          '[attr.aria-disabled]': 'disabled.toString()',
                          '[attr.aria-invalid]': 'errorState',
                          '[attr.aria-multiselectable]': 'multiple',
                          '[attr.role]': 'role',
                          '[class.mat-chip-list-disabled]': 'disabled',
                          '[class.mat-chip-list-invalid]': 'errorState',
                          '[class.mat-chip-list-required]': 'required',
                          '[attr.aria-orientation]': 'ariaOrientation',
                          'class': 'mat-chip-list',
                          '(focus)': 'focus()',
                          '(blur)': '_blur()',
                          '(keydown)': '_keydown($event)',
                          '[id]': '_uid',
                      },
                      providers: [{ provide: MatFormFieldControl, useExisting: MatChipList }],
                      styles: [".mat-chip{position:relative;overflow:hidden;box-sizing:border-box;-webkit-tap-highlight-color:transparent;transform:translateZ(0)}.mat-standard-chip{transition:box-shadow 280ms cubic-bezier(.4,0,.2,1);display:inline-flex;padding:7px 12px;border-radius:16px;align-items:center;cursor:default;min-height:32px;height:1px}.mat-standard-chip .mat-chip-remove.mat-icon{width:18px;height:18px}.mat-standard-chip::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit;opacity:0;content:'';pointer-events:none;transition:opacity .2s cubic-bezier(.35,0,.25,1)}.mat-standard-chip:hover::after{opacity:.12}.mat-standard-chip:focus{outline:0}.mat-standard-chip:focus::after{opacity:.16}@media (-ms-high-contrast:active){.mat-standard-chip{outline:solid 1px}.mat-standard-chip:focus{outline:dotted 2px}}.mat-standard-chip.mat-chip-disabled::after{opacity:0}.mat-standard-chip.mat-chip-disabled .mat-chip-remove,.mat-standard-chip.mat-chip-disabled .mat-chip-trailing-icon{cursor:default}.mat-standard-chip.mat-chip-with-avatar,.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-top:0;padding-bottom:0}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-right:8px;padding-left:0}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-left:8px;padding-right:0}.mat-standard-chip.mat-chip-with-trailing-icon{padding-top:7px;padding-bottom:7px;padding-right:8px;padding-left:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon{padding-left:8px;padding-right:12px}.mat-standard-chip.mat-chip-with-avatar{padding-left:0;padding-right:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-avatar{padding-right:0;padding-left:12px}.mat-standard-chip .mat-chip-avatar{width:24px;height:24px;margin-right:8px;margin-left:4px}[dir=rtl] .mat-standard-chip .mat-chip-avatar{margin-left:8px;margin-right:4px}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{width:18px;height:18px;cursor:pointer}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-standard-chip .mat-chip-remove,[dir=rtl] .mat-standard-chip .mat-chip-trailing-icon{margin-right:8px;margin-left:0}.mat-chip-list-wrapper{display:flex;flex-direction:row;flex-wrap:wrap;align-items:center;margin:-4px}.mat-chip-list-wrapper .mat-standard-chip,.mat-chip-list-wrapper input.mat-input-element{margin:4px}.mat-chip-list-stacked .mat-chip-list-wrapper{flex-direction:column;align-items:flex-start}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-standard-chip{width:100%}.mat-chip-avatar{border-radius:50%;justify-content:center;align-items:center;display:flex;overflow:hidden;object-fit:cover}input.mat-chip-input{width:150px;margin:4px;flex:1 0 150px}"],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      /** @nocollapse */
      MatChipList.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.ChangeDetectorRef },
              { type: Directionality, decorators: [{ type: core.Optional }] },
              { type: forms.NgForm, decorators: [{ type: core.Optional }] },
              { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] },
              { type: ErrorStateMatcher },
              { type: forms.NgControl, decorators: [{ type: core.Optional }, { type: core.Self }] }
          ];
      };
      MatChipList.propDecorators = {
          errorStateMatcher: [{ type: core.Input }],
          multiple: [{ type: core.Input }],
          compareWith: [{ type: core.Input }],
          value: [{ type: core.Input }],
          required: [{ type: core.Input }],
          placeholder: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          ariaOrientation: [{ type: core.Input, args: ['aria-orientation',] }],
          selectable: [{ type: core.Input }],
          tabIndex: [{ type: core.Input }],
          change: [{ type: core.Output }],
          valueChange: [{ type: core.Output }],
          chips: [{ type: core.ContentChildren, args: [MatChip,] }]
      };
      return MatChipList;
  }(_MatChipListMixinBase));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Increasing integer for generating unique ids.
  /** @type {?} */
  var nextUniqueId$1$2 = 0;
  /**
   * Directive that adds chip-specific behaviors to an input element inside `<mat-form-field>`.
   * May be placed inside or outside of an `<mat-chip-list>`.
   */
  var MatChipInput = /** @class */ (function () {
      function MatChipInput(_elementRef, _defaultOptions) {
          this._elementRef = _elementRef;
          this._defaultOptions = _defaultOptions;
          /**
           * Whether the control is focused.
           */
          this.focused = false;
          this._addOnBlur = false;
          /**
           * The list of key codes that will trigger a chipEnd event.
           *
           * Defaults to `[ENTER]`.
           */
          this.separatorKeyCodes = this._defaultOptions.separatorKeyCodes;
          /**
           * Emitted when a chip is to be added.
           */
          this.chipEnd = new core.EventEmitter();
          /**
           * The input's placeholder text.
           */
          this.placeholder = '';
          /**
           * Unique id for the input.
           */
          this.id = "mat-chip-list-input-" + nextUniqueId$1$2++;
          this._disabled = false;
          this._inputElement = ( /** @type {?} */(this._elementRef.nativeElement));
      }
      Object.defineProperty(MatChipInput.prototype, "chipList", {
          /** Register input for chip list */
          set: /**
           * Register input for chip list
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (value) {
                  this._chipList = value;
                  this._chipList.registerInput(this);
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipInput.prototype, "addOnBlur", {
          /**
           * Whether or not the chipEnd event will be emitted when the input is blurred.
           */
          get: /**
           * Whether or not the chipEnd event will be emitted when the input is blurred.
           * @return {?}
           */ function () { return this._addOnBlur; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._addOnBlur = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipInput.prototype, "disabled", {
          /** Whether the input is disabled. */
          get: /**
           * Whether the input is disabled.
           * @return {?}
           */ function () { return this._disabled || (this._chipList && this._chipList.disabled); },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._disabled = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatChipInput.prototype, "empty", {
          /** Whether the input is empty. */
          get: /**
           * Whether the input is empty.
           * @return {?}
           */ function () { return !this._inputElement.value; },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatChipInput.prototype.ngOnChanges = /**
       * @return {?}
       */
          function () {
              this._chipList.stateChanges.next();
          };
      /** Utility method to make host definition/tests more clear. */
      /**
       * Utility method to make host definition/tests more clear.
       * @param {?=} event
       * @return {?}
       */
      MatChipInput.prototype._keydown = /**
       * Utility method to make host definition/tests more clear.
       * @param {?=} event
       * @return {?}
       */
          function (event) {
              this._emitChipEnd(event);
          };
      /** Checks to see if the blur should emit the (chipEnd) event. */
      /**
       * Checks to see if the blur should emit the (chipEnd) event.
       * @return {?}
       */
      MatChipInput.prototype._blur = /**
       * Checks to see if the blur should emit the (chipEnd) event.
       * @return {?}
       */
          function () {
              if (this.addOnBlur) {
                  this._emitChipEnd();
              }
              this.focused = false;
              // Blur the chip list if it is not focused
              if (!this._chipList.focused) {
                  this._chipList._blur();
              }
              this._chipList.stateChanges.next();
          };
      /**
       * @return {?}
       */
      MatChipInput.prototype._focus = /**
       * @return {?}
       */
          function () {
              this.focused = true;
              this._chipList.stateChanges.next();
          };
      /** Checks to see if the (chipEnd) event needs to be emitted. */
      /**
       * Checks to see if the (chipEnd) event needs to be emitted.
       * @param {?=} event
       * @return {?}
       */
      MatChipInput.prototype._emitChipEnd = /**
       * Checks to see if the (chipEnd) event needs to be emitted.
       * @param {?=} event
       * @return {?}
       */
          function (event) {
              if (!this._inputElement.value && !!event) {
                  this._chipList._keydown(event);
              }
              if (!event || this._isSeparatorKey(event)) {
                  this.chipEnd.emit({ input: this._inputElement, value: this._inputElement.value });
                  if (event) {
                      event.preventDefault();
                  }
              }
          };
      /**
       * @return {?}
       */
      MatChipInput.prototype._onInput = /**
       * @return {?}
       */
          function () {
              // Let chip list know whenever the value changes.
              this._chipList.stateChanges.next();
          };
      /** Focuses the input. */
      /**
       * Focuses the input.
       * @return {?}
       */
      MatChipInput.prototype.focus = /**
       * Focuses the input.
       * @return {?}
       */
          function () {
              this._inputElement.focus();
          };
      /** Checks whether a keycode is one of the configured separators. */
      /**
       * Checks whether a keycode is one of the configured separators.
       * @private
       * @param {?} event
       * @return {?}
       */
      MatChipInput.prototype._isSeparatorKey = /**
       * Checks whether a keycode is one of the configured separators.
       * @private
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (hasModifierKey(event)) {
                  return false;
              }
              /** @type {?} */
              var separators = this.separatorKeyCodes;
              /** @type {?} */
              var keyCode = event.keyCode;
              return Array.isArray(separators) ? separators.indexOf(keyCode) > -1 : separators.has(keyCode);
          };
      MatChipInput.decorators = [
          { type: core.Directive, args: [{
                      selector: 'input[matChipInputFor]',
                      exportAs: 'matChipInput, matChipInputFor',
                      host: {
                          'class': 'mat-chip-input mat-input-element',
                          '(keydown)': '_keydown($event)',
                          '(blur)': '_blur()',
                          '(focus)': '_focus()',
                          '(input)': '_onInput()',
                          '[id]': 'id',
                          '[attr.disabled]': 'disabled || null',
                          '[attr.placeholder]': 'placeholder || null',
                          '[attr.aria-invalid]': '_chipList && _chipList.ngControl ? _chipList.ngControl.invalid : null',
                      }
                  },] },
      ];
      /** @nocollapse */
      MatChipInput.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: undefined, decorators: [{ type: core.Inject, args: [MAT_CHIPS_DEFAULT_OPTIONS,] }] }
          ];
      };
      MatChipInput.propDecorators = {
          chipList: [{ type: core.Input, args: ['matChipInputFor',] }],
          addOnBlur: [{ type: core.Input, args: ['matChipInputAddOnBlur',] }],
          separatorKeyCodes: [{ type: core.Input, args: ['matChipInputSeparatorKeyCodes',] }],
          chipEnd: [{ type: core.Output, args: ['matChipInputTokenEnd',] }],
          placeholder: [{ type: core.Input }],
          id: [{ type: core.Input }],
          disabled: [{ type: core.Input }]
      };
      return MatChipInput;
  }());

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Configuration for opening a modal dialog with the MatDialog service.
   * @template D
   */
  var /**
   * Configuration for opening a modal dialog with the MatDialog service.
   * @template D
   */ MatDialogConfig = /** @class */ (function () {
      function MatDialogConfig() {
          /**
           * The ARIA role of the dialog element.
           */
          this.role = 'dialog';
          /**
           * Custom class for the overlay pane.
           */
          this.panelClass = '';
          /**
           * Whether the dialog has a backdrop.
           */
          this.hasBackdrop = true;
          /**
           * Custom class for the backdrop,
           */
          this.backdropClass = '';
          /**
           * Whether the user can use escape or clicking on the backdrop to close the modal.
           */
          this.disableClose = false;
          /**
           * Width of the dialog.
           */
          this.width = '';
          /**
           * Height of the dialog.
           */
          this.height = '';
          /**
           * Max-width of the dialog. If a number is provided, pixel units are assumed. Defaults to 80vw
           */
          this.maxWidth = '80vw';
          /**
           * Data being injected into the child component.
           */
          this.data = null;
          /**
           * ID of the element that describes the dialog.
           */
          this.ariaDescribedBy = null;
          /**
           * Aria label to assign to the dialog element
           */
          this.ariaLabel = null;
          /**
           * Whether the dialog should focus the first focusable element on open.
           */
          this.autoFocus = true;
          /**
           * Whether the dialog should restore focus to the
           * previously-focused element, after it's closed.
           */
          this.restoreFocus = true;
          /**
           * Whether the dialog should close when the user goes backwards/forwards in history.
           * Note that this usually doesn't include clicking on links (unless the user is using
           * the `HashLocationStrategy`).
           */
          this.closeOnNavigation = true;
          // TODO(jelbourn): add configuration for lifecycle hooks, ARIA labelling.
      }
      return MatDialogConfig;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var animationBody = [
      // Note: The `enter` animation transitions to `transform: none`, because for some reason
      // specifying the transform explicitly, causes IE both to blur the dialog content and
      // decimate the animation performance. Leaving it as `none` solves both issues.
      state('void, exit', style({ opacity: 0, transform: 'scale(0.7)' })),
      state('enter', style({ transform: 'none' })),
      transition('* => enter', animate('150ms cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'none', opacity: 1 }))),
      transition('* => void, * => exit', animate('75ms cubic-bezier(0.4, 0.0, 0.2, 1)', style({ opacity: 0 }))),
  ];
  /**
   * Animations used by MatDialog.
   * \@docs-private
   * @type {?}
   */
  var matDialogAnimations = {
      /**
       * Animation that is applied on the dialog container by defalt.
       */
      dialogContainer: trigger('dialogContainer', animationBody),
      /**
       * @deprecated \@breaking-change 8.0.0 Use `matDialogAnimations.dialogContainer` instead.
       */
      slideDialog: trigger('slideDialog', animationBody)
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Throws an exception for the case when a ComponentPortal is
   * attached to a DomPortalOutlet without an origin.
   * \@docs-private
   * @return {?}
   */
  function throwMatDialogContentAlreadyAttachedError() {
      throw Error('Attempting to attach dialog content after content is already attached');
  }
  /**
   * Internal component that wraps user-provided dialog content.
   * Animation is based on https://material.io/guidelines/motion/choreography.html.
   * \@docs-private
   */
  var MatDialogContainer = /** @class */ (function (_super) {
      tslib_1.__extends(MatDialogContainer, _super);
      function MatDialogContainer(_elementRef, _focusTrapFactory, _changeDetectorRef, _document, _config) {
          var _this = _super.call(this) || this;
          _this._elementRef = _elementRef;
          _this._focusTrapFactory = _focusTrapFactory;
          _this._changeDetectorRef = _changeDetectorRef;
          _this._document = _document;
          _this._config = _config;
          /**
           * Element that was focused before the dialog was opened. Save this to restore upon close.
           */
          _this._elementFocusedBeforeDialogWasOpened = null;
          /**
           * State of the dialog animation.
           */
          _this._state = 'enter';
          /**
           * Emits when an animation state changes.
           */
          _this._animationStateChanged = new core.EventEmitter();
          /**
           * ID of the element that should be considered as the dialog's label.
           */
          _this._ariaLabelledBy = null;
          return _this;
      }
      /**
       * Attach a ComponentPortal as content to this dialog container.
       * @param portal Portal to be attached as the dialog content.
       */
      /**
       * Attach a ComponentPortal as content to this dialog container.
       * @template T
       * @param {?} portal Portal to be attached as the dialog content.
       * @return {?}
       */
      MatDialogContainer.prototype.attachComponentPortal = /**
       * Attach a ComponentPortal as content to this dialog container.
       * @template T
       * @param {?} portal Portal to be attached as the dialog content.
       * @return {?}
       */
          function (portal) {
              if (this._portalOutlet.hasAttached()) {
                  throwMatDialogContentAlreadyAttachedError();
              }
              this._savePreviouslyFocusedElement();
              return this._portalOutlet.attachComponentPortal(portal);
          };
      /**
       * Attach a TemplatePortal as content to this dialog container.
       * @param portal Portal to be attached as the dialog content.
       */
      /**
       * Attach a TemplatePortal as content to this dialog container.
       * @template C
       * @param {?} portal Portal to be attached as the dialog content.
       * @return {?}
       */
      MatDialogContainer.prototype.attachTemplatePortal = /**
       * Attach a TemplatePortal as content to this dialog container.
       * @template C
       * @param {?} portal Portal to be attached as the dialog content.
       * @return {?}
       */
          function (portal) {
              if (this._portalOutlet.hasAttached()) {
                  throwMatDialogContentAlreadyAttachedError();
              }
              this._savePreviouslyFocusedElement();
              return this._portalOutlet.attachTemplatePortal(portal);
          };
      /** Moves the focus inside the focus trap. */
      /**
       * Moves the focus inside the focus trap.
       * @private
       * @return {?}
       */
      MatDialogContainer.prototype._trapFocus = /**
       * Moves the focus inside the focus trap.
       * @private
       * @return {?}
       */
          function () {
              if (!this._focusTrap) {
                  this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);
              }
              // If were to attempt to focus immediately, then the content of the dialog would not yet be
              // ready in instances where change detection has to run first. To deal with this, we simply
              // wait for the microtask queue to be empty.
              if (this._config.autoFocus) {
                  this._focusTrap.focusInitialElementWhenReady();
              }
          };
      /** Restores focus to the element that was focused before the dialog opened. */
      /**
       * Restores focus to the element that was focused before the dialog opened.
       * @private
       * @return {?}
       */
      MatDialogContainer.prototype._restoreFocus = /**
       * Restores focus to the element that was focused before the dialog opened.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var toFocus = this._elementFocusedBeforeDialogWasOpened;
              // We need the extra check, because IE can set the `activeElement` to null in some cases.
              if (this._config.restoreFocus && toFocus && typeof toFocus.focus === 'function') {
                  toFocus.focus();
              }
              if (this._focusTrap) {
                  this._focusTrap.destroy();
              }
          };
      /** Saves a reference to the element that was focused before the dialog was opened. */
      /**
       * Saves a reference to the element that was focused before the dialog was opened.
       * @private
       * @return {?}
       */
      MatDialogContainer.prototype._savePreviouslyFocusedElement = /**
       * Saves a reference to the element that was focused before the dialog was opened.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._document) {
                  this._elementFocusedBeforeDialogWasOpened = ( /** @type {?} */(this._document.activeElement));
                  // Note that there is no focus method when rendering on the server.
                  if (this._elementRef.nativeElement.focus) {
                      // Move focus onto the dialog immediately in order to prevent the user from accidentally
                      // opening multiple dialogs at the same time. Needs to be async, because the element
                      // may not be focusable immediately.
                      Promise.resolve().then(function () { return _this._elementRef.nativeElement.focus(); });
                  }
              }
          };
      /** Callback, invoked whenever an animation on the host completes. */
      /**
       * Callback, invoked whenever an animation on the host completes.
       * @param {?} event
       * @return {?}
       */
      MatDialogContainer.prototype._onAnimationDone = /**
       * Callback, invoked whenever an animation on the host completes.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (event.toState === 'enter') {
                  this._trapFocus();
              }
              else if (event.toState === 'exit') {
                  this._restoreFocus();
              }
              this._animationStateChanged.emit(event);
          };
      /** Callback, invoked when an animation on the host starts. */
      /**
       * Callback, invoked when an animation on the host starts.
       * @param {?} event
       * @return {?}
       */
      MatDialogContainer.prototype._onAnimationStart = /**
       * Callback, invoked when an animation on the host starts.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              this._animationStateChanged.emit(event);
          };
      /** Starts the dialog exit animation. */
      /**
       * Starts the dialog exit animation.
       * @return {?}
       */
      MatDialogContainer.prototype._startExitAnimation = /**
       * Starts the dialog exit animation.
       * @return {?}
       */
          function () {
              this._state = 'exit';
              // Mark the container for check so it can react if the
              // view container is using OnPush change detection.
              this._changeDetectorRef.markForCheck();
          };
      MatDialogContainer.decorators = [
          { type: core.Component, args: [{ selector: 'mat-dialog-container',
                      template: "<ng-template cdkPortalOutlet></ng-template>",
                      styles: [".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}@media (-ms-high-contrast:active){.mat-dialog-container{outline:solid 1px}}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button+.mat-button,.mat-dialog-actions .mat-button+.mat-raised-button,.mat-dialog-actions .mat-raised-button+.mat-button,.mat-dialog-actions .mat-raised-button+.mat-raised-button{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button+.mat-button,[dir=rtl] .mat-dialog-actions .mat-button+.mat-raised-button,[dir=rtl] .mat-dialog-actions .mat-raised-button+.mat-button,[dir=rtl] .mat-dialog-actions .mat-raised-button+.mat-raised-button{margin-left:0;margin-right:8px}"],
                      encapsulation: core.ViewEncapsulation.None,
                      // Using OnPush for dialogs caused some G3 sync issues. Disabled until we can track them down.
                      // tslint:disable-next-line:validate-decorators
                      changeDetection: core.ChangeDetectionStrategy.Default,
                      animations: [matDialogAnimations.dialogContainer],
                      host: {
                          'class': 'mat-dialog-container',
                          'tabindex': '-1',
                          'aria-modal': 'true',
                          '[attr.id]': '_id',
                          '[attr.role]': '_config.role',
                          '[attr.aria-labelledby]': '_config.ariaLabel ? null : _ariaLabelledBy',
                          '[attr.aria-label]': '_config.ariaLabel',
                          '[attr.aria-describedby]': '_config.ariaDescribedBy || null',
                          '[@dialogContainer]': '_state',
                          '(@dialogContainer.start)': '_onAnimationStart($event)',
                          '(@dialogContainer.done)': '_onAnimationDone($event)',
                      },
                  },] },
      ];
      /** @nocollapse */
      MatDialogContainer.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: FocusTrapFactory },
              { type: core.ChangeDetectorRef },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] },
              { type: MatDialogConfig }
          ];
      };
      MatDialogContainer.propDecorators = {
          _portalOutlet: [{ type: core.ViewChild, args: [CdkPortalOutlet,] }]
      };
      return MatDialogContainer;
  }(BasePortalOutlet));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // TODO(jelbourn): resizing
  // Counter for unique dialog ids.
  /** @type {?} */
  var uniqueId = 0;
  /**
   * Reference to a dialog opened via the MatDialog service.
   * @template T, R
   */
  var /**
   * Reference to a dialog opened via the MatDialog service.
   * @template T, R
   */ MatDialogRef = /** @class */ (function () {
      function MatDialogRef(_overlayRef, _containerInstance, 
      // @breaking-change 8.0.0 `_location` parameter to be removed.
      _location, id) {
          if (id === void 0) {
              id = "mat-dialog-" + uniqueId++;
          }
          var _this = this;
          this._overlayRef = _overlayRef;
          this._containerInstance = _containerInstance;
          this.id = id;
          /**
           * Whether the user is allowed to close the dialog.
           */
          this.disableClose = this._containerInstance._config.disableClose;
          /**
           * Subject for notifying the user that the dialog has finished opening.
           */
          this._afterOpened = new rxjs.Subject();
          /**
           * Subject for notifying the user that the dialog has finished closing.
           */
          this._afterClosed = new rxjs.Subject();
          /**
           * Subject for notifying the user that the dialog has started closing.
           */
          this._beforeClosed = new rxjs.Subject();
          // Pass the id along to the container.
          _containerInstance._id = id;
          // Emit when opening animation completes
          _containerInstance._animationStateChanged.pipe(operators.filter(function (event) { return event.phaseName === 'done' && event.toState === 'enter'; }), operators.take(1))
              .subscribe(function () {
              _this._afterOpened.next();
              _this._afterOpened.complete();
          });
          // Dispose overlay when closing animation is complete
          _containerInstance._animationStateChanged.pipe(operators.filter(function (event) { return event.phaseName === 'done' && event.toState === 'exit'; }), operators.take(1)).subscribe(function () { return _this._overlayRef.dispose(); });
          _overlayRef.detachments().subscribe(function () {
              _this._beforeClosed.next(_this._result);
              _this._beforeClosed.complete();
              _this._afterClosed.next(_this._result);
              _this._afterClosed.complete();
              _this.componentInstance = ( /** @type {?} */(null));
              _this._overlayRef.dispose();
          });
          _overlayRef.keydownEvents()
              .pipe(operators.filter(function (event) { return event.keyCode === ESCAPE && !_this.disableClose; }))
              .subscribe(function () { return _this.close(); });
      }
      /**
       * Close the dialog.
       * @param dialogResult Optional result to return to the dialog opener.
       */
      /**
       * Close the dialog.
       * @param {?=} dialogResult Optional result to return to the dialog opener.
       * @return {?}
       */
      MatDialogRef.prototype.close = /**
       * Close the dialog.
       * @param {?=} dialogResult Optional result to return to the dialog opener.
       * @return {?}
       */
          function (dialogResult) {
              var _this = this;
              this._result = dialogResult;
              // Transition the backdrop in parallel to the dialog.
              this._containerInstance._animationStateChanged.pipe(operators.filter(function (event) { return event.phaseName === 'start'; }), operators.take(1))
                  .subscribe(function () {
                  _this._beforeClosed.next(dialogResult);
                  _this._beforeClosed.complete();
                  _this._overlayRef.detachBackdrop();
              });
              this._containerInstance._startExitAnimation();
          };
      /**
       * Gets an observable that is notified when the dialog is finished opening.
       */
      /**
       * Gets an observable that is notified when the dialog is finished opening.
       * @return {?}
       */
      MatDialogRef.prototype.afterOpened = /**
       * Gets an observable that is notified when the dialog is finished opening.
       * @return {?}
       */
          function () {
              return this._afterOpened.asObservable();
          };
      /**
       * Gets an observable that is notified when the dialog is finished closing.
       */
      /**
       * Gets an observable that is notified when the dialog is finished closing.
       * @return {?}
       */
      MatDialogRef.prototype.afterClosed = /**
       * Gets an observable that is notified when the dialog is finished closing.
       * @return {?}
       */
          function () {
              return this._afterClosed.asObservable();
          };
      /**
       * Gets an observable that is notified when the dialog has started closing.
       */
      /**
       * Gets an observable that is notified when the dialog has started closing.
       * @return {?}
       */
      MatDialogRef.prototype.beforeClosed = /**
       * Gets an observable that is notified when the dialog has started closing.
       * @return {?}
       */
          function () {
              return this._beforeClosed.asObservable();
          };
      /**
       * Gets an observable that emits when the overlay's backdrop has been clicked.
       */
      /**
       * Gets an observable that emits when the overlay's backdrop has been clicked.
       * @return {?}
       */
      MatDialogRef.prototype.backdropClick = /**
       * Gets an observable that emits when the overlay's backdrop has been clicked.
       * @return {?}
       */
          function () {
              return this._overlayRef.backdropClick();
          };
      /**
       * Gets an observable that emits when keydown events are targeted on the overlay.
       */
      /**
       * Gets an observable that emits when keydown events are targeted on the overlay.
       * @return {?}
       */
      MatDialogRef.prototype.keydownEvents = /**
       * Gets an observable that emits when keydown events are targeted on the overlay.
       * @return {?}
       */
          function () {
              return this._overlayRef.keydownEvents();
          };
      /**
       * Updates the dialog's position.
       * @param position New dialog position.
       */
      /**
       * Updates the dialog's position.
       * @template THIS
       * @this {THIS}
       * @param {?=} position New dialog position.
       * @return {THIS}
       */
      MatDialogRef.prototype.updatePosition = /**
       * Updates the dialog's position.
       * @template THIS
       * @this {THIS}
       * @param {?=} position New dialog position.
       * @return {THIS}
       */
          function (position) {
              /** @type {?} */
              var strategy = ( /** @type {?} */(this))._getPositionStrategy();
              if (position && (position.left || position.right)) {
                  position.left ? strategy.left(position.left) : strategy.right(position.right);
              }
              else {
                  strategy.centerHorizontally();
              }
              if (position && (position.top || position.bottom)) {
                  position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);
              }
              else {
                  strategy.centerVertically();
              }
              ( /** @type {?} */(this))._overlayRef.updatePosition();
              return ( /** @type {?} */(this));
          };
      /**
       * Updates the dialog's width and height.
       * @param width New width of the dialog.
       * @param height New height of the dialog.
       */
      /**
       * Updates the dialog's width and height.
       * @template THIS
       * @this {THIS}
       * @param {?=} width New width of the dialog.
       * @param {?=} height New height of the dialog.
       * @return {THIS}
       */
      MatDialogRef.prototype.updateSize = /**
       * Updates the dialog's width and height.
       * @template THIS
       * @this {THIS}
       * @param {?=} width New width of the dialog.
       * @param {?=} height New height of the dialog.
       * @return {THIS}
       */
          function (width, height) {
              if (width === void 0) {
                  width = '';
              }
              if (height === void 0) {
                  height = '';
              }
              ( /** @type {?} */(this))._getPositionStrategy().width(width).height(height);
              ( /** @type {?} */(this))._overlayRef.updatePosition();
              return ( /** @type {?} */(this));
          };
      /** Add a CSS class or an array of classes to the overlay pane. */
      /**
       * Add a CSS class or an array of classes to the overlay pane.
       * @template THIS
       * @this {THIS}
       * @param {?} classes
       * @return {THIS}
       */
      MatDialogRef.prototype.addPanelClass = /**
       * Add a CSS class or an array of classes to the overlay pane.
       * @template THIS
       * @this {THIS}
       * @param {?} classes
       * @return {THIS}
       */
          function (classes) {
              ( /** @type {?} */(this))._overlayRef.addPanelClass(classes);
              return ( /** @type {?} */(this));
          };
      /** Remove a CSS class or an array of classes from the overlay pane. */
      /**
       * Remove a CSS class or an array of classes from the overlay pane.
       * @template THIS
       * @this {THIS}
       * @param {?} classes
       * @return {THIS}
       */
      MatDialogRef.prototype.removePanelClass = /**
       * Remove a CSS class or an array of classes from the overlay pane.
       * @template THIS
       * @this {THIS}
       * @param {?} classes
       * @return {THIS}
       */
          function (classes) {
              ( /** @type {?} */(this))._overlayRef.removePanelClass(classes);
              return ( /** @type {?} */(this));
          };
      /**
       * Gets an observable that is notified when the dialog is finished opening.
       * @deprecated Use `afterOpened` instead.
       * @breaking-change 8.0.0
       */
      /**
       * Gets an observable that is notified when the dialog is finished opening.
       * @deprecated Use `afterOpened` instead.
       * \@breaking-change 8.0.0
       * @return {?}
       */
      MatDialogRef.prototype.afterOpen = /**
       * Gets an observable that is notified when the dialog is finished opening.
       * @deprecated Use `afterOpened` instead.
       * \@breaking-change 8.0.0
       * @return {?}
       */
          function () {
              return this.afterOpened();
          };
      /**
       * Gets an observable that is notified when the dialog has started closing.
       * @deprecated Use `beforeClosed` instead.
       * @breaking-change 8.0.0
       */
      /**
       * Gets an observable that is notified when the dialog has started closing.
       * @deprecated Use `beforeClosed` instead.
       * \@breaking-change 8.0.0
       * @return {?}
       */
      MatDialogRef.prototype.beforeClose = /**
       * Gets an observable that is notified when the dialog has started closing.
       * @deprecated Use `beforeClosed` instead.
       * \@breaking-change 8.0.0
       * @return {?}
       */
          function () {
              return this.beforeClosed();
          };
      /** Fetches the position strategy object from the overlay ref. */
      /**
       * Fetches the position strategy object from the overlay ref.
       * @private
       * @return {?}
       */
      MatDialogRef.prototype._getPositionStrategy = /**
       * Fetches the position strategy object from the overlay ref.
       * @private
       * @return {?}
       */
          function () {
              return ( /** @type {?} */(this._overlayRef.getConfig().positionStrategy));
          };
      return MatDialogRef;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token that can be used to access the data that was passed in to a dialog.
   * @type {?}
   */
  var MAT_DIALOG_DATA = new core.InjectionToken('MatDialogData');
  /**
   * Injection token that can be used to specify default dialog options.
   * @type {?}
   */
  var MAT_DIALOG_DEFAULT_OPTIONS = new core.InjectionToken('mat-dialog-default-options');
  /**
   * Injection token that determines the scroll handling while the dialog is open.
   * @type {?}
   */
  var MAT_DIALOG_SCROLL_STRATEGY = new core.InjectionToken('mat-dialog-scroll-strategy');
  /**
   * Service to open Material Design modal dialogs.
   */
  var MatDialog = /** @class */ (function () {
      function MatDialog(_overlay, _injector, _location, _defaultOptions, scrollStrategy, _parentDialog, _overlayContainer) {
          var _this = this;
          this._overlay = _overlay;
          this._injector = _injector;
          this._location = _location;
          this._defaultOptions = _defaultOptions;
          this._parentDialog = _parentDialog;
          this._overlayContainer = _overlayContainer;
          this._openDialogsAtThisLevel = [];
          this._afterAllClosedAtThisLevel = new rxjs.Subject();
          this._afterOpenedAtThisLevel = new rxjs.Subject();
          this._ariaHiddenElements = new Map();
          /**
           * Stream that emits when all open dialog have finished closing.
           * Will emit on subscribe if there are no open dialogs to begin with.
           */
          this.afterAllClosed = rxjs.defer(function () {
              return _this.openDialogs.length ?
                  _this._afterAllClosed :
                  _this._afterAllClosed.pipe(operators.startWith(undefined));
          });
          this._scrollStrategy = scrollStrategy;
      }
      Object.defineProperty(MatDialog.prototype, "openDialogs", {
          /** Keeps track of the currently-open dialogs. */
          get: /**
           * Keeps track of the currently-open dialogs.
           * @return {?}
           */ function () {
              return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDialog.prototype, "afterOpened", {
          /** Stream that emits when a dialog has been opened. */
          get: /**
           * Stream that emits when a dialog has been opened.
           * @return {?}
           */ function () {
              return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDialog.prototype, "afterOpen", {
          /**
           * Stream that emits when a dialog has been opened.
           * @deprecated Use `afterOpened` instead.
           * @breaking-change 8.0.0
           */
          get: /**
           * Stream that emits when a dialog has been opened.
           * @deprecated Use `afterOpened` instead.
           * \@breaking-change 8.0.0
           * @return {?}
           */ function () {
              return this.afterOpened;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDialog.prototype, "_afterAllClosed", {
          get: /**
           * @return {?}
           */ function () {
              /** @type {?} */
              var parent = this._parentDialog;
              return parent ? parent._afterAllClosed : this._afterAllClosedAtThisLevel;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Opens a modal dialog containing the given component.
       * @param componentOrTemplateRef Type of the component to load into the dialog,
       *     or a TemplateRef to instantiate as the dialog content.
       * @param config Extra configuration options.
       * @returns Reference to the newly-opened dialog.
       */
      /**
       * Opens a modal dialog containing the given component.
       * @template T, D, R
       * @param {?} componentOrTemplateRef Type of the component to load into the dialog,
       *     or a TemplateRef to instantiate as the dialog content.
       * @param {?=} config Extra configuration options.
       * @return {?} Reference to the newly-opened dialog.
       */
      MatDialog.prototype.open = /**
       * Opens a modal dialog containing the given component.
       * @template T, D, R
       * @param {?} componentOrTemplateRef Type of the component to load into the dialog,
       *     or a TemplateRef to instantiate as the dialog content.
       * @param {?=} config Extra configuration options.
       * @return {?} Reference to the newly-opened dialog.
       */
          function (componentOrTemplateRef, config) {
              var _this = this;
              config = _applyConfigDefaults$1(config, this._defaultOptions || new MatDialogConfig());
              if (config.id && this.getDialogById(config.id)) {
                  throw Error("Dialog with id \"" + config.id + "\" exists already. The dialog id must be unique.");
              }
              /** @type {?} */
              var overlayRef = this._createOverlay(config);
              /** @type {?} */
              var dialogContainer = this._attachDialogContainer(overlayRef, config);
              /** @type {?} */
              var dialogRef = this._attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config);
              // If this is the first dialog that we're opening, hide all the non-overlay content.
              if (!this.openDialogs.length) {
                  this._hideNonDialogContentFromAssistiveTechnology();
              }
              this.openDialogs.push(dialogRef);
              dialogRef.afterClosed().subscribe(function () { return _this._removeOpenDialog(dialogRef); });
              this.afterOpened.next(dialogRef);
              return dialogRef;
          };
      /**
       * Closes all of the currently-open dialogs.
       */
      /**
       * Closes all of the currently-open dialogs.
       * @return {?}
       */
      MatDialog.prototype.closeAll = /**
       * Closes all of the currently-open dialogs.
       * @return {?}
       */
          function () {
              this._closeDialogs(this.openDialogs);
          };
      /**
       * Finds an open dialog by its id.
       * @param id ID to use when looking up the dialog.
       */
      /**
       * Finds an open dialog by its id.
       * @param {?} id ID to use when looking up the dialog.
       * @return {?}
       */
      MatDialog.prototype.getDialogById = /**
       * Finds an open dialog by its id.
       * @param {?} id ID to use when looking up the dialog.
       * @return {?}
       */
          function (id) {
              return this.openDialogs.find(function (dialog) { return dialog.id === id; });
          };
      /**
       * @return {?}
       */
      MatDialog.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              // Only close the dialogs at this level on destroy
              // since the parent service may still be active.
              this._closeDialogs(this._openDialogsAtThisLevel);
              this._afterAllClosedAtThisLevel.complete();
              this._afterOpenedAtThisLevel.complete();
          };
      /**
       * Creates the overlay into which the dialog will be loaded.
       * @param config The dialog configuration.
       * @returns A promise resolving to the OverlayRef for the created overlay.
       */
      /**
       * Creates the overlay into which the dialog will be loaded.
       * @private
       * @param {?} config The dialog configuration.
       * @return {?} A promise resolving to the OverlayRef for the created overlay.
       */
      MatDialog.prototype._createOverlay = /**
       * Creates the overlay into which the dialog will be loaded.
       * @private
       * @param {?} config The dialog configuration.
       * @return {?} A promise resolving to the OverlayRef for the created overlay.
       */
          function (config) {
              /** @type {?} */
              var overlayConfig = this._getOverlayConfig(config);
              return this._overlay.create(overlayConfig);
          };
      /**
       * Creates an overlay config from a dialog config.
       * @param dialogConfig The dialog configuration.
       * @returns The overlay configuration.
       */
      /**
       * Creates an overlay config from a dialog config.
       * @private
       * @param {?} dialogConfig The dialog configuration.
       * @return {?} The overlay configuration.
       */
      MatDialog.prototype._getOverlayConfig = /**
       * Creates an overlay config from a dialog config.
       * @private
       * @param {?} dialogConfig The dialog configuration.
       * @return {?} The overlay configuration.
       */
          function (dialogConfig) {
              /** @type {?} */
              var state$$1 = new OverlayConfig({
                  positionStrategy: this._overlay.position().global(),
                  scrollStrategy: dialogConfig.scrollStrategy || this._scrollStrategy(),
                  panelClass: dialogConfig.panelClass,
                  hasBackdrop: dialogConfig.hasBackdrop,
                  direction: dialogConfig.direction,
                  minWidth: dialogConfig.minWidth,
                  minHeight: dialogConfig.minHeight,
                  maxWidth: dialogConfig.maxWidth,
                  maxHeight: dialogConfig.maxHeight,
                  disposeOnNavigation: dialogConfig.closeOnNavigation
              });
              if (dialogConfig.backdropClass) {
                  state$$1.backdropClass = dialogConfig.backdropClass;
              }
              return state$$1;
          };
      /**
       * Attaches an MatDialogContainer to a dialog's already-created overlay.
       * @param overlay Reference to the dialog's underlying overlay.
       * @param config The dialog configuration.
       * @returns A promise resolving to a ComponentRef for the attached container.
       */
      /**
       * Attaches an MatDialogContainer to a dialog's already-created overlay.
       * @private
       * @param {?} overlay Reference to the dialog's underlying overlay.
       * @param {?} config The dialog configuration.
       * @return {?} A promise resolving to a ComponentRef for the attached container.
       */
      MatDialog.prototype._attachDialogContainer = /**
       * Attaches an MatDialogContainer to a dialog's already-created overlay.
       * @private
       * @param {?} overlay Reference to the dialog's underlying overlay.
       * @param {?} config The dialog configuration.
       * @return {?} A promise resolving to a ComponentRef for the attached container.
       */
          function (overlay, config) {
              /** @type {?} */
              var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
              /** @type {?} */
              var injector = new PortalInjector(userInjector || this._injector, new WeakMap([
                  [MatDialogConfig, config]
              ]));
              /** @type {?} */
              var containerPortal = new ComponentPortal(MatDialogContainer, config.viewContainerRef, injector);
              /** @type {?} */
              var containerRef = overlay.attach(containerPortal);
              return containerRef.instance;
          };
      /**
       * Attaches the user-provided component to the already-created MatDialogContainer.
       * @param componentOrTemplateRef The type of component being loaded into the dialog,
       *     or a TemplateRef to instantiate as the content.
       * @param dialogContainer Reference to the wrapping MatDialogContainer.
       * @param overlayRef Reference to the overlay in which the dialog resides.
       * @param config The dialog configuration.
       * @returns A promise resolving to the MatDialogRef that should be returned to the user.
       */
      /**
       * Attaches the user-provided component to the already-created MatDialogContainer.
       * @private
       * @template T, R
       * @param {?} componentOrTemplateRef The type of component being loaded into the dialog,
       *     or a TemplateRef to instantiate as the content.
       * @param {?} dialogContainer Reference to the wrapping MatDialogContainer.
       * @param {?} overlayRef Reference to the overlay in which the dialog resides.
       * @param {?} config The dialog configuration.
       * @return {?} A promise resolving to the MatDialogRef that should be returned to the user.
       */
      MatDialog.prototype._attachDialogContent = /**
       * Attaches the user-provided component to the already-created MatDialogContainer.
       * @private
       * @template T, R
       * @param {?} componentOrTemplateRef The type of component being loaded into the dialog,
       *     or a TemplateRef to instantiate as the content.
       * @param {?} dialogContainer Reference to the wrapping MatDialogContainer.
       * @param {?} overlayRef Reference to the overlay in which the dialog resides.
       * @param {?} config The dialog configuration.
       * @return {?} A promise resolving to the MatDialogRef that should be returned to the user.
       */
          function (componentOrTemplateRef, dialogContainer, overlayRef, config) {
              // Create a reference to the dialog we're creating in order to give the user a handle
              // to modify and close it.
              /** @type {?} */
              var dialogRef = new MatDialogRef(overlayRef, dialogContainer, this._location, config.id);
              // When the dialog backdrop is clicked, we want to close it.
              if (config.hasBackdrop) {
                  overlayRef.backdropClick().subscribe(function () {
                      if (!dialogRef.disableClose) {
                          dialogRef.close();
                      }
                  });
              }
              if (componentOrTemplateRef instanceof core.TemplateRef) {
                  dialogContainer.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef, ( /** @type {?} */(null)), ( /** @type {?} */({ $implicit: config.data, dialogRef: dialogRef }))));
              }
              else {
                  /** @type {?} */
                  var injector = this._createInjector(config, dialogRef, dialogContainer);
                  /** @type {?} */
                  var contentRef = dialogContainer.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, undefined, injector));
                  dialogRef.componentInstance = contentRef.instance;
              }
              dialogRef
                  .updateSize(config.width, config.height)
                  .updatePosition(config.position);
              return dialogRef;
          };
      /**
       * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
       * of a dialog to close itself and, optionally, to return a value.
       * @param config Config object that is used to construct the dialog.
       * @param dialogRef Reference to the dialog.
       * @param container Dialog container element that wraps all of the contents.
       * @returns The custom injector that can be used inside the dialog.
       */
      /**
       * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
       * of a dialog to close itself and, optionally, to return a value.
       * @private
       * @template T
       * @param {?} config Config object that is used to construct the dialog.
       * @param {?} dialogRef Reference to the dialog.
       * @param {?} dialogContainer
       * @return {?} The custom injector that can be used inside the dialog.
       */
      MatDialog.prototype._createInjector = /**
       * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
       * of a dialog to close itself and, optionally, to return a value.
       * @private
       * @template T
       * @param {?} config Config object that is used to construct the dialog.
       * @param {?} dialogRef Reference to the dialog.
       * @param {?} dialogContainer
       * @return {?} The custom injector that can be used inside the dialog.
       */
          function (config, dialogRef, dialogContainer) {
              /** @type {?} */
              var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
              // The MatDialogContainer is injected in the portal as the MatDialogContainer and the dialog's
              // content are created out of the same ViewContainerRef and as such, are siblings for injector
              // purposes. To allow the hierarchy that is expected, the MatDialogContainer is explicitly
              // added to the injection tokens.
              /** @type {?} */
              var injectionTokens = new WeakMap([
                  [MatDialogContainer, dialogContainer],
                  [MAT_DIALOG_DATA, config.data],
                  [MatDialogRef, dialogRef]
              ]);
              if (config.direction &&
                  (!userInjector || !userInjector.get(Directionality, null))) {
                  injectionTokens.set(Directionality, {
                      value: config.direction,
                      change: rxjs.of()
                  });
              }
              return new PortalInjector(userInjector || this._injector, injectionTokens);
          };
      /**
       * Removes a dialog from the array of open dialogs.
       * @param dialogRef Dialog to be removed.
       */
      /**
       * Removes a dialog from the array of open dialogs.
       * @private
       * @param {?} dialogRef Dialog to be removed.
       * @return {?}
       */
      MatDialog.prototype._removeOpenDialog = /**
       * Removes a dialog from the array of open dialogs.
       * @private
       * @param {?} dialogRef Dialog to be removed.
       * @return {?}
       */
          function (dialogRef) {
              /** @type {?} */
              var index = this.openDialogs.indexOf(dialogRef);
              if (index > -1) {
                  this.openDialogs.splice(index, 1);
                  // If all the dialogs were closed, remove/restore the `aria-hidden`
                  // to a the siblings and emit to the `afterAllClosed` stream.
                  if (!this.openDialogs.length) {
                      this._ariaHiddenElements.forEach(function (previousValue, element) {
                          if (previousValue) {
                              element.setAttribute('aria-hidden', previousValue);
                          }
                          else {
                              element.removeAttribute('aria-hidden');
                          }
                      });
                      this._ariaHiddenElements.clear();
                      this._afterAllClosed.next();
                  }
              }
          };
      /**
       * Hides all of the content that isn't an overlay from assistive technology.
       */
      /**
       * Hides all of the content that isn't an overlay from assistive technology.
       * @private
       * @return {?}
       */
      MatDialog.prototype._hideNonDialogContentFromAssistiveTechnology = /**
       * Hides all of the content that isn't an overlay from assistive technology.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var overlayContainer = this._overlayContainer.getContainerElement();
              // Ensure that the overlay container is attached to the DOM.
              if (overlayContainer.parentElement) {
                  /** @type {?} */
                  var siblings = overlayContainer.parentElement.children;
                  for (var i = siblings.length - 1; i > -1; i--) {
                      /** @type {?} */
                      var sibling = siblings[i];
                      if (sibling !== overlayContainer &&
                          sibling.nodeName !== 'SCRIPT' &&
                          sibling.nodeName !== 'STYLE' &&
                          !sibling.hasAttribute('aria-live')) {
                          this._ariaHiddenElements.set(sibling, sibling.getAttribute('aria-hidden'));
                          sibling.setAttribute('aria-hidden', 'true');
                      }
                  }
              }
          };
      /** Closes all of the dialogs in an array. */
      /**
       * Closes all of the dialogs in an array.
       * @private
       * @param {?} dialogs
       * @return {?}
       */
      MatDialog.prototype._closeDialogs = /**
       * Closes all of the dialogs in an array.
       * @private
       * @param {?} dialogs
       * @return {?}
       */
          function (dialogs) {
              /** @type {?} */
              var i = dialogs.length;
              while (i--) {
                  // The `_openDialogs` property isn't updated after close until the rxjs subscription
                  // runs on the next microtask, in addition to modifying the array as we're going
                  // through it. We loop through all of them and call close without assuming that
                  // they'll be removed from the list instantaneously.
                  dialogs[i].close();
              }
          };
      MatDialog.decorators = [
          { type: core.Injectable },
      ];
      /** @nocollapse */
      MatDialog.ctorParameters = function () {
          return [
              { type: Overlay },
              { type: core.Injector },
              { type: common.Location, decorators: [{ type: core.Optional }] },
              { type: MatDialogConfig, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_DIALOG_DEFAULT_OPTIONS,] }] },
              { type: undefined, decorators: [{ type: core.Inject, args: [MAT_DIALOG_SCROLL_STRATEGY,] }] },
              { type: MatDialog, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
              { type: OverlayContainer }
          ];
      };
      return MatDialog;
  }());
  /**
   * Applies default options to the dialog config.
   * @param {?=} config Config to be modified.
   * @param {?=} defaultOptions Default options provided.
   * @return {?} The new configuration object.
   */
  function _applyConfigDefaults$1(config, defaultOptions) {
      return tslib_1.__assign({}, defaultOptions, config);
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Counter used to generate unique IDs for dialog elements.
   * @type {?}
   */
  var dialogElementUid = 0;
  /**
   * Button that will close the current dialog.
   */
  var MatDialogClose = /** @class */ (function () {
      function MatDialogClose(dialogRef, _elementRef, _dialog) {
          this.dialogRef = dialogRef;
          this._elementRef = _elementRef;
          this._dialog = _dialog;
          /**
           * Screenreader label for the button.
           */
          this.ariaLabel = 'Close dialog';
      }
      /**
       * @return {?}
       */
      MatDialogClose.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              if (!this.dialogRef) {
                  // When this directive is included in a dialog via TemplateRef (rather than being
                  // in a Component), the DialogRef isn't available via injection because embedded
                  // views cannot be given a custom injector. Instead, we look up the DialogRef by
                  // ID. This must occur in `onInit`, as the ID binding for the dialog container won't
                  // be resolved at constructor time.
                  this.dialogRef = ( /** @type {?} */(getClosestDialog(this._elementRef, this._dialog.openDialogs)));
              }
          };
      /**
       * @param {?} changes
       * @return {?}
       */
      MatDialogClose.prototype.ngOnChanges = /**
       * @param {?} changes
       * @return {?}
       */
          function (changes) {
              /** @type {?} */
              var proxiedChange = changes._matDialogClose || changes._matDialogCloseResult;
              if (proxiedChange) {
                  this.dialogResult = proxiedChange.currentValue;
              }
          };
      MatDialogClose.decorators = [
          { type: core.Directive, args: [{
                      selector: "button[mat-dialog-close], button[matDialogClose]",
                      exportAs: 'matDialogClose',
                      host: {
                          '(click)': 'dialogRef.close(dialogResult)',
                          '[attr.aria-label]': 'ariaLabel',
                          'type': 'button',
                      }
                  },] },
      ];
      /** @nocollapse */
      MatDialogClose.ctorParameters = function () {
          return [
              { type: MatDialogRef, decorators: [{ type: core.Optional }] },
              { type: core.ElementRef },
              { type: MatDialog }
          ];
      };
      MatDialogClose.propDecorators = {
          ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
          dialogResult: [{ type: core.Input, args: ['mat-dialog-close',] }],
          _matDialogClose: [{ type: core.Input, args: ['matDialogClose',] }]
      };
      return MatDialogClose;
  }());
  /**
   * Title of a dialog element. Stays fixed to the top of the dialog when scrolling.
   */
  var MatDialogTitle = /** @class */ (function () {
      function MatDialogTitle(_dialogRef, _elementRef, _dialog) {
          this._dialogRef = _dialogRef;
          this._elementRef = _elementRef;
          this._dialog = _dialog;
          this.id = "mat-dialog-title-" + dialogElementUid++;
      }
      /**
       * @return {?}
       */
      MatDialogTitle.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this._dialogRef) {
                  this._dialogRef = ( /** @type {?} */(getClosestDialog(this._elementRef, this._dialog.openDialogs)));
              }
              if (this._dialogRef) {
                  Promise.resolve().then(function () {
                      /** @type {?} */
                      var container = _this._dialogRef._containerInstance;
                      if (container && !container._ariaLabelledBy) {
                          container._ariaLabelledBy = _this.id;
                      }
                  });
              }
          };
      MatDialogTitle.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mat-dialog-title], [matDialogTitle]',
                      exportAs: 'matDialogTitle',
                      host: {
                          'class': 'mat-dialog-title',
                          '[id]': 'id',
                      },
                  },] },
      ];
      /** @nocollapse */
      MatDialogTitle.ctorParameters = function () {
          return [
              { type: MatDialogRef, decorators: [{ type: core.Optional }] },
              { type: core.ElementRef },
              { type: MatDialog }
          ];
      };
      MatDialogTitle.propDecorators = {
          id: [{ type: core.Input }]
      };
      return MatDialogTitle;
  }());
  /**
   * Finds the closest MatDialogRef to an element by looking at the DOM.
   * @param {?} element Element relative to which to look for a dialog.
   * @param {?} openDialogs References to the currently-open dialogs.
   * @return {?}
   */
  function getClosestDialog(element, openDialogs) {
      /** @type {?} */
      var parent = element.nativeElement.parentElement;
      while (parent && !parent.classList.contains('mat-dialog-container')) {
          parent = parent.parentElement;
      }
      return parent ? openDialogs.find(function (dialog) { return dialog.id === ( /** @type {?} */(parent)).id; }) : null;
  }

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Options to pass to the animationstart listener.
   * @type {?}
   */
  var listenerOptions = normalizePassiveListenerOptions({ passive: true });
  /**
   * An injectable service that can be used to monitor the autofill state of an input.
   * Based on the following blog post:
   * https://medium.com/\@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7
   */
  var AutofillMonitor = /** @class */ (function () {
      function AutofillMonitor(_platform, _ngZone) {
          this._platform = _platform;
          this._ngZone = _ngZone;
          this._monitoredElements = new Map();
      }
      /**
       * @param {?} elementOrRef
       * @return {?}
       */
      AutofillMonitor.prototype.monitor = /**
       * @param {?} elementOrRef
       * @return {?}
       */
          function (elementOrRef) {
              var _this = this;
              if (!this._platform.isBrowser) {
                  return rxjs.EMPTY;
              }
              /** @type {?} */
              var element = coerceElement(elementOrRef);
              /** @type {?} */
              var info = this._monitoredElements.get(element);
              if (info) {
                  return info.subject.asObservable();
              }
              /** @type {?} */
              var result = new rxjs.Subject();
              /** @type {?} */
              var cssClass = 'cdk-text-field-autofilled';
              /** @type {?} */
              var listener = ( /** @type {?} */((function (event) {
                  // Animation events fire on initial element render, we check for the presence of the autofill
                  // CSS class to make sure this is a real change in state, not just the initial render before
                  // we fire off events.
                  if (event.animationName === 'cdk-text-field-autofill-start' &&
                      !element.classList.contains(cssClass)) {
                      element.classList.add(cssClass);
                      _this._ngZone.run(function () { return result.next({ target: ( /** @type {?} */(event.target)), isAutofilled: true }); });
                  }
                  else if (event.animationName === 'cdk-text-field-autofill-end' &&
                      element.classList.contains(cssClass)) {
                      element.classList.remove(cssClass);
                      _this._ngZone.run(function () { return result.next({ target: ( /** @type {?} */(event.target)), isAutofilled: false }); });
                  }
              })));
              this._ngZone.runOutsideAngular(function () {
                  element.addEventListener('animationstart', listener, listenerOptions);
                  element.classList.add('cdk-text-field-autofill-monitored');
              });
              this._monitoredElements.set(element, {
                  subject: result,
                  unlisten: function () {
                      element.removeEventListener('animationstart', listener, listenerOptions);
                  }
              });
              return result.asObservable();
          };
      /**
       * @param {?} elementOrRef
       * @return {?}
       */
      AutofillMonitor.prototype.stopMonitoring = /**
       * @param {?} elementOrRef
       * @return {?}
       */
          function (elementOrRef) {
              /** @type {?} */
              var element = coerceElement(elementOrRef);
              /** @type {?} */
              var info = this._monitoredElements.get(element);
              if (info) {
                  info.unlisten();
                  info.subject.complete();
                  element.classList.remove('cdk-text-field-autofill-monitored');
                  element.classList.remove('cdk-text-field-autofilled');
                  this._monitoredElements.delete(element);
              }
          };
      /**
       * @return {?}
       */
      AutofillMonitor.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._monitoredElements.forEach(function (_info, element) { return _this.stopMonitoring(element); });
          };
      AutofillMonitor.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */
      AutofillMonitor.ctorParameters = function () {
          return [
              { type: Platform },
              { type: core.NgZone }
          ];
      };
      /** @nocollapse */ AutofillMonitor.ngInjectableDef = core.defineInjectable({ factory: function AutofillMonitor_Factory() { return new AutofillMonitor(core.inject(Platform), core.inject(core.NgZone)); }, token: AutofillMonitor, providedIn: "root" });
      return AutofillMonitor;
  }());
  /**
   * A directive that can be used to monitor the autofill state of an input.
   */
  var CdkAutofill = /** @class */ (function () {
      function CdkAutofill(_elementRef, _autofillMonitor) {
          this._elementRef = _elementRef;
          this._autofillMonitor = _autofillMonitor;
          /**
           * Emits when the autofill state of the element changes.
           */
          this.cdkAutofill = new core.EventEmitter();
      }
      /**
       * @return {?}
       */
      CdkAutofill.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._autofillMonitor
                  .monitor(this._elementRef)
                  .subscribe(function (event) { return _this.cdkAutofill.emit(event); });
          };
      /**
       * @return {?}
       */
      CdkAutofill.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._autofillMonitor.stopMonitoring(this._elementRef);
          };
      CdkAutofill.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkAutofill]',
                  },] },
      ];
      /** @nocollapse */
      CdkAutofill.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: AutofillMonitor }
          ];
      };
      CdkAutofill.propDecorators = {
          cdkAutofill: [{ type: core.Output }]
      };
      return CdkAutofill;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Directive to automatically resize a textarea to fit its content.
   */
  var CdkTextareaAutosize = /** @class */ (function () {
      function CdkTextareaAutosize(_elementRef, _platform, _ngZone) {
          this._elementRef = _elementRef;
          this._platform = _platform;
          this._ngZone = _ngZone;
          this._destroyed = new rxjs.Subject();
          this._enabled = true;
          /**
           * Value of minRows as of last resize. If the minRows has decreased, the
           * height of the textarea needs to be recomputed to reflect the new minimum. The maxHeight
           * does not have the same problem because it does not affect the textarea's scrollHeight.
           */
          this._previousMinRows = -1;
          this._textareaElement = ( /** @type {?} */(this._elementRef.nativeElement));
      }
      Object.defineProperty(CdkTextareaAutosize.prototype, "minRows", {
          /** Minimum amount of rows in the textarea. */
          get: /**
           * Minimum amount of rows in the textarea.
           * @return {?}
           */ function () { return this._minRows; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._minRows = value;
              this._setMinHeight();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkTextareaAutosize.prototype, "maxRows", {
          /** Maximum amount of rows in the textarea. */
          get: /**
           * Maximum amount of rows in the textarea.
           * @return {?}
           */ function () { return this._maxRows; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._maxRows = value;
              this._setMaxHeight();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkTextareaAutosize.prototype, "enabled", {
          /** Whether autosizing is enabled or not */
          get: /**
           * Whether autosizing is enabled or not
           * @return {?}
           */ function () { return this._enabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              value = coerceBooleanProperty(value);
              // Only act if the actual value changed. This specifically helps to not run
              // resizeToFitContent too early (i.e. before ngAfterViewInit)
              if (this._enabled !== value) {
                  (this._enabled = value) ? this.resizeToFitContent(true) : this.reset();
              }
          },
          enumerable: true,
          configurable: true
      });
      /** Sets the minimum height of the textarea as determined by minRows. */
      /**
       * Sets the minimum height of the textarea as determined by minRows.
       * @return {?}
       */
      CdkTextareaAutosize.prototype._setMinHeight = /**
       * Sets the minimum height of the textarea as determined by minRows.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var minHeight = this.minRows && this._cachedLineHeight ?
                  this.minRows * this._cachedLineHeight + "px" : null;
              if (minHeight) {
                  this._textareaElement.style.minHeight = minHeight;
              }
          };
      /** Sets the maximum height of the textarea as determined by maxRows. */
      /**
       * Sets the maximum height of the textarea as determined by maxRows.
       * @return {?}
       */
      CdkTextareaAutosize.prototype._setMaxHeight = /**
       * Sets the maximum height of the textarea as determined by maxRows.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var maxHeight = this.maxRows && this._cachedLineHeight ?
                  this.maxRows * this._cachedLineHeight + "px" : null;
              if (maxHeight) {
                  this._textareaElement.style.maxHeight = maxHeight;
              }
          };
      /**
       * @return {?}
       */
      CdkTextareaAutosize.prototype.ngAfterViewInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._platform.isBrowser) {
                  // Remember the height which we started with in case autosizing is disabled
                  this._initialHeight = this._textareaElement.style.height;
                  this.resizeToFitContent();
                  this._ngZone.runOutsideAngular(function () {
                      rxjs.fromEvent(window, 'resize')
                          .pipe(operators.auditTime(16), operators.takeUntil(_this._destroyed))
                          .subscribe(function () { return _this.resizeToFitContent(true); });
                  });
              }
          };
      /**
       * @return {?}
       */
      CdkTextareaAutosize.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._destroyed.next();
              this._destroyed.complete();
          };
      /**
       * Cache the height of a single-row textarea if it has not already been cached.
       *
       * We need to know how large a single "row" of a textarea is in order to apply minRows and
       * maxRows. For the initial version, we will assume that the height of a single line in the
       * textarea does not ever change.
       */
      /**
       * Cache the height of a single-row textarea if it has not already been cached.
       *
       * We need to know how large a single "row" of a textarea is in order to apply minRows and
       * maxRows. For the initial version, we will assume that the height of a single line in the
       * textarea does not ever change.
       * @private
       * @return {?}
       */
      CdkTextareaAutosize.prototype._cacheTextareaLineHeight = /**
       * Cache the height of a single-row textarea if it has not already been cached.
       *
       * We need to know how large a single "row" of a textarea is in order to apply minRows and
       * maxRows. For the initial version, we will assume that the height of a single line in the
       * textarea does not ever change.
       * @private
       * @return {?}
       */
          function () {
              if (this._cachedLineHeight) {
                  return;
              }
              // Use a clone element because we have to override some styles.
              /** @type {?} */
              var textareaClone = ( /** @type {?} */(this._textareaElement.cloneNode(false)));
              textareaClone.rows = 1;
              // Use `position: absolute` so that this doesn't cause a browser layout and use
              // `visibility: hidden` so that nothing is rendered. Clear any other styles that
              // would affect the height.
              textareaClone.style.position = 'absolute';
              textareaClone.style.visibility = 'hidden';
              textareaClone.style.border = 'none';
              textareaClone.style.padding = '0';
              textareaClone.style.height = '';
              textareaClone.style.minHeight = '';
              textareaClone.style.maxHeight = '';
              // In Firefox it happens that textarea elements are always bigger than the specified amount
              // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.
              // As a workaround that removes the extra space for the scrollbar, we can just set overflow
              // to hidden. This ensures that there is no invalid calculation of the line height.
              // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654
              textareaClone.style.overflow = 'hidden';
              ( /** @type {?} */(this._textareaElement.parentNode)).appendChild(textareaClone);
              this._cachedLineHeight = textareaClone.clientHeight;
              ( /** @type {?} */(this._textareaElement.parentNode)).removeChild(textareaClone);
              // Min and max heights have to be re-calculated if the cached line height changes
              this._setMinHeight();
              this._setMaxHeight();
          };
      /**
       * @return {?}
       */
      CdkTextareaAutosize.prototype.ngDoCheck = /**
       * @return {?}
       */
          function () {
              if (this._platform.isBrowser) {
                  this.resizeToFitContent();
              }
          };
      /**
       * Resize the textarea to fit its content.
       * @param force Whether to force a height recalculation. By default the height will be
       *    recalculated only if the value changed since the last call.
       */
      /**
       * Resize the textarea to fit its content.
       * @param {?=} force Whether to force a height recalculation. By default the height will be
       *    recalculated only if the value changed since the last call.
       * @return {?}
       */
      CdkTextareaAutosize.prototype.resizeToFitContent = /**
       * Resize the textarea to fit its content.
       * @param {?=} force Whether to force a height recalculation. By default the height will be
       *    recalculated only if the value changed since the last call.
       * @return {?}
       */
          function (force) {
              var _this = this;
              if (force === void 0) {
                  force = false;
              }
              // If autosizing is disabled, just skip everything else
              if (!this._enabled) {
                  return;
              }
              this._cacheTextareaLineHeight();
              // If we haven't determined the line-height yet, we know we're still hidden and there's no point
              // in checking the height of the textarea.
              if (!this._cachedLineHeight) {
                  return;
              }
              /** @type {?} */
              var textarea = ( /** @type {?} */(this._elementRef.nativeElement));
              /** @type {?} */
              var value = textarea.value;
              // Only resize if the value or minRows have changed since these calculations can be expensive.
              if (!force && this._minRows === this._previousMinRows && value === this._previousValue) {
                  return;
              }
              /** @type {?} */
              var placeholderText = textarea.placeholder;
              // Reset the textarea height to auto in order to shrink back to its default size.
              // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.
              // Long placeholders that are wider than the textarea width may lead to a bigger scrollHeight
              // value. To ensure that the scrollHeight is not bigger than the content, the placeholders
              // need to be removed temporarily.
              textarea.classList.add('cdk-textarea-autosize-measuring');
              textarea.placeholder = '';
              // The cdk-textarea-autosize-measuring class includes a 2px padding to workaround an issue with
              // Chrome, so we account for that extra space here by subtracting 4 (2px top + 2px bottom).
              /** @type {?} */
              var height = textarea.scrollHeight - 4;
              // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.
              textarea.style.height = height + "px";
              textarea.classList.remove('cdk-textarea-autosize-measuring');
              textarea.placeholder = placeholderText;
              this._ngZone.runOutsideAngular(function () {
                  if (typeof requestAnimationFrame !== 'undefined') {
                      requestAnimationFrame(function () { return _this._scrollToCaretPosition(textarea); });
                  }
                  else {
                      setTimeout(function () { return _this._scrollToCaretPosition(textarea); });
                  }
              });
              this._previousValue = value;
              this._previousMinRows = this._minRows;
          };
      /**
       * Resets the textarea to it's original size
       */
      /**
       * Resets the textarea to it's original size
       * @return {?}
       */
      CdkTextareaAutosize.prototype.reset = /**
       * Resets the textarea to it's original size
       * @return {?}
       */
          function () {
              // Do not try to change the textarea, if the initialHeight has not been determined yet
              // This might potentially remove styles when reset() is called before ngAfterViewInit
              if (this._initialHeight === undefined) {
                  return;
              }
              this._textareaElement.style.height = this._initialHeight;
          };
      /**
       * @return {?}
       */
      CdkTextareaAutosize.prototype._noopInputHandler = /**
       * @return {?}
       */
          function () {
              // no-op handler that ensures we're running change detection on input events.
          };
      /**
       * Scrolls a textarea to the caret position. On Firefox resizing the textarea will
       * prevent it from scrolling to the caret position. We need to re-set the selection
       * in order for it to scroll to the proper position.
       */
      /**
       * Scrolls a textarea to the caret position. On Firefox resizing the textarea will
       * prevent it from scrolling to the caret position. We need to re-set the selection
       * in order for it to scroll to the proper position.
       * @private
       * @param {?} textarea
       * @return {?}
       */
      CdkTextareaAutosize.prototype._scrollToCaretPosition = /**
       * Scrolls a textarea to the caret position. On Firefox resizing the textarea will
       * prevent it from scrolling to the caret position. We need to re-set the selection
       * in order for it to scroll to the proper position.
       * @private
       * @param {?} textarea
       * @return {?}
       */
          function (textarea) {
              var selectionStart = textarea.selectionStart, selectionEnd = textarea.selectionEnd;
              // IE will throw an "Unspecified error" if we try to set the selection range after the
              // element has been removed from the DOM. Assert that the directive hasn't been destroyed
              // between the time we requested the animation frame and when it was executed.
              // Also note that we have to assert that the textarea is focused before we set the
              // selection range. Setting the selection range on a non-focused textarea will cause
              // it to receive focus on IE and Edge.
              if (!this._destroyed.isStopped && document.activeElement === textarea) {
                  textarea.setSelectionRange(selectionStart, selectionEnd);
              }
          };
      CdkTextareaAutosize.decorators = [
          { type: core.Directive, args: [{
                      selector: 'textarea[cdkTextareaAutosize]',
                      exportAs: 'cdkTextareaAutosize',
                      host: {
                          'class': 'cdk-textarea-autosize',
                          // Textarea elements that have the directive applied should have a single row by default.
                          // Browsers normally show two rows by default and therefore this limits the minRows binding.
                          'rows': '1',
                          '(input)': '_noopInputHandler()',
                      },
                  },] },
      ];
      /** @nocollapse */
      CdkTextareaAutosize.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: Platform },
              { type: core.NgZone }
          ];
      };
      CdkTextareaAutosize.propDecorators = {
          minRows: [{ type: core.Input, args: ['cdkAutosizeMinRows',] }],
          maxRows: [{ type: core.Input, args: ['cdkAutosizeMaxRows',] }],
          enabled: [{ type: core.Input, args: ['cdkTextareaAutosize',] }]
      };
      return CdkTextareaAutosize;
  }());

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Directive to automatically resize a textarea to fit its content.
   * @deprecated Use `cdkTextareaAutosize` from `\@angular/cdk/text-field` instead.
   * \@breaking-change 8.0.0
   */
  var MatTextareaAutosize = /** @class */ (function (_super) {
      tslib_1.__extends(MatTextareaAutosize, _super);
      function MatTextareaAutosize() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      Object.defineProperty(MatTextareaAutosize.prototype, "matAutosizeMinRows", {
          get: /**
           * @return {?}
           */ function () { return this.minRows; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this.minRows = value; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatTextareaAutosize.prototype, "matAutosizeMaxRows", {
          get: /**
           * @return {?}
           */ function () { return this.maxRows; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this.maxRows = value; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatTextareaAutosize.prototype, "matAutosize", {
          get: /**
           * @return {?}
           */ function () { return this.enabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this.enabled = value; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatTextareaAutosize.prototype, "matTextareaAutosize", {
          get: /**
           * @return {?}
           */ function () { return this.enabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this.enabled = value; },
          enumerable: true,
          configurable: true
      });
      MatTextareaAutosize.decorators = [
          { type: core.Directive, args: [{
                      selector: 'textarea[mat-autosize], textarea[matTextareaAutosize]',
                      exportAs: 'matTextareaAutosize',
                      inputs: ['cdkAutosizeMinRows', 'cdkAutosizeMaxRows'],
                      host: {
                          'class': 'cdk-textarea-autosize mat-autosize',
                          // Textarea elements that have the directive applied should have a single row by default.
                          // Browsers normally show two rows by default and therefore this limits the minRows binding.
                          'rows': '1',
                          '(input)': '_noopInputHandler()',
                      },
                  },] },
      ];
      MatTextareaAutosize.propDecorators = {
          matAutosizeMinRows: [{ type: core.Input }],
          matAutosizeMaxRows: [{ type: core.Input }],
          matAutosize: [{ type: core.Input, args: ['mat-autosize',] }],
          matTextareaAutosize: [{ type: core.Input }]
      };
      return MatTextareaAutosize;
  }(CdkTextareaAutosize));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@docs-private
   * @param {?} type
   * @return {?}
   */
  function getMatInputUnsupportedTypeError(type) {
      return Error("Input type \"" + type + "\" isn't supported by matInput.");
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * This token is used to inject the object whose value should be set into `MatInput`. If none is
   * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide
   * themselves for this token, in order to make `MatInput` delegate the getting and setting of the
   * value to them.
   * @type {?}
   */
  var MAT_INPUT_VALUE_ACCESSOR = new core.InjectionToken('MAT_INPUT_VALUE_ACCESSOR');
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.
  /** @type {?} */
  var MAT_INPUT_INVALID_TYPES = [
      'button',
      'checkbox',
      'file',
      'hidden',
      'image',
      'radio',
      'range',
      'reset',
      'submit'
  ];
  /** @type {?} */
  var nextUniqueId$5 = 0;
  // Boilerplate for applying mixins to MatInput.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatInput.
  /**
   * \@docs-private
   */
  MatInputBase = /** @class */ (function () {
      function MatInputBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {
          this._defaultErrorStateMatcher = _defaultErrorStateMatcher;
          this._parentForm = _parentForm;
          this._parentFormGroup = _parentFormGroup;
          this.ngControl = ngControl;
      }
      return MatInputBase;
  }());
  /** @type {?} */
  var _MatInputMixinBase = mixinErrorState(MatInputBase);
  /**
   * Directive that allows a native input to work inside a `MatFormField`.
   */
  var MatInput = /** @class */ (function (_super) {
      tslib_1.__extends(MatInput, _super);
      function MatInput(_elementRef, _platform, ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, ngZone) {
          var _this = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;
          _this._elementRef = _elementRef;
          _this._platform = _platform;
          _this.ngControl = ngControl;
          _this._autofillMonitor = _autofillMonitor;
          _this._uid = "mat-input-" + nextUniqueId$5++;
          /**
           * Whether the component is being rendered on the server.
           */
          _this._isServer = false;
          /**
           * Whether the component is a native html select.
           */
          _this._isNativeSelect = false;
          /**
           * Implemented as part of MatFormFieldControl.
           * \@docs-private
           */
          _this.focused = false;
          /**
           * Implemented as part of MatFormFieldControl.
           * \@docs-private
           */
          _this.stateChanges = new rxjs.Subject();
          /**
           * Implemented as part of MatFormFieldControl.
           * \@docs-private
           */
          _this.controlType = 'mat-input';
          /**
           * Implemented as part of MatFormFieldControl.
           * \@docs-private
           */
          _this.autofilled = false;
          _this._disabled = false;
          _this._required = false;
          _this._type = 'text';
          _this._readonly = false;
          _this._neverEmptyInputTypes = [
              'date',
              'datetime',
              'datetime-local',
              'month',
              'time',
              'week'
          ].filter(function (t) { return getSupportedInputTypes().has(t); });
          /** @type {?} */
          var element = _this._elementRef.nativeElement;
          // If no input value accessor was explicitly specified, use the element as the input value
          // accessor.
          _this._inputValueAccessor = inputValueAccessor || element;
          _this._previousNativeValue = _this.value;
          // Force setter to be called in case id was not specified.
          _this.id = _this.id;
          // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete
          // key. In order to get around this we need to "jiggle" the caret loose. Since this bug only
          // exists on iOS, we only bother to install the listener on iOS.
          if (_platform.IOS) {
              ngZone.runOutsideAngular(function () {
                  _elementRef.nativeElement.addEventListener('keyup', function (event) {
                      /** @type {?} */
                      var el = ( /** @type {?} */(event.target));
                      if (!el.value && !el.selectionStart && !el.selectionEnd) {
                          // Note: Just setting `0, 0` doesn't fix the issue. Setting
                          // `1, 1` fixes it for the first time that you type text and
                          // then hold delete. Toggling to `1, 1` and then back to
                          // `0, 0` seems to completely fix it.
                          el.setSelectionRange(1, 1);
                          el.setSelectionRange(0, 0);
                      }
                  });
              });
          }
          _this._isServer = !_this._platform.isBrowser;
          _this._isNativeSelect = element.nodeName.toLowerCase() === 'select';
          if (_this._isNativeSelect) {
              _this.controlType = (( /** @type {?} */(element))).multiple ? 'mat-native-select-multiple' :
                  'mat-native-select';
          }
          return _this;
      }
      Object.defineProperty(MatInput.prototype, "disabled", {
          /**
           * Implemented as part of MatFormFieldControl.
           * @docs-private
           */
          get: /**
           * Implemented as part of MatFormFieldControl.
           * \@docs-private
           * @return {?}
           */ function () {
              if (this.ngControl && this.ngControl.disabled !== null) {
                  return this.ngControl.disabled;
              }
              return this._disabled;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._disabled = coerceBooleanProperty(value);
              // Browsers may not fire the blur event if the input is disabled too quickly.
              // Reset from here to ensure that the element doesn't become stuck.
              if (this.focused) {
                  this.focused = false;
                  this.stateChanges.next();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatInput.prototype, "id", {
          /**
           * Implemented as part of MatFormFieldControl.
           * @docs-private
           */
          get: /**
           * Implemented as part of MatFormFieldControl.
           * \@docs-private
           * @return {?}
           */ function () { return this._id; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._id = value || this._uid; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatInput.prototype, "required", {
          /**
           * Implemented as part of MatFormFieldControl.
           * @docs-private
           */
          get: /**
           * Implemented as part of MatFormFieldControl.
           * \@docs-private
           * @return {?}
           */ function () { return this._required; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._required = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatInput.prototype, "type", {
          /** Input type of the element. */
          get: /**
           * Input type of the element.
           * @return {?}
           */ function () { return this._type; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._type = value || 'text';
              this._validateType();
              // When using Angular inputs, developers are no longer able to set the properties on the native
              // input element. To ensure that bindings for `type` work, we need to sync the setter
              // with the native property. Textarea elements don't support the type property or attribute.
              if (!this._isTextarea() && getSupportedInputTypes().has(this._type)) {
                  (( /** @type {?} */(this._elementRef.nativeElement))).type = this._type;
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatInput.prototype, "value", {
          /**
           * Implemented as part of MatFormFieldControl.
           * @docs-private
           */
          get: /**
           * Implemented as part of MatFormFieldControl.
           * \@docs-private
           * @return {?}
           */ function () { return this._inputValueAccessor.value; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (value !== this.value) {
                  this._inputValueAccessor.value = value;
                  this.stateChanges.next();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatInput.prototype, "readonly", {
          /** Whether the element is readonly. */
          get: /**
           * Whether the element is readonly.
           * @return {?}
           */ function () { return this._readonly; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._readonly = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatInput.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._platform.isBrowser) {
                  this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(function (event) {
                      _this.autofilled = event.isAutofilled;
                      _this.stateChanges.next();
                  });
              }
          };
      /**
       * @return {?}
       */
      MatInput.prototype.ngOnChanges = /**
       * @return {?}
       */
          function () {
              this.stateChanges.next();
          };
      /**
       * @return {?}
       */
      MatInput.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this.stateChanges.complete();
              if (this._platform.isBrowser) {
                  this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);
              }
          };
      /**
       * @return {?}
       */
      MatInput.prototype.ngDoCheck = /**
       * @return {?}
       */
          function () {
              if (this.ngControl) {
                  // We need to re-evaluate this on every change detection cycle, because there are some
                  // error triggers that we can't subscribe to (e.g. parent form submissions). This means
                  // that whatever logic is in here has to be super lean or we risk destroying the performance.
                  this.updateErrorState();
              }
              // We need to dirty-check the native element's value, because there are some cases where
              // we won't be notified when it changes (e.g. the consumer isn't using forms or they're
              // updating the value using `emitEvent: false`).
              this._dirtyCheckNativeValue();
          };
      /** Focuses the input. */
      /**
       * Focuses the input.
       * @return {?}
       */
      MatInput.prototype.focus = /**
       * Focuses the input.
       * @return {?}
       */
          function () {
              this._elementRef.nativeElement.focus();
          };
      /** Callback for the cases where the focused state of the input changes. */
      /**
       * Callback for the cases where the focused state of the input changes.
       * @param {?} isFocused
       * @return {?}
       */
      MatInput.prototype._focusChanged = /**
       * Callback for the cases where the focused state of the input changes.
       * @param {?} isFocused
       * @return {?}
       */
          function (isFocused) {
              if (isFocused !== this.focused && (!this.readonly || !isFocused)) {
                  this.focused = isFocused;
                  this.stateChanges.next();
              }
          };
      /**
       * @return {?}
       */
      MatInput.prototype._onInput = /**
       * @return {?}
       */
          function () {
              // This is a noop function and is used to let Angular know whenever the value changes.
              // Angular will run a new change detection each time the `input` event has been dispatched.
              // It's necessary that Angular recognizes the value change, because when floatingLabel
              // is set to false and Angular forms aren't used, the placeholder won't recognize the
              // value changes and will not disappear.
              // Listening to the input event wouldn't be necessary when the input is using the
              // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.
          };
      /** Does some manual dirty checking on the native input `value` property. */
      /**
       * Does some manual dirty checking on the native input `value` property.
       * @protected
       * @return {?}
       */
      MatInput.prototype._dirtyCheckNativeValue = /**
       * Does some manual dirty checking on the native input `value` property.
       * @protected
       * @return {?}
       */
          function () {
              /** @type {?} */
              var newValue = this._elementRef.nativeElement.value;
              if (this._previousNativeValue !== newValue) {
                  this._previousNativeValue = newValue;
                  this.stateChanges.next();
              }
          };
      /** Make sure the input is a supported type. */
      /**
       * Make sure the input is a supported type.
       * @protected
       * @return {?}
       */
      MatInput.prototype._validateType = /**
       * Make sure the input is a supported type.
       * @protected
       * @return {?}
       */
          function () {
              if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {
                  throw getMatInputUnsupportedTypeError(this._type);
              }
          };
      /** Checks whether the input type is one of the types that are never empty. */
      /**
       * Checks whether the input type is one of the types that are never empty.
       * @protected
       * @return {?}
       */
      MatInput.prototype._isNeverEmpty = /**
       * Checks whether the input type is one of the types that are never empty.
       * @protected
       * @return {?}
       */
          function () {
              return this._neverEmptyInputTypes.indexOf(this._type) > -1;
          };
      /** Checks whether the input is invalid based on the native validation. */
      /**
       * Checks whether the input is invalid based on the native validation.
       * @protected
       * @return {?}
       */
      MatInput.prototype._isBadInput = /**
       * Checks whether the input is invalid based on the native validation.
       * @protected
       * @return {?}
       */
          function () {
              // The `validity` property won't be present on platform-server.
              /** @type {?} */
              var validity = (( /** @type {?} */(this._elementRef.nativeElement))).validity;
              return validity && validity.badInput;
          };
      /** Determines if the component host is a textarea. */
      /**
       * Determines if the component host is a textarea.
       * @protected
       * @return {?}
       */
      MatInput.prototype._isTextarea = /**
       * Determines if the component host is a textarea.
       * @protected
       * @return {?}
       */
          function () {
              return this._elementRef.nativeElement.nodeName.toLowerCase() === 'textarea';
          };
      Object.defineProperty(MatInput.prototype, "empty", {
          /**
           * Implemented as part of MatFormFieldControl.
           * @docs-private
           */
          get: /**
           * Implemented as part of MatFormFieldControl.
           * \@docs-private
           * @return {?}
           */ function () {
              return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() &&
                  !this.autofilled;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatInput.prototype, "shouldLabelFloat", {
          /**
           * Implemented as part of MatFormFieldControl.
           * @docs-private
           */
          get: /**
           * Implemented as part of MatFormFieldControl.
           * \@docs-private
           * @return {?}
           */ function () {
              if (this._isNativeSelect) {
                  // For a single-selection `<select>`, the label should float when the selected option has
                  // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid
                  // overlapping the label with the options.
                  /** @type {?} */
                  var selectElement = ( /** @type {?} */(this._elementRef.nativeElement));
                  /** @type {?} */
                  var firstOption = selectElement.options[0];
                  // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be
                  // -1 if the `value` is set to something, that isn't in the list of options, at a later point.
                  return this.focused || selectElement.multiple || !this.empty ||
                      !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);
              }
              else {
                  return this.focused || !this.empty;
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Implemented as part of MatFormFieldControl.
       * @docs-private
       */
      /**
       * Implemented as part of MatFormFieldControl.
       * \@docs-private
       * @param {?} ids
       * @return {?}
       */
      MatInput.prototype.setDescribedByIds = /**
       * Implemented as part of MatFormFieldControl.
       * \@docs-private
       * @param {?} ids
       * @return {?}
       */
          function (ids) {
              this._ariaDescribedby = ids.join(' ');
          };
      /**
       * Implemented as part of MatFormFieldControl.
       * @docs-private
       */
      /**
       * Implemented as part of MatFormFieldControl.
       * \@docs-private
       * @return {?}
       */
      MatInput.prototype.onContainerClick = /**
       * Implemented as part of MatFormFieldControl.
       * \@docs-private
       * @return {?}
       */
          function () {
              // Do not re-focus the input element if the element is already focused. Otherwise it can happen
              // that someone clicks on a time input and the cursor resets to the "hours" field while the
              // "minutes" field was actually clicked. See: https://github.com/angular/material2/issues/12849
              if (!this.focused) {
                  this.focus();
              }
          };
      MatInput.decorators = [
          { type: core.Directive, args: [{
                      selector: "input[matInput], textarea[matInput], select[matNativeControl],\n      input[matNativeControl], textarea[matNativeControl]",
                      exportAs: 'matInput',
                      host: {
                          /**
                           * \@breaking-change 8.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.
                           */
                          'class': 'mat-input-element mat-form-field-autofill-control',
                          '[class.mat-input-server]': '_isServer',
                          // Native input properties that are overwritten by Angular inputs need to be synced with
                          // the native input element. Otherwise property bindings for those don't work.
                          '[attr.id]': 'id',
                          '[attr.placeholder]': 'placeholder',
                          '[disabled]': 'disabled',
                          '[required]': 'required',
                          '[attr.readonly]': 'readonly && !_isNativeSelect || null',
                          '[attr.aria-describedby]': '_ariaDescribedby || null',
                          '[attr.aria-invalid]': 'errorState',
                          '[attr.aria-required]': 'required.toString()',
                          '(blur)': '_focusChanged(false)',
                          '(focus)': '_focusChanged(true)',
                          '(input)': '_onInput()',
                      },
                      providers: [{ provide: MatFormFieldControl, useExisting: MatInput }],
                  },] },
      ];
      /** @nocollapse */
      MatInput.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: Platform },
              { type: forms.NgControl, decorators: [{ type: core.Optional }, { type: core.Self }] },
              { type: forms.NgForm, decorators: [{ type: core.Optional }] },
              { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] },
              { type: ErrorStateMatcher },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Self }, { type: core.Inject, args: [MAT_INPUT_VALUE_ACCESSOR,] }] },
              { type: AutofillMonitor },
              { type: core.NgZone }
          ];
      };
      MatInput.propDecorators = {
          disabled: [{ type: core.Input }],
          id: [{ type: core.Input }],
          placeholder: [{ type: core.Input }],
          required: [{ type: core.Input }],
          type: [{ type: core.Input }],
          errorStateMatcher: [{ type: core.Input }],
          value: [{ type: core.Input }],
          readonly: [{ type: core.Input }]
      };
      return MatInput;
  }(_MatInputMixinBase));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@docs-private
   * @param {?} provider
   * @return {?}
   */
  function createMissingDateImplError(provider) {
      return Error("MatDatepicker: No provider found for " + provider + ". You must import one of the following " +
          "modules at your application root: MatNativeDateModule, MatMomentDateModule, or provide a " +
          "custom implementation.");
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Datepicker data that requires internationalization.
   */
  var MatDatepickerIntl = /** @class */ (function () {
      function MatDatepickerIntl() {
          /**
           * Stream that emits whenever the labels here are changed. Use this to notify
           * components if the labels have changed after initialization.
           */
          this.changes = new rxjs.Subject();
          /**
           * A label for the calendar popup (used by screen readers).
           */
          this.calendarLabel = 'Calendar';
          /**
           * A label for the button used to open the calendar popup (used by screen readers).
           */
          this.openCalendarLabel = 'Open calendar';
          /**
           * A label for the previous month button (used by screen readers).
           */
          this.prevMonthLabel = 'Previous month';
          /**
           * A label for the next month button (used by screen readers).
           */
          this.nextMonthLabel = 'Next month';
          /**
           * A label for the previous year button (used by screen readers).
           */
          this.prevYearLabel = 'Previous year';
          /**
           * A label for the next year button (used by screen readers).
           */
          this.nextYearLabel = 'Next year';
          /**
           * A label for the previous multi-year button (used by screen readers).
           */
          this.prevMultiYearLabel = 'Previous 20 years';
          /**
           * A label for the next multi-year button (used by screen readers).
           */
          this.nextMultiYearLabel = 'Next 20 years';
          /**
           * A label for the 'switch to month view' button (used by screen readers).
           */
          this.switchToMonthViewLabel = 'Choose date';
          /**
           * A label for the 'switch to year view' button (used by screen readers).
           */
          this.switchToMultiYearViewLabel = 'Choose month and year';
      }
      MatDatepickerIntl.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */ MatDatepickerIntl.ngInjectableDef = core.defineInjectable({ factory: function MatDatepickerIntl_Factory() { return new MatDatepickerIntl(); }, token: MatDatepickerIntl, providedIn: "root" });
      return MatDatepickerIntl;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * An internal class that represents the data corresponding to a single calendar cell.
   * \@docs-private
   */
  var /**
   * An internal class that represents the data corresponding to a single calendar cell.
   * \@docs-private
   */ MatCalendarCell = /** @class */ (function () {
      function MatCalendarCell(value, displayValue, ariaLabel, enabled, cssClasses) {
          this.value = value;
          this.displayValue = displayValue;
          this.ariaLabel = ariaLabel;
          this.enabled = enabled;
          this.cssClasses = cssClasses;
      }
      return MatCalendarCell;
  }());
  /**
   * An internal component used to display calendar data in a table.
   * \@docs-private
   */
  var MatCalendarBody = /** @class */ (function () {
      function MatCalendarBody(_elementRef, _ngZone) {
          this._elementRef = _elementRef;
          this._ngZone = _ngZone;
          /**
           * The number of columns in the table.
           */
          this.numCols = 7;
          /**
           * The cell number of the active cell in the table.
           */
          this.activeCell = 0;
          /**
           * The aspect ratio (width / height) to use for the cells in the table. This aspect ratio will be
           * maintained even as the table resizes.
           */
          this.cellAspectRatio = 1;
          /**
           * Emits when a new value is selected.
           */
          this.selectedValueChange = new core.EventEmitter();
      }
      /**
       * @param {?} cell
       * @return {?}
       */
      MatCalendarBody.prototype._cellClicked = /**
       * @param {?} cell
       * @return {?}
       */
          function (cell) {
              if (cell.enabled) {
                  this.selectedValueChange.emit(cell.value);
              }
          };
      /**
       * @param {?} changes
       * @return {?}
       */
      MatCalendarBody.prototype.ngOnChanges = /**
       * @param {?} changes
       * @return {?}
       */
          function (changes) {
              /** @type {?} */
              var columnChanges = changes.numCols;
              var _a = this, rows = _a.rows, numCols = _a.numCols;
              if (changes.rows || columnChanges) {
                  this._firstRowOffset = rows && rows.length && rows[0].length ? numCols - rows[0].length : 0;
              }
              if (changes.cellAspectRatio || columnChanges || !this._cellPadding) {
                  this._cellPadding = 50 * this.cellAspectRatio / numCols + "%";
              }
              if (columnChanges || !this._cellWidth) {
                  this._cellWidth = 100 / numCols + "%";
              }
          };
      /**
       * @param {?} rowIndex
       * @param {?} colIndex
       * @return {?}
       */
      MatCalendarBody.prototype._isActiveCell = /**
       * @param {?} rowIndex
       * @param {?} colIndex
       * @return {?}
       */
          function (rowIndex, colIndex) {
              /** @type {?} */
              var cellNumber = rowIndex * this.numCols + colIndex;
              // Account for the fact that the first row may not have as many cells.
              if (rowIndex) {
                  cellNumber -= this._firstRowOffset;
              }
              return cellNumber == this.activeCell;
          };
      /** Focuses the active cell after the microtask queue is empty. */
      /**
       * Focuses the active cell after the microtask queue is empty.
       * @return {?}
       */
      MatCalendarBody.prototype._focusActiveCell = /**
       * Focuses the active cell after the microtask queue is empty.
       * @return {?}
       */
          function () {
              var _this = this;
              this._ngZone.runOutsideAngular(function () {
                  _this._ngZone.onStable.asObservable().pipe(operators.take(1)).subscribe(function () {
                      /** @type {?} */
                      var activeCell = _this._elementRef.nativeElement.querySelector('.mat-calendar-body-active');
                      if (activeCell) {
                          activeCell.focus();
                      }
                  });
              });
          };
      MatCalendarBody.decorators = [
          { type: core.Component, args: [{ selector: '[mat-calendar-body]',
                      template: "<tr *ngIf=\"_firstRowOffset < labelMinRequiredCells\" aria-hidden=\"true\"><td class=\"mat-calendar-body-label\" [attr.colspan]=\"numCols\" [style.paddingTop]=\"_cellPadding\" [style.paddingBottom]=\"_cellPadding\">{{label}}</td></tr><tr *ngFor=\"let row of rows; let rowIndex = index\" role=\"row\"><td *ngIf=\"rowIndex === 0 && _firstRowOffset\" aria-hidden=\"true\" class=\"mat-calendar-body-label\" [attr.colspan]=\"_firstRowOffset\" [style.paddingTop]=\"_cellPadding\" [style.paddingBottom]=\"_cellPadding\">{{_firstRowOffset >= labelMinRequiredCells ? label : ''}}</td><td *ngFor=\"let item of row; let colIndex = index\" role=\"gridcell\" class=\"mat-calendar-body-cell\" [ngClass]=\"item.cssClasses\" [tabindex]=\"_isActiveCell(rowIndex, colIndex) ? 0 : -1\" [class.mat-calendar-body-disabled]=\"!item.enabled\" [class.mat-calendar-body-active]=\"_isActiveCell(rowIndex, colIndex)\" [attr.aria-label]=\"item.ariaLabel\" [attr.aria-disabled]=\"!item.enabled || null\" [attr.aria-selected]=\"selectedValue === item.value\" (click)=\"_cellClicked(item)\" [style.width]=\"_cellWidth\" [style.paddingTop]=\"_cellPadding\" [style.paddingBottom]=\"_cellPadding\"><div class=\"mat-calendar-body-cell-content\" [class.mat-calendar-body-selected]=\"selectedValue === item.value\" [class.mat-calendar-body-today]=\"todayValue === item.value\">{{item.displayValue}}</div></td></tr>",
                      styles: [".mat-calendar-body{min-width:224px}.mat-calendar-body-label{height:0;line-height:0;text-align:left;padding-left:4.71429%;padding-right:4.71429%}.mat-calendar-body-cell{position:relative;height:0;line-height:0;text-align:center;outline:0;cursor:pointer}.mat-calendar-body-disabled{cursor:default}.mat-calendar-body-cell-content{position:absolute;top:5%;left:5%;display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:90%;height:90%;line-height:1;border-width:1px;border-style:solid;border-radius:999px}@media (-ms-high-contrast:active){.mat-calendar-body-cell-content{border:none}}@media (-ms-high-contrast:active){.mat-calendar-body-selected,.mat-datepicker-popup:not(:empty){outline:solid 1px}.mat-calendar-body-today{outline:dotted 1px}}[dir=rtl] .mat-calendar-body-label{text-align:right}"],
                      host: {
                          'class': 'mat-calendar-body',
                          'role': 'grid',
                          'aria-readonly': 'true'
                      },
                      exportAs: 'matCalendarBody',
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatCalendarBody.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.NgZone }
          ];
      };
      MatCalendarBody.propDecorators = {
          label: [{ type: core.Input }],
          rows: [{ type: core.Input }],
          todayValue: [{ type: core.Input }],
          selectedValue: [{ type: core.Input }],
          labelMinRequiredCells: [{ type: core.Input }],
          numCols: [{ type: core.Input }],
          activeCell: [{ type: core.Input }],
          cellAspectRatio: [{ type: core.Input }],
          selectedValueChange: [{ type: core.Output }]
      };
      return MatCalendarBody;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var DAYS_PER_WEEK = 7;
  /**
   * An internal component used to display a single month in the datepicker.
   * \@docs-private
   * @template D
   */
  var MatMonthView = /** @class */ (function () {
      function MatMonthView(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {
          this._changeDetectorRef = _changeDetectorRef;
          this._dateFormats = _dateFormats;
          this._dateAdapter = _dateAdapter;
          this._dir = _dir;
          /**
           * Emits when a new date is selected.
           */
          this.selectedChange = new core.EventEmitter();
          /**
           * Emits when any date is selected.
           */
          this._userSelection = new core.EventEmitter();
          /**
           * Emits when any date is activated.
           */
          this.activeDateChange = new core.EventEmitter();
          if (!this._dateAdapter) {
              throw createMissingDateImplError('DateAdapter');
          }
          if (!this._dateFormats) {
              throw createMissingDateImplError('MAT_DATE_FORMATS');
          }
          /** @type {?} */
          var firstDayOfWeek = this._dateAdapter.getFirstDayOfWeek();
          /** @type {?} */
          var narrowWeekdays = this._dateAdapter.getDayOfWeekNames('narrow');
          /** @type {?} */
          var longWeekdays = this._dateAdapter.getDayOfWeekNames('long');
          // Rotate the labels for days of the week based on the configured first day of the week.
          /** @type {?} */
          var weekdays = longWeekdays.map(function (long, i) {
              return { long: long, narrow: narrowWeekdays[i] };
          });
          this._weekdays = weekdays.slice(firstDayOfWeek).concat(weekdays.slice(0, firstDayOfWeek));
          this._activeDate = this._dateAdapter.today();
      }
      Object.defineProperty(MatMonthView.prototype, "activeDate", {
          /**
           * The date to display in this month view (everything other than the month and year is ignored).
           */
          get: /**
           * The date to display in this month view (everything other than the month and year is ignored).
           * @return {?}
           */ function () { return this._activeDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var oldActiveDate = this._activeDate;
              /** @type {?} */
              var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();
              this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);
              if (!this._hasSameMonthAndYear(oldActiveDate, this._activeDate)) {
                  this._init();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatMonthView.prototype, "selected", {
          /** The currently selected date. */
          get: /**
           * The currently selected date.
           * @return {?}
           */ function () { return this._selected; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
              this._selectedDate = this._getDateInCurrentMonth(this._selected);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatMonthView.prototype, "minDate", {
          /** The minimum selectable date. */
          get: /**
           * The minimum selectable date.
           * @return {?}
           */ function () { return this._minDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatMonthView.prototype, "maxDate", {
          /** The maximum selectable date. */
          get: /**
           * The maximum selectable date.
           * @return {?}
           */ function () { return this._maxDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatMonthView.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this._init();
          };
      /** Handles when a new date is selected. */
      /**
       * Handles when a new date is selected.
       * @param {?} date
       * @return {?}
       */
      MatMonthView.prototype._dateSelected = /**
       * Handles when a new date is selected.
       * @param {?} date
       * @return {?}
       */
          function (date) {
              if (this._selectedDate != date) {
                  /** @type {?} */
                  var selectedYear = this._dateAdapter.getYear(this.activeDate);
                  /** @type {?} */
                  var selectedMonth = this._dateAdapter.getMonth(this.activeDate);
                  /** @type {?} */
                  var selectedDate = this._dateAdapter.createDate(selectedYear, selectedMonth, date);
                  this.selectedChange.emit(selectedDate);
              }
              this._userSelection.emit();
          };
      /** Handles keydown events on the calendar body when calendar is in month view. */
      /**
       * Handles keydown events on the calendar body when calendar is in month view.
       * @param {?} event
       * @return {?}
       */
      MatMonthView.prototype._handleCalendarBodyKeydown = /**
       * Handles keydown events on the calendar body when calendar is in month view.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
              // disabled ones from being selected. This may not be ideal, we should look into whether
              // navigation should skip over disabled dates, and if so, how to implement that efficiently.
              // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
              // disabled ones from being selected. This may not be ideal, we should look into whether
              // navigation should skip over disabled dates, and if so, how to implement that efficiently.
              /** @type {?} */
              var oldActiveDate = this._activeDate;
              /** @type {?} */
              var isRtl = this._isRtl();
              switch (event.keyCode) {
                  case LEFT_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? 1 : -1);
                      break;
                  case RIGHT_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? -1 : 1);
                      break;
                  case UP_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, -7);
                      break;
                  case DOWN_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 7);
                      break;
                  case HOME:
                      this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 1 - this._dateAdapter.getDate(this._activeDate));
                      break;
                  case END:
                      this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, (this._dateAdapter.getNumDaysInMonth(this._activeDate) -
                          this._dateAdapter.getDate(this._activeDate)));
                      break;
                  case PAGE_UP:
                      this.activeDate = event.altKey ?
                          this._dateAdapter.addCalendarYears(this._activeDate, -1) :
                          this._dateAdapter.addCalendarMonths(this._activeDate, -1);
                      break;
                  case PAGE_DOWN:
                      this.activeDate = event.altKey ?
                          this._dateAdapter.addCalendarYears(this._activeDate, 1) :
                          this._dateAdapter.addCalendarMonths(this._activeDate, 1);
                      break;
                  case ENTER:
                  case SPACE:
                      if (!this.dateFilter || this.dateFilter(this._activeDate)) {
                          this._dateSelected(this._dateAdapter.getDate(this._activeDate));
                          this._userSelection.emit();
                          // Prevent unexpected default actions such as form submission.
                          event.preventDefault();
                      }
                      return;
                  default:
                      // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                      return;
              }
              if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
                  this.activeDateChange.emit(this.activeDate);
              }
              this._focusActiveCell();
              // Prevent unexpected default actions such as form submission.
              event.preventDefault();
          };
      /** Initializes this month view. */
      /**
       * Initializes this month view.
       * @return {?}
       */
      MatMonthView.prototype._init = /**
       * Initializes this month view.
       * @return {?}
       */
          function () {
              this._selectedDate = this._getDateInCurrentMonth(this.selected);
              this._todayDate = this._getDateInCurrentMonth(this._dateAdapter.today());
              this._monthLabel =
                  this._dateAdapter.getMonthNames('short')[this._dateAdapter.getMonth(this.activeDate)]
                      .toLocaleUpperCase();
              /** @type {?} */
              var firstOfMonth = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), 1);
              this._firstWeekOffset =
                  (DAYS_PER_WEEK + this._dateAdapter.getDayOfWeek(firstOfMonth) -
                      this._dateAdapter.getFirstDayOfWeek()) % DAYS_PER_WEEK;
              this._createWeekCells();
              this._changeDetectorRef.markForCheck();
          };
      /** Focuses the active cell after the microtask queue is empty. */
      /**
       * Focuses the active cell after the microtask queue is empty.
       * @return {?}
       */
      MatMonthView.prototype._focusActiveCell = /**
       * Focuses the active cell after the microtask queue is empty.
       * @return {?}
       */
          function () {
              this._matCalendarBody._focusActiveCell();
          };
      /** Creates MatCalendarCells for the dates in this month. */
      /**
       * Creates MatCalendarCells for the dates in this month.
       * @private
       * @return {?}
       */
      MatMonthView.prototype._createWeekCells = /**
       * Creates MatCalendarCells for the dates in this month.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var daysInMonth = this._dateAdapter.getNumDaysInMonth(this.activeDate);
              /** @type {?} */
              var dateNames = this._dateAdapter.getDateNames();
              this._weeks = [[]];
              for (var i = 0, cell = this._firstWeekOffset; i < daysInMonth; i++, cell++) {
                  if (cell == DAYS_PER_WEEK) {
                      this._weeks.push([]);
                      cell = 0;
                  }
                  /** @type {?} */
                  var date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), i + 1);
                  /** @type {?} */
                  var enabled = this._shouldEnableDate(date);
                  /** @type {?} */
                  var ariaLabel = this._dateAdapter.format(date, this._dateFormats.display.dateA11yLabel);
                  /** @type {?} */
                  var cellClasses = this.dateClass ? this.dateClass(date) : undefined;
                  this._weeks[this._weeks.length - 1]
                      .push(new MatCalendarCell(i + 1, dateNames[i], ariaLabel, enabled, cellClasses));
              }
          };
      /** Date filter for the month */
      /**
       * Date filter for the month
       * @private
       * @param {?} date
       * @return {?}
       */
      MatMonthView.prototype._shouldEnableDate = /**
       * Date filter for the month
       * @private
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return !!date &&
                  (!this.dateFilter || this.dateFilter(date)) &&
                  (!this.minDate || this._dateAdapter.compareDate(date, this.minDate) >= 0) &&
                  (!this.maxDate || this._dateAdapter.compareDate(date, this.maxDate) <= 0);
          };
      /**
       * Gets the date in this month that the given Date falls on.
       * Returns null if the given Date is in another month.
       */
      /**
       * Gets the date in this month that the given Date falls on.
       * Returns null if the given Date is in another month.
       * @private
       * @param {?} date
       * @return {?}
       */
      MatMonthView.prototype._getDateInCurrentMonth = /**
       * Gets the date in this month that the given Date falls on.
       * Returns null if the given Date is in another month.
       * @private
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date && this._hasSameMonthAndYear(date, this.activeDate) ?
                  this._dateAdapter.getDate(date) : null;
          };
      /** Checks whether the 2 dates are non-null and fall within the same month of the same year. */
      /**
       * Checks whether the 2 dates are non-null and fall within the same month of the same year.
       * @private
       * @param {?} d1
       * @param {?} d2
       * @return {?}
       */
      MatMonthView.prototype._hasSameMonthAndYear = /**
       * Checks whether the 2 dates are non-null and fall within the same month of the same year.
       * @private
       * @param {?} d1
       * @param {?} d2
       * @return {?}
       */
          function (d1, d2) {
              return !!(d1 && d2 && this._dateAdapter.getMonth(d1) == this._dateAdapter.getMonth(d2) &&
                  this._dateAdapter.getYear(d1) == this._dateAdapter.getYear(d2));
          };
      /**
       * @param obj The object to check.
       * @returns The given object if it is both a date instance and valid, otherwise null.
       */
      /**
       * @private
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
      MatMonthView.prototype._getValidDateOrNull = /**
       * @private
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
          function (obj) {
              return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
          };
      /** Determines whether the user has the RTL layout direction. */
      /**
       * Determines whether the user has the RTL layout direction.
       * @private
       * @return {?}
       */
      MatMonthView.prototype._isRtl = /**
       * Determines whether the user has the RTL layout direction.
       * @private
       * @return {?}
       */
          function () {
              return this._dir && this._dir.value === 'rtl';
          };
      MatMonthView.decorators = [
          { type: core.Component, args: [{ selector: 'mat-month-view',
                      template: "<table class=\"mat-calendar-table\"><thead class=\"mat-calendar-table-header\"><tr><th *ngFor=\"let day of _weekdays\" [attr.aria-label]=\"day.long\">{{day.narrow}}</th></tr><tr><th class=\"mat-calendar-table-header-divider\" colspan=\"7\" aria-hidden=\"true\"></th></tr></thead><tbody mat-calendar-body [label]=\"_monthLabel\" [rows]=\"_weeks\" [todayValue]=\"_todayDate\" [selectedValue]=\"_selectedDate\" [labelMinRequiredCells]=\"3\" [activeCell]=\"_dateAdapter.getDate(activeDate) - 1\" (selectedValueChange)=\"_dateSelected($event)\" (keydown)=\"_handleCalendarBodyKeydown($event)\"></tbody></table>",
                      exportAs: 'matMonthView',
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      /** @nocollapse */
      MatMonthView.ctorParameters = function () {
          return [
              { type: core.ChangeDetectorRef },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_DATE_FORMATS,] }] },
              { type: DateAdapter, decorators: [{ type: core.Optional }] },
              { type: Directionality, decorators: [{ type: core.Optional }] }
          ];
      };
      MatMonthView.propDecorators = {
          activeDate: [{ type: core.Input }],
          selected: [{ type: core.Input }],
          minDate: [{ type: core.Input }],
          maxDate: [{ type: core.Input }],
          dateFilter: [{ type: core.Input }],
          dateClass: [{ type: core.Input }],
          selectedChange: [{ type: core.Output }],
          _userSelection: [{ type: core.Output }],
          activeDateChange: [{ type: core.Output }],
          _matCalendarBody: [{ type: core.ViewChild, args: [MatCalendarBody,] }]
      };
      return MatMonthView;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var yearsPerPage = 24;
  /** @type {?} */
  var yearsPerRow = 4;
  /**
   * An internal component used to display a year selector in the datepicker.
   * \@docs-private
   * @template D
   */
  var MatMultiYearView = /** @class */ (function () {
      function MatMultiYearView(_changeDetectorRef, _dateAdapter, _dir) {
          this._changeDetectorRef = _changeDetectorRef;
          this._dateAdapter = _dateAdapter;
          this._dir = _dir;
          /**
           * Emits when a new year is selected.
           */
          this.selectedChange = new core.EventEmitter();
          /**
           * Emits the selected year. This doesn't imply a change on the selected date
           */
          this.yearSelected = new core.EventEmitter();
          /**
           * Emits when any date is activated.
           */
          this.activeDateChange = new core.EventEmitter();
          if (!this._dateAdapter) {
              throw createMissingDateImplError('DateAdapter');
          }
          this._activeDate = this._dateAdapter.today();
      }
      Object.defineProperty(MatMultiYearView.prototype, "activeDate", {
          /** The date to display in this multi-year view (everything other than the year is ignored). */
          get: /**
           * The date to display in this multi-year view (everything other than the year is ignored).
           * @return {?}
           */ function () { return this._activeDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var oldActiveDate = this._activeDate;
              /** @type {?} */
              var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();
              this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);
              if (Math.floor(this._dateAdapter.getYear(oldActiveDate) / yearsPerPage) !=
                  Math.floor(this._dateAdapter.getYear(this._activeDate) / yearsPerPage)) {
                  this._init();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatMultiYearView.prototype, "selected", {
          /** The currently selected date. */
          get: /**
           * The currently selected date.
           * @return {?}
           */ function () { return this._selected; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
              this._selectedYear = this._selected && this._dateAdapter.getYear(this._selected);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatMultiYearView.prototype, "minDate", {
          /** The minimum selectable date. */
          get: /**
           * The minimum selectable date.
           * @return {?}
           */ function () { return this._minDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatMultiYearView.prototype, "maxDate", {
          /** The maximum selectable date. */
          get: /**
           * The maximum selectable date.
           * @return {?}
           */ function () { return this._maxDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatMultiYearView.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this._init();
          };
      /** Initializes this multi-year view. */
      /**
       * Initializes this multi-year view.
       * @return {?}
       */
      MatMultiYearView.prototype._init = /**
       * Initializes this multi-year view.
       * @return {?}
       */
          function () {
              var _this = this;
              this._todayYear = this._dateAdapter.getYear(this._dateAdapter.today());
              /** @type {?} */
              var activeYear = this._dateAdapter.getYear(this._activeDate);
              /** @type {?} */
              var activeOffset = activeYear % yearsPerPage;
              this._years = [];
              for (var i = 0, row = []; i < yearsPerPage; i++) {
                  row.push(activeYear - activeOffset + i);
                  if (row.length == yearsPerRow) {
                      this._years.push(row.map(function (year) { return _this._createCellForYear(year); }));
                      row = [];
                  }
              }
              this._changeDetectorRef.markForCheck();
          };
      /** Handles when a new year is selected. */
      /**
       * Handles when a new year is selected.
       * @param {?} year
       * @return {?}
       */
      MatMultiYearView.prototype._yearSelected = /**
       * Handles when a new year is selected.
       * @param {?} year
       * @return {?}
       */
          function (year) {
              this.yearSelected.emit(this._dateAdapter.createDate(year, 0, 1));
              /** @type {?} */
              var month = this._dateAdapter.getMonth(this.activeDate);
              /** @type {?} */
              var daysInMonth = this._dateAdapter.getNumDaysInMonth(this._dateAdapter.createDate(year, month, 1));
              this.selectedChange.emit(this._dateAdapter.createDate(year, month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));
          };
      /** Handles keydown events on the calendar body when calendar is in multi-year view. */
      /**
       * Handles keydown events on the calendar body when calendar is in multi-year view.
       * @param {?} event
       * @return {?}
       */
      MatMultiYearView.prototype._handleCalendarBodyKeydown = /**
       * Handles keydown events on the calendar body when calendar is in multi-year view.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
              // disabled ones from being selected. This may not be ideal, we should look into whether
              // navigation should skip over disabled dates, and if so, how to implement that efficiently.
              // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
              // disabled ones from being selected. This may not be ideal, we should look into whether
              // navigation should skip over disabled dates, and if so, how to implement that efficiently.
              /** @type {?} */
              var oldActiveDate = this._activeDate;
              /** @type {?} */
              var isRtl = this._isRtl();
              switch (event.keyCode) {
                  case LEFT_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? 1 : -1);
                      break;
                  case RIGHT_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? -1 : 1);
                      break;
                  case UP_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -yearsPerRow);
                      break;
                  case DOWN_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerRow);
                      break;
                  case HOME:
                      this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -this._dateAdapter.getYear(this._activeDate) % yearsPerPage);
                      break;
                  case END:
                      this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerPage - this._dateAdapter.getYear(this._activeDate) % yearsPerPage - 1);
                      break;
                  case PAGE_UP:
                      this.activeDate =
                          this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -yearsPerPage * 10 : -yearsPerPage);
                      break;
                  case PAGE_DOWN:
                      this.activeDate =
                          this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? yearsPerPage * 10 : yearsPerPage);
                      break;
                  case ENTER:
                  case SPACE:
                      this._yearSelected(this._dateAdapter.getYear(this._activeDate));
                      break;
                  default:
                      // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                      return;
              }
              if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
                  this.activeDateChange.emit(this.activeDate);
              }
              this._focusActiveCell();
              // Prevent unexpected default actions such as form submission.
              event.preventDefault();
          };
      /**
       * @return {?}
       */
      MatMultiYearView.prototype._getActiveCell = /**
       * @return {?}
       */
          function () {
              return this._dateAdapter.getYear(this.activeDate) % yearsPerPage;
          };
      /** Focuses the active cell after the microtask queue is empty. */
      /**
       * Focuses the active cell after the microtask queue is empty.
       * @return {?}
       */
      MatMultiYearView.prototype._focusActiveCell = /**
       * Focuses the active cell after the microtask queue is empty.
       * @return {?}
       */
          function () {
              this._matCalendarBody._focusActiveCell();
          };
      /** Creates an MatCalendarCell for the given year. */
      /**
       * Creates an MatCalendarCell for the given year.
       * @private
       * @param {?} year
       * @return {?}
       */
      MatMultiYearView.prototype._createCellForYear = /**
       * Creates an MatCalendarCell for the given year.
       * @private
       * @param {?} year
       * @return {?}
       */
          function (year) {
              /** @type {?} */
              var yearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(year, 0, 1));
              return new MatCalendarCell(year, yearName, yearName, this._shouldEnableYear(year));
          };
      /** Whether the given year is enabled. */
      /**
       * Whether the given year is enabled.
       * @private
       * @param {?} year
       * @return {?}
       */
      MatMultiYearView.prototype._shouldEnableYear = /**
       * Whether the given year is enabled.
       * @private
       * @param {?} year
       * @return {?}
       */
          function (year) {
              // disable if the year is greater than maxDate lower than minDate
              if (year === undefined || year === null ||
                  (this.maxDate && year > this._dateAdapter.getYear(this.maxDate)) ||
                  (this.minDate && year < this._dateAdapter.getYear(this.minDate))) {
                  return false;
              }
              // enable if it reaches here and there's no filter defined
              if (!this.dateFilter) {
                  return true;
              }
              /** @type {?} */
              var firstOfYear = this._dateAdapter.createDate(year, 0, 1);
              // If any date in the year is enabled count the year as enabled.
              for (var date = firstOfYear; this._dateAdapter.getYear(date) == year; date = this._dateAdapter.addCalendarDays(date, 1)) {
                  if (this.dateFilter(date)) {
                      return true;
                  }
              }
              return false;
          };
      /**
       * @param obj The object to check.
       * @returns The given object if it is both a date instance and valid, otherwise null.
       */
      /**
       * @private
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
      MatMultiYearView.prototype._getValidDateOrNull = /**
       * @private
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
          function (obj) {
              return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
          };
      /** Determines whether the user has the RTL layout direction. */
      /**
       * Determines whether the user has the RTL layout direction.
       * @private
       * @return {?}
       */
      MatMultiYearView.prototype._isRtl = /**
       * Determines whether the user has the RTL layout direction.
       * @private
       * @return {?}
       */
          function () {
              return this._dir && this._dir.value === 'rtl';
          };
      MatMultiYearView.decorators = [
          { type: core.Component, args: [{ selector: 'mat-multi-year-view',
                      template: "<table class=\"mat-calendar-table\"><thead class=\"mat-calendar-table-header\"><tr><th class=\"mat-calendar-table-header-divider\" colspan=\"4\"></th></tr></thead><tbody mat-calendar-body [rows]=\"_years\" [todayValue]=\"_todayYear\" [selectedValue]=\"_selectedYear\" [numCols]=\"4\" [cellAspectRatio]=\"4 / 7\" [activeCell]=\"_getActiveCell()\" (selectedValueChange)=\"_yearSelected($event)\" (keydown)=\"_handleCalendarBodyKeydown($event)\"></tbody></table>",
                      exportAs: 'matMultiYearView',
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      /** @nocollapse */
      MatMultiYearView.ctorParameters = function () {
          return [
              { type: core.ChangeDetectorRef },
              { type: DateAdapter, decorators: [{ type: core.Optional }] },
              { type: Directionality, decorators: [{ type: core.Optional }] }
          ];
      };
      MatMultiYearView.propDecorators = {
          activeDate: [{ type: core.Input }],
          selected: [{ type: core.Input }],
          minDate: [{ type: core.Input }],
          maxDate: [{ type: core.Input }],
          dateFilter: [{ type: core.Input }],
          selectedChange: [{ type: core.Output }],
          yearSelected: [{ type: core.Output }],
          activeDateChange: [{ type: core.Output }],
          _matCalendarBody: [{ type: core.ViewChild, args: [MatCalendarBody,] }]
      };
      return MatMultiYearView;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * An internal component used to display a single year in the datepicker.
   * \@docs-private
   * @template D
   */
  var MatYearView = /** @class */ (function () {
      function MatYearView(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {
          this._changeDetectorRef = _changeDetectorRef;
          this._dateFormats = _dateFormats;
          this._dateAdapter = _dateAdapter;
          this._dir = _dir;
          /**
           * Emits when a new month is selected.
           */
          this.selectedChange = new core.EventEmitter();
          /**
           * Emits the selected month. This doesn't imply a change on the selected date
           */
          this.monthSelected = new core.EventEmitter();
          /**
           * Emits when any date is activated.
           */
          this.activeDateChange = new core.EventEmitter();
          if (!this._dateAdapter) {
              throw createMissingDateImplError('DateAdapter');
          }
          if (!this._dateFormats) {
              throw createMissingDateImplError('MAT_DATE_FORMATS');
          }
          this._activeDate = this._dateAdapter.today();
      }
      Object.defineProperty(MatYearView.prototype, "activeDate", {
          /** The date to display in this year view (everything other than the year is ignored). */
          get: /**
           * The date to display in this year view (everything other than the year is ignored).
           * @return {?}
           */ function () { return this._activeDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var oldActiveDate = this._activeDate;
              /** @type {?} */
              var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();
              this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);
              if (this._dateAdapter.getYear(oldActiveDate) !== this._dateAdapter.getYear(this._activeDate)) {
                  this._init();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatYearView.prototype, "selected", {
          /** The currently selected date. */
          get: /**
           * The currently selected date.
           * @return {?}
           */ function () { return this._selected; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
              this._selectedMonth = this._getMonthInCurrentYear(this._selected);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatYearView.prototype, "minDate", {
          /** The minimum selectable date. */
          get: /**
           * The minimum selectable date.
           * @return {?}
           */ function () { return this._minDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatYearView.prototype, "maxDate", {
          /** The maximum selectable date. */
          get: /**
           * The maximum selectable date.
           * @return {?}
           */ function () { return this._maxDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatYearView.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this._init();
          };
      /** Handles when a new month is selected. */
      /**
       * Handles when a new month is selected.
       * @param {?} month
       * @return {?}
       */
      MatYearView.prototype._monthSelected = /**
       * Handles when a new month is selected.
       * @param {?} month
       * @return {?}
       */
          function (month) {
              /** @type {?} */
              var normalizedDate = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1);
              this.monthSelected.emit(normalizedDate);
              /** @type {?} */
              var daysInMonth = this._dateAdapter.getNumDaysInMonth(normalizedDate);
              this.selectedChange.emit(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));
          };
      /** Handles keydown events on the calendar body when calendar is in year view. */
      /**
       * Handles keydown events on the calendar body when calendar is in year view.
       * @param {?} event
       * @return {?}
       */
      MatYearView.prototype._handleCalendarBodyKeydown = /**
       * Handles keydown events on the calendar body when calendar is in year view.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
              // disabled ones from being selected. This may not be ideal, we should look into whether
              // navigation should skip over disabled dates, and if so, how to implement that efficiently.
              // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
              // disabled ones from being selected. This may not be ideal, we should look into whether
              // navigation should skip over disabled dates, and if so, how to implement that efficiently.
              /** @type {?} */
              var oldActiveDate = this._activeDate;
              /** @type {?} */
              var isRtl = this._isRtl();
              switch (event.keyCode) {
                  case LEFT_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? 1 : -1);
                      break;
                  case RIGHT_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? -1 : 1);
                      break;
                  case UP_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -4);
                      break;
                  case DOWN_ARROW:
                      this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 4);
                      break;
                  case HOME:
                      this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -this._dateAdapter.getMonth(this._activeDate));
                      break;
                  case END:
                      this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 11 - this._dateAdapter.getMonth(this._activeDate));
                      break;
                  case PAGE_UP:
                      this.activeDate =
                          this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -10 : -1);
                      break;
                  case PAGE_DOWN:
                      this.activeDate =
                          this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? 10 : 1);
                      break;
                  case ENTER:
                  case SPACE:
                      this._monthSelected(this._dateAdapter.getMonth(this._activeDate));
                      break;
                  default:
                      // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                      return;
              }
              if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
                  this.activeDateChange.emit(this.activeDate);
              }
              this._focusActiveCell();
              // Prevent unexpected default actions such as form submission.
              event.preventDefault();
          };
      /** Initializes this year view. */
      /**
       * Initializes this year view.
       * @return {?}
       */
      MatYearView.prototype._init = /**
       * Initializes this year view.
       * @return {?}
       */
          function () {
              var _this = this;
              this._selectedMonth = this._getMonthInCurrentYear(this.selected);
              this._todayMonth = this._getMonthInCurrentYear(this._dateAdapter.today());
              this._yearLabel = this._dateAdapter.getYearName(this.activeDate);
              /** @type {?} */
              var monthNames = this._dateAdapter.getMonthNames('short');
              // First row of months only contains 5 elements so we can fit the year label on the same row.
              this._months = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]].map(function (row) { return row.map(function (month) { return _this._createCellForMonth(month, monthNames[month]); }); });
              this._changeDetectorRef.markForCheck();
          };
      /** Focuses the active cell after the microtask queue is empty. */
      /**
       * Focuses the active cell after the microtask queue is empty.
       * @return {?}
       */
      MatYearView.prototype._focusActiveCell = /**
       * Focuses the active cell after the microtask queue is empty.
       * @return {?}
       */
          function () {
              this._matCalendarBody._focusActiveCell();
          };
      /**
       * Gets the month in this year that the given Date falls on.
       * Returns null if the given Date is in another year.
       */
      /**
       * Gets the month in this year that the given Date falls on.
       * Returns null if the given Date is in another year.
       * @private
       * @param {?} date
       * @return {?}
       */
      MatYearView.prototype._getMonthInCurrentYear = /**
       * Gets the month in this year that the given Date falls on.
       * Returns null if the given Date is in another year.
       * @private
       * @param {?} date
       * @return {?}
       */
          function (date) {
              return date && this._dateAdapter.getYear(date) == this._dateAdapter.getYear(this.activeDate) ?
                  this._dateAdapter.getMonth(date) : null;
          };
      /** Creates an MatCalendarCell for the given month. */
      /**
       * Creates an MatCalendarCell for the given month.
       * @private
       * @param {?} month
       * @param {?} monthName
       * @return {?}
       */
      MatYearView.prototype._createCellForMonth = /**
       * Creates an MatCalendarCell for the given month.
       * @private
       * @param {?} month
       * @param {?} monthName
       * @return {?}
       */
          function (month, monthName) {
              /** @type {?} */
              var ariaLabel = this._dateAdapter.format(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1), this._dateFormats.display.monthYearA11yLabel);
              return new MatCalendarCell(month, monthName.toLocaleUpperCase(), ariaLabel, this._shouldEnableMonth(month));
          };
      /** Whether the given month is enabled. */
      /**
       * Whether the given month is enabled.
       * @private
       * @param {?} month
       * @return {?}
       */
      MatYearView.prototype._shouldEnableMonth = /**
       * Whether the given month is enabled.
       * @private
       * @param {?} month
       * @return {?}
       */
          function (month) {
              /** @type {?} */
              var activeYear = this._dateAdapter.getYear(this.activeDate);
              if (month === undefined || month === null ||
                  this._isYearAndMonthAfterMaxDate(activeYear, month) ||
                  this._isYearAndMonthBeforeMinDate(activeYear, month)) {
                  return false;
              }
              if (!this.dateFilter) {
                  return true;
              }
              /** @type {?} */
              var firstOfMonth = this._dateAdapter.createDate(activeYear, month, 1);
              // If any date in the month is enabled count the month as enabled.
              for (var date = firstOfMonth; this._dateAdapter.getMonth(date) == month; date = this._dateAdapter.addCalendarDays(date, 1)) {
                  if (this.dateFilter(date)) {
                      return true;
                  }
              }
              return false;
          };
      /**
       * Tests whether the combination month/year is after this.maxDate, considering
       * just the month and year of this.maxDate
       */
      /**
       * Tests whether the combination month/year is after this.maxDate, considering
       * just the month and year of this.maxDate
       * @private
       * @param {?} year
       * @param {?} month
       * @return {?}
       */
      MatYearView.prototype._isYearAndMonthAfterMaxDate = /**
       * Tests whether the combination month/year is after this.maxDate, considering
       * just the month and year of this.maxDate
       * @private
       * @param {?} year
       * @param {?} month
       * @return {?}
       */
          function (year, month) {
              if (this.maxDate) {
                  /** @type {?} */
                  var maxYear = this._dateAdapter.getYear(this.maxDate);
                  /** @type {?} */
                  var maxMonth = this._dateAdapter.getMonth(this.maxDate);
                  return year > maxYear || (year === maxYear && month > maxMonth);
              }
              return false;
          };
      /**
       * Tests whether the combination month/year is before this.minDate, considering
       * just the month and year of this.minDate
       */
      /**
       * Tests whether the combination month/year is before this.minDate, considering
       * just the month and year of this.minDate
       * @private
       * @param {?} year
       * @param {?} month
       * @return {?}
       */
      MatYearView.prototype._isYearAndMonthBeforeMinDate = /**
       * Tests whether the combination month/year is before this.minDate, considering
       * just the month and year of this.minDate
       * @private
       * @param {?} year
       * @param {?} month
       * @return {?}
       */
          function (year, month) {
              if (this.minDate) {
                  /** @type {?} */
                  var minYear = this._dateAdapter.getYear(this.minDate);
                  /** @type {?} */
                  var minMonth = this._dateAdapter.getMonth(this.minDate);
                  return year < minYear || (year === minYear && month < minMonth);
              }
              return false;
          };
      /**
       * @param obj The object to check.
       * @returns The given object if it is both a date instance and valid, otherwise null.
       */
      /**
       * @private
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
      MatYearView.prototype._getValidDateOrNull = /**
       * @private
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
          function (obj) {
              return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
          };
      /** Determines whether the user has the RTL layout direction. */
      /**
       * Determines whether the user has the RTL layout direction.
       * @private
       * @return {?}
       */
      MatYearView.prototype._isRtl = /**
       * Determines whether the user has the RTL layout direction.
       * @private
       * @return {?}
       */
          function () {
              return this._dir && this._dir.value === 'rtl';
          };
      MatYearView.decorators = [
          { type: core.Component, args: [{ selector: 'mat-year-view',
                      template: "<table class=\"mat-calendar-table\"><thead class=\"mat-calendar-table-header\"><tr><th class=\"mat-calendar-table-header-divider\" colspan=\"4\"></th></tr></thead><tbody mat-calendar-body [label]=\"_yearLabel\" [rows]=\"_months\" [todayValue]=\"_todayMonth\" [selectedValue]=\"_selectedMonth\" [labelMinRequiredCells]=\"2\" [numCols]=\"4\" [cellAspectRatio]=\"4 / 7\" [activeCell]=\"_dateAdapter.getMonth(activeDate)\" (selectedValueChange)=\"_monthSelected($event)\" (keydown)=\"_handleCalendarBodyKeydown($event)\"></tbody></table>",
                      exportAs: 'matYearView',
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      /** @nocollapse */
      MatYearView.ctorParameters = function () {
          return [
              { type: core.ChangeDetectorRef },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_DATE_FORMATS,] }] },
              { type: DateAdapter, decorators: [{ type: core.Optional }] },
              { type: Directionality, decorators: [{ type: core.Optional }] }
          ];
      };
      MatYearView.propDecorators = {
          activeDate: [{ type: core.Input }],
          selected: [{ type: core.Input }],
          minDate: [{ type: core.Input }],
          maxDate: [{ type: core.Input }],
          dateFilter: [{ type: core.Input }],
          selectedChange: [{ type: core.Output }],
          monthSelected: [{ type: core.Output }],
          activeDateChange: [{ type: core.Output }],
          _matCalendarBody: [{ type: core.ViewChild, args: [MatCalendarBody,] }]
      };
      return MatYearView;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Default header for MatCalendar
   * @template D
   */
  var MatCalendarHeader = /** @class */ (function () {
      function MatCalendarHeader(_intl, calendar, _dateAdapter, _dateFormats, changeDetectorRef) {
          this._intl = _intl;
          this.calendar = calendar;
          this._dateAdapter = _dateAdapter;
          this._dateFormats = _dateFormats;
          this.calendar.stateChanges.subscribe(function () { return changeDetectorRef.markForCheck(); });
      }
      Object.defineProperty(MatCalendarHeader.prototype, "periodButtonText", {
          /** The label for the current calendar view. */
          get: /**
           * The label for the current calendar view.
           * @return {?}
           */ function () {
              if (this.calendar.currentView == 'month') {
                  return this._dateAdapter
                      .format(this.calendar.activeDate, this._dateFormats.display.monthYearLabel)
                      .toLocaleUpperCase();
              }
              if (this.calendar.currentView == 'year') {
                  return this._dateAdapter.getYearName(this.calendar.activeDate);
              }
              /** @type {?} */
              var activeYear = this._dateAdapter.getYear(this.calendar.activeDate);
              /** @type {?} */
              var firstYearInView = this._dateAdapter.getYearName(this._dateAdapter.createDate(activeYear - activeYear % 24, 0, 1));
              /** @type {?} */
              var lastYearInView = this._dateAdapter.getYearName(this._dateAdapter.createDate(activeYear + yearsPerPage - 1 - activeYear % 24, 0, 1));
              return firstYearInView + " \u2013 " + lastYearInView;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatCalendarHeader.prototype, "periodButtonLabel", {
          get: /**
           * @return {?}
           */ function () {
              return this.calendar.currentView == 'month' ?
                  this._intl.switchToMultiYearViewLabel : this._intl.switchToMonthViewLabel;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatCalendarHeader.prototype, "prevButtonLabel", {
          /** The label for the previous button. */
          get: /**
           * The label for the previous button.
           * @return {?}
           */ function () {
              return {
                  'month': this._intl.prevMonthLabel,
                  'year': this._intl.prevYearLabel,
                  'multi-year': this._intl.prevMultiYearLabel
              }[this.calendar.currentView];
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatCalendarHeader.prototype, "nextButtonLabel", {
          /** The label for the next button. */
          get: /**
           * The label for the next button.
           * @return {?}
           */ function () {
              return {
                  'month': this._intl.nextMonthLabel,
                  'year': this._intl.nextYearLabel,
                  'multi-year': this._intl.nextMultiYearLabel
              }[this.calendar.currentView];
          },
          enumerable: true,
          configurable: true
      });
      /** Handles user clicks on the period label. */
      /**
       * Handles user clicks on the period label.
       * @return {?}
       */
      MatCalendarHeader.prototype.currentPeriodClicked = /**
       * Handles user clicks on the period label.
       * @return {?}
       */
          function () {
              this.calendar.currentView = this.calendar.currentView == 'month' ? 'multi-year' : 'month';
          };
      /** Handles user clicks on the previous button. */
      /**
       * Handles user clicks on the previous button.
       * @return {?}
       */
      MatCalendarHeader.prototype.previousClicked = /**
       * Handles user clicks on the previous button.
       * @return {?}
       */
          function () {
              this.calendar.activeDate = this.calendar.currentView == 'month' ?
                  this._dateAdapter.addCalendarMonths(this.calendar.activeDate, -1) :
                  this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? -1 : -yearsPerPage);
          };
      /** Handles user clicks on the next button. */
      /**
       * Handles user clicks on the next button.
       * @return {?}
       */
      MatCalendarHeader.prototype.nextClicked = /**
       * Handles user clicks on the next button.
       * @return {?}
       */
          function () {
              this.calendar.activeDate = this.calendar.currentView == 'month' ?
                  this._dateAdapter.addCalendarMonths(this.calendar.activeDate, 1) :
                  this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? 1 : yearsPerPage);
          };
      /** Whether the previous period button is enabled. */
      /**
       * Whether the previous period button is enabled.
       * @return {?}
       */
      MatCalendarHeader.prototype.previousEnabled = /**
       * Whether the previous period button is enabled.
       * @return {?}
       */
          function () {
              if (!this.calendar.minDate) {
                  return true;
              }
              return !this.calendar.minDate ||
                  !this._isSameView(this.calendar.activeDate, this.calendar.minDate);
          };
      /** Whether the next period button is enabled. */
      /**
       * Whether the next period button is enabled.
       * @return {?}
       */
      MatCalendarHeader.prototype.nextEnabled = /**
       * Whether the next period button is enabled.
       * @return {?}
       */
          function () {
              return !this.calendar.maxDate ||
                  !this._isSameView(this.calendar.activeDate, this.calendar.maxDate);
          };
      /** Whether the two dates represent the same view in the current view mode (month or year). */
      /**
       * Whether the two dates represent the same view in the current view mode (month or year).
       * @private
       * @param {?} date1
       * @param {?} date2
       * @return {?}
       */
      MatCalendarHeader.prototype._isSameView = /**
       * Whether the two dates represent the same view in the current view mode (month or year).
       * @private
       * @param {?} date1
       * @param {?} date2
       * @return {?}
       */
          function (date1, date2) {
              if (this.calendar.currentView == 'month') {
                  return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2) &&
                      this._dateAdapter.getMonth(date1) == this._dateAdapter.getMonth(date2);
              }
              if (this.calendar.currentView == 'year') {
                  return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2);
              }
              // Otherwise we are in 'multi-year' view.
              return Math.floor(this._dateAdapter.getYear(date1) / yearsPerPage) ==
                  Math.floor(this._dateAdapter.getYear(date2) / yearsPerPage);
          };
      MatCalendarHeader.decorators = [
          { type: core.Component, args: [{ selector: 'mat-calendar-header',
                      template: "<div class=\"mat-calendar-header\"><div class=\"mat-calendar-controls\"><button mat-button type=\"button\" class=\"mat-calendar-period-button\" (click)=\"currentPeriodClicked()\" [attr.aria-label]=\"periodButtonLabel\" cdkAriaLive=\"polite\">{{periodButtonText}}<div class=\"mat-calendar-arrow\" [class.mat-calendar-invert]=\"calendar.currentView != 'month'\"></div></button><div class=\"mat-calendar-spacer\"></div><ng-content></ng-content><button mat-icon-button type=\"button\" class=\"mat-calendar-previous-button\" [disabled]=\"!previousEnabled()\" (click)=\"previousClicked()\" [attr.aria-label]=\"prevButtonLabel\"></button> <button mat-icon-button type=\"button\" class=\"mat-calendar-next-button\" [disabled]=\"!nextEnabled()\" (click)=\"nextClicked()\" [attr.aria-label]=\"nextButtonLabel\"></button></div></div>",
                      exportAs: 'matCalendarHeader',
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatCalendarHeader.ctorParameters = function () {
          return [
              { type: MatDatepickerIntl },
              { type: MatCalendar, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return MatCalendar; }),] }] },
              { type: DateAdapter, decorators: [{ type: core.Optional }] },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_DATE_FORMATS,] }] },
              { type: core.ChangeDetectorRef }
          ];
      };
      return MatCalendarHeader;
  }());
  /**
   * A calendar that is used as part of the datepicker.
   * \@docs-private
   * @template D
   */
  var MatCalendar = /** @class */ (function () {
      function MatCalendar(_intl, _dateAdapter, _dateFormats, _changeDetectorRef) {
          var _this = this;
          this._dateAdapter = _dateAdapter;
          this._dateFormats = _dateFormats;
          this._changeDetectorRef = _changeDetectorRef;
          /**
           * Used for scheduling that focus should be moved to the active cell on the next tick.
           * We need to schedule it, rather than do it immediately, because we have to wait
           * for Angular to re-evaluate the view children.
           */
          this._moveFocusOnNextTick = false;
          /**
           * Whether the calendar should be started in month or year view.
           */
          this.startView = 'month';
          /**
           * Emits when the currently selected date changes.
           */
          this.selectedChange = new core.EventEmitter();
          /**
           * Emits the year chosen in multiyear view.
           * This doesn't imply a change on the selected date.
           */
          this.yearSelected = new core.EventEmitter();
          /**
           * Emits the month chosen in year view.
           * This doesn't imply a change on the selected date.
           */
          this.monthSelected = new core.EventEmitter();
          /**
           * Emits when any date is selected.
           */
          this._userSelection = new core.EventEmitter();
          /**
           * Emits whenever there is a state change that the header may need to respond to.
           */
          this.stateChanges = new rxjs.Subject();
          if (!this._dateAdapter) {
              throw createMissingDateImplError('DateAdapter');
          }
          if (!this._dateFormats) {
              throw createMissingDateImplError('MAT_DATE_FORMATS');
          }
          this._intlChanges = _intl.changes.subscribe(function () {
              _changeDetectorRef.markForCheck();
              _this.stateChanges.next();
          });
      }
      Object.defineProperty(MatCalendar.prototype, "startAt", {
          /** A date representing the period (month or year) to start the calendar in. */
          get: /**
           * A date representing the period (month or year) to start the calendar in.
           * @return {?}
           */ function () { return this._startAt; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatCalendar.prototype, "selected", {
          /** The currently selected date. */
          get: /**
           * The currently selected date.
           * @return {?}
           */ function () { return this._selected; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatCalendar.prototype, "minDate", {
          /** The minimum selectable date. */
          get: /**
           * The minimum selectable date.
           * @return {?}
           */ function () { return this._minDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatCalendar.prototype, "maxDate", {
          /** The maximum selectable date. */
          get: /**
           * The maximum selectable date.
           * @return {?}
           */ function () { return this._maxDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatCalendar.prototype, "activeDate", {
          /**
           * The current active date. This determines which time period is shown and which date is
           * highlighted when using keyboard navigation.
           */
          get: /**
           * The current active date. This determines which time period is shown and which date is
           * highlighted when using keyboard navigation.
           * @return {?}
           */ function () { return this._clampedActiveDate; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._clampedActiveDate = this._dateAdapter.clampDate(value, this.minDate, this.maxDate);
              this.stateChanges.next();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatCalendar.prototype, "currentView", {
          /** Whether the calendar is in month view. */
          get: /**
           * Whether the calendar is in month view.
           * @return {?}
           */ function () { return this._currentView; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._currentView = value;
              this._moveFocusOnNextTick = true;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatCalendar.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this._calendarHeaderPortal = new ComponentPortal(this.headerComponent || MatCalendarHeader);
              this.activeDate = this.startAt || this._dateAdapter.today();
              // Assign to the private property since we don't want to move focus on init.
              this._currentView = this.startView;
          };
      /**
       * @return {?}
       */
      MatCalendar.prototype.ngAfterViewChecked = /**
       * @return {?}
       */
          function () {
              if (this._moveFocusOnNextTick) {
                  this._moveFocusOnNextTick = false;
                  this.focusActiveCell();
              }
          };
      /**
       * @return {?}
       */
      MatCalendar.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._intlChanges.unsubscribe();
              this.stateChanges.complete();
          };
      /**
       * @param {?} changes
       * @return {?}
       */
      MatCalendar.prototype.ngOnChanges = /**
       * @param {?} changes
       * @return {?}
       */
          function (changes) {
              /** @type {?} */
              var change = changes.minDate || changes.maxDate || changes.dateFilter;
              if (change && !change.firstChange) {
                  /** @type {?} */
                  var view = this._getCurrentViewComponent();
                  if (view) {
                      // We need to `detectChanges` manually here, because the `minDate`, `maxDate` etc. are
                      // passed down to the view via data bindings which won't be up-to-date when we call `_init`.
                      this._changeDetectorRef.detectChanges();
                      view._init();
                  }
              }
              this.stateChanges.next();
          };
      /**
       * @return {?}
       */
      MatCalendar.prototype.focusActiveCell = /**
       * @return {?}
       */
          function () {
              this._getCurrentViewComponent()._focusActiveCell();
          };
      /** Updates today's date after an update of the active date */
      /**
       * Updates today's date after an update of the active date
       * @return {?}
       */
      MatCalendar.prototype.updateTodaysDate = /**
       * Updates today's date after an update of the active date
       * @return {?}
       */
          function () {
              /** @type {?} */
              var view = this.currentView == 'month' ? this.monthView :
                  (this.currentView == 'year' ? this.yearView : this.multiYearView);
              view.ngAfterContentInit();
          };
      /** Handles date selection in the month view. */
      /**
       * Handles date selection in the month view.
       * @param {?} date
       * @return {?}
       */
      MatCalendar.prototype._dateSelected = /**
       * Handles date selection in the month view.
       * @param {?} date
       * @return {?}
       */
          function (date) {
              if (!this._dateAdapter.sameDate(date, this.selected)) {
                  this.selectedChange.emit(date);
              }
          };
      /** Handles year selection in the multiyear view. */
      /**
       * Handles year selection in the multiyear view.
       * @param {?} normalizedYear
       * @return {?}
       */
      MatCalendar.prototype._yearSelectedInMultiYearView = /**
       * Handles year selection in the multiyear view.
       * @param {?} normalizedYear
       * @return {?}
       */
          function (normalizedYear) {
              this.yearSelected.emit(normalizedYear);
          };
      /** Handles month selection in the year view. */
      /**
       * Handles month selection in the year view.
       * @param {?} normalizedMonth
       * @return {?}
       */
      MatCalendar.prototype._monthSelectedInYearView = /**
       * Handles month selection in the year view.
       * @param {?} normalizedMonth
       * @return {?}
       */
          function (normalizedMonth) {
              this.monthSelected.emit(normalizedMonth);
          };
      /**
       * @return {?}
       */
      MatCalendar.prototype._userSelected = /**
       * @return {?}
       */
          function () {
              this._userSelection.emit();
          };
      /** Handles year/month selection in the multi-year/year views. */
      /**
       * Handles year/month selection in the multi-year/year views.
       * @param {?} date
       * @param {?} view
       * @return {?}
       */
      MatCalendar.prototype._goToDateInView = /**
       * Handles year/month selection in the multi-year/year views.
       * @param {?} date
       * @param {?} view
       * @return {?}
       */
          function (date, view) {
              this.activeDate = date;
              this.currentView = view;
          };
      /**
       * @param obj The object to check.
       * @returns The given object if it is both a date instance and valid, otherwise null.
       */
      /**
       * @private
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
      MatCalendar.prototype._getValidDateOrNull = /**
       * @private
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
          function (obj) {
              return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
          };
      /** Returns the component instance that corresponds to the current calendar view. */
      /**
       * Returns the component instance that corresponds to the current calendar view.
       * @private
       * @return {?}
       */
      MatCalendar.prototype._getCurrentViewComponent = /**
       * Returns the component instance that corresponds to the current calendar view.
       * @private
       * @return {?}
       */
          function () {
              return this.monthView || this.yearView || this.multiYearView;
          };
      MatCalendar.decorators = [
          { type: core.Component, args: [{ selector: 'mat-calendar',
                      template: "<ng-template [cdkPortalOutlet]=\"_calendarHeaderPortal\"></ng-template><div class=\"mat-calendar-content\" [ngSwitch]=\"currentView\" cdkMonitorSubtreeFocus tabindex=\"-1\"><mat-month-view *ngSwitchCase=\"'month'\" [(activeDate)]=\"activeDate\" [selected]=\"selected\" [dateFilter]=\"dateFilter\" [maxDate]=\"maxDate\" [minDate]=\"minDate\" [dateClass]=\"dateClass\" (selectedChange)=\"_dateSelected($event)\" (_userSelection)=\"_userSelected()\"></mat-month-view><mat-year-view *ngSwitchCase=\"'year'\" [(activeDate)]=\"activeDate\" [selected]=\"selected\" [dateFilter]=\"dateFilter\" [maxDate]=\"maxDate\" [minDate]=\"minDate\" (monthSelected)=\"_monthSelectedInYearView($event)\" (selectedChange)=\"_goToDateInView($event, 'month')\"></mat-year-view><mat-multi-year-view *ngSwitchCase=\"'multi-year'\" [(activeDate)]=\"activeDate\" [selected]=\"selected\" [dateFilter]=\"dateFilter\" [maxDate]=\"maxDate\" [minDate]=\"minDate\" (yearSelected)=\"_yearSelectedInMultiYearView($event)\" (selectedChange)=\"_goToDateInView($event, 'year')\"></mat-multi-year-view></div>",
                      styles: [".mat-calendar{display:block}.mat-calendar-header{padding:8px 8px 0 8px}.mat-calendar-content{padding:0 8px 8px 8px;outline:0}.mat-calendar-controls{display:flex;margin:5% calc(33% / 7 - 16px)}.mat-calendar-spacer{flex:1 1 auto}.mat-calendar-period-button{min-width:0}.mat-calendar-arrow{display:inline-block;width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top-width:5px;border-top-style:solid;margin:0 0 0 5px;vertical-align:middle}.mat-calendar-arrow.mat-calendar-invert{transform:rotate(180deg)}[dir=rtl] .mat-calendar-arrow{margin:0 5px 0 0}.mat-calendar-next-button,.mat-calendar-previous-button{position:relative}.mat-calendar-next-button::after,.mat-calendar-previous-button::after{top:0;left:0;right:0;bottom:0;position:absolute;content:'';margin:15.5px;border:0 solid currentColor;border-top-width:2px}[dir=rtl] .mat-calendar-next-button,[dir=rtl] .mat-calendar-previous-button{transform:rotate(180deg)}.mat-calendar-previous-button::after{border-left-width:2px;transform:translateX(2px) rotate(-45deg)}.mat-calendar-next-button::after{border-right-width:2px;transform:translateX(-2px) rotate(45deg)}.mat-calendar-table{border-spacing:0;border-collapse:collapse;width:100%}.mat-calendar-table-header th{text-align:center;padding:0 0 8px 0}.mat-calendar-table-header-divider{position:relative;height:1px}.mat-calendar-table-header-divider::after{content:'';position:absolute;top:0;left:-8px;right:-8px;height:1px}"],
                      host: {
                          'class': 'mat-calendar',
                      },
                      exportAs: 'matCalendar',
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatCalendar.ctorParameters = function () {
          return [
              { type: MatDatepickerIntl },
              { type: DateAdapter, decorators: [{ type: core.Optional }] },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_DATE_FORMATS,] }] },
              { type: core.ChangeDetectorRef }
          ];
      };
      MatCalendar.propDecorators = {
          headerComponent: [{ type: core.Input }],
          startAt: [{ type: core.Input }],
          startView: [{ type: core.Input }],
          selected: [{ type: core.Input }],
          minDate: [{ type: core.Input }],
          maxDate: [{ type: core.Input }],
          dateFilter: [{ type: core.Input }],
          dateClass: [{ type: core.Input }],
          selectedChange: [{ type: core.Output }],
          yearSelected: [{ type: core.Output }],
          monthSelected: [{ type: core.Output }],
          _userSelection: [{ type: core.Output }],
          monthView: [{ type: core.ViewChild, args: [MatMonthView,] }],
          yearView: [{ type: core.ViewChild, args: [MatYearView,] }],
          multiYearView: [{ type: core.ViewChild, args: [MatMultiYearView,] }]
      };
      return MatCalendar;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Animations used by the Material datepicker.
   * \@docs-private
   * @type {?}
   */
  var matDatepickerAnimations = {
      /**
       * Transforms the height of the datepicker's calendar.
       */
      transformPanel: trigger('transformPanel', [
          state('void', style({
              opacity: 0,
              transform: 'scale(1, 0.8)'
          })),
          transition('void => enter', animate('120ms cubic-bezier(0, 0, 0.2, 1)', style({
              opacity: 1,
              transform: 'scale(1, 1)'
          }))),
          transition('* => void', animate('100ms linear', style({ opacity: 0 })))
      ]),
      /**
       * Fades in the content of the calendar.
       */
      fadeInCalendar: trigger('fadeInCalendar', [
          state('void', style({ opacity: 0 })),
          state('enter', style({ opacity: 1 })),
          // TODO(crisbeto): this animation should be removed since it isn't quite on spec, but we
          // need to keep it until #12440 gets in, otherwise the exit animation will look glitchy.
          transition('void => *', animate('120ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)'))
      ])
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Used to generate a unique ID for each datepicker instance.
   * @type {?}
   */
  var datepickerUid = 0;
  /**
   * Injection token that determines the scroll handling while the calendar is open.
   * @type {?}
   */
  var MAT_DATEPICKER_SCROLL_STRATEGY = new core.InjectionToken('mat-datepicker-scroll-strategy');
  // Boilerplate for applying mixins to MatDatepickerContent.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatDatepickerContent.
  /**
   * \@docs-private
   */
  MatDatepickerContentBase = /** @class */ (function () {
      function MatDatepickerContentBase(_elementRef) {
          this._elementRef = _elementRef;
      }
      return MatDatepickerContentBase;
  }());
  /** @type {?} */
  var _MatDatepickerContentMixinBase = mixinColor(MatDatepickerContentBase);
  /**
   * Component used as the content for the datepicker dialog and popup. We use this instead of using
   * MatCalendar directly as the content so we can control the initial focus. This also gives us a
   * place to put additional features of the popup that are not part of the calendar itself in the
   * future. (e.g. confirmation buttons).
   * \@docs-private
   * @template D
   */
  var MatDatepickerContent = /** @class */ (function (_super) {
      tslib_1.__extends(MatDatepickerContent, _super);
      function MatDatepickerContent(elementRef) {
          return _super.call(this, elementRef) || this;
      }
      /**
       * @return {?}
       */
      MatDatepickerContent.prototype.ngAfterViewInit = /**
       * @return {?}
       */
          function () {
              this._calendar.focusActiveCell();
          };
      MatDatepickerContent.decorators = [
          { type: core.Component, args: [{ selector: 'mat-datepicker-content',
                      template: "<mat-calendar cdkTrapFocus [id]=\"datepicker.id\" [ngClass]=\"datepicker.panelClass\" [startAt]=\"datepicker.startAt\" [startView]=\"datepicker.startView\" [minDate]=\"datepicker._minDate\" [maxDate]=\"datepicker._maxDate\" [dateFilter]=\"datepicker._dateFilter\" [headerComponent]=\"datepicker.calendarHeaderComponent\" [selected]=\"datepicker._selected\" [dateClass]=\"datepicker.dateClass\" [@fadeInCalendar]=\"'enter'\" (selectedChange)=\"datepicker.select($event)\" (yearSelected)=\"datepicker._selectYear($event)\" (monthSelected)=\"datepicker._selectMonth($event)\" (_userSelection)=\"datepicker.close()\"></mat-calendar>",
                      styles: [".mat-datepicker-content{display:block;border-radius:4px}.mat-datepicker-content .mat-calendar{width:296px;height:354px}.mat-datepicker-content-touch{display:block;max-height:80vh;overflow:auto;margin:-24px}.mat-datepicker-content-touch .mat-calendar{min-width:250px;min-height:312px;max-width:750px;max-height:788px}@media all and (orientation:landscape){.mat-datepicker-content-touch .mat-calendar{width:64vh;height:80vh}}@media all and (orientation:portrait){.mat-datepicker-content-touch .mat-calendar{width:80vw;height:100vw}}"],
                      host: {
                          'class': 'mat-datepicker-content',
                          '[@transformPanel]': '"enter"',
                          '[class.mat-datepicker-content-touch]': 'datepicker.touchUi',
                      },
                      animations: [
                          matDatepickerAnimations.transformPanel,
                          matDatepickerAnimations.fadeInCalendar,
                      ],
                      exportAs: 'matDatepickerContent',
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      inputs: ['color'],
                  },] },
      ];
      /** @nocollapse */
      MatDatepickerContent.ctorParameters = function () {
          return [
              { type: core.ElementRef }
          ];
      };
      MatDatepickerContent.propDecorators = {
          _calendar: [{ type: core.ViewChild, args: [MatCalendar,] }]
      };
      return MatDatepickerContent;
  }(_MatDatepickerContentMixinBase));
  // TODO(mmalerba): We use a component instead of a directive here so the user can use implicit
  // template reference variables (e.g. #d vs #d="matDatepicker"). We can change this to a directive
  // if angular adds support for `exportAs: '$implicit'` on directives.
  /**
   * Component responsible for managing the datepicker popup/dialog.
   * @template D
   */
  var MatDatepicker = /** @class */ (function () {
      function MatDatepicker(_dialog, _overlay, _ngZone, _viewContainerRef, scrollStrategy, _dateAdapter, _dir, _document) {
          this._dialog = _dialog;
          this._overlay = _overlay;
          this._ngZone = _ngZone;
          this._viewContainerRef = _viewContainerRef;
          this._dateAdapter = _dateAdapter;
          this._dir = _dir;
          this._document = _document;
          /**
           * The view that the calendar should start in.
           */
          this.startView = 'month';
          this._touchUi = false;
          /**
           * Emits selected year in multiyear view.
           * This doesn't imply a change on the selected date.
           */
          this.yearSelected = new core.EventEmitter();
          /**
           * Emits selected month in year view.
           * This doesn't imply a change on the selected date.
           */
          this.monthSelected = new core.EventEmitter();
          /**
           * Emits when the datepicker has been opened.
           */
          this.openedStream = new core.EventEmitter();
          /**
           * Emits when the datepicker has been closed.
           */
          this.closedStream = new core.EventEmitter();
          this._opened = false;
          /**
           * The id for the datepicker calendar.
           */
          this.id = "mat-datepicker-" + datepickerUid++;
          this._validSelected = null;
          /**
           * The element that was focused before the datepicker was opened.
           */
          this._focusedElementBeforeOpen = null;
          /**
           * Subscription to value changes in the associated input element.
           */
          this._inputSubscription = rxjs.Subscription.EMPTY;
          /**
           * Emits when the datepicker is disabled.
           */
          this._disabledChange = new rxjs.Subject();
          /**
           * Emits new selected date when selected date changes.
           */
          this._selectedChanged = new rxjs.Subject();
          if (!this._dateAdapter) {
              throw createMissingDateImplError('DateAdapter');
          }
          this._scrollStrategy = scrollStrategy;
      }
      Object.defineProperty(MatDatepicker.prototype, "startAt", {
          /** The date to open the calendar to initially. */
          get: /**
           * The date to open the calendar to initially.
           * @return {?}
           */ function () {
              // If an explicit startAt is set we start there, otherwise we start at whatever the currently
              // selected value is.
              return this._startAt || (this._datepickerInput ? this._datepickerInput.value : null);
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDatepicker.prototype, "color", {
          /** Color palette to use on the datepicker's calendar. */
          get: /**
           * Color palette to use on the datepicker's calendar.
           * @return {?}
           */ function () {
              return this._color ||
                  (this._datepickerInput ? this._datepickerInput._getThemePalette() : undefined);
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._color = value;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDatepicker.prototype, "touchUi", {
          /**
           * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather
           * than a popup and elements have more padding to allow for bigger touch targets.
           */
          get: /**
           * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather
           * than a popup and elements have more padding to allow for bigger touch targets.
           * @return {?}
           */ function () { return this._touchUi; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._touchUi = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDatepicker.prototype, "disabled", {
          /** Whether the datepicker pop-up should be disabled. */
          get: /**
           * Whether the datepicker pop-up should be disabled.
           * @return {?}
           */ function () {
              return this._disabled === undefined && this._datepickerInput ?
                  this._datepickerInput.disabled : !!this._disabled;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var newValue = coerceBooleanProperty(value);
              if (newValue !== this._disabled) {
                  this._disabled = newValue;
                  this._disabledChange.next(newValue);
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDatepicker.prototype, "opened", {
          /** Whether the calendar is open. */
          get: /**
           * Whether the calendar is open.
           * @return {?}
           */ function () { return this._opened; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { value ? this.open() : this.close(); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDatepicker.prototype, "_selected", {
          /** The currently selected date. */
          get: /**
           * The currently selected date.
           * @return {?}
           */ function () { return this._validSelected; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._validSelected = value; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDatepicker.prototype, "_minDate", {
          /** The minimum selectable date. */
          get: /**
           * The minimum selectable date.
           * @return {?}
           */ function () {
              return this._datepickerInput && this._datepickerInput.min;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDatepicker.prototype, "_maxDate", {
          /** The maximum selectable date. */
          get: /**
           * The maximum selectable date.
           * @return {?}
           */ function () {
              return this._datepickerInput && this._datepickerInput.max;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDatepicker.prototype, "_dateFilter", {
          get: /**
           * @return {?}
           */ function () {
              return this._datepickerInput && this._datepickerInput._dateFilter;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatDatepicker.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this.close();
              this._inputSubscription.unsubscribe();
              this._disabledChange.complete();
              if (this._popupRef) {
                  this._popupRef.dispose();
                  this._popupComponentRef = null;
              }
          };
      /** Selects the given date */
      /**
       * Selects the given date
       * @param {?} date
       * @return {?}
       */
      MatDatepicker.prototype.select = /**
       * Selects the given date
       * @param {?} date
       * @return {?}
       */
          function (date) {
              /** @type {?} */
              var oldValue = this._selected;
              this._selected = date;
              if (!this._dateAdapter.sameDate(oldValue, this._selected)) {
                  this._selectedChanged.next(date);
              }
          };
      /** Emits the selected year in multiyear view */
      /**
       * Emits the selected year in multiyear view
       * @param {?} normalizedYear
       * @return {?}
       */
      MatDatepicker.prototype._selectYear = /**
       * Emits the selected year in multiyear view
       * @param {?} normalizedYear
       * @return {?}
       */
          function (normalizedYear) {
              this.yearSelected.emit(normalizedYear);
          };
      /** Emits selected month in year view */
      /**
       * Emits selected month in year view
       * @param {?} normalizedMonth
       * @return {?}
       */
      MatDatepicker.prototype._selectMonth = /**
       * Emits selected month in year view
       * @param {?} normalizedMonth
       * @return {?}
       */
          function (normalizedMonth) {
              this.monthSelected.emit(normalizedMonth);
          };
      /**
       * Register an input with this datepicker.
       * @param input The datepicker input to register with this datepicker.
       */
      /**
       * Register an input with this datepicker.
       * @param {?} input The datepicker input to register with this datepicker.
       * @return {?}
       */
      MatDatepicker.prototype._registerInput = /**
       * Register an input with this datepicker.
       * @param {?} input The datepicker input to register with this datepicker.
       * @return {?}
       */
          function (input) {
              var _this = this;
              if (this._datepickerInput) {
                  throw Error('A MatDatepicker can only be associated with a single input.');
              }
              this._datepickerInput = input;
              this._inputSubscription =
                  this._datepickerInput._valueChange.subscribe(function (value) { return _this._selected = value; });
          };
      /** Open the calendar. */
      /**
       * Open the calendar.
       * @return {?}
       */
      MatDatepicker.prototype.open = /**
       * Open the calendar.
       * @return {?}
       */
          function () {
              if (this._opened || this.disabled) {
                  return;
              }
              if (!this._datepickerInput) {
                  throw Error('Attempted to open an MatDatepicker with no associated input.');
              }
              if (this._document) {
                  this._focusedElementBeforeOpen = this._document.activeElement;
              }
              this.touchUi ? this._openAsDialog() : this._openAsPopup();
              this._opened = true;
              this.openedStream.emit();
          };
      /** Close the calendar. */
      /**
       * Close the calendar.
       * @return {?}
       */
      MatDatepicker.prototype.close = /**
       * Close the calendar.
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this._opened) {
                  return;
              }
              if (this._popupRef && this._popupRef.hasAttached()) {
                  this._popupRef.detach();
              }
              if (this._dialogRef) {
                  this._dialogRef.close();
                  this._dialogRef = null;
              }
              if (this._calendarPortal && this._calendarPortal.isAttached) {
                  this._calendarPortal.detach();
              }
              /** @type {?} */
              var completeClose = function () {
                  // The `_opened` could've been reset already if
                  // we got two events in quick succession.
                  if (_this._opened) {
                      _this._opened = false;
                      _this.closedStream.emit();
                      _this._focusedElementBeforeOpen = null;
                  }
              };
              if (this._focusedElementBeforeOpen &&
                  typeof this._focusedElementBeforeOpen.focus === 'function') {
                  // Because IE moves focus asynchronously, we can't count on it being restored before we've
                  // marked the datepicker as closed. If the event fires out of sequence and the element that
                  // we're refocusing opens the datepicker on focus, the user could be stuck with not being
                  // able to close the calendar at all. We work around it by making the logic, that marks
                  // the datepicker as closed, async as well.
                  this._focusedElementBeforeOpen.focus();
                  setTimeout(completeClose);
              }
              else {
                  completeClose();
              }
          };
      /** Open the calendar as a dialog. */
      /**
       * Open the calendar as a dialog.
       * @private
       * @return {?}
       */
      MatDatepicker.prototype._openAsDialog = /**
       * Open the calendar as a dialog.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              // Usually this would be handled by `open` which ensures that we can only have one overlay
              // open at a time, however since we reset the variables in async handlers some overlays
              // may slip through if the user opens and closes multiple times in quick succession (e.g.
              // by holding down the enter key).
              if (this._dialogRef) {
                  this._dialogRef.close();
              }
              this._dialogRef = this._dialog.open(MatDatepickerContent, {
                  direction: this._dir ? this._dir.value : 'ltr',
                  viewContainerRef: this._viewContainerRef,
                  panelClass: 'mat-datepicker-dialog',
              });
              this._dialogRef.afterClosed().subscribe(function () { return _this.close(); });
              this._dialogRef.componentInstance.datepicker = this;
              this._setColor();
          };
      /** Open the calendar as a popup. */
      /**
       * Open the calendar as a popup.
       * @private
       * @return {?}
       */
      MatDatepicker.prototype._openAsPopup = /**
       * Open the calendar as a popup.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this._calendarPortal) {
                  this._calendarPortal = new ComponentPortal(MatDatepickerContent, this._viewContainerRef);
              }
              if (!this._popupRef) {
                  this._createPopup();
              }
              if (!this._popupRef.hasAttached()) {
                  this._popupComponentRef = this._popupRef.attach(this._calendarPortal);
                  this._popupComponentRef.instance.datepicker = this;
                  this._setColor();
                  // Update the position once the calendar has rendered.
                  this._ngZone.onStable.asObservable().pipe(operators.take(1)).subscribe(function () {
                      _this._popupRef.updatePosition();
                  });
              }
          };
      /** Create the popup. */
      /**
       * Create the popup.
       * @private
       * @return {?}
       */
      MatDatepicker.prototype._createPopup = /**
       * Create the popup.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var overlayConfig = new OverlayConfig({
                  positionStrategy: this._createPopupPositionStrategy(),
                  hasBackdrop: true,
                  backdropClass: 'mat-overlay-transparent-backdrop',
                  direction: this._dir,
                  scrollStrategy: this._scrollStrategy(),
                  panelClass: 'mat-datepicker-popup',
              });
              this._popupRef = this._overlay.create(overlayConfig);
              this._popupRef.overlayElement.setAttribute('role', 'dialog');
              rxjs.merge(this._popupRef.backdropClick(), this._popupRef.detachments(), this._popupRef.keydownEvents().pipe(operators.filter(function (event) {
                  // Closing on alt + up is only valid when there's an input associated with the datepicker.
                  return event.keyCode === ESCAPE ||
                      (_this._datepickerInput && event.altKey && event.keyCode === UP_ARROW);
              }))).subscribe(function () { return _this.close(); });
          };
      /** Create the popup PositionStrategy. */
      /**
       * Create the popup PositionStrategy.
       * @private
       * @return {?}
       */
      MatDatepicker.prototype._createPopupPositionStrategy = /**
       * Create the popup PositionStrategy.
       * @private
       * @return {?}
       */
          function () {
              return this._overlay.position()
                  .flexibleConnectedTo(this._datepickerInput.getConnectedOverlayOrigin())
                  .withTransformOriginOn('.mat-datepicker-content')
                  .withFlexibleDimensions(false)
                  .withViewportMargin(8)
                  .withLockedPosition()
                  .withPositions([
                  {
                      originX: 'start',
                      originY: 'bottom',
                      overlayX: 'start',
                      overlayY: 'top'
                  },
                  {
                      originX: 'start',
                      originY: 'top',
                      overlayX: 'start',
                      overlayY: 'bottom'
                  },
                  {
                      originX: 'end',
                      originY: 'bottom',
                      overlayX: 'end',
                      overlayY: 'top'
                  },
                  {
                      originX: 'end',
                      originY: 'top',
                      overlayX: 'end',
                      overlayY: 'bottom'
                  }
              ]);
          };
      /**
       * @param obj The object to check.
       * @returns The given object if it is both a date instance and valid, otherwise null.
       */
      /**
       * @private
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
      MatDatepicker.prototype._getValidDateOrNull = /**
       * @private
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
          function (obj) {
              return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
          };
      /** Passes the current theme color along to the calendar overlay. */
      /**
       * Passes the current theme color along to the calendar overlay.
       * @private
       * @return {?}
       */
      MatDatepicker.prototype._setColor = /**
       * Passes the current theme color along to the calendar overlay.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var color = this.color;
              if (this._popupComponentRef) {
                  this._popupComponentRef.instance.color = color;
              }
              if (this._dialogRef) {
                  this._dialogRef.componentInstance.color = color;
              }
          };
      MatDatepicker.decorators = [
          { type: core.Component, args: [{ selector: 'mat-datepicker',
                      template: '',
                      exportAs: 'matDatepicker',
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                  },] },
      ];
      /** @nocollapse */
      MatDatepicker.ctorParameters = function () {
          return [
              { type: MatDialog },
              { type: Overlay },
              { type: core.NgZone },
              { type: core.ViewContainerRef },
              { type: undefined, decorators: [{ type: core.Inject, args: [MAT_DATEPICKER_SCROLL_STRATEGY,] }] },
              { type: DateAdapter, decorators: [{ type: core.Optional }] },
              { type: Directionality, decorators: [{ type: core.Optional }] },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] }
          ];
      };
      MatDatepicker.propDecorators = {
          calendarHeaderComponent: [{ type: core.Input }],
          startAt: [{ type: core.Input }],
          startView: [{ type: core.Input }],
          color: [{ type: core.Input }],
          touchUi: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          yearSelected: [{ type: core.Output }],
          monthSelected: [{ type: core.Output }],
          panelClass: [{ type: core.Input }],
          dateClass: [{ type: core.Input }],
          openedStream: [{ type: core.Output, args: ['opened',] }],
          closedStream: [{ type: core.Output, args: ['closed',] }],
          opened: [{ type: core.Input }]
      };
      return MatDatepicker;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@docs-private
   * @type {?}
   */
  var MAT_DATEPICKER_VALUE_ACCESSOR = {
      provide: forms.NG_VALUE_ACCESSOR,
      useExisting: core.forwardRef(function () { return MatDatepickerInput; }),
      multi: true
  };
  /**
   * \@docs-private
   * @type {?}
   */
  var MAT_DATEPICKER_VALIDATORS = {
      provide: forms.NG_VALIDATORS,
      useExisting: core.forwardRef(function () { return MatDatepickerInput; }),
      multi: true
  };
  /**
   * An event used for datepicker input and change events. We don't always have access to a native
   * input or change event because the event may have been triggered by the user clicking on the
   * calendar popup. For consistency, we always use MatDatepickerInputEvent instead.
   * @template D
   */
  var /**
   * An event used for datepicker input and change events. We don't always have access to a native
   * input or change event because the event may have been triggered by the user clicking on the
   * calendar popup. For consistency, we always use MatDatepickerInputEvent instead.
   * @template D
   */ MatDatepickerInputEvent = /** @class */ (function () {
      function MatDatepickerInputEvent(target, targetElement) {
          this.target = target;
          this.targetElement = targetElement;
          this.value = this.target.value;
      }
      return MatDatepickerInputEvent;
  }());
  /**
   * Directive used to connect an input to a MatDatepicker.
   * @template D
   */
  var MatDatepickerInput = /** @class */ (function () {
      function MatDatepickerInput(_elementRef, _dateAdapter, _dateFormats, _formField) {
          var _this = this;
          this._elementRef = _elementRef;
          this._dateAdapter = _dateAdapter;
          this._dateFormats = _dateFormats;
          this._formField = _formField;
          /**
           * Emits when a `change` event is fired on this `<input>`.
           */
          this.dateChange = new core.EventEmitter();
          /**
           * Emits when an `input` event is fired on this `<input>`.
           */
          this.dateInput = new core.EventEmitter();
          /**
           * Emits when the value changes (either due to user input or programmatic change).
           */
          this._valueChange = new core.EventEmitter();
          /**
           * Emits when the disabled state has changed
           */
          this._disabledChange = new core.EventEmitter();
          this._onTouched = function () { };
          this._cvaOnChange = function () { };
          this._validatorOnChange = function () { };
          this._datepickerSubscription = rxjs.Subscription.EMPTY;
          this._localeSubscription = rxjs.Subscription.EMPTY;
          /**
           * The form control validator for whether the input parses.
           */
          this._parseValidator = function () {
              return _this._lastValueValid ?
                  null : { 'matDatepickerParse': { 'text': _this._elementRef.nativeElement.value } };
          };
          /**
           * The form control validator for the min date.
           */
          this._minValidator = function (control) {
              /** @type {?} */
              var controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
              return (!_this.min || !controlValue ||
                  _this._dateAdapter.compareDate(_this.min, controlValue) <= 0) ?
                  null : { 'matDatepickerMin': { 'min': _this.min, 'actual': controlValue } };
          };
          /**
           * The form control validator for the max date.
           */
          this._maxValidator = function (control) {
              /** @type {?} */
              var controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
              return (!_this.max || !controlValue ||
                  _this._dateAdapter.compareDate(_this.max, controlValue) >= 0) ?
                  null : { 'matDatepickerMax': { 'max': _this.max, 'actual': controlValue } };
          };
          /**
           * The form control validator for the date filter.
           */
          this._filterValidator = function (control) {
              /** @type {?} */
              var controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
              return !_this._dateFilter || !controlValue || _this._dateFilter(controlValue) ?
                  null : { 'matDatepickerFilter': true };
          };
          /**
           * The combined form control validator for this input.
           */
          this._validator = forms.Validators.compose([this._parseValidator, this._minValidator, this._maxValidator, this._filterValidator]);
          /**
           * Whether the last value set on the input was valid.
           */
          this._lastValueValid = false;
          if (!this._dateAdapter) {
              throw createMissingDateImplError('DateAdapter');
          }
          if (!this._dateFormats) {
              throw createMissingDateImplError('MAT_DATE_FORMATS');
          }
          // Update the displayed date when the locale changes.
          this._localeSubscription = _dateAdapter.localeChanges.subscribe(function () {
              _this.value = _this.value;
          });
      }
      Object.defineProperty(MatDatepickerInput.prototype, "matDatepicker", {
          /** The datepicker that this input is associated with. */
          set: /**
           * The datepicker that this input is associated with.
           * @param {?} value
           * @return {?}
           */ function (value) {
              var _this = this;
              if (!value) {
                  return;
              }
              this._datepicker = value;
              this._datepicker._registerInput(this);
              this._datepickerSubscription.unsubscribe();
              this._datepickerSubscription = this._datepicker._selectedChanged.subscribe(function (selected) {
                  _this.value = selected;
                  _this._cvaOnChange(selected);
                  _this._onTouched();
                  _this.dateInput.emit(new MatDatepickerInputEvent(_this, _this._elementRef.nativeElement));
                  _this.dateChange.emit(new MatDatepickerInputEvent(_this, _this._elementRef.nativeElement));
              });
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDatepickerInput.prototype, "matDatepickerFilter", {
          /** Function that can be used to filter out dates within the datepicker. */
          set: /**
           * Function that can be used to filter out dates within the datepicker.
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._dateFilter = value;
              this._validatorOnChange();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDatepickerInput.prototype, "value", {
          /** The value of the input. */
          get: /**
           * The value of the input.
           * @return {?}
           */ function () { return this._value; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              value = this._dateAdapter.deserialize(value);
              this._lastValueValid = !value || this._dateAdapter.isValid(value);
              value = this._getValidDateOrNull(value);
              /** @type {?} */
              var oldDate = this.value;
              this._value = value;
              this._formatValue(value);
              if (!this._dateAdapter.sameDate(oldDate, value)) {
                  this._valueChange.emit(value);
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDatepickerInput.prototype, "min", {
          /** The minimum valid date. */
          get: /**
           * The minimum valid date.
           * @return {?}
           */ function () { return this._min; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._min = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
              this._validatorOnChange();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDatepickerInput.prototype, "max", {
          /** The maximum valid date. */
          get: /**
           * The maximum valid date.
           * @return {?}
           */ function () { return this._max; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._max = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
              this._validatorOnChange();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDatepickerInput.prototype, "disabled", {
          /** Whether the datepicker-input is disabled. */
          get: /**
           * Whether the datepicker-input is disabled.
           * @return {?}
           */ function () { return !!this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var newValue = coerceBooleanProperty(value);
              /** @type {?} */
              var element = this._elementRef.nativeElement;
              if (this._disabled !== newValue) {
                  this._disabled = newValue;
                  this._disabledChange.emit(newValue);
              }
              // We need to null check the `blur` method, because it's undefined during SSR.
              if (newValue && element.blur) {
                  // Normally, native input elements automatically blur if they turn disabled. This behavior
                  // is problematic, because it would mean that it triggers another change detection cycle,
                  // which then causes a changed after checked error if the input element was focused before.
                  element.blur();
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatDatepickerInput.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._datepickerSubscription.unsubscribe();
              this._localeSubscription.unsubscribe();
              this._valueChange.complete();
              this._disabledChange.complete();
          };
      /** @docs-private */
      /**
       * \@docs-private
       * @param {?} fn
       * @return {?}
       */
      MatDatepickerInput.prototype.registerOnValidatorChange = /**
       * \@docs-private
       * @param {?} fn
       * @return {?}
       */
          function (fn) {
              this._validatorOnChange = fn;
          };
      /** @docs-private */
      /**
       * \@docs-private
       * @param {?} c
       * @return {?}
       */
      MatDatepickerInput.prototype.validate = /**
       * \@docs-private
       * @param {?} c
       * @return {?}
       */
          function (c) {
              return this._validator ? this._validator(c) : null;
          };
      /**
       * @deprecated
       * @breaking-change 8.0.0 Use `getConnectedOverlayOrigin` instead
       */
      /**
       * @deprecated
       * \@breaking-change 8.0.0 Use `getConnectedOverlayOrigin` instead
       * @return {?}
       */
      MatDatepickerInput.prototype.getPopupConnectionElementRef = /**
       * @deprecated
       * \@breaking-change 8.0.0 Use `getConnectedOverlayOrigin` instead
       * @return {?}
       */
          function () {
              return this.getConnectedOverlayOrigin();
          };
      /**
       * Gets the element that the datepicker popup should be connected to.
       * @return The element to connect the popup to.
       */
      /**
       * Gets the element that the datepicker popup should be connected to.
       * @return {?} The element to connect the popup to.
       */
      MatDatepickerInput.prototype.getConnectedOverlayOrigin = /**
       * Gets the element that the datepicker popup should be connected to.
       * @return {?} The element to connect the popup to.
       */
          function () {
              return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;
          };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} value
       * @return {?}
       */
      MatDatepickerInput.prototype.writeValue =
          // Implemented as part of ControlValueAccessor.
          /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this.value = value;
          };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} fn
       * @return {?}
       */
      MatDatepickerInput.prototype.registerOnChange =
          // Implemented as part of ControlValueAccessor.
          /**
           * @param {?} fn
           * @return {?}
           */
          function (fn) {
              this._cvaOnChange = fn;
          };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} fn
       * @return {?}
       */
      MatDatepickerInput.prototype.registerOnTouched =
          // Implemented as part of ControlValueAccessor.
          /**
           * @param {?} fn
           * @return {?}
           */
          function (fn) {
              this._onTouched = fn;
          };
      // Implemented as part of ControlValueAccessor.
      // Implemented as part of ControlValueAccessor.
      /**
       * @param {?} isDisabled
       * @return {?}
       */
      MatDatepickerInput.prototype.setDisabledState =
          // Implemented as part of ControlValueAccessor.
          /**
           * @param {?} isDisabled
           * @return {?}
           */
          function (isDisabled) {
              this.disabled = isDisabled;
          };
      /**
       * @param {?} event
       * @return {?}
       */
      MatDatepickerInput.prototype._onKeydown = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var isAltDownArrow = event.altKey && event.keyCode === DOWN_ARROW;
              if (this._datepicker && isAltDownArrow && !this._elementRef.nativeElement.readOnly) {
                  this._datepicker.open();
                  event.preventDefault();
              }
          };
      /**
       * @param {?} value
       * @return {?}
       */
      MatDatepickerInput.prototype._onInput = /**
       * @param {?} value
       * @return {?}
       */
          function (value) {
              /** @type {?} */
              var date = this._dateAdapter.parse(value, this._dateFormats.parse.dateInput);
              this._lastValueValid = !date || this._dateAdapter.isValid(date);
              date = this._getValidDateOrNull(date);
              if (!this._dateAdapter.sameDate(date, this._value)) {
                  this._value = date;
                  this._cvaOnChange(date);
                  this._valueChange.emit(date);
                  this.dateInput.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));
              }
              else {
                  this._validatorOnChange();
              }
          };
      /**
       * @return {?}
       */
      MatDatepickerInput.prototype._onChange = /**
       * @return {?}
       */
          function () {
              this.dateChange.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));
          };
      /** Returns the palette used by the input's form field, if any. */
      /**
       * Returns the palette used by the input's form field, if any.
       * @return {?}
       */
      MatDatepickerInput.prototype._getThemePalette = /**
       * Returns the palette used by the input's form field, if any.
       * @return {?}
       */
          function () {
              return this._formField ? this._formField.color : undefined;
          };
      /** Handles blur events on the input. */
      /**
       * Handles blur events on the input.
       * @return {?}
       */
      MatDatepickerInput.prototype._onBlur = /**
       * Handles blur events on the input.
       * @return {?}
       */
          function () {
              // Reformat the input only if we have a valid value.
              if (this.value) {
                  this._formatValue(this.value);
              }
              this._onTouched();
          };
      /** Formats a value and sets it on the input element. */
      /**
       * Formats a value and sets it on the input element.
       * @private
       * @param {?} value
       * @return {?}
       */
      MatDatepickerInput.prototype._formatValue = /**
       * Formats a value and sets it on the input element.
       * @private
       * @param {?} value
       * @return {?}
       */
          function (value) {
              this._elementRef.nativeElement.value =
                  value ? this._dateAdapter.format(value, this._dateFormats.display.dateInput) : '';
          };
      /**
       * @param obj The object to check.
       * @returns The given object if it is both a date instance and valid, otherwise null.
       */
      /**
       * @private
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
      MatDatepickerInput.prototype._getValidDateOrNull = /**
       * @private
       * @param {?} obj The object to check.
       * @return {?} The given object if it is both a date instance and valid, otherwise null.
       */
          function (obj) {
              return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
          };
      MatDatepickerInput.decorators = [
          { type: core.Directive, args: [{
                      selector: 'input[matDatepicker]',
                      providers: [
                          MAT_DATEPICKER_VALUE_ACCESSOR,
                          MAT_DATEPICKER_VALIDATORS,
                          { provide: MAT_INPUT_VALUE_ACCESSOR, useExisting: MatDatepickerInput },
                      ],
                      host: {
                          '[attr.aria-haspopup]': 'true',
                          '[attr.aria-owns]': '(_datepicker?.opened && _datepicker.id) || null',
                          '[attr.min]': 'min ? _dateAdapter.toIso8601(min) : null',
                          '[attr.max]': 'max ? _dateAdapter.toIso8601(max) : null',
                          '[disabled]': 'disabled',
                          '(input)': '_onInput($event.target.value)',
                          '(change)': '_onChange()',
                          '(blur)': '_onBlur()',
                          '(keydown)': '_onKeydown($event)',
                      },
                      exportAs: 'matDatepickerInput',
                  },] },
      ];
      /** @nocollapse */
      MatDatepickerInput.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: DateAdapter, decorators: [{ type: core.Optional }] },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_DATE_FORMATS,] }] },
              { type: MatFormField, decorators: [{ type: core.Optional }] }
          ];
      };
      MatDatepickerInput.propDecorators = {
          matDatepicker: [{ type: core.Input }],
          matDatepickerFilter: [{ type: core.Input }],
          value: [{ type: core.Input }],
          min: [{ type: core.Input }],
          max: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          dateChange: [{ type: core.Output }],
          dateInput: [{ type: core.Output }]
      };
      return MatDatepickerInput;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Can be used to override the icon of a `matDatepickerToggle`.
   */
  var MatDatepickerToggleIcon = /** @class */ (function () {
      function MatDatepickerToggleIcon() {
      }
      MatDatepickerToggleIcon.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matDatepickerToggleIcon]'
                  },] },
      ];
      return MatDatepickerToggleIcon;
  }());
  /**
   * @template D
   */
  var MatDatepickerToggle = /** @class */ (function () {
      function MatDatepickerToggle(_intl, _changeDetectorRef, defaultTabIndex) {
          this._intl = _intl;
          this._changeDetectorRef = _changeDetectorRef;
          this._stateChanges = rxjs.Subscription.EMPTY;
          /** @type {?} */
          var parsedTabIndex = Number(defaultTabIndex);
          this.tabIndex = (parsedTabIndex || parsedTabIndex === 0) ? parsedTabIndex : null;
      }
      Object.defineProperty(MatDatepickerToggle.prototype, "disabled", {
          /** Whether the toggle button is disabled. */
          get: /**
           * Whether the toggle button is disabled.
           * @return {?}
           */ function () {
              return this._disabled === undefined ? this.datepicker.disabled : !!this._disabled;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._disabled = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @param {?} changes
       * @return {?}
       */
      MatDatepickerToggle.prototype.ngOnChanges = /**
       * @param {?} changes
       * @return {?}
       */
          function (changes) {
              if (changes.datepicker) {
                  this._watchStateChanges();
              }
          };
      /**
       * @return {?}
       */
      MatDatepickerToggle.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._stateChanges.unsubscribe();
          };
      /**
       * @return {?}
       */
      MatDatepickerToggle.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this._watchStateChanges();
          };
      /**
       * @param {?} event
       * @return {?}
       */
      MatDatepickerToggle.prototype._open = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (this.datepicker && !this.disabled) {
                  this.datepicker.open();
                  event.stopPropagation();
              }
          };
      /**
       * @private
       * @return {?}
       */
      MatDatepickerToggle.prototype._watchStateChanges = /**
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var datepickerDisabled = this.datepicker ? this.datepicker._disabledChange : rxjs.of();
              /** @type {?} */
              var inputDisabled = this.datepicker && this.datepicker._datepickerInput ?
                  this.datepicker._datepickerInput._disabledChange : rxjs.of();
              /** @type {?} */
              var datepickerToggled = this.datepicker ?
                  rxjs.merge(this.datepicker.openedStream, this.datepicker.closedStream) :
                  rxjs.of();
              this._stateChanges.unsubscribe();
              this._stateChanges = rxjs.merge(this._intl.changes, datepickerDisabled, inputDisabled, datepickerToggled).subscribe(function () { return _this._changeDetectorRef.markForCheck(); });
          };
      MatDatepickerToggle.decorators = [
          { type: core.Component, args: [{ selector: 'mat-datepicker-toggle',
                      template: "<button #button mat-icon-button type=\"button\" aria-haspopup=\"true\" [attr.aria-label]=\"_intl.openCalendarLabel\" [attr.tabindex]=\"disabled ? -1 : tabIndex\" [disabled]=\"disabled\" [disableRipple]=\"disableRipple\" (click)=\"_open($event)\"><svg *ngIf=\"!_customIcon\" class=\"mat-datepicker-toggle-default-icon\" viewBox=\"0 0 24 24\" width=\"24px\" height=\"24px\" fill=\"currentColor\" focusable=\"false\"><path d=\"M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z\"/></svg><ng-content select=\"[matDatepickerToggleIcon]\"></ng-content></button>",
                      styles: [".mat-form-field-appearance-legacy .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-datepicker-toggle-default-icon{width:1em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-datepicker-toggle-default-icon{display:block;width:1.5em;height:1.5em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-datepicker-toggle-default-icon{margin:auto}"],
                      host: {
                          'class': 'mat-datepicker-toggle',
                          // Always set the tabindex to -1 so that it doesn't overlap with any custom tabindex the
                          // consumer may have provided, while still being able to receive focus.
                          '[attr.tabindex]': '-1',
                          '[class.mat-datepicker-toggle-active]': 'datepicker && datepicker.opened',
                          '[class.mat-accent]': 'datepicker && datepicker.color === "accent"',
                          '[class.mat-warn]': 'datepicker && datepicker.color === "warn"',
                          '(focus)': '_button.focus()',
                      },
                      exportAs: 'matDatepickerToggle',
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatDatepickerToggle.ctorParameters = function () {
          return [
              { type: MatDatepickerIntl },
              { type: core.ChangeDetectorRef },
              { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] }
          ];
      };
      MatDatepickerToggle.propDecorators = {
          datepicker: [{ type: core.Input, args: ['for',] }],
          tabIndex: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          disableRipple: [{ type: core.Input }],
          _customIcon: [{ type: core.ContentChild, args: [MatDatepickerToggleIcon,] }],
          _button: [{ type: core.ViewChild, args: ['button',] }]
      };
      return MatDatepickerToggle;
  }());

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var MatDivider = /** @class */ (function () {
      function MatDivider() {
          this._vertical = false;
          this._inset = false;
      }
      Object.defineProperty(MatDivider.prototype, "vertical", {
          /** Whether the divider is vertically aligned. */
          get: /**
           * Whether the divider is vertically aligned.
           * @return {?}
           */ function () { return this._vertical; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._vertical = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDivider.prototype, "inset", {
          /** Whether the divider is an inset divider. */
          get: /**
           * Whether the divider is an inset divider.
           * @return {?}
           */ function () { return this._inset; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._inset = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      MatDivider.decorators = [
          { type: core.Component, args: [{ selector: 'mat-divider',
                      host: {
                          'role': 'separator',
                          '[attr.aria-orientation]': 'vertical ? "vertical" : "horizontal"',
                          '[class.mat-divider-vertical]': 'vertical',
                          '[class.mat-divider-horizontal]': '!vertical',
                          '[class.mat-divider-inset]': 'inset',
                          'class': 'mat-divider'
                      },
                      template: '',
                      styles: [".mat-divider{display:block;margin:0;border-top-width:1px;border-top-style:solid}.mat-divider.mat-divider-vertical{border-top:0;border-right-width:1px;border-right-style:solid}.mat-divider.mat-divider-inset{margin-left:80px}[dir=rtl] .mat-divider.mat-divider-inset{margin-left:auto;margin-right:80px}"],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      MatDivider.propDecorators = {
          vertical: [{ type: core.Input }],
          inset: [{ type: core.Input }]
      };
      return MatDivider;
  }());

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Used to generate unique ID for each accordion.
   * @type {?}
   */
  var nextId$2 = 0;
  /**
   * Directive whose purpose is to manage the expanded state of CdkAccordionItem children.
   */
  var CdkAccordion = /** @class */ (function () {
      function CdkAccordion() {
          /**
           * Emits when the state of the accordion changes
           */
          this._stateChanges = new rxjs.Subject();
          /**
           * Stream that emits true/false when openAll/closeAll is triggered.
           */
          this._openCloseAllActions = new rxjs.Subject();
          /**
           * A readonly id value to use for unique selection coordination.
           */
          this.id = "cdk-accordion-" + nextId$2++;
          this._multi = false;
      }
      Object.defineProperty(CdkAccordion.prototype, "multi", {
          /** Whether the accordion should allow multiple expanded accordion items simultaneously. */
          get: /**
           * Whether the accordion should allow multiple expanded accordion items simultaneously.
           * @return {?}
           */ function () { return this._multi; },
          set: /**
           * @param {?} multi
           * @return {?}
           */ function (multi) { this._multi = coerceBooleanProperty(multi); },
          enumerable: true,
          configurable: true
      });
      /** Opens all enabled accordion items in an accordion where multi is enabled. */
      /**
       * Opens all enabled accordion items in an accordion where multi is enabled.
       * @return {?}
       */
      CdkAccordion.prototype.openAll = /**
       * Opens all enabled accordion items in an accordion where multi is enabled.
       * @return {?}
       */
          function () {
              this._openCloseAll(true);
          };
      /** Closes all enabled accordion items in an accordion where multi is enabled. */
      /**
       * Closes all enabled accordion items in an accordion where multi is enabled.
       * @return {?}
       */
      CdkAccordion.prototype.closeAll = /**
       * Closes all enabled accordion items in an accordion where multi is enabled.
       * @return {?}
       */
          function () {
              this._openCloseAll(false);
          };
      /**
       * @param {?} changes
       * @return {?}
       */
      CdkAccordion.prototype.ngOnChanges = /**
       * @param {?} changes
       * @return {?}
       */
          function (changes) {
              this._stateChanges.next(changes);
          };
      /**
       * @return {?}
       */
      CdkAccordion.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._stateChanges.complete();
          };
      /**
       * @private
       * @param {?} expanded
       * @return {?}
       */
      CdkAccordion.prototype._openCloseAll = /**
       * @private
       * @param {?} expanded
       * @return {?}
       */
          function (expanded) {
              if (this.multi) {
                  this._openCloseAllActions.next(expanded);
              }
          };
      CdkAccordion.decorators = [
          { type: core.Directive, args: [{
                      selector: 'cdk-accordion, [cdkAccordion]',
                      exportAs: 'cdkAccordion',
                  },] },
      ];
      CdkAccordion.propDecorators = {
          multi: [{ type: core.Input }]
      };
      return CdkAccordion;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Used to generate unique ID for each accordion item.
   * @type {?}
   */
  var nextId$1$1 = 0;
  var ɵ0$4 = undefined;
  /**
   * An basic directive expected to be extended and decorated as a component.  Sets up all
   * events and attributes needed to be managed by a CdkAccordion parent.
   */
  var CdkAccordionItem = /** @class */ (function () {
      function CdkAccordionItem(accordion, _changeDetectorRef, _expansionDispatcher) {
          var _this = this;
          this.accordion = accordion;
          this._changeDetectorRef = _changeDetectorRef;
          this._expansionDispatcher = _expansionDispatcher;
          /**
           * Subscription to openAll/closeAll events.
           */
          this._openCloseAllSubscription = rxjs.Subscription.EMPTY;
          /**
           * Event emitted every time the AccordionItem is closed.
           */
          this.closed = new core.EventEmitter();
          /**
           * Event emitted every time the AccordionItem is opened.
           */
          this.opened = new core.EventEmitter();
          /**
           * Event emitted when the AccordionItem is destroyed.
           */
          this.destroyed = new core.EventEmitter();
          /**
           * Emits whenever the expanded state of the accordion changes.
           * Primarily used to facilitate two-way binding.
           * \@docs-private
           */
          this.expandedChange = new core.EventEmitter();
          /**
           * The unique AccordionItem id.
           */
          this.id = "cdk-accordion-child-" + nextId$1$1++;
          this._expanded = false;
          this._disabled = false;
          /**
           * Unregister function for _expansionDispatcher.
           */
          this._removeUniqueSelectionListener = function () { };
          this._removeUniqueSelectionListener =
              _expansionDispatcher.listen(function (id, accordionId) {
                  if (_this.accordion && !_this.accordion.multi &&
                      _this.accordion.id === accordionId && _this.id !== id) {
                      _this.expanded = false;
                  }
              });
          // When an accordion item is hosted in an accordion, subscribe to open/close events.
          if (this.accordion) {
              this._openCloseAllSubscription = this._subscribeToOpenCloseAllActions();
          }
      }
      Object.defineProperty(CdkAccordionItem.prototype, "expanded", {
          /** Whether the AccordionItem is expanded. */
          get: /**
           * Whether the AccordionItem is expanded.
           * @return {?}
           */ function () { return this._expanded; },
          set: /**
           * @param {?} expanded
           * @return {?}
           */ function (expanded) {
              expanded = coerceBooleanProperty(expanded);
              // Only emit events and update the internal value if the value changes.
              if (this._expanded !== expanded) {
                  this._expanded = expanded;
                  this.expandedChange.emit(expanded);
                  if (expanded) {
                      this.opened.emit();
                      /**
                       * In the unique selection dispatcher, the id parameter is the id of the CdkAccordionItem,
                       * the name value is the id of the accordion.
                       * @type {?}
                       */
                      var accordionId = this.accordion ? this.accordion.id : this.id;
                      this._expansionDispatcher.notify(this.id, accordionId);
                  }
                  else {
                      this.closed.emit();
                  }
                  // Ensures that the animation will run when the value is set outside of an `@Input`.
                  // This includes cases like the open, close and toggle methods.
                  this._changeDetectorRef.markForCheck();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkAccordionItem.prototype, "disabled", {
          /** Whether the AccordionItem is disabled. */
          get: /**
           * Whether the AccordionItem is disabled.
           * @return {?}
           */ function () { return this._disabled; },
          set: /**
           * @param {?} disabled
           * @return {?}
           */ function (disabled) { this._disabled = coerceBooleanProperty(disabled); },
          enumerable: true,
          configurable: true
      });
      /** Emits an event for the accordion item being destroyed. */
      /**
       * Emits an event for the accordion item being destroyed.
       * @return {?}
       */
      CdkAccordionItem.prototype.ngOnDestroy = /**
       * Emits an event for the accordion item being destroyed.
       * @return {?}
       */
          function () {
              this.opened.complete();
              this.closed.complete();
              this.destroyed.emit();
              this.destroyed.complete();
              this._removeUniqueSelectionListener();
              this._openCloseAllSubscription.unsubscribe();
          };
      /** Toggles the expanded state of the accordion item. */
      /**
       * Toggles the expanded state of the accordion item.
       * @return {?}
       */
      CdkAccordionItem.prototype.toggle = /**
       * Toggles the expanded state of the accordion item.
       * @return {?}
       */
          function () {
              if (!this.disabled) {
                  this.expanded = !this.expanded;
              }
          };
      /** Sets the expanded state of the accordion item to false. */
      /**
       * Sets the expanded state of the accordion item to false.
       * @return {?}
       */
      CdkAccordionItem.prototype.close = /**
       * Sets the expanded state of the accordion item to false.
       * @return {?}
       */
          function () {
              if (!this.disabled) {
                  this.expanded = false;
              }
          };
      /** Sets the expanded state of the accordion item to true. */
      /**
       * Sets the expanded state of the accordion item to true.
       * @return {?}
       */
      CdkAccordionItem.prototype.open = /**
       * Sets the expanded state of the accordion item to true.
       * @return {?}
       */
          function () {
              if (!this.disabled) {
                  this.expanded = true;
              }
          };
      /**
       * @private
       * @return {?}
       */
      CdkAccordionItem.prototype._subscribeToOpenCloseAllActions = /**
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              return this.accordion._openCloseAllActions.subscribe(function (expanded) {
                  // Only change expanded state if item is enabled
                  if (!_this.disabled) {
                      _this.expanded = expanded;
                  }
              });
          };
      CdkAccordionItem.decorators = [
          { type: core.Directive, args: [{
                      selector: 'cdk-accordion-item, [cdkAccordionItem]',
                      exportAs: 'cdkAccordionItem',
                      providers: [
                          // Provide CdkAccordion as undefined to prevent nested accordion items from registering
                          // to the same accordion.
                          { provide: CdkAccordion, useValue: ɵ0$4 },
                      ],
                  },] },
      ];
      /** @nocollapse */
      CdkAccordionItem.ctorParameters = function () {
          return [
              { type: CdkAccordion, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
              { type: core.ChangeDetectorRef },
              { type: UniqueSelectionDispatcher }
          ];
      };
      CdkAccordionItem.propDecorators = {
          closed: [{ type: core.Output }],
          opened: [{ type: core.Output }],
          destroyed: [{ type: core.Output }],
          expandedChange: [{ type: core.Output }],
          expanded: [{ type: core.Input }],
          disabled: [{ type: core.Input }]
      };
      return CdkAccordionItem;
  }());

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Token used to provide a `MatAccordion` to `MatExpansionPanel`.
   * Used primarily to avoid circular imports between `MatAccordion` and `MatExpansionPanel`.
   * @type {?}
   */
  var MAT_ACCORDION = new core.InjectionToken('MAT_ACCORDION');
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Time and timing curve for expansion panel animations.
   * @type {?}
   */
  var EXPANSION_PANEL_ANIMATION_TIMING = '225ms cubic-bezier(0.4,0.0,0.2,1)';
  /**
   * Animations used by the Material expansion panel.
   *
   * A bug in angular animation's `state` when ViewContainers are moved using ViewContainerRef.move()
   * causes the animation state of moved components to become `void` upon exit, and not update again
   * upon reentry into the DOM.  This can lead a to situation for the expansion panel where the state
   * of the panel is `expanded` or `collapsed` but the animation state is `void`.
   *
   * To correctly handle animating to the next state, we animate between `void` and `collapsed` which
   * are defined to have the same styles. Since angular animates from the current styles to the
   * destination state's style definition, in situations where we are moving from `void`'s styles to
   * `collapsed` this acts a noop since no style values change.
   *
   * In the case where angular's animation state is out of sync with the expansion panel's state, the
   * expansion panel being `expanded` and angular animations being `void`, the animation from the
   * `expanded`'s effective styles (though in a `void` animation state) to the collapsed state will
   * occur as expected.
   *
   * Angular Bug: https://github.com/angular/angular/issues/18847
   *
   * \@docs-private
   * @type {?}
   */
  var matExpansionAnimations = {
      /**
       * Animation that rotates the indicator arrow.
       */
      indicatorRotate: trigger('indicatorRotate', [
          state('collapsed, void', style({ transform: 'rotate(0deg)' })),
          state('expanded', style({ transform: 'rotate(180deg)' })),
          transition('expanded <=> collapsed, void => collapsed', animate(EXPANSION_PANEL_ANIMATION_TIMING)),
      ]),
      /**
       * Animation that expands and collapses the panel header height.
       */
      expansionHeaderHeight: trigger('expansionHeight', [
          state('collapsed, void', style({
              height: '{{collapsedHeight}}',
          }), {
              params: { collapsedHeight: '48px' },
          }),
          state('expanded', style({
              height: '{{expandedHeight}}'
          }), {
              params: { expandedHeight: '64px' }
          }),
          transition('expanded <=> collapsed, void => collapsed', group([
              query('@indicatorRotate', animateChild(), { optional: true }),
              animate(EXPANSION_PANEL_ANIMATION_TIMING),
          ])),
      ]),
      /**
       * Animation that expands and collapses the panel content.
       */
      bodyExpansion: trigger('bodyExpansion', [
          state('collapsed, void', style({ height: '0px', visibility: 'hidden' })),
          state('expanded', style({ height: '*', visibility: 'visible' })),
          transition('expanded <=> collapsed, void => collapsed', animate(EXPANSION_PANEL_ANIMATION_TIMING)),
      ])
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Expansion panel content that will be rendered lazily
   * after the panel is opened for the first time.
   */
  var MatExpansionPanelContent = /** @class */ (function () {
      function MatExpansionPanelContent(_template) {
          this._template = _template;
      }
      MatExpansionPanelContent.decorators = [
          { type: core.Directive, args: [{
                      selector: 'ng-template[matExpansionPanelContent]'
                  },] },
      ];
      /** @nocollapse */
      MatExpansionPanelContent.ctorParameters = function () {
          return [
              { type: core.TemplateRef }
          ];
      };
      return MatExpansionPanelContent;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Counter for generating unique element ids.
   * @type {?}
   */
  var uniqueId$1 = 0;
  /**
   * Injection token that can be used to configure the defalt
   * options for the expansion panel component.
   * @type {?}
   */
  var MAT_EXPANSION_PANEL_DEFAULT_OPTIONS = new core.InjectionToken('MAT_EXPANSION_PANEL_DEFAULT_OPTIONS');
  var ɵ0$5 = undefined;
  /**
   * `<mat-expansion-panel>`
   *
   * This component can be used as a single element to show expandable content, or as one of
   * multiple children of an element with the MatAccordion directive attached.
   */
  var MatExpansionPanel = /** @class */ (function (_super) {
      tslib_1.__extends(MatExpansionPanel, _super);
      function MatExpansionPanel(accordion, _changeDetectorRef, _uniqueSelectionDispatcher, _viewContainerRef, 
      // @breaking-change 8.0.0 _document and _animationMode to be made required
      _document, _animationMode, defaultOptions) {
          var _this = _super.call(this, accordion, _changeDetectorRef, _uniqueSelectionDispatcher) || this;
          _this._viewContainerRef = _viewContainerRef;
          _this._animationMode = _animationMode;
          _this._hideToggle = false;
          /**
           * An event emitted after the body's expansion animation happens.
           */
          _this.afterExpand = new core.EventEmitter();
          /**
           * An event emitted after the body's collapse animation happens.
           */
          _this.afterCollapse = new core.EventEmitter();
          /**
           * Stream that emits for changes in `\@Input` properties.
           */
          _this._inputChanges = new rxjs.Subject();
          /**
           * ID for the associated header element. Used for a11y labelling.
           */
          _this._headerId = "mat-expansion-panel-header-" + uniqueId$1++;
          /**
           * Stream of body animation done events.
           */
          _this._bodyAnimationDone = new rxjs.Subject();
          _this.accordion = accordion;
          _this._document = _document;
          // We need a Subject with distinctUntilChanged, because the `done` event
          // fires twice on some browsers. See https://github.com/angular/angular/issues/24084
          _this._bodyAnimationDone.pipe(operators.distinctUntilChanged(function (x, y) {
              return x.fromState === y.fromState && x.toState === y.toState;
          })).subscribe(function (event) {
              if (event.fromState !== 'void') {
                  if (event.toState === 'expanded') {
                      _this.afterExpand.emit();
                  }
                  else if (event.toState === 'collapsed') {
                      _this.afterCollapse.emit();
                  }
              }
          });
          if (defaultOptions) {
              _this.hideToggle = defaultOptions.hideToggle;
          }
          return _this;
      }
      Object.defineProperty(MatExpansionPanel.prototype, "hideToggle", {
          /** Whether the toggle indicator should be hidden. */
          get: /**
           * Whether the toggle indicator should be hidden.
           * @return {?}
           */ function () {
              return this._hideToggle || (this.accordion && this.accordion.hideToggle);
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._hideToggle = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      /** Determines whether the expansion panel should have spacing between it and its siblings. */
      /**
       * Determines whether the expansion panel should have spacing between it and its siblings.
       * @return {?}
       */
      MatExpansionPanel.prototype._hasSpacing = /**
       * Determines whether the expansion panel should have spacing between it and its siblings.
       * @return {?}
       */
          function () {
              if (this.accordion) {
                  // We don't need to subscribe to the `stateChanges` of the parent accordion because each time
                  // the [displayMode] input changes, the change detection will also cover the host bindings
                  // of this expansion panel.
                  return (this.expanded ? this.accordion.displayMode : this._getExpandedState()) === 'default';
              }
              return false;
          };
      /** Gets the expanded state string. */
      /**
       * Gets the expanded state string.
       * @return {?}
       */
      MatExpansionPanel.prototype._getExpandedState = /**
       * Gets the expanded state string.
       * @return {?}
       */
          function () {
              return this.expanded ? 'expanded' : 'collapsed';
          };
      /**
       * @return {?}
       */
      MatExpansionPanel.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._lazyContent) {
                  // Render the content as soon as the panel becomes open.
                  this.opened.pipe(operators.startWith(( /** @type {?} */(null))), operators.filter(function () { return _this.expanded && !_this._portal; }), operators.take(1)).subscribe(function () {
                      _this._portal = new TemplatePortal(_this._lazyContent._template, _this._viewContainerRef);
                  });
              }
          };
      /**
       * @param {?} changes
       * @return {?}
       */
      MatExpansionPanel.prototype.ngOnChanges = /**
       * @param {?} changes
       * @return {?}
       */
          function (changes) {
              this._inputChanges.next(changes);
          };
      /**
       * @return {?}
       */
      MatExpansionPanel.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              _super.prototype.ngOnDestroy.call(this);
              this._bodyAnimationDone.complete();
              this._inputChanges.complete();
          };
      /** Checks whether the expansion panel's content contains the currently-focused element. */
      /**
       * Checks whether the expansion panel's content contains the currently-focused element.
       * @return {?}
       */
      MatExpansionPanel.prototype._containsFocus = /**
       * Checks whether the expansion panel's content contains the currently-focused element.
       * @return {?}
       */
          function () {
              if (this._body && this._document) {
                  /** @type {?} */
                  var focusedElement = this._document.activeElement;
                  /** @type {?} */
                  var bodyElement = this._body.nativeElement;
                  return focusedElement === bodyElement || bodyElement.contains(focusedElement);
              }
              return false;
          };
      MatExpansionPanel.decorators = [
          { type: core.Component, args: [{ styles: [".mat-expansion-panel{box-sizing:content-box;display:block;margin:0;border-radius:4px;overflow:hidden;transition:margin 225ms cubic-bezier(.4,0,.2,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-accordion .mat-expansion-panel:not(.mat-expanded),.mat-accordion .mat-expansion-panel:not(.mat-expansion-panel-spacing){border-radius:0}.mat-accordion .mat-expansion-panel:first-of-type{border-top-right-radius:4px;border-top-left-radius:4px}.mat-accordion .mat-expansion-panel:last-of-type{border-bottom-right-radius:4px;border-bottom-left-radius:4px}@media (-ms-high-contrast:active){.mat-expansion-panel{outline:solid 1px}}.mat-expansion-panel._mat-animation-noopable,.mat-expansion-panel.ng-animate-disabled,.ng-animate-disabled .mat-expansion-panel{transition:none}.mat-expansion-panel-content{display:flex;flex-direction:column;overflow:visible}.mat-expansion-panel-body{padding:0 24px 16px}.mat-expansion-panel-spacing{margin:16px 0}.mat-accordion>.mat-expansion-panel-spacing:first-child,.mat-accordion>:first-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-top:0}.mat-accordion>.mat-expansion-panel-spacing:last-child,.mat-accordion>:last-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-bottom:0}.mat-action-row{border-top-style:solid;border-top-width:1px;display:flex;flex-direction:row;justify-content:flex-end;padding:16px 8px 16px 24px}.mat-action-row button.mat-button{margin-left:8px}[dir=rtl] .mat-action-row button.mat-button{margin-left:0;margin-right:8px}"],
                      selector: 'mat-expansion-panel',
                      exportAs: 'matExpansionPanel',
                      template: "<ng-content select=\"mat-expansion-panel-header\"></ng-content><div class=\"mat-expansion-panel-content\" role=\"region\" [@bodyExpansion]=\"_getExpandedState()\" (@bodyExpansion.done)=\"_bodyAnimationDone.next($event)\" [attr.aria-labelledby]=\"_headerId\" [id]=\"id\" #body><div class=\"mat-expansion-panel-body\"><ng-content></ng-content><ng-template [cdkPortalOutlet]=\"_portal\"></ng-template></div><ng-content select=\"mat-action-row\"></ng-content></div>",
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      inputs: ['disabled', 'expanded'],
                      outputs: ['opened', 'closed', 'expandedChange'],
                      animations: [matExpansionAnimations.bodyExpansion],
                      providers: [
                          // Provide MatAccordion as undefined to prevent nested expansion panels from registering
                          // to the same accordion.
                          { provide: MAT_ACCORDION, useValue: ɵ0$5 },
                      ],
                      host: {
                          'class': 'mat-expansion-panel',
                          '[class.mat-expanded]': 'expanded',
                          '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                          '[class.mat-expansion-panel-spacing]': '_hasSpacing()',
                      }
                  },] },
      ];
      /** @nocollapse */
      MatExpansionPanel.ctorParameters = function () {
          return [
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.SkipSelf }, { type: core.Inject, args: [MAT_ACCORDION,] }] },
              { type: core.ChangeDetectorRef },
              { type: UniqueSelectionDispatcher },
              { type: core.ViewContainerRef },
              { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
              { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] },
              { type: undefined, decorators: [{ type: core.Inject, args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS,] }, { type: core.Optional }] }
          ];
      };
      MatExpansionPanel.propDecorators = {
          hideToggle: [{ type: core.Input }],
          afterExpand: [{ type: core.Output }],
          afterCollapse: [{ type: core.Output }],
          _lazyContent: [{ type: core.ContentChild, args: [MatExpansionPanelContent,] }],
          _body: [{ type: core.ViewChild, args: ['body',] }]
      };
      return MatExpansionPanel;
  }(CdkAccordionItem));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * `<mat-expansion-panel-header>`
   *
   * This component corresponds to the header element of an `<mat-expansion-panel>`.
   */
  var MatExpansionPanelHeader = /** @class */ (function () {
      function MatExpansionPanelHeader(panel, _element, _focusMonitor, _changeDetectorRef, defaultOptions) {
          var _this = this;
          this.panel = panel;
          this._element = _element;
          this._focusMonitor = _focusMonitor;
          this._changeDetectorRef = _changeDetectorRef;
          this._parentChangeSubscription = rxjs.Subscription.EMPTY;
          /** @type {?} */
          var accordionHideToggleChange = panel.accordion ?
              panel.accordion._stateChanges.pipe(operators.filter(function (changes) { return !!changes.hideToggle; })) : rxjs.EMPTY;
          // Since the toggle state depends on an @Input on the panel, we
          // need to subscribe and trigger change detection manually.
          this._parentChangeSubscription = rxjs.merge(panel.opened, panel.closed, accordionHideToggleChange, panel._inputChanges.pipe(operators.filter(function (changes) { return !!(changes.hideToggle || changes.disabled); })))
              .subscribe(function () { return _this._changeDetectorRef.markForCheck(); });
          // Avoids focus being lost if the panel contained the focused element and was closed.
          panel.closed
              .pipe(operators.filter(function () { return panel._containsFocus(); }))
              .subscribe(function () { return _focusMonitor.focusVia(_element, 'program'); });
          _focusMonitor.monitor(_element).subscribe(function (origin) {
              if (origin && panel.accordion) {
                  panel.accordion._handleHeaderFocus(_this);
              }
          });
          if (defaultOptions) {
              this.expandedHeight = defaultOptions.expandedHeight;
              this.collapsedHeight = defaultOptions.collapsedHeight;
          }
      }
      Object.defineProperty(MatExpansionPanelHeader.prototype, "disabled", {
          /**
           * Whether the associated panel is disabled. Implemented as a part of `FocusableOption`.
           * @docs-private
           */
          get: /**
           * Whether the associated panel is disabled. Implemented as a part of `FocusableOption`.
           * \@docs-private
           * @return {?}
           */ function () {
              return this.panel.disabled;
          },
          enumerable: true,
          configurable: true
      });
      /** Toggles the expanded state of the panel. */
      /**
       * Toggles the expanded state of the panel.
       * @return {?}
       */
      MatExpansionPanelHeader.prototype._toggle = /**
       * Toggles the expanded state of the panel.
       * @return {?}
       */
          function () {
              this.panel.toggle();
          };
      /** Gets whether the panel is expanded. */
      /**
       * Gets whether the panel is expanded.
       * @return {?}
       */
      MatExpansionPanelHeader.prototype._isExpanded = /**
       * Gets whether the panel is expanded.
       * @return {?}
       */
          function () {
              return this.panel.expanded;
          };
      /** Gets the expanded state string of the panel. */
      /**
       * Gets the expanded state string of the panel.
       * @return {?}
       */
      MatExpansionPanelHeader.prototype._getExpandedState = /**
       * Gets the expanded state string of the panel.
       * @return {?}
       */
          function () {
              return this.panel._getExpandedState();
          };
      /** Gets the panel id. */
      /**
       * Gets the panel id.
       * @return {?}
       */
      MatExpansionPanelHeader.prototype._getPanelId = /**
       * Gets the panel id.
       * @return {?}
       */
          function () {
              return this.panel.id;
          };
      /** Gets whether the expand indicator should be shown. */
      /**
       * Gets whether the expand indicator should be shown.
       * @return {?}
       */
      MatExpansionPanelHeader.prototype._showToggle = /**
       * Gets whether the expand indicator should be shown.
       * @return {?}
       */
          function () {
              return !this.panel.hideToggle && !this.panel.disabled;
          };
      /** Handle keydown event calling to toggle() if appropriate. */
      /**
       * Handle keydown event calling to toggle() if appropriate.
       * @param {?} event
       * @return {?}
       */
      MatExpansionPanelHeader.prototype._keydown = /**
       * Handle keydown event calling to toggle() if appropriate.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              switch (event.keyCode) {
                  // Toggle for space and enter keys.
                  case SPACE:
                  case ENTER:
                      if (!hasModifierKey(event)) {
                          event.preventDefault();
                          this._toggle();
                      }
                      break;
                  default:
                      if (this.panel.accordion) {
                          this.panel.accordion._handleHeaderKeydown(event);
                      }
                      return;
              }
          };
      /**
       * Focuses the panel header. Implemented as a part of `FocusableOption`.
       * @param origin Origin of the action that triggered the focus.
       * @docs-private
       */
      /**
       * Focuses the panel header. Implemented as a part of `FocusableOption`.
       * \@docs-private
       * @param {?=} origin Origin of the action that triggered the focus.
       * @return {?}
       */
      MatExpansionPanelHeader.prototype.focus = /**
       * Focuses the panel header. Implemented as a part of `FocusableOption`.
       * \@docs-private
       * @param {?=} origin Origin of the action that triggered the focus.
       * @return {?}
       */
          function (origin) {
              if (origin === void 0) {
                  origin = 'program';
              }
              this._focusMonitor.focusVia(this._element, origin);
          };
      /**
       * @return {?}
       */
      MatExpansionPanelHeader.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._parentChangeSubscription.unsubscribe();
              this._focusMonitor.stopMonitoring(this._element);
          };
      MatExpansionPanelHeader.decorators = [
          { type: core.Component, args: [{ selector: 'mat-expansion-panel-header',
                      styles: [".mat-expansion-panel-header{display:flex;flex-direction:row;align-items:center;padding:0 24px;border-radius:inherit}.mat-expansion-panel-header:focus,.mat-expansion-panel-header:hover{outline:0}.mat-expansion-panel-header.mat-expanded:focus,.mat-expansion-panel-header.mat-expanded:hover{background:inherit}.mat-expansion-panel-header:not([aria-disabled=true]){cursor:pointer}.mat-content{display:flex;flex:1;flex-direction:row;overflow:hidden}.mat-expansion-panel-header-description,.mat-expansion-panel-header-title{display:flex;flex-grow:1;margin-right:16px}[dir=rtl] .mat-expansion-panel-header-description,[dir=rtl] .mat-expansion-panel-header-title{margin-right:0;margin-left:16px}.mat-expansion-panel-header-description{flex-grow:2}.mat-expansion-indicator::after{border-style:solid;border-width:0 2px 2px 0;content:'';display:inline-block;padding:3px;transform:rotate(45deg);vertical-align:middle}"],
                      template: "<span class=\"mat-content\"><ng-content select=\"mat-panel-title\"></ng-content><ng-content select=\"mat-panel-description\"></ng-content><ng-content></ng-content></span><span [@indicatorRotate]=\"_getExpandedState()\" *ngIf=\"_showToggle()\" class=\"mat-expansion-indicator\"></span>",
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      animations: [
                          matExpansionAnimations.indicatorRotate,
                          matExpansionAnimations.expansionHeaderHeight
                      ],
                      host: {
                          'class': 'mat-expansion-panel-header',
                          'role': 'button',
                          '[attr.id]': 'panel._headerId',
                          '[attr.tabindex]': 'disabled ? -1 : 0',
                          '[attr.aria-controls]': '_getPanelId()',
                          '[attr.aria-expanded]': '_isExpanded()',
                          '[attr.aria-disabled]': 'panel.disabled',
                          '[class.mat-expanded]': '_isExpanded()',
                          '(click)': '_toggle()',
                          '(keydown)': '_keydown($event)',
                          '[@expansionHeight]': "{\n        value: _getExpandedState(),\n        params: {\n          collapsedHeight: collapsedHeight,\n          expandedHeight: expandedHeight\n        }\n    }",
                      },
                  },] },
      ];
      /** @nocollapse */
      MatExpansionPanelHeader.ctorParameters = function () {
          return [
              { type: MatExpansionPanel, decorators: [{ type: core.Host }] },
              { type: core.ElementRef },
              { type: FocusMonitor },
              { type: core.ChangeDetectorRef },
              { type: undefined, decorators: [{ type: core.Inject, args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS,] }, { type: core.Optional }] }
          ];
      };
      MatExpansionPanelHeader.propDecorators = {
          expandedHeight: [{ type: core.Input }],
          collapsedHeight: [{ type: core.Input }]
      };
      return MatExpansionPanelHeader;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Directive for a Material Design Accordion.
   */
  var MatAccordion = /** @class */ (function (_super) {
      tslib_1.__extends(MatAccordion, _super);
      function MatAccordion() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this._hideToggle = false;
          /**
           * Display mode used for all expansion panels in the accordion. Currently two display
           * modes exist:
           *  default - a gutter-like spacing is placed around any expanded panel, placing the expanded
           *     panel at a different elevation from the rest of the accordion.
           *  flat - no spacing is placed around expanded panels, showing all panels at the same
           *     elevation.
           */
          _this.displayMode = 'default';
          return _this;
      }
      Object.defineProperty(MatAccordion.prototype, "hideToggle", {
          /** Whether the expansion indicator should be hidden. */
          get: /**
           * Whether the expansion indicator should be hidden.
           * @return {?}
           */ function () { return this._hideToggle; },
          set: /**
           * @param {?} show
           * @return {?}
           */ function (show) { this._hideToggle = coerceBooleanProperty(show); },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatAccordion.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this._keyManager = new FocusKeyManager(this._headers).withWrap();
          };
      /** Handles keyboard events coming in from the panel headers. */
      /**
       * Handles keyboard events coming in from the panel headers.
       * @param {?} event
       * @return {?}
       */
      MatAccordion.prototype._handleHeaderKeydown = /**
       * Handles keyboard events coming in from the panel headers.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              var keyCode = event.keyCode;
              /** @type {?} */
              var manager = this._keyManager;
              if (keyCode === HOME) {
                  manager.setFirstItemActive();
                  event.preventDefault();
              }
              else if (keyCode === END) {
                  manager.setLastItemActive();
                  event.preventDefault();
              }
              else {
                  this._keyManager.onKeydown(event);
              }
          };
      /**
       * @param {?} header
       * @return {?}
       */
      MatAccordion.prototype._handleHeaderFocus = /**
       * @param {?} header
       * @return {?}
       */
          function (header) {
              this._keyManager.updateActiveItem(header);
          };
      MatAccordion.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-accordion',
                      exportAs: 'matAccordion',
                      inputs: ['multi'],
                      providers: [{
                              provide: MAT_ACCORDION,
                              useExisting: MatAccordion
                          }],
                      host: {
                          class: 'mat-accordion'
                      }
                  },] },
      ];
      MatAccordion.propDecorators = {
          _headers: [{ type: core.ContentChildren, args: [MatExpansionPanelHeader, { descendants: true },] }],
          hideToggle: [{ type: core.Input }],
          displayMode: [{ type: core.Input }]
      };
      return MatAccordion;
  }(CdkAccordion));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token used to provide a grid list to a tile and to avoid circular imports.
   * \@docs-private
   * @type {?}
   */
  var MAT_GRID_LIST = new core.InjectionToken('MAT_GRID_LIST');
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var MatGridTile = /** @class */ (function () {
      function MatGridTile(_element, _gridList) {
          this._element = _element;
          this._gridList = _gridList;
          this._rowspan = 1;
          this._colspan = 1;
      }
      Object.defineProperty(MatGridTile.prototype, "rowspan", {
          /** Amount of rows that the grid tile takes up. */
          get: /**
           * Amount of rows that the grid tile takes up.
           * @return {?}
           */ function () { return this._rowspan; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._rowspan = Math.round(coerceNumberProperty(value)); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatGridTile.prototype, "colspan", {
          /** Amount of columns that the grid tile takes up. */
          get: /**
           * Amount of columns that the grid tile takes up.
           * @return {?}
           */ function () { return this._colspan; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._colspan = Math.round(coerceNumberProperty(value)); },
          enumerable: true,
          configurable: true
      });
      /**
       * Sets the style of the grid-tile element.  Needs to be set manually to avoid
       * "Changed after checked" errors that would occur with HostBinding.
       */
      /**
       * Sets the style of the grid-tile element.  Needs to be set manually to avoid
       * "Changed after checked" errors that would occur with HostBinding.
       * @param {?} property
       * @param {?} value
       * @return {?}
       */
      MatGridTile.prototype._setStyle = /**
       * Sets the style of the grid-tile element.  Needs to be set manually to avoid
       * "Changed after checked" errors that would occur with HostBinding.
       * @param {?} property
       * @param {?} value
       * @return {?}
       */
          function (property, value) {
              (( /** @type {?} */(this._element.nativeElement.style)))[property] = value;
          };
      MatGridTile.decorators = [
          { type: core.Component, args: [{ selector: 'mat-grid-tile',
                      exportAs: 'matGridTile',
                      host: {
                          'class': 'mat-grid-tile',
                      },
                      template: "<figure class=\"mat-figure\"><ng-content></ng-content></figure>",
                      styles: [".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-figure{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}.mat-grid-tile .mat-grid-tile-footer,.mat-grid-tile .mat-grid-tile-header{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-footer>*,.mat-grid-tile .mat-grid-tile-header>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-tile-footer.mat-2-line,.mat-grid-tile .mat-grid-tile-header.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}"],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatGridTile.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_GRID_LIST,] }] }
          ];
      };
      MatGridTile.propDecorators = {
          rowspan: [{ type: core.Input }],
          colspan: [{ type: core.Input }]
      };
      return MatGridTile;
  }());
  var MatGridTileText = /** @class */ (function () {
      function MatGridTileText(_element) {
          this._element = _element;
      }
      /**
       * @return {?}
       */
      MatGridTileText.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              setLines(this._lines, this._element);
          };
      MatGridTileText.decorators = [
          { type: core.Component, args: [{ selector: 'mat-grid-tile-header, mat-grid-tile-footer',
                      template: "<ng-content select=\"[mat-grid-avatar], [matGridAvatar]\"></ng-content><div class=\"mat-grid-list-text\"><ng-content select=\"[mat-line], [matLine]\"></ng-content></div><ng-content></ng-content>",
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                  },] },
      ];
      /** @nocollapse */
      MatGridTileText.ctorParameters = function () {
          return [
              { type: core.ElementRef }
          ];
      };
      MatGridTileText.propDecorators = {
          _lines: [{ type: core.ContentChildren, args: [MatLine,] }]
      };
      return MatGridTileText;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Class for determining, from a list of tiles, the (row, col) position of each of those tiles
   * in the grid. This is necessary (rather than just rendering the tiles in normal document flow)
   * because the tiles can have a rowspan.
   *
   * The positioning algorithm greedily places each tile as soon as it encounters a gap in the grid
   * large enough to accommodate it so that the tiles still render in the same order in which they
   * are given.
   *
   * The basis of the algorithm is the use of an array to track the already placed tiles. Each
   * element of the array corresponds to a column, and the value indicates how many cells in that
   * column are already occupied; zero indicates an empty cell. Moving "down" to the next row
   * decrements each value in the tracking array (indicating that the column is one cell closer to
   * being free).
   *
   * \@docs-private
   */
  var /**
   * Class for determining, from a list of tiles, the (row, col) position of each of those tiles
   * in the grid. This is necessary (rather than just rendering the tiles in normal document flow)
   * because the tiles can have a rowspan.
   *
   * The positioning algorithm greedily places each tile as soon as it encounters a gap in the grid
   * large enough to accommodate it so that the tiles still render in the same order in which they
   * are given.
   *
   * The basis of the algorithm is the use of an array to track the already placed tiles. Each
   * element of the array corresponds to a column, and the value indicates how many cells in that
   * column are already occupied; zero indicates an empty cell. Moving "down" to the next row
   * decrements each value in the tracking array (indicating that the column is one cell closer to
   * being free).
   *
   * \@docs-private
   */ TileCoordinator = /** @class */ (function () {
      function TileCoordinator() {
          /**
           * Index at which the search for the next gap will start.
           */
          this.columnIndex = 0;
          /**
           * The current row index.
           */
          this.rowIndex = 0;
      }
      Object.defineProperty(TileCoordinator.prototype, "rowCount", {
          /** Gets the total number of rows occupied by tiles */
          get: /**
           * Gets the total number of rows occupied by tiles
           * @return {?}
           */ function () { return this.rowIndex + 1; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(TileCoordinator.prototype, "rowspan", {
          /**
           * Gets the total span of rows occupied by tiles.
           * Ex: A list with 1 row that contains a tile with rowspan 2 will have a total rowspan of 2.
           */
          get: /**
           * Gets the total span of rows occupied by tiles.
           * Ex: A list with 1 row that contains a tile with rowspan 2 will have a total rowspan of 2.
           * @return {?}
           */ function () {
              /** @type {?} */
              var lastRowMax = Math.max.apply(Math, this.tracker);
              // if any of the tiles has a rowspan that pushes it beyond the total row count,
              // add the difference to the rowcount
              return lastRowMax > 1 ? this.rowCount + lastRowMax - 1 : this.rowCount;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Updates the tile positions.
       * @param numColumns Amount of columns in the grid.
       */
      /**
       * Updates the tile positions.
       * @param {?} numColumns Amount of columns in the grid.
       * @param {?} tiles
       * @return {?}
       */
      TileCoordinator.prototype.update = /**
       * Updates the tile positions.
       * @param {?} numColumns Amount of columns in the grid.
       * @param {?} tiles
       * @return {?}
       */
          function (numColumns, tiles) {
              var _this = this;
              this.columnIndex = 0;
              this.rowIndex = 0;
              this.tracker = new Array(numColumns);
              this.tracker.fill(0, 0, this.tracker.length);
              this.positions = tiles.map(function (tile) { return _this._trackTile(tile); });
          };
      /** Calculates the row and col position of a tile. */
      /**
       * Calculates the row and col position of a tile.
       * @private
       * @param {?} tile
       * @return {?}
       */
      TileCoordinator.prototype._trackTile = /**
       * Calculates the row and col position of a tile.
       * @private
       * @param {?} tile
       * @return {?}
       */
          function (tile) {
              // Find a gap large enough for this tile.
              /** @type {?} */
              var gapStartIndex = this._findMatchingGap(tile.colspan);
              // Place tile in the resulting gap.
              this._markTilePosition(gapStartIndex, tile);
              // The next time we look for a gap, the search will start at columnIndex, which should be
              // immediately after the tile that has just been placed.
              this.columnIndex = gapStartIndex + tile.colspan;
              return new TilePosition(this.rowIndex, gapStartIndex);
          };
      /** Finds the next available space large enough to fit the tile. */
      /**
       * Finds the next available space large enough to fit the tile.
       * @private
       * @param {?} tileCols
       * @return {?}
       */
      TileCoordinator.prototype._findMatchingGap = /**
       * Finds the next available space large enough to fit the tile.
       * @private
       * @param {?} tileCols
       * @return {?}
       */
          function (tileCols) {
              if (tileCols > this.tracker.length) {
                  throw Error("mat-grid-list: tile with colspan " + tileCols + " is wider than " +
                      ("grid with cols=\"" + this.tracker.length + "\"."));
              }
              // Start index is inclusive, end index is exclusive.
              /** @type {?} */
              var gapStartIndex = -1;
              /** @type {?} */
              var gapEndIndex = -1;
              // Look for a gap large enough to fit the given tile. Empty spaces are marked with a zero.
              do {
                  // If we've reached the end of the row, go to the next row.
                  if (this.columnIndex + tileCols > this.tracker.length) {
                      this._nextRow();
                      gapStartIndex = this.tracker.indexOf(0, this.columnIndex);
                      gapEndIndex = this._findGapEndIndex(gapStartIndex);
                      continue;
                  }
                  gapStartIndex = this.tracker.indexOf(0, this.columnIndex);
                  // If there are no more empty spaces in this row at all, move on to the next row.
                  if (gapStartIndex == -1) {
                      this._nextRow();
                      gapStartIndex = this.tracker.indexOf(0, this.columnIndex);
                      gapEndIndex = this._findGapEndIndex(gapStartIndex);
                      continue;
                  }
                  gapEndIndex = this._findGapEndIndex(gapStartIndex);
                  // If a gap large enough isn't found, we want to start looking immediately after the current
                  // gap on the next iteration.
                  this.columnIndex = gapStartIndex + 1;
                  // Continue iterating until we find a gap wide enough for this tile. Since gapEndIndex is
                  // exclusive, gapEndIndex is 0 means we didn't find a gap and should continue.
              } while ((gapEndIndex - gapStartIndex < tileCols) || (gapEndIndex == 0));
              // If we still didn't manage to find a gap, ensure that the index is
              // at least zero so the tile doesn't get pulled out of the grid.
              return Math.max(gapStartIndex, 0);
          };
      /** Move "down" to the next row. */
      /**
       * Move "down" to the next row.
       * @private
       * @return {?}
       */
      TileCoordinator.prototype._nextRow = /**
       * Move "down" to the next row.
       * @private
       * @return {?}
       */
          function () {
              this.columnIndex = 0;
              this.rowIndex++;
              // Decrement all spaces by one to reflect moving down one row.
              for (var i = 0; i < this.tracker.length; i++) {
                  this.tracker[i] = Math.max(0, this.tracker[i] - 1);
              }
          };
      /**
       * Finds the end index (exclusive) of a gap given the index from which to start looking.
       * The gap ends when a non-zero value is found.
       */
      /**
       * Finds the end index (exclusive) of a gap given the index from which to start looking.
       * The gap ends when a non-zero value is found.
       * @private
       * @param {?} gapStartIndex
       * @return {?}
       */
      TileCoordinator.prototype._findGapEndIndex = /**
       * Finds the end index (exclusive) of a gap given the index from which to start looking.
       * The gap ends when a non-zero value is found.
       * @private
       * @param {?} gapStartIndex
       * @return {?}
       */
          function (gapStartIndex) {
              for (var i = gapStartIndex + 1; i < this.tracker.length; i++) {
                  if (this.tracker[i] != 0) {
                      return i;
                  }
              }
              // The gap ends with the end of the row.
              return this.tracker.length;
          };
      /** Update the tile tracker to account for the given tile in the given space. */
      /**
       * Update the tile tracker to account for the given tile in the given space.
       * @private
       * @param {?} start
       * @param {?} tile
       * @return {?}
       */
      TileCoordinator.prototype._markTilePosition = /**
       * Update the tile tracker to account for the given tile in the given space.
       * @private
       * @param {?} start
       * @param {?} tile
       * @return {?}
       */
          function (start, tile) {
              for (var i = 0; i < tile.colspan; i++) {
                  this.tracker[start + i] = tile.rowspan;
              }
          };
      return TileCoordinator;
  }());
  /**
   * Simple data structure for tile position (row, col).
   * \@docs-private
   */
  var /**
   * Simple data structure for tile position (row, col).
   * \@docs-private
   */ TilePosition = /** @class */ (function () {
      function TilePosition(row, col) {
          this.row = row;
          this.col = col;
      }
      return TilePosition;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * RegExp that can be used to check whether a value will
   * be allowed inside a CSS `calc()` expression.
   * @type {?}
   */
  var cssCalcAllowedValue = /^-?\d+((\.\d+)?[A-Za-z%$]?)+$/;
  /**
   * Sets the style properties for an individual tile, given the position calculated by the
   * Tile Coordinator.
   * \@docs-private
   * @abstract
   */
  var /**
   * Sets the style properties for an individual tile, given the position calculated by the
   * Tile Coordinator.
   * \@docs-private
   * @abstract
   */ TileStyler = /** @class */ (function () {
      function TileStyler() {
          this._rows = 0;
          this._rowspan = 0;
      }
      /**
       * Adds grid-list layout info once it is available. Cannot be processed in the constructor
       * because these properties haven't been calculated by that point.
       *
       * @param gutterSize Size of the grid's gutter.
       * @param tracker Instance of the TileCoordinator.
       * @param cols Amount of columns in the grid.
       * @param direction Layout direction of the grid.
       */
      /**
       * Adds grid-list layout info once it is available. Cannot be processed in the constructor
       * because these properties haven't been calculated by that point.
       *
       * @param {?} gutterSize Size of the grid's gutter.
       * @param {?} tracker Instance of the TileCoordinator.
       * @param {?} cols Amount of columns in the grid.
       * @param {?} direction Layout direction of the grid.
       * @return {?}
       */
      TileStyler.prototype.init = /**
       * Adds grid-list layout info once it is available. Cannot be processed in the constructor
       * because these properties haven't been calculated by that point.
       *
       * @param {?} gutterSize Size of the grid's gutter.
       * @param {?} tracker Instance of the TileCoordinator.
       * @param {?} cols Amount of columns in the grid.
       * @param {?} direction Layout direction of the grid.
       * @return {?}
       */
          function (gutterSize, tracker, cols, direction) {
              this._gutterSize = normalizeUnits(gutterSize);
              this._rows = tracker.rowCount;
              this._rowspan = tracker.rowspan;
              this._cols = cols;
              this._direction = direction;
          };
      /**
       * Computes the amount of space a single 1x1 tile would take up (width or height).
       * Used as a basis for other calculations.
       * @param sizePercent Percent of the total grid-list space that one 1x1 tile would take up.
       * @param gutterFraction Fraction of the gutter size taken up by one 1x1 tile.
       * @return The size of a 1x1 tile as an expression that can be evaluated via CSS calc().
       */
      /**
       * Computes the amount of space a single 1x1 tile would take up (width or height).
       * Used as a basis for other calculations.
       * @param {?} sizePercent Percent of the total grid-list space that one 1x1 tile would take up.
       * @param {?} gutterFraction Fraction of the gutter size taken up by one 1x1 tile.
       * @return {?} The size of a 1x1 tile as an expression that can be evaluated via CSS calc().
       */
      TileStyler.prototype.getBaseTileSize = /**
       * Computes the amount of space a single 1x1 tile would take up (width or height).
       * Used as a basis for other calculations.
       * @param {?} sizePercent Percent of the total grid-list space that one 1x1 tile would take up.
       * @param {?} gutterFraction Fraction of the gutter size taken up by one 1x1 tile.
       * @return {?} The size of a 1x1 tile as an expression that can be evaluated via CSS calc().
       */
          function (sizePercent, gutterFraction) {
              // Take the base size percent (as would be if evenly dividing the size between cells),
              // and then subtracting the size of one gutter. However, since there are no gutters on the
              // edges, each tile only uses a fraction (gutterShare = numGutters / numCells) of the gutter
              // size. (Imagine having one gutter per tile, and then breaking up the extra gutter on the
              // edge evenly among the cells).
              return "(" + sizePercent + "% - (" + this._gutterSize + " * " + gutterFraction + "))";
          };
      /**
       * Gets The horizontal or vertical position of a tile, e.g., the 'top' or 'left' property value.
       * @param offset Number of tiles that have already been rendered in the row/column.
       * @param baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).
       * @return Position of the tile as a CSS calc() expression.
       */
      /**
       * Gets The horizontal or vertical position of a tile, e.g., the 'top' or 'left' property value.
       * @param {?} baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).
       * @param {?} offset Number of tiles that have already been rendered in the row/column.
       * @return {?} Position of the tile as a CSS calc() expression.
       */
      TileStyler.prototype.getTilePosition = /**
       * Gets The horizontal or vertical position of a tile, e.g., the 'top' or 'left' property value.
       * @param {?} baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).
       * @param {?} offset Number of tiles that have already been rendered in the row/column.
       * @return {?} Position of the tile as a CSS calc() expression.
       */
          function (baseSize, offset) {
              // The position comes the size of a 1x1 tile plus gutter for each previous tile in the
              // row/column (offset).
              return offset === 0 ? '0' : calc("(" + baseSize + " + " + this._gutterSize + ") * " + offset);
          };
      /**
       * Gets the actual size of a tile, e.g., width or height, taking rowspan or colspan into account.
       * @param baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).
       * @param span The tile's rowspan or colspan.
       * @return Size of the tile as a CSS calc() expression.
       */
      /**
       * Gets the actual size of a tile, e.g., width or height, taking rowspan or colspan into account.
       * @param {?} baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).
       * @param {?} span The tile's rowspan or colspan.
       * @return {?} Size of the tile as a CSS calc() expression.
       */
      TileStyler.prototype.getTileSize = /**
       * Gets the actual size of a tile, e.g., width or height, taking rowspan or colspan into account.
       * @param {?} baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).
       * @param {?} span The tile's rowspan or colspan.
       * @return {?} Size of the tile as a CSS calc() expression.
       */
          function (baseSize, span) {
              return "(" + baseSize + " * " + span + ") + (" + (span - 1) + " * " + this._gutterSize + ")";
          };
      /**
       * Sets the style properties to be applied to a tile for the given row and column index.
       * @param tile Tile to which to apply the styling.
       * @param rowIndex Index of the tile's row.
       * @param colIndex Index of the tile's column.
       */
      /**
       * Sets the style properties to be applied to a tile for the given row and column index.
       * @param {?} tile Tile to which to apply the styling.
       * @param {?} rowIndex Index of the tile's row.
       * @param {?} colIndex Index of the tile's column.
       * @return {?}
       */
      TileStyler.prototype.setStyle = /**
       * Sets the style properties to be applied to a tile for the given row and column index.
       * @param {?} tile Tile to which to apply the styling.
       * @param {?} rowIndex Index of the tile's row.
       * @param {?} colIndex Index of the tile's column.
       * @return {?}
       */
          function (tile, rowIndex, colIndex) {
              // Percent of the available horizontal space that one column takes up.
              /** @type {?} */
              var percentWidthPerTile = 100 / this._cols;
              // Fraction of the vertical gutter size that each column takes up.
              // For example, if there are 5 columns, each column uses 4/5 = 0.8 times the gutter width.
              /** @type {?} */
              var gutterWidthFractionPerTile = (this._cols - 1) / this._cols;
              this.setColStyles(tile, colIndex, percentWidthPerTile, gutterWidthFractionPerTile);
              this.setRowStyles(tile, rowIndex, percentWidthPerTile, gutterWidthFractionPerTile);
          };
      /** Sets the horizontal placement of the tile in the list. */
      /**
       * Sets the horizontal placement of the tile in the list.
       * @param {?} tile
       * @param {?} colIndex
       * @param {?} percentWidth
       * @param {?} gutterWidth
       * @return {?}
       */
      TileStyler.prototype.setColStyles = /**
       * Sets the horizontal placement of the tile in the list.
       * @param {?} tile
       * @param {?} colIndex
       * @param {?} percentWidth
       * @param {?} gutterWidth
       * @return {?}
       */
          function (tile, colIndex, percentWidth, gutterWidth) {
              // Base horizontal size of a column.
              /** @type {?} */
              var baseTileWidth = this.getBaseTileSize(percentWidth, gutterWidth);
              // The width and horizontal position of each tile is always calculated the same way, but the
              // height and vertical position depends on the rowMode.
              /** @type {?} */
              var side = this._direction === 'rtl' ? 'right' : 'left';
              tile._setStyle(side, this.getTilePosition(baseTileWidth, colIndex));
              tile._setStyle('width', calc(this.getTileSize(baseTileWidth, tile.colspan)));
          };
      /**
       * Calculates the total size taken up by gutters across one axis of a list.
       */
      /**
       * Calculates the total size taken up by gutters across one axis of a list.
       * @return {?}
       */
      TileStyler.prototype.getGutterSpan = /**
       * Calculates the total size taken up by gutters across one axis of a list.
       * @return {?}
       */
          function () {
              return this._gutterSize + " * (" + this._rowspan + " - 1)";
          };
      /**
       * Calculates the total size taken up by tiles across one axis of a list.
       * @param tileHeight Height of the tile.
       */
      /**
       * Calculates the total size taken up by tiles across one axis of a list.
       * @param {?} tileHeight Height of the tile.
       * @return {?}
       */
      TileStyler.prototype.getTileSpan = /**
       * Calculates the total size taken up by tiles across one axis of a list.
       * @param {?} tileHeight Height of the tile.
       * @return {?}
       */
          function (tileHeight) {
              return this._rowspan + " * " + this.getTileSize(tileHeight, 1);
          };
      /**
       * Calculates the computed height and returns the correct style property to set.
       * This method can be implemented by each type of TileStyler.
       * @docs-private
       */
      /**
       * Calculates the computed height and returns the correct style property to set.
       * This method can be implemented by each type of TileStyler.
       * \@docs-private
       * @return {?}
       */
      TileStyler.prototype.getComputedHeight = /**
       * Calculates the computed height and returns the correct style property to set.
       * This method can be implemented by each type of TileStyler.
       * \@docs-private
       * @return {?}
       */
          function () { return null; };
      return TileStyler;
  }());
  /**
   * This type of styler is instantiated when the user passes in a fixed row height.
   * Example `<mat-grid-list cols="3" rowHeight="100px">`
   * \@docs-private
   */
  var /**
   * This type of styler is instantiated when the user passes in a fixed row height.
   * Example `<mat-grid-list cols="3" rowHeight="100px">`
   * \@docs-private
   */ FixedTileStyler = /** @class */ (function (_super) {
      tslib_1.__extends(FixedTileStyler, _super);
      function FixedTileStyler(fixedRowHeight) {
          var _this = _super.call(this) || this;
          _this.fixedRowHeight = fixedRowHeight;
          return _this;
      }
      /**
       * @param {?} gutterSize
       * @param {?} tracker
       * @param {?} cols
       * @param {?} direction
       * @return {?}
       */
      FixedTileStyler.prototype.init = /**
       * @param {?} gutterSize
       * @param {?} tracker
       * @param {?} cols
       * @param {?} direction
       * @return {?}
       */
          function (gutterSize, tracker, cols, direction) {
              _super.prototype.init.call(this, gutterSize, tracker, cols, direction);
              this.fixedRowHeight = normalizeUnits(this.fixedRowHeight);
              if (!cssCalcAllowedValue.test(this.fixedRowHeight)) {
                  throw Error("Invalid value \"" + this.fixedRowHeight + "\" set as rowHeight.");
              }
          };
      /**
       * @param {?} tile
       * @param {?} rowIndex
       * @return {?}
       */
      FixedTileStyler.prototype.setRowStyles = /**
       * @param {?} tile
       * @param {?} rowIndex
       * @return {?}
       */
          function (tile, rowIndex) {
              tile._setStyle('top', this.getTilePosition(this.fixedRowHeight, rowIndex));
              tile._setStyle('height', calc(this.getTileSize(this.fixedRowHeight, tile.rowspan)));
          };
      /**
       * @return {?}
       */
      FixedTileStyler.prototype.getComputedHeight = /**
       * @return {?}
       */
          function () {
              return [
                  'height', calc(this.getTileSpan(this.fixedRowHeight) + " + " + this.getGutterSpan())
              ];
          };
      /**
       * @param {?} list
       * @return {?}
       */
      FixedTileStyler.prototype.reset = /**
       * @param {?} list
       * @return {?}
       */
          function (list) {
              list._setListStyle(['height', null]);
              if (list._tiles) {
                  list._tiles.forEach(function (tile) {
                      tile._setStyle('top', null);
                      tile._setStyle('height', null);
                  });
              }
          };
      return FixedTileStyler;
  }(TileStyler));
  /**
   * This type of styler is instantiated when the user passes in a width:height ratio
   * for the row height.  Example `<mat-grid-list cols="3" rowHeight="3:1">`
   * \@docs-private
   */
  var /**
   * This type of styler is instantiated when the user passes in a width:height ratio
   * for the row height.  Example `<mat-grid-list cols="3" rowHeight="3:1">`
   * \@docs-private
   */ RatioTileStyler = /** @class */ (function (_super) {
      tslib_1.__extends(RatioTileStyler, _super);
      function RatioTileStyler(value) {
          var _this = _super.call(this) || this;
          _this._parseRatio(value);
          return _this;
      }
      /**
       * @param {?} tile
       * @param {?} rowIndex
       * @param {?} percentWidth
       * @param {?} gutterWidth
       * @return {?}
       */
      RatioTileStyler.prototype.setRowStyles = /**
       * @param {?} tile
       * @param {?} rowIndex
       * @param {?} percentWidth
       * @param {?} gutterWidth
       * @return {?}
       */
          function (tile, rowIndex, percentWidth, gutterWidth) {
              /** @type {?} */
              var percentHeightPerTile = percentWidth / this.rowHeightRatio;
              this.baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterWidth);
              // Use padding-top and margin-top to maintain the given aspect ratio, as
              // a percentage-based value for these properties is applied versus the *width* of the
              // containing block. See http://www.w3.org/TR/CSS2/box.html#margin-properties
              tile._setStyle('marginTop', this.getTilePosition(this.baseTileHeight, rowIndex));
              tile._setStyle('paddingTop', calc(this.getTileSize(this.baseTileHeight, tile.rowspan)));
          };
      /**
       * @return {?}
       */
      RatioTileStyler.prototype.getComputedHeight = /**
       * @return {?}
       */
          function () {
              return [
                  'paddingBottom', calc(this.getTileSpan(this.baseTileHeight) + " + " + this.getGutterSpan())
              ];
          };
      /**
       * @param {?} list
       * @return {?}
       */
      RatioTileStyler.prototype.reset = /**
       * @param {?} list
       * @return {?}
       */
          function (list) {
              list._setListStyle(['paddingBottom', null]);
              list._tiles.forEach(function (tile) {
                  tile._setStyle('marginTop', null);
                  tile._setStyle('paddingTop', null);
              });
          };
      /**
       * @private
       * @param {?} value
       * @return {?}
       */
      RatioTileStyler.prototype._parseRatio = /**
       * @private
       * @param {?} value
       * @return {?}
       */
          function (value) {
              /** @type {?} */
              var ratioParts = value.split(':');
              if (ratioParts.length !== 2) {
                  throw Error("mat-grid-list: invalid ratio given for row-height: \"" + value + "\"");
              }
              this.rowHeightRatio = parseFloat(ratioParts[0]) / parseFloat(ratioParts[1]);
          };
      return RatioTileStyler;
  }(TileStyler));
  /**
   * This type of styler is instantiated when the user selects a "fit" row height mode.
   * In other words, the row height will reflect the total height of the container divided
   * by the number of rows.  Example `<mat-grid-list cols="3" rowHeight="fit">`
   *
   * \@docs-private
   */
  var /**
   * This type of styler is instantiated when the user selects a "fit" row height mode.
   * In other words, the row height will reflect the total height of the container divided
   * by the number of rows.  Example `<mat-grid-list cols="3" rowHeight="fit">`
   *
   * \@docs-private
   */ FitTileStyler = /** @class */ (function (_super) {
      tslib_1.__extends(FitTileStyler, _super);
      function FitTileStyler() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * @param {?} tile
       * @param {?} rowIndex
       * @return {?}
       */
      FitTileStyler.prototype.setRowStyles = /**
       * @param {?} tile
       * @param {?} rowIndex
       * @return {?}
       */
          function (tile, rowIndex) {
              // Percent of the available vertical space that one row takes up.
              /** @type {?} */
              var percentHeightPerTile = 100 / this._rowspan;
              // Fraction of the horizontal gutter size that each column takes up.
              /** @type {?} */
              var gutterHeightPerTile = (this._rows - 1) / this._rows;
              // Base vertical size of a column.
              /** @type {?} */
              var baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterHeightPerTile);
              tile._setStyle('top', this.getTilePosition(baseTileHeight, rowIndex));
              tile._setStyle('height', calc(this.getTileSize(baseTileHeight, tile.rowspan)));
          };
      /**
       * @param {?} list
       * @return {?}
       */
      FitTileStyler.prototype.reset = /**
       * @param {?} list
       * @return {?}
       */
          function (list) {
              if (list._tiles) {
                  list._tiles.forEach(function (tile) {
                      tile._setStyle('top', null);
                      tile._setStyle('height', null);
                  });
              }
          };
      return FitTileStyler;
  }(TileStyler));
  /**
   * Wraps a CSS string in a calc function
   * @param {?} exp
   * @return {?}
   */
  function calc(exp) {
      return "calc(" + exp + ")";
  }
  /**
   * Appends pixels to a CSS string if no units are given.
   * @param {?} value
   * @return {?}
   */
  function normalizeUnits(value) {
      return value.match(/([A-Za-z%]+)$/) ? value : value + "px";
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // TODO(kara): Conditional (responsive) column count / row size.
  // TODO(kara): Re-layout on window resize / media change (debounced).
  // TODO(kara): gridTileHeader and gridTileFooter.
  /** @type {?} */
  var MAT_FIT_MODE = 'fit';
  var MatGridList = /** @class */ (function () {
      function MatGridList(_element, _dir) {
          this._element = _element;
          this._dir = _dir;
          /**
           * The amount of space between tiles. This will be something like '5px' or '2em'.
           */
          this._gutter = '1px';
      }
      Object.defineProperty(MatGridList.prototype, "cols", {
          /** Amount of columns in the grid list. */
          get: /**
           * Amount of columns in the grid list.
           * @return {?}
           */ function () { return this._cols; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._cols = Math.max(1, Math.round(coerceNumberProperty(value)));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatGridList.prototype, "gutterSize", {
          /** Size of the grid list's gutter in pixels. */
          get: /**
           * Size of the grid list's gutter in pixels.
           * @return {?}
           */ function () { return this._gutter; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._gutter = "" + (value == null ? '' : value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatGridList.prototype, "rowHeight", {
          /** Set internal representation of row height from the user-provided value. */
          get: /**
           * Set internal representation of row height from the user-provided value.
           * @return {?}
           */ function () { return this._rowHeight; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var newValue = "" + (value == null ? '' : value);
              if (newValue !== this._rowHeight) {
                  this._rowHeight = newValue;
                  this._setTileStyler(this._rowHeight);
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatGridList.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              this._checkCols();
              this._checkRowHeight();
          };
      /**
       * The layout calculation is fairly cheap if nothing changes, so there's little cost
       * to run it frequently.
       */
      /**
       * The layout calculation is fairly cheap if nothing changes, so there's little cost
       * to run it frequently.
       * @return {?}
       */
      MatGridList.prototype.ngAfterContentChecked = /**
       * The layout calculation is fairly cheap if nothing changes, so there's little cost
       * to run it frequently.
       * @return {?}
       */
          function () {
              this._layoutTiles();
          };
      /** Throw a friendly error if cols property is missing */
      /**
       * Throw a friendly error if cols property is missing
       * @private
       * @return {?}
       */
      MatGridList.prototype._checkCols = /**
       * Throw a friendly error if cols property is missing
       * @private
       * @return {?}
       */
          function () {
              if (!this.cols) {
                  throw Error("mat-grid-list: must pass in number of columns. " +
                      "Example: <mat-grid-list cols=\"3\">");
              }
          };
      /** Default to equal width:height if rowHeight property is missing */
      /**
       * Default to equal width:height if rowHeight property is missing
       * @private
       * @return {?}
       */
      MatGridList.prototype._checkRowHeight = /**
       * Default to equal width:height if rowHeight property is missing
       * @private
       * @return {?}
       */
          function () {
              if (!this._rowHeight) {
                  this._setTileStyler('1:1');
              }
          };
      /** Creates correct Tile Styler subtype based on rowHeight passed in by user */
      /**
       * Creates correct Tile Styler subtype based on rowHeight passed in by user
       * @private
       * @param {?} rowHeight
       * @return {?}
       */
      MatGridList.prototype._setTileStyler = /**
       * Creates correct Tile Styler subtype based on rowHeight passed in by user
       * @private
       * @param {?} rowHeight
       * @return {?}
       */
          function (rowHeight) {
              if (this._tileStyler) {
                  this._tileStyler.reset(this);
              }
              if (rowHeight === MAT_FIT_MODE) {
                  this._tileStyler = new FitTileStyler();
              }
              else if (rowHeight && rowHeight.indexOf(':') > -1) {
                  this._tileStyler = new RatioTileStyler(rowHeight);
              }
              else {
                  this._tileStyler = new FixedTileStyler(rowHeight);
              }
          };
      /** Computes and applies the size and position for all children grid tiles. */
      /**
       * Computes and applies the size and position for all children grid tiles.
       * @private
       * @return {?}
       */
      MatGridList.prototype._layoutTiles = /**
       * Computes and applies the size and position for all children grid tiles.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this._tileCoordinator) {
                  this._tileCoordinator = new TileCoordinator();
              }
              /** @type {?} */
              var tracker = this._tileCoordinator;
              /** @type {?} */
              var tiles = this._tiles.filter(function (tile) { return !tile._gridList || tile._gridList === _this; });
              /** @type {?} */
              var direction = this._dir ? this._dir.value : 'ltr';
              this._tileCoordinator.update(this.cols, tiles);
              this._tileStyler.init(this.gutterSize, tracker, this.cols, direction);
              tiles.forEach(function (tile, index) {
                  /** @type {?} */
                  var pos = tracker.positions[index];
                  _this._tileStyler.setStyle(tile, pos.row, pos.col);
              });
              this._setListStyle(this._tileStyler.getComputedHeight());
          };
      /** Sets style on the main grid-list element, given the style name and value. */
      /**
       * Sets style on the main grid-list element, given the style name and value.
       * @param {?} style
       * @return {?}
       */
      MatGridList.prototype._setListStyle = /**
       * Sets style on the main grid-list element, given the style name and value.
       * @param {?} style
       * @return {?}
       */
          function (style) {
              if (style) {
                  (( /** @type {?} */(this._element.nativeElement.style)))[style[0]] = style[1];
              }
          };
      MatGridList.decorators = [
          { type: core.Component, args: [{ selector: 'mat-grid-list',
                      exportAs: 'matGridList',
                      template: "<div><ng-content></ng-content></div>",
                      styles: [".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-figure{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}.mat-grid-tile .mat-grid-tile-footer,.mat-grid-tile .mat-grid-tile-header{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-footer>*,.mat-grid-tile .mat-grid-tile-header>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-tile-footer.mat-2-line,.mat-grid-tile .mat-grid-tile-header.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}"],
                      host: {
                          'class': 'mat-grid-list',
                      },
                      providers: [{
                              provide: MAT_GRID_LIST,
                              useExisting: MatGridList
                          }],
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                  },] },
      ];
      /** @nocollapse */
      MatGridList.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: Directionality, decorators: [{ type: core.Optional }] }
          ];
      };
      MatGridList.propDecorators = {
          _tiles: [{ type: core.ContentChildren, args: [MatGridTile, { descendants: true },] }],
          cols: [{ type: core.Input }],
          gutterSize: [{ type: core.Input }],
          rowHeight: [{ type: core.Input }]
      };
      return MatGridList;
  }());

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Returns an exception to be thrown in the case when attempting to
   * load an icon with a name that cannot be found.
   * \@docs-private
   * @param {?} iconName
   * @return {?}
   */
  function getMatIconNameNotFoundError(iconName) {
      return Error("Unable to find icon with the name \"" + iconName + "\"");
  }
  /**
   * Returns an exception to be thrown when the consumer attempts to use
   * `<mat-icon>` without including \@angular/http.
   * \@docs-private
   * @return {?}
   */
  function getMatIconNoHttpProviderError() {
      return Error('Could not find HttpClient provider for use with Angular Material icons. ' +
          'Please include the HttpClientModule from @angular/common/http in your ' +
          'app imports.');
  }
  /**
   * Returns an exception to be thrown when a URL couldn't be sanitized.
   * \@docs-private
   * @param {?} url URL that was attempted to be sanitized.
   * @return {?}
   */
  function getMatIconFailedToSanitizeUrlError(url) {
      return Error("The URL provided to MatIconRegistry was not trusted as a resource URL " +
          ("via Angular's DomSanitizer. Attempted URL was \"" + url + "\"."));
  }
  /**
   * Returns an exception to be thrown when a HTML string couldn't be sanitized.
   * \@docs-private
   * @param {?} literal HTML that was attempted to be sanitized.
   * @return {?}
   */
  function getMatIconFailedToSanitizeLiteralError(literal) {
      return Error("The literal provided to MatIconRegistry was not trusted as safe HTML by " +
          ("Angular's DomSanitizer. Attempted literal was \"" + literal + "\"."));
  }
  /**
   * Configuration for an icon, including the URL and possibly the cached SVG element.
   * \@docs-private
   */
  var /**
   * Configuration for an icon, including the URL and possibly the cached SVG element.
   * \@docs-private
   */ SvgIconConfig = /** @class */ (function () {
      function SvgIconConfig(data) {
          // Note that we can't use `instanceof SVGElement` here,
          // because it'll break during server-side rendering.
          if (!!(( /** @type {?} */(data))).nodeName) {
              this.svgElement = ( /** @type {?} */(data));
          }
          else {
              this.url = ( /** @type {?} */(data));
          }
      }
      return SvgIconConfig;
  }());
  /**
   * Service to register and display icons used by the `<mat-icon>` component.
   * - Registers icon URLs by namespace and name.
   * - Registers icon set URLs by namespace.
   * - Registers aliases for CSS classes, for use with icon fonts.
   * - Loads icons from URLs and extracts individual icons from icon sets.
   */
  var MatIconRegistry = /** @class */ (function () {
      function MatIconRegistry(_httpClient, _sanitizer, document) {
          this._httpClient = _httpClient;
          this._sanitizer = _sanitizer;
          /**
           * URLs and cached SVG elements for individual icons. Keys are of the format "[namespace]:[icon]".
           */
          this._svgIconConfigs = new Map();
          /**
           * SvgIconConfig objects and cached SVG elements for icon sets, keyed by namespace.
           * Multiple icon sets can be registered under the same namespace.
           */
          this._iconSetConfigs = new Map();
          /**
           * Cache for icons loaded by direct URLs.
           */
          this._cachedIconsByUrl = new Map();
          /**
           * In-progress icon fetches. Used to coalesce multiple requests to the same URL.
           */
          this._inProgressUrlFetches = new Map();
          /**
           * Map from font identifiers to their CSS class names. Used for icon fonts.
           */
          this._fontCssClassesByAlias = new Map();
          /**
           * The CSS class to apply when an `<mat-icon>` component has no icon name, url, or font specified.
           * The default 'material-icons' value assumes that the material icon font has been loaded as
           * described at http://google.github.io/material-design-icons/#icon-font-for-the-web
           */
          this._defaultFontSetClass = 'material-icons';
          this._document = document;
      }
      /**
       * Registers an icon by URL in the default namespace.
       * @param iconName Name under which the icon should be registered.
       * @param url
       */
      /**
       * Registers an icon by URL in the default namespace.
       * @template THIS
       * @this {THIS}
       * @param {?} iconName Name under which the icon should be registered.
       * @param {?} url
       * @return {THIS}
       */
      MatIconRegistry.prototype.addSvgIcon = /**
       * Registers an icon by URL in the default namespace.
       * @template THIS
       * @this {THIS}
       * @param {?} iconName Name under which the icon should be registered.
       * @param {?} url
       * @return {THIS}
       */
          function (iconName, url) {
              return ( /** @type {?} */(this)).addSvgIconInNamespace('', iconName, url);
          };
      /**
       * Registers an icon using an HTML string in the default namespace.
       * @param iconName Name under which the icon should be registered.
       * @param literal SVG source of the icon.
       */
      /**
       * Registers an icon using an HTML string in the default namespace.
       * @template THIS
       * @this {THIS}
       * @param {?} iconName Name under which the icon should be registered.
       * @param {?} literal SVG source of the icon.
       * @return {THIS}
       */
      MatIconRegistry.prototype.addSvgIconLiteral = /**
       * Registers an icon using an HTML string in the default namespace.
       * @template THIS
       * @this {THIS}
       * @param {?} iconName Name under which the icon should be registered.
       * @param {?} literal SVG source of the icon.
       * @return {THIS}
       */
          function (iconName, literal) {
              return ( /** @type {?} */(this)).addSvgIconLiteralInNamespace('', iconName, literal);
          };
      /**
       * Registers an icon by URL in the specified namespace.
       * @param namespace Namespace in which the icon should be registered.
       * @param iconName Name under which the icon should be registered.
       * @param url
       */
      /**
       * Registers an icon by URL in the specified namespace.
       * @template THIS
       * @this {THIS}
       * @param {?} namespace Namespace in which the icon should be registered.
       * @param {?} iconName Name under which the icon should be registered.
       * @param {?} url
       * @return {THIS}
       */
      MatIconRegistry.prototype.addSvgIconInNamespace = /**
       * Registers an icon by URL in the specified namespace.
       * @template THIS
       * @this {THIS}
       * @param {?} namespace Namespace in which the icon should be registered.
       * @param {?} iconName Name under which the icon should be registered.
       * @param {?} url
       * @return {THIS}
       */
          function (namespace, iconName, url) {
              return ( /** @type {?} */(this))._addSvgIconConfig(namespace, iconName, new SvgIconConfig(url));
          };
      /**
       * Registers an icon using an HTML string in the specified namespace.
       * @param namespace Namespace in which the icon should be registered.
       * @param iconName Name under which the icon should be registered.
       * @param literal SVG source of the icon.
       */
      /**
       * Registers an icon using an HTML string in the specified namespace.
       * @template THIS
       * @this {THIS}
       * @param {?} namespace Namespace in which the icon should be registered.
       * @param {?} iconName Name under which the icon should be registered.
       * @param {?} literal SVG source of the icon.
       * @return {THIS}
       */
      MatIconRegistry.prototype.addSvgIconLiteralInNamespace = /**
       * Registers an icon using an HTML string in the specified namespace.
       * @template THIS
       * @this {THIS}
       * @param {?} namespace Namespace in which the icon should be registered.
       * @param {?} iconName Name under which the icon should be registered.
       * @param {?} literal SVG source of the icon.
       * @return {THIS}
       */
          function (namespace, iconName, literal) {
              /** @type {?} */
              var sanitizedLiteral = ( /** @type {?} */(this))._sanitizer.sanitize(core.SecurityContext.HTML, literal);
              if (!sanitizedLiteral) {
                  throw getMatIconFailedToSanitizeLiteralError(literal);
              }
              /** @type {?} */
              var svgElement = ( /** @type {?} */(this))._createSvgElementForSingleIcon(sanitizedLiteral);
              return ( /** @type {?} */(this))._addSvgIconConfig(namespace, iconName, new SvgIconConfig(svgElement));
          };
      /**
       * Registers an icon set by URL in the default namespace.
       * @param url
       */
      /**
       * Registers an icon set by URL in the default namespace.
       * @template THIS
       * @this {THIS}
       * @param {?} url
       * @return {THIS}
       */
      MatIconRegistry.prototype.addSvgIconSet = /**
       * Registers an icon set by URL in the default namespace.
       * @template THIS
       * @this {THIS}
       * @param {?} url
       * @return {THIS}
       */
          function (url) {
              return ( /** @type {?} */(this)).addSvgIconSetInNamespace('', url);
          };
      /**
       * Registers an icon set using an HTML string in the default namespace.
       * @param literal SVG source of the icon set.
       */
      /**
       * Registers an icon set using an HTML string in the default namespace.
       * @template THIS
       * @this {THIS}
       * @param {?} literal SVG source of the icon set.
       * @return {THIS}
       */
      MatIconRegistry.prototype.addSvgIconSetLiteral = /**
       * Registers an icon set using an HTML string in the default namespace.
       * @template THIS
       * @this {THIS}
       * @param {?} literal SVG source of the icon set.
       * @return {THIS}
       */
          function (literal) {
              return ( /** @type {?} */(this)).addSvgIconSetLiteralInNamespace('', literal);
          };
      /**
       * Registers an icon set by URL in the specified namespace.
       * @param namespace Namespace in which to register the icon set.
       * @param url
       */
      /**
       * Registers an icon set by URL in the specified namespace.
       * @template THIS
       * @this {THIS}
       * @param {?} namespace Namespace in which to register the icon set.
       * @param {?} url
       * @return {THIS}
       */
      MatIconRegistry.prototype.addSvgIconSetInNamespace = /**
       * Registers an icon set by URL in the specified namespace.
       * @template THIS
       * @this {THIS}
       * @param {?} namespace Namespace in which to register the icon set.
       * @param {?} url
       * @return {THIS}
       */
          function (namespace, url) {
              return ( /** @type {?} */(this))._addSvgIconSetConfig(namespace, new SvgIconConfig(url));
          };
      /**
       * Registers an icon set using an HTML string in the specified namespace.
       * @param namespace Namespace in which to register the icon set.
       * @param literal SVG source of the icon set.
       */
      /**
       * Registers an icon set using an HTML string in the specified namespace.
       * @template THIS
       * @this {THIS}
       * @param {?} namespace Namespace in which to register the icon set.
       * @param {?} literal SVG source of the icon set.
       * @return {THIS}
       */
      MatIconRegistry.prototype.addSvgIconSetLiteralInNamespace = /**
       * Registers an icon set using an HTML string in the specified namespace.
       * @template THIS
       * @this {THIS}
       * @param {?} namespace Namespace in which to register the icon set.
       * @param {?} literal SVG source of the icon set.
       * @return {THIS}
       */
          function (namespace, literal) {
              /** @type {?} */
              var sanitizedLiteral = ( /** @type {?} */(this))._sanitizer.sanitize(core.SecurityContext.HTML, literal);
              if (!sanitizedLiteral) {
                  throw getMatIconFailedToSanitizeLiteralError(literal);
              }
              /** @type {?} */
              var svgElement = ( /** @type {?} */(this))._svgElementFromString(sanitizedLiteral);
              return ( /** @type {?} */(this))._addSvgIconSetConfig(namespace, new SvgIconConfig(svgElement));
          };
      /**
       * Defines an alias for a CSS class name to be used for icon fonts. Creating an matIcon
       * component with the alias as the fontSet input will cause the class name to be applied
       * to the `<mat-icon>` element.
       *
       * @param alias Alias for the font.
       * @param className Class name override to be used instead of the alias.
       */
      /**
       * Defines an alias for a CSS class name to be used for icon fonts. Creating an matIcon
       * component with the alias as the fontSet input will cause the class name to be applied
       * to the `<mat-icon>` element.
       *
       * @template THIS
       * @this {THIS}
       * @param {?} alias Alias for the font.
       * @param {?=} className Class name override to be used instead of the alias.
       * @return {THIS}
       */
      MatIconRegistry.prototype.registerFontClassAlias = /**
       * Defines an alias for a CSS class name to be used for icon fonts. Creating an matIcon
       * component with the alias as the fontSet input will cause the class name to be applied
       * to the `<mat-icon>` element.
       *
       * @template THIS
       * @this {THIS}
       * @param {?} alias Alias for the font.
       * @param {?=} className Class name override to be used instead of the alias.
       * @return {THIS}
       */
          function (alias, className) {
              if (className === void 0) {
                  className = alias;
              }
              ( /** @type {?} */(this))._fontCssClassesByAlias.set(alias, className);
              return ( /** @type {?} */(this));
          };
      /**
       * Returns the CSS class name associated with the alias by a previous call to
       * registerFontClassAlias. If no CSS class has been associated, returns the alias unmodified.
       */
      /**
       * Returns the CSS class name associated with the alias by a previous call to
       * registerFontClassAlias. If no CSS class has been associated, returns the alias unmodified.
       * @param {?} alias
       * @return {?}
       */
      MatIconRegistry.prototype.classNameForFontAlias = /**
       * Returns the CSS class name associated with the alias by a previous call to
       * registerFontClassAlias. If no CSS class has been associated, returns the alias unmodified.
       * @param {?} alias
       * @return {?}
       */
          function (alias) {
              return this._fontCssClassesByAlias.get(alias) || alias;
          };
      /**
       * Sets the CSS class name to be used for icon fonts when an `<mat-icon>` component does not
       * have a fontSet input value, and is not loading an icon by name or URL.
       *
       * @param className
       */
      /**
       * Sets the CSS class name to be used for icon fonts when an `<mat-icon>` component does not
       * have a fontSet input value, and is not loading an icon by name or URL.
       *
       * @template THIS
       * @this {THIS}
       * @param {?} className
       * @return {THIS}
       */
      MatIconRegistry.prototype.setDefaultFontSetClass = /**
       * Sets the CSS class name to be used for icon fonts when an `<mat-icon>` component does not
       * have a fontSet input value, and is not loading an icon by name or URL.
       *
       * @template THIS
       * @this {THIS}
       * @param {?} className
       * @return {THIS}
       */
          function (className) {
              ( /** @type {?} */(this))._defaultFontSetClass = className;
              return ( /** @type {?} */(this));
          };
      /**
       * Returns the CSS class name to be used for icon fonts when an `<mat-icon>` component does not
       * have a fontSet input value, and is not loading an icon by name or URL.
       */
      /**
       * Returns the CSS class name to be used for icon fonts when an `<mat-icon>` component does not
       * have a fontSet input value, and is not loading an icon by name or URL.
       * @return {?}
       */
      MatIconRegistry.prototype.getDefaultFontSetClass = /**
       * Returns the CSS class name to be used for icon fonts when an `<mat-icon>` component does not
       * have a fontSet input value, and is not loading an icon by name or URL.
       * @return {?}
       */
          function () {
              return this._defaultFontSetClass;
          };
      /**
       * Returns an Observable that produces the icon (as an `<svg>` DOM element) from the given URL.
       * The response from the URL may be cached so this will not always cause an HTTP request, but
       * the produced element will always be a new copy of the originally fetched icon. (That is,
       * it will not contain any modifications made to elements previously returned).
       *
       * @param safeUrl URL from which to fetch the SVG icon.
       */
      /**
       * Returns an Observable that produces the icon (as an `<svg>` DOM element) from the given URL.
       * The response from the URL may be cached so this will not always cause an HTTP request, but
       * the produced element will always be a new copy of the originally fetched icon. (That is,
       * it will not contain any modifications made to elements previously returned).
       *
       * @param {?} safeUrl URL from which to fetch the SVG icon.
       * @return {?}
       */
      MatIconRegistry.prototype.getSvgIconFromUrl = /**
       * Returns an Observable that produces the icon (as an `<svg>` DOM element) from the given URL.
       * The response from the URL may be cached so this will not always cause an HTTP request, but
       * the produced element will always be a new copy of the originally fetched icon. (That is,
       * it will not contain any modifications made to elements previously returned).
       *
       * @param {?} safeUrl URL from which to fetch the SVG icon.
       * @return {?}
       */
          function (safeUrl) {
              var _this = this;
              /** @type {?} */
              var url = this._sanitizer.sanitize(core.SecurityContext.RESOURCE_URL, safeUrl);
              if (!url) {
                  throw getMatIconFailedToSanitizeUrlError(safeUrl);
              }
              /** @type {?} */
              var cachedIcon = this._cachedIconsByUrl.get(url);
              if (cachedIcon) {
                  return rxjs.of(cloneSvg(cachedIcon));
              }
              return this._loadSvgIconFromConfig(new SvgIconConfig(safeUrl)).pipe(operators.tap(function (svg) { return _this._cachedIconsByUrl.set(( /** @type {?} */(url)), svg); }), operators.map(function (svg) { return cloneSvg(svg); }));
          };
      /**
       * Returns an Observable that produces the icon (as an `<svg>` DOM element) with the given name
       * and namespace. The icon must have been previously registered with addIcon or addIconSet;
       * if not, the Observable will throw an error.
       *
       * @param name Name of the icon to be retrieved.
       * @param namespace Namespace in which to look for the icon.
       */
      /**
       * Returns an Observable that produces the icon (as an `<svg>` DOM element) with the given name
       * and namespace. The icon must have been previously registered with addIcon or addIconSet;
       * if not, the Observable will throw an error.
       *
       * @param {?} name Name of the icon to be retrieved.
       * @param {?=} namespace Namespace in which to look for the icon.
       * @return {?}
       */
      MatIconRegistry.prototype.getNamedSvgIcon = /**
       * Returns an Observable that produces the icon (as an `<svg>` DOM element) with the given name
       * and namespace. The icon must have been previously registered with addIcon or addIconSet;
       * if not, the Observable will throw an error.
       *
       * @param {?} name Name of the icon to be retrieved.
       * @param {?=} namespace Namespace in which to look for the icon.
       * @return {?}
       */
          function (name, namespace) {
              if (namespace === void 0) {
                  namespace = '';
              }
              // Return (copy of) cached icon if possible.
              /** @type {?} */
              var key = iconKey(namespace, name);
              /** @type {?} */
              var config = this._svgIconConfigs.get(key);
              if (config) {
                  return this._getSvgFromConfig(config);
              }
              // See if we have any icon sets registered for the namespace.
              /** @type {?} */
              var iconSetConfigs = this._iconSetConfigs.get(namespace);
              if (iconSetConfigs) {
                  return this._getSvgFromIconSetConfigs(name, iconSetConfigs);
              }
              return rxjs.throwError(getMatIconNameNotFoundError(key));
          };
      /**
       * @return {?}
       */
      MatIconRegistry.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._svgIconConfigs.clear();
              this._iconSetConfigs.clear();
              this._cachedIconsByUrl.clear();
          };
      /**
       * Returns the cached icon for a SvgIconConfig if available, or fetches it from its URL if not.
       */
      /**
       * Returns the cached icon for a SvgIconConfig if available, or fetches it from its URL if not.
       * @private
       * @param {?} config
       * @return {?}
       */
      MatIconRegistry.prototype._getSvgFromConfig = /**
       * Returns the cached icon for a SvgIconConfig if available, or fetches it from its URL if not.
       * @private
       * @param {?} config
       * @return {?}
       */
          function (config) {
              if (config.svgElement) {
                  // We already have the SVG element for this icon, return a copy.
                  return rxjs.of(cloneSvg(config.svgElement));
              }
              else {
                  // Fetch the icon from the config's URL, cache it, and return a copy.
                  return this._loadSvgIconFromConfig(config).pipe(operators.tap(function (svg) { return config.svgElement = svg; }), operators.map(function (svg) { return cloneSvg(svg); }));
              }
          };
      /**
       * Attempts to find an icon with the specified name in any of the SVG icon sets.
       * First searches the available cached icons for a nested element with a matching name, and
       * if found copies the element to a new `<svg>` element. If not found, fetches all icon sets
       * that have not been cached, and searches again after all fetches are completed.
       * The returned Observable produces the SVG element if possible, and throws
       * an error if no icon with the specified name can be found.
       */
      /**
       * Attempts to find an icon with the specified name in any of the SVG icon sets.
       * First searches the available cached icons for a nested element with a matching name, and
       * if found copies the element to a new `<svg>` element. If not found, fetches all icon sets
       * that have not been cached, and searches again after all fetches are completed.
       * The returned Observable produces the SVG element if possible, and throws
       * an error if no icon with the specified name can be found.
       * @private
       * @param {?} name
       * @param {?} iconSetConfigs
       * @return {?}
       */
      MatIconRegistry.prototype._getSvgFromIconSetConfigs = /**
       * Attempts to find an icon with the specified name in any of the SVG icon sets.
       * First searches the available cached icons for a nested element with a matching name, and
       * if found copies the element to a new `<svg>` element. If not found, fetches all icon sets
       * that have not been cached, and searches again after all fetches are completed.
       * The returned Observable produces the SVG element if possible, and throws
       * an error if no icon with the specified name can be found.
       * @private
       * @param {?} name
       * @param {?} iconSetConfigs
       * @return {?}
       */
          function (name, iconSetConfigs) {
              var _this = this;
              // For all the icon set SVG elements we've fetched, see if any contain an icon with the
              // requested name.
              /** @type {?} */
              var namedIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);
              if (namedIcon) {
                  // We could cache namedIcon in _svgIconConfigs, but since we have to make a copy every
                  // time anyway, there's probably not much advantage compared to just always extracting
                  // it from the icon set.
                  return rxjs.of(namedIcon);
              }
              // Not found in any cached icon sets. If there are icon sets with URLs that we haven't
              // fetched, fetch them now and look for iconName in the results.
              /** @type {?} */
              var iconSetFetchRequests = iconSetConfigs
                  .filter(function (iconSetConfig) { return !iconSetConfig.svgElement; })
                  .map(function (iconSetConfig) {
                  return _this._loadSvgIconSetFromConfig(iconSetConfig).pipe(operators.catchError(function (err) {
                      /** @type {?} */
                      var url = _this._sanitizer.sanitize(core.SecurityContext.RESOURCE_URL, iconSetConfig.url);
                      // Swallow errors fetching individual URLs so the
                      // combined Observable won't necessarily fail.
                      console.error("Loading icon set URL: " + url + " failed: " + err.message);
                      return rxjs.of(null);
                  }));
              });
              // Fetch all the icon set URLs. When the requests complete, every IconSet should have a
              // cached SVG element (unless the request failed), and we can check again for the icon.
              return rxjs.forkJoin(iconSetFetchRequests).pipe(operators.map(function () {
                  /** @type {?} */
                  var foundIcon = _this._extractIconWithNameFromAnySet(name, iconSetConfigs);
                  if (!foundIcon) {
                      throw getMatIconNameNotFoundError(name);
                  }
                  return foundIcon;
              }));
          };
      /**
       * Searches the cached SVG elements for the given icon sets for a nested icon element whose "id"
       * tag matches the specified name. If found, copies the nested element to a new SVG element and
       * returns it. Returns null if no matching element is found.
       */
      /**
       * Searches the cached SVG elements for the given icon sets for a nested icon element whose "id"
       * tag matches the specified name. If found, copies the nested element to a new SVG element and
       * returns it. Returns null if no matching element is found.
       * @private
       * @param {?} iconName
       * @param {?} iconSetConfigs
       * @return {?}
       */
      MatIconRegistry.prototype._extractIconWithNameFromAnySet = /**
       * Searches the cached SVG elements for the given icon sets for a nested icon element whose "id"
       * tag matches the specified name. If found, copies the nested element to a new SVG element and
       * returns it. Returns null if no matching element is found.
       * @private
       * @param {?} iconName
       * @param {?} iconSetConfigs
       * @return {?}
       */
          function (iconName, iconSetConfigs) {
              // Iterate backwards, so icon sets added later have precedence.
              for (var i = iconSetConfigs.length - 1; i >= 0; i--) {
                  /** @type {?} */
                  var config = iconSetConfigs[i];
                  if (config.svgElement) {
                      /** @type {?} */
                      var foundIcon = this._extractSvgIconFromSet(config.svgElement, iconName);
                      if (foundIcon) {
                          return foundIcon;
                      }
                  }
              }
              return null;
          };
      /**
       * Loads the content of the icon URL specified in the SvgIconConfig and creates an SVG element
       * from it.
       */
      /**
       * Loads the content of the icon URL specified in the SvgIconConfig and creates an SVG element
       * from it.
       * @private
       * @param {?} config
       * @return {?}
       */
      MatIconRegistry.prototype._loadSvgIconFromConfig = /**
       * Loads the content of the icon URL specified in the SvgIconConfig and creates an SVG element
       * from it.
       * @private
       * @param {?} config
       * @return {?}
       */
          function (config) {
              var _this = this;
              return this._fetchUrl(config.url)
                  .pipe(operators.map(function (svgText) { return _this._createSvgElementForSingleIcon(svgText); }));
          };
      /**
       * Loads the content of the icon set URL specified in the SvgIconConfig and creates an SVG element
       * from it.
       */
      /**
       * Loads the content of the icon set URL specified in the SvgIconConfig and creates an SVG element
       * from it.
       * @private
       * @param {?} config
       * @return {?}
       */
      MatIconRegistry.prototype._loadSvgIconSetFromConfig = /**
       * Loads the content of the icon set URL specified in the SvgIconConfig and creates an SVG element
       * from it.
       * @private
       * @param {?} config
       * @return {?}
       */
          function (config) {
              var _this = this;
              // If the SVG for this icon set has already been parsed, do nothing.
              if (config.svgElement) {
                  return rxjs.of(config.svgElement);
              }
              return this._fetchUrl(config.url).pipe(operators.map(function (svgText) {
                  // It is possible that the icon set was parsed and cached by an earlier request, so parsing
                  // only needs to occur if the cache is yet unset.
                  if (!config.svgElement) {
                      config.svgElement = _this._svgElementFromString(svgText);
                  }
                  return config.svgElement;
              }));
          };
      /**
       * Creates a DOM element from the given SVG string, and adds default attributes.
       */
      /**
       * Creates a DOM element from the given SVG string, and adds default attributes.
       * @private
       * @param {?} responseText
       * @return {?}
       */
      MatIconRegistry.prototype._createSvgElementForSingleIcon = /**
       * Creates a DOM element from the given SVG string, and adds default attributes.
       * @private
       * @param {?} responseText
       * @return {?}
       */
          function (responseText) {
              /** @type {?} */
              var svg = this._svgElementFromString(responseText);
              this._setSvgAttributes(svg);
              return svg;
          };
      /**
       * Searches the cached element of the given SvgIconConfig for a nested icon element whose "id"
       * tag matches the specified name. If found, copies the nested element to a new SVG element and
       * returns it. Returns null if no matching element is found.
       */
      /**
       * Searches the cached element of the given SvgIconConfig for a nested icon element whose "id"
       * tag matches the specified name. If found, copies the nested element to a new SVG element and
       * returns it. Returns null if no matching element is found.
       * @private
       * @param {?} iconSet
       * @param {?} iconName
       * @return {?}
       */
      MatIconRegistry.prototype._extractSvgIconFromSet = /**
       * Searches the cached element of the given SvgIconConfig for a nested icon element whose "id"
       * tag matches the specified name. If found, copies the nested element to a new SVG element and
       * returns it. Returns null if no matching element is found.
       * @private
       * @param {?} iconSet
       * @param {?} iconName
       * @return {?}
       */
          function (iconSet, iconName) {
              /** @type {?} */
              var iconSource = iconSet.querySelector('#' + iconName);
              if (!iconSource) {
                  return null;
              }
              // Clone the element and remove the ID to prevent multiple elements from being added
              // to the page with the same ID.
              /** @type {?} */
              var iconElement = ( /** @type {?} */(iconSource.cloneNode(true)));
              iconElement.removeAttribute('id');
              // If the icon node is itself an <svg> node, clone and return it directly. If not, set it as
              // the content of a new <svg> node.
              if (iconElement.nodeName.toLowerCase() === 'svg') {
                  return this._setSvgAttributes(( /** @type {?} */(iconElement)));
              }
              // If the node is a <symbol>, it won't be rendered so we have to convert it into <svg>. Note
              // that the same could be achieved by referring to it via <use href="#id">, however the <use>
              // tag is problematic on Firefox, because it needs to include the current page path.
              if (iconElement.nodeName.toLowerCase() === 'symbol') {
                  return this._setSvgAttributes(this._toSvgElement(iconElement));
              }
              // createElement('SVG') doesn't work as expected; the DOM ends up with
              // the correct nodes, but the SVG content doesn't render. Instead we
              // have to create an empty SVG node using innerHTML and append its content.
              // Elements created using DOMParser.parseFromString have the same problem.
              // http://stackoverflow.com/questions/23003278/svg-innerhtml-in-firefox-can-not-display
              /** @type {?} */
              var svg = this._svgElementFromString('<svg></svg>');
              // Clone the node so we don't remove it from the parent icon set element.
              svg.appendChild(iconElement);
              return this._setSvgAttributes(svg);
          };
      /**
       * Creates a DOM element from the given SVG string.
       */
      /**
       * Creates a DOM element from the given SVG string.
       * @private
       * @param {?} str
       * @return {?}
       */
      MatIconRegistry.prototype._svgElementFromString = /**
       * Creates a DOM element from the given SVG string.
       * @private
       * @param {?} str
       * @return {?}
       */
          function (str) {
              /** @type {?} */
              var div = this._document.createElement('DIV');
              div.innerHTML = str;
              /** @type {?} */
              var svg = ( /** @type {?} */(div.querySelector('svg')));
              if (!svg) {
                  throw Error('<svg> tag not found');
              }
              return svg;
          };
      /**
       * Converts an element into an SVG node by cloning all of its children.
       */
      /**
       * Converts an element into an SVG node by cloning all of its children.
       * @private
       * @param {?} element
       * @return {?}
       */
      MatIconRegistry.prototype._toSvgElement = /**
       * Converts an element into an SVG node by cloning all of its children.
       * @private
       * @param {?} element
       * @return {?}
       */
          function (element) {
              /** @type {?} */
              var svg = this._svgElementFromString('<svg></svg>');
              for (var i = 0; i < element.childNodes.length; i++) {
                  if (element.childNodes[i].nodeType === this._document.ELEMENT_NODE) {
                      svg.appendChild(element.childNodes[i].cloneNode(true));
                  }
              }
              return svg;
          };
      /**
       * Sets the default attributes for an SVG element to be used as an icon.
       */
      /**
       * Sets the default attributes for an SVG element to be used as an icon.
       * @private
       * @param {?} svg
       * @return {?}
       */
      MatIconRegistry.prototype._setSvgAttributes = /**
       * Sets the default attributes for an SVG element to be used as an icon.
       * @private
       * @param {?} svg
       * @return {?}
       */
          function (svg) {
              svg.setAttribute('fit', '');
              svg.setAttribute('height', '100%');
              svg.setAttribute('width', '100%');
              svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
              svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.
              return svg;
          };
      /**
       * Returns an Observable which produces the string contents of the given URL. Results may be
       * cached, so future calls with the same URL may not cause another HTTP request.
       */
      /**
       * Returns an Observable which produces the string contents of the given URL. Results may be
       * cached, so future calls with the same URL may not cause another HTTP request.
       * @private
       * @param {?} safeUrl
       * @return {?}
       */
      MatIconRegistry.prototype._fetchUrl = /**
       * Returns an Observable which produces the string contents of the given URL. Results may be
       * cached, so future calls with the same URL may not cause another HTTP request.
       * @private
       * @param {?} safeUrl
       * @return {?}
       */
          function (safeUrl) {
              var _this = this;
              if (!this._httpClient) {
                  throw getMatIconNoHttpProviderError();
              }
              if (safeUrl == null) {
                  throw Error("Cannot fetch icon from URL \"" + safeUrl + "\".");
              }
              /** @type {?} */
              var url = this._sanitizer.sanitize(core.SecurityContext.RESOURCE_URL, safeUrl);
              if (!url) {
                  throw getMatIconFailedToSanitizeUrlError(safeUrl);
              }
              // Store in-progress fetches to avoid sending a duplicate request for a URL when there is
              // already a request in progress for that URL. It's necessary to call share() on the
              // Observable returned by http.get() so that multiple subscribers don't cause multiple XHRs.
              /** @type {?} */
              var inProgressFetch = this._inProgressUrlFetches.get(url);
              if (inProgressFetch) {
                  return inProgressFetch;
              }
              // TODO(jelbourn): for some reason, the `finalize` operator "loses" the generic type on the
              // Observable. Figure out why and fix it.
              /** @type {?} */
              var req = this._httpClient.get(url, { responseType: 'text' }).pipe(operators.finalize(function () { return _this._inProgressUrlFetches.delete(url); }), operators.share());
              this._inProgressUrlFetches.set(url, req);
              return req;
          };
      /**
       * Registers an icon config by name in the specified namespace.
       * @param namespace Namespace in which to register the icon config.
       * @param iconName Name under which to register the config.
       * @param config Config to be registered.
       */
      /**
       * Registers an icon config by name in the specified namespace.
       * @private
       * @template THIS
       * @this {THIS}
       * @param {?} namespace Namespace in which to register the icon config.
       * @param {?} iconName Name under which to register the config.
       * @param {?} config Config to be registered.
       * @return {THIS}
       */
      MatIconRegistry.prototype._addSvgIconConfig = /**
       * Registers an icon config by name in the specified namespace.
       * @private
       * @template THIS
       * @this {THIS}
       * @param {?} namespace Namespace in which to register the icon config.
       * @param {?} iconName Name under which to register the config.
       * @param {?} config Config to be registered.
       * @return {THIS}
       */
          function (namespace, iconName, config) {
              ( /** @type {?} */(this))._svgIconConfigs.set(iconKey(namespace, iconName), config);
              return ( /** @type {?} */(this));
          };
      /**
       * Registers an icon set config in the specified namespace.
       * @param namespace Namespace in which to register the icon config.
       * @param config Config to be registered.
       */
      /**
       * Registers an icon set config in the specified namespace.
       * @private
       * @template THIS
       * @this {THIS}
       * @param {?} namespace Namespace in which to register the icon config.
       * @param {?} config Config to be registered.
       * @return {THIS}
       */
      MatIconRegistry.prototype._addSvgIconSetConfig = /**
       * Registers an icon set config in the specified namespace.
       * @private
       * @template THIS
       * @this {THIS}
       * @param {?} namespace Namespace in which to register the icon config.
       * @param {?} config Config to be registered.
       * @return {THIS}
       */
          function (namespace, config) {
              /** @type {?} */
              var configNamespace = ( /** @type {?} */(this))._iconSetConfigs.get(namespace);
              if (configNamespace) {
                  configNamespace.push(config);
              }
              else {
                  ( /** @type {?} */(this))._iconSetConfigs.set(namespace, [config]);
              }
              return ( /** @type {?} */(this));
          };
      MatIconRegistry.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */
      MatIconRegistry.ctorParameters = function () {
          return [
              { type: http.HttpClient, decorators: [{ type: core.Optional }] },
              { type: platformBrowser.DomSanitizer },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] }
          ];
      };
      /** @nocollapse */ MatIconRegistry.ngInjectableDef = core.defineInjectable({ factory: function MatIconRegistry_Factory() { return new MatIconRegistry(core.inject(http.HttpClient, 8), core.inject(platformBrowser.DomSanitizer), core.inject(common.DOCUMENT, 8)); }, token: MatIconRegistry, providedIn: "root" });
      return MatIconRegistry;
  }());
  /**
   * \@docs-private
   * @param {?} parentRegistry
   * @param {?} httpClient
   * @param {?} sanitizer
   * @param {?=} document
   * @return {?}
   */
  function ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry, httpClient, sanitizer, document) {
      return parentRegistry || new MatIconRegistry(httpClient, sanitizer, document);
  }
  /**
   * \@docs-private
   * @type {?}
   */
  var ICON_REGISTRY_PROVIDER = {
      // If there is already an MatIconRegistry available, use that. Otherwise, provide a new one.
      provide: MatIconRegistry,
      deps: [
          [new core.Optional(), new core.SkipSelf(), MatIconRegistry],
          [new core.Optional(), http.HttpClient],
          platformBrowser.DomSanitizer,
          [new core.Optional(), ( /** @type {?} */(common.DOCUMENT))],
      ],
      useFactory: ICON_REGISTRY_PROVIDER_FACTORY,
  };
  /**
   * Clones an SVGElement while preserving type information.
   * @param {?} svg
   * @return {?}
   */
  function cloneSvg(svg) {
      return ( /** @type {?} */(svg.cloneNode(true)));
  }
  /**
   * Returns the cache key to use for an icon namespace and name.
   * @param {?} namespace
   * @param {?} name
   * @return {?}
   */
  function iconKey(namespace, name) {
      return namespace + ':' + name;
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Boilerplate for applying mixins to MatIcon.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatIcon.
  /**
   * \@docs-private
   */
  MatIconBase = /** @class */ (function () {
      function MatIconBase(_elementRef) {
          this._elementRef = _elementRef;
      }
      return MatIconBase;
  }());
  /** @type {?} */
  var _MatIconMixinBase = mixinColor(MatIconBase);
  /**
   * Injection token used to provide the current location to `MatIcon`.
   * Used to handle server-side rendering and to stub out during unit tests.
   * \@docs-private
   * @type {?}
   */
  var MAT_ICON_LOCATION = new core.InjectionToken('mat-icon-location', {
      providedIn: 'root',
      factory: MAT_ICON_LOCATION_FACTORY
  });
  /**
   * \@docs-private
   * @return {?}
   */
  function MAT_ICON_LOCATION_FACTORY() {
      /** @type {?} */
      var _document = core.inject(common.DOCUMENT);
      /** @type {?} */
      var _location = _document ? _document.location : null;
      return {
          // Note that this needs to be a function, rather than a property, because Angular
          // will only resolve it once, but we want the current path on each call.
          getPathname: function () { return _location ? (_location.pathname + _location.search) : ''; }
      };
  }
  /**
   * SVG attributes that accept a FuncIRI (e.g. `url(<something>)`).
   * @type {?}
   */
  var funcIriAttributes = [
      'clip-path',
      'color-profile',
      'src',
      'cursor',
      'fill',
      'filter',
      'marker',
      'marker-start',
      'marker-mid',
      'marker-end',
      'mask',
      'stroke'
  ];
  var ɵ0$6 = function (attr) { return "[" + attr + "]"; };
  /**
   * Selector that can be used to find all elements that are using a `FuncIRI`.
   * @type {?}
   */
  var funcIriAttributeSelector = funcIriAttributes.map(ɵ0$6).join(', ');
  /**
   * Regex that can be used to extract the id out of a FuncIRI.
   * @type {?}
   */
  var funcIriPattern = /^url\(['"]?#(.*?)['"]?\)$/;
  /**
   * Component to display an icon. It can be used in the following ways:
   *
   * - Specify the svgIcon input to load an SVG icon from a URL previously registered with the
   *   addSvgIcon, addSvgIconInNamespace, addSvgIconSet, or addSvgIconSetInNamespace methods of
   *   MatIconRegistry. If the svgIcon value contains a colon it is assumed to be in the format
   *   "[namespace]:[name]", if not the value will be the name of an icon in the default namespace.
   *   Examples:
   *     `<mat-icon svgIcon="left-arrow"></mat-icon>
   *     <mat-icon svgIcon="animals:cat"></mat-icon>`
   *
   * - Use a font ligature as an icon by putting the ligature text in the content of the `<mat-icon>`
   *   component. By default the Material icons font is used as described at
   *   http://google.github.io/material-design-icons/#icon-font-for-the-web. You can specify an
   *   alternate font by setting the fontSet input to either the CSS class to apply to use the
   *   desired font, or to an alias previously registered with MatIconRegistry.registerFontClassAlias.
   *   Examples:
   *     `<mat-icon>home</mat-icon>
   *     <mat-icon fontSet="myfont">sun</mat-icon>`
   *
   * - Specify a font glyph to be included via CSS rules by setting the fontSet input to specify the
   *   font, and the fontIcon input to specify the icon. Typically the fontIcon will specify a
   *   CSS class which causes the glyph to be displayed via a :before selector, as in
   *   https://fortawesome.github.io/Font-Awesome/examples/
   *   Example:
   *     `<mat-icon fontSet="fa" fontIcon="alarm"></mat-icon>`
   */
  var MatIcon = /** @class */ (function (_super) {
      tslib_1.__extends(MatIcon, _super);
      function MatIcon(elementRef, _iconRegistry, ariaHidden, _location) {
          var _this = _super.call(this, elementRef) || this;
          _this._iconRegistry = _iconRegistry;
          _this._location = _location;
          _this._inline = false;
          // If the user has not explicitly set aria-hidden, mark the icon as hidden, as this is
          // the right thing to do for the majority of icon use-cases.
          if (!ariaHidden) {
              elementRef.nativeElement.setAttribute('aria-hidden', 'true');
          }
          return _this;
      }
      Object.defineProperty(MatIcon.prototype, "inline", {
          /**
           * Whether the icon should be inlined, automatically sizing the icon to match the font size of
           * the element the icon is contained in.
           */
          get: /**
           * Whether the icon should be inlined, automatically sizing the icon to match the font size of
           * the element the icon is contained in.
           * @return {?}
           */ function () {
              return this._inline;
          },
          set: /**
           * @param {?} inline
           * @return {?}
           */ function (inline) {
              this._inline = coerceBooleanProperty(inline);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatIcon.prototype, "fontSet", {
          /** Font set that the icon is a part of. */
          get: /**
           * Font set that the icon is a part of.
           * @return {?}
           */ function () { return this._fontSet; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._fontSet = this._cleanupFontValue(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatIcon.prototype, "fontIcon", {
          /** Name of an icon within a font set. */
          get: /**
           * Name of an icon within a font set.
           * @return {?}
           */ function () { return this._fontIcon; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._fontIcon = this._cleanupFontValue(value);
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Splits an svgIcon binding value into its icon set and icon name components.
       * Returns a 2-element array of [(icon set), (icon name)].
       * The separator for the two fields is ':'. If there is no separator, an empty
       * string is returned for the icon set and the entire value is returned for
       * the icon name. If the argument is falsy, returns an array of two empty strings.
       * Throws an error if the name contains two or more ':' separators.
       * Examples:
       *   `'social:cake' -> ['social', 'cake']
       *   'penguin' -> ['', 'penguin']
       *   null -> ['', '']
       *   'a:b:c' -> (throws Error)`
       */
      /**
       * Splits an svgIcon binding value into its icon set and icon name components.
       * Returns a 2-element array of [(icon set), (icon name)].
       * The separator for the two fields is ':'. If there is no separator, an empty
       * string is returned for the icon set and the entire value is returned for
       * the icon name. If the argument is falsy, returns an array of two empty strings.
       * Throws an error if the name contains two or more ':' separators.
       * Examples:
       *   `'social:cake' -> ['social', 'cake']
       *   'penguin' -> ['', 'penguin']
       *   null -> ['', '']
       *   'a:b:c' -> (throws Error)`
       * @private
       * @param {?} iconName
       * @return {?}
       */
      MatIcon.prototype._splitIconName = /**
       * Splits an svgIcon binding value into its icon set and icon name components.
       * Returns a 2-element array of [(icon set), (icon name)].
       * The separator for the two fields is ':'. If there is no separator, an empty
       * string is returned for the icon set and the entire value is returned for
       * the icon name. If the argument is falsy, returns an array of two empty strings.
       * Throws an error if the name contains two or more ':' separators.
       * Examples:
       *   `'social:cake' -> ['social', 'cake']
       *   'penguin' -> ['', 'penguin']
       *   null -> ['', '']
       *   'a:b:c' -> (throws Error)`
       * @private
       * @param {?} iconName
       * @return {?}
       */
          function (iconName) {
              if (!iconName) {
                  return ['', ''];
              }
              /** @type {?} */
              var parts = iconName.split(':');
              switch (parts.length) {
                  case 1: return ['', parts[0]]; // Use default namespace.
                  case 2: return ( /** @type {?} */(parts));
                  default: throw Error("Invalid icon name: \"" + iconName + "\"");
              }
          };
      /**
       * @param {?} changes
       * @return {?}
       */
      MatIcon.prototype.ngOnChanges = /**
       * @param {?} changes
       * @return {?}
       */
          function (changes) {
              var _this = this;
              // Only update the inline SVG icon if the inputs changed, to avoid unnecessary DOM operations.
              if (changes.svgIcon) {
                  if (this.svgIcon) {
                      var _a = this._splitIconName(this.svgIcon), namespace = _a[0], iconName = _a[1];
                      this._iconRegistry.getNamedSvgIcon(iconName, namespace).pipe(operators.take(1)).subscribe(function (svg) { return _this._setSvgElement(svg); }, function (err) { return console.log("Error retrieving icon: " + err.message); });
                  }
                  else {
                      this._clearSvgElement();
                  }
              }
              if (this._usingFontIcon()) {
                  this._updateFontIconClasses();
              }
          };
      /**
       * @return {?}
       */
      MatIcon.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              // Update font classes because ngOnChanges won't be called if none of the inputs are present,
              // e.g. <mat-icon>arrow</mat-icon> In this case we need to add a CSS class for the default font.
              if (this._usingFontIcon()) {
                  this._updateFontIconClasses();
              }
          };
      /**
       * @return {?}
       */
      MatIcon.prototype.ngAfterViewChecked = /**
       * @return {?}
       */
          function () {
              /** @type {?} */
              var cachedElements = this._elementsWithExternalReferences;
              if (cachedElements && this._location && cachedElements.size) {
                  /** @type {?} */
                  var newPath = this._location.getPathname();
                  // We need to check whether the URL has changed on each change detection since
                  // the browser doesn't have an API that will let us react on link clicks and
                  // we can't depend on the Angular router. The references need to be updated,
                  // because while most browsers don't care whether the URL is correct after
                  // the first render, Safari will break if the user navigates to a different
                  // page and the SVG isn't re-rendered.
                  if (newPath !== this._previousPath) {
                      this._previousPath = newPath;
                      this._prependPathToReferences(newPath);
                  }
              }
          };
      /**
       * @return {?}
       */
      MatIcon.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              if (this._elementsWithExternalReferences) {
                  this._elementsWithExternalReferences.clear();
              }
          };
      /**
       * @private
       * @return {?}
       */
      MatIcon.prototype._usingFontIcon = /**
       * @private
       * @return {?}
       */
          function () {
              return !this.svgIcon;
          };
      /**
       * @private
       * @param {?} svg
       * @return {?}
       */
      MatIcon.prototype._setSvgElement = /**
       * @private
       * @param {?} svg
       * @return {?}
       */
          function (svg) {
              this._clearSvgElement();
              // Workaround for IE11 and Edge ignoring `style` tags inside dynamically-created SVGs.
              // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10898469/
              // Do this before inserting the element into the DOM, in order to avoid a style recalculation.
              /** @type {?} */
              var styleTags = ( /** @type {?} */(svg.querySelectorAll('style')));
              for (var i = 0; i < styleTags.length; i++) {
                  styleTags[i].textContent += ' ';
              }
              // Note: we do this fix here, rather than the icon registry, because the
              // references have to point to the URL at the time that the icon was created.
              if (this._location) {
                  /** @type {?} */
                  var path = this._location.getPathname();
                  this._previousPath = path;
                  this._cacheChildrenWithExternalReferences(svg);
                  this._prependPathToReferences(path);
              }
              this._elementRef.nativeElement.appendChild(svg);
          };
      /**
       * @private
       * @return {?}
       */
      MatIcon.prototype._clearSvgElement = /**
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var layoutElement = this._elementRef.nativeElement;
              /** @type {?} */
              var childCount = layoutElement.childNodes.length;
              if (this._elementsWithExternalReferences) {
                  this._elementsWithExternalReferences.clear();
              }
              // Remove existing non-element child nodes and SVGs, and add the new SVG element. Note that
              // we can't use innerHTML, because IE will throw if the element has a data binding.
              while (childCount--) {
                  /** @type {?} */
                  var child = layoutElement.childNodes[childCount];
                  // 1 corresponds to Node.ELEMENT_NODE. We remove all non-element nodes in order to get rid
                  // of any loose text nodes, as well as any SVG elements in order to remove any old icons.
                  if (child.nodeType !== 1 || child.nodeName.toLowerCase() === 'svg') {
                      layoutElement.removeChild(child);
                  }
              }
          };
      /**
       * @private
       * @return {?}
       */
      MatIcon.prototype._updateFontIconClasses = /**
       * @private
       * @return {?}
       */
          function () {
              if (!this._usingFontIcon()) {
                  return;
              }
              /** @type {?} */
              var elem = this._elementRef.nativeElement;
              /** @type {?} */
              var fontSetClass = this.fontSet ?
                  this._iconRegistry.classNameForFontAlias(this.fontSet) :
                  this._iconRegistry.getDefaultFontSetClass();
              if (fontSetClass != this._previousFontSetClass) {
                  if (this._previousFontSetClass) {
                      elem.classList.remove(this._previousFontSetClass);
                  }
                  if (fontSetClass) {
                      elem.classList.add(fontSetClass);
                  }
                  this._previousFontSetClass = fontSetClass;
              }
              if (this.fontIcon != this._previousFontIconClass) {
                  if (this._previousFontIconClass) {
                      elem.classList.remove(this._previousFontIconClass);
                  }
                  if (this.fontIcon) {
                      elem.classList.add(this.fontIcon);
                  }
                  this._previousFontIconClass = this.fontIcon;
              }
          };
      /**
       * Cleans up a value to be used as a fontIcon or fontSet.
       * Since the value ends up being assigned as a CSS class, we
       * have to trim the value and omit space-separated values.
       */
      /**
       * Cleans up a value to be used as a fontIcon or fontSet.
       * Since the value ends up being assigned as a CSS class, we
       * have to trim the value and omit space-separated values.
       * @private
       * @param {?} value
       * @return {?}
       */
      MatIcon.prototype._cleanupFontValue = /**
       * Cleans up a value to be used as a fontIcon or fontSet.
       * Since the value ends up being assigned as a CSS class, we
       * have to trim the value and omit space-separated values.
       * @private
       * @param {?} value
       * @return {?}
       */
          function (value) {
              return typeof value === 'string' ? value.trim().split(' ')[0] : value;
          };
      /**
       * Prepends the current path to all elements that have an attribute pointing to a `FuncIRI`
       * reference. This is required because WebKit browsers require references to be prefixed with
       * the current path, if the page has a `base` tag.
       */
      /**
       * Prepends the current path to all elements that have an attribute pointing to a `FuncIRI`
       * reference. This is required because WebKit browsers require references to be prefixed with
       * the current path, if the page has a `base` tag.
       * @private
       * @param {?} path
       * @return {?}
       */
      MatIcon.prototype._prependPathToReferences = /**
       * Prepends the current path to all elements that have an attribute pointing to a `FuncIRI`
       * reference. This is required because WebKit browsers require references to be prefixed with
       * the current path, if the page has a `base` tag.
       * @private
       * @param {?} path
       * @return {?}
       */
          function (path) {
              /** @type {?} */
              var elements = this._elementsWithExternalReferences;
              if (elements) {
                  elements.forEach(function (attrs, element) {
                      attrs.forEach(function (attr) {
                          element.setAttribute(attr.name, "url('" + path + "#" + attr.value + "')");
                      });
                  });
              }
          };
      /**
       * Caches the children of an SVG element that have `url()`
       * references that we need to prefix with the current path.
       */
      /**
       * Caches the children of an SVG element that have `url()`
       * references that we need to prefix with the current path.
       * @private
       * @param {?} element
       * @return {?}
       */
      MatIcon.prototype._cacheChildrenWithExternalReferences = /**
       * Caches the children of an SVG element that have `url()`
       * references that we need to prefix with the current path.
       * @private
       * @param {?} element
       * @return {?}
       */
          function (element) {
              /** @type {?} */
              var elementsWithFuncIri = element.querySelectorAll(funcIriAttributeSelector);
              /** @type {?} */
              var elements = this._elementsWithExternalReferences =
                  this._elementsWithExternalReferences || new Map();
              var _loop_1 = function (i) {
                  funcIriAttributes.forEach(function (attr) {
                      /** @type {?} */
                      var elementWithReference = elementsWithFuncIri[i];
                      /** @type {?} */
                      var value = elementWithReference.getAttribute(attr);
                      /** @type {?} */
                      var match = value ? value.match(funcIriPattern) : null;
                      if (match) {
                          /** @type {?} */
                          var attributes = elements.get(elementWithReference);
                          if (!attributes) {
                              attributes = [];
                              elements.set(elementWithReference, attributes);
                          }
                          ( /** @type {?} */(attributes)).push({ name: attr, value: match[1] });
                      }
                  });
              };
              for (var i = 0; i < elementsWithFuncIri.length; i++) {
                  _loop_1(i);
              }
          };
      MatIcon.decorators = [
          { type: core.Component, args: [{ template: '<ng-content></ng-content>',
                      selector: 'mat-icon',
                      exportAs: 'matIcon',
                      styles: [".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1,1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}"],
                      inputs: ['color'],
                      host: {
                          'role': 'img',
                          'class': 'mat-icon notranslate',
                          '[class.mat-icon-inline]': 'inline',
                          '[class.mat-icon-no-color]': 'color !== "primary" && color !== "accent" && color !== "warn"',
                      },
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatIcon.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: MatIconRegistry },
              { type: String, decorators: [{ type: core.Attribute, args: ['aria-hidden',] }] },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_ICON_LOCATION,] }] }
          ];
      };
      MatIcon.propDecorators = {
          inline: [{ type: core.Input }],
          svgIcon: [{ type: core.Input }],
          fontSet: [{ type: core.Input }],
          fontIcon: [{ type: core.Input }]
      };
      return MatIcon;
  }(_MatIconMixinBase));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Boilerplate for applying mixins to MatList.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatList.
  /**
   * \@docs-private
   */
  MatListBase = /** @class */ (function () {
      function MatListBase() {
      }
      return MatListBase;
  }());
  /** @type {?} */
  var _MatListMixinBase = mixinDisableRipple(MatListBase);
  // Boilerplate for applying mixins to MatListItem.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatListItem.
  /**
   * \@docs-private
   */
  MatListItemBase = /** @class */ (function () {
      function MatListItemBase() {
      }
      return MatListItemBase;
  }());
  /** @type {?} */
  var _MatListItemMixinBase = mixinDisableRipple(MatListItemBase);
  var MatNavList = /** @class */ (function (_super) {
      tslib_1.__extends(MatNavList, _super);
      function MatNavList() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          /**
           * Emits when the state of the list changes.
           */
          _this._stateChanges = new rxjs.Subject();
          return _this;
      }
      /**
       * @return {?}
       */
      MatNavList.prototype.ngOnChanges = /**
       * @return {?}
       */
          function () {
              this._stateChanges.next();
          };
      /**
       * @return {?}
       */
      MatNavList.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._stateChanges.complete();
          };
      MatNavList.decorators = [
          { type: core.Component, args: [{ selector: 'mat-nav-list',
                      exportAs: 'matNavList',
                      host: {
                          'role': 'navigation',
                          'class': 'mat-nav-list mat-list-base'
                      },
                      template: "<ng-content></ng-content>",
                      styles: [".mat-subheader{display:flex;box-sizing:border-box;padding:16px;align-items:center}.mat-list-base .mat-subheader{margin:0}.mat-list-base{padding-top:8px;display:block;-webkit-tap-highlight-color:transparent}.mat-list-base .mat-subheader{height:48px;line-height:16px}.mat-list-base .mat-subheader:first-child{margin-top:-8px}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{display:block;height:48px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base .mat-list-item .mat-list-item-content,.mat-list-base .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base .mat-list-item .mat-list-item-content-reverse,.mat-list-base .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base .mat-list-item .mat-list-item-ripple,.mat-list-base .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar,.mat-list-base .mat-list-option.mat-list-item-with-avatar{height:56px}.mat-list-base .mat-list-item.mat-2-line,.mat-list-base .mat-list-option.mat-2-line{height:72px}.mat-list-base .mat-list-item.mat-3-line,.mat-list-base .mat-list-option.mat-3-line{height:88px}.mat-list-base .mat-list-item.mat-multi-line,.mat-list-base .mat-list-option.mat-multi-line{height:auto}.mat-list-base .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base .mat-list-item .mat-list-text,.mat-list-base .mat-list-option .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base .mat-list-item .mat-list-text>*,.mat-list-base .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list-base .mat-list-item .mat-list-text:empty,.mat-list-base .mat-list-option .mat-list-text:empty{display:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base .mat-list-item .mat-list-avatar,.mat-list-base .mat-list-option .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%;object-fit:cover}.mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:72px;width:calc(100% - 72px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:72px}.mat-list-base .mat-list-item .mat-list-icon,.mat-list-base .mat-list-option .mat-list-icon{flex-shrink:0;width:24px;height:24px;font-size:24px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:64px;width:calc(100% - 64px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:64px}.mat-list-base .mat-list-item .mat-divider,.mat-list-base .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base .mat-list-item .mat-divider,[dir=rtl] .mat-list-base .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-list-base[dense]{padding-top:4px;display:block}.mat-list-base[dense] .mat-subheader{height:40px;line-height:8px}.mat-list-base[dense] .mat-subheader:first-child{margin-top:-4px}.mat-list-base[dense] .mat-list-item,.mat-list-base[dense] .mat-list-option{display:block;height:40px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-item-content,.mat-list-base[dense] .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base[dense] .mat-list-item .mat-list-item-content-reverse,.mat-list-base[dense] .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base[dense] .mat-list-item .mat-list-item-ripple,.mat-list-base[dense] .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar{height:48px}.mat-list-base[dense] .mat-list-item.mat-2-line,.mat-list-base[dense] .mat-list-option.mat-2-line{height:60px}.mat-list-base[dense] .mat-list-item.mat-3-line,.mat-list-base[dense] .mat-list-option.mat-3-line{height:76px}.mat-list-base[dense] .mat-list-item.mat-multi-line,.mat-list-base[dense] .mat-list-option.mat-multi-line{height:auto}.mat-list-base[dense] .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base[dense] .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base[dense] .mat-list-item .mat-list-text,.mat-list-base[dense] .mat-list-option .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-text>*,.mat-list-base[dense] .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list-base[dense] .mat-list-item .mat-list-text:empty,.mat-list-base[dense] .mat-list-option .mat-list-text:empty{display:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base[dense] .mat-list-item .mat-list-avatar,.mat-list-base[dense] .mat-list-option .mat-list-avatar{flex-shrink:0;width:36px;height:36px;border-radius:50%;object-fit:cover}.mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:68px;width:calc(100% - 68px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:68px}.mat-list-base[dense] .mat-list-item .mat-list-icon,.mat-list-base[dense] .mat-list-option .mat-list-icon{flex-shrink:0;width:20px;height:20px;font-size:20px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:60px;width:calc(100% - 60px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:60px}.mat-list-base[dense] .mat-list-item .mat-divider,.mat-list-base[dense] .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-divider,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base[dense] .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-nav-list a{text-decoration:none;color:inherit}.mat-nav-list .mat-list-item{cursor:pointer;outline:0}mat-action-list button{background:0 0;color:inherit;border:none;font:inherit;outline:inherit;-webkit-tap-highlight-color:transparent}mat-action-list button::-moz-focus-inner{border:0}mat-action-list .mat-list-item{cursor:pointer;outline:inherit}.mat-list-option:not(.mat-list-item-disabled){cursor:pointer;outline:0}@media (-ms-high-contrast:active){.mat-selection-list:focus{outline-style:dotted}.mat-list-option:focus,.mat-list-option:hover,.mat-nav-list .mat-list-item:focus,.mat-nav-list .mat-list-item:hover,mat-action-list .mat-list-item:focus,mat-action-list .mat-list-item:hover{outline:dotted 1px}}@media (hover:none){.mat-list-option:not(.mat-list-item-disabled):hover,.mat-nav-list .mat-list-item:not(.mat-list-item-disabled):hover{background:0 0}}"],
                      inputs: ['disableRipple'],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      return MatNavList;
  }(_MatListMixinBase));
  var MatList = /** @class */ (function (_super) {
      tslib_1.__extends(MatList, _super);
      /**
       * @deprecated _elementRef parameter to be made required.
       * @breaking-change 8.0.0
       */
      function MatList(_elementRef) {
          var _this = _super.call(this) || this;
          _this._elementRef = _elementRef;
          /**
           * Emits when the state of the list changes.
           */
          _this._stateChanges = new rxjs.Subject();
          return _this;
      }
      /**
       * @return {?}
       */
      MatList.prototype._getListType = /**
       * @return {?}
       */
          function () {
              /** @type {?} */
              var elementRef = this._elementRef;
              // @breaking-change 8.0.0 Remove null check once _elementRef is a required param.
              if (elementRef) {
                  /** @type {?} */
                  var nodeName = elementRef.nativeElement.nodeName.toLowerCase();
                  if (nodeName === 'mat-list') {
                      return 'list';
                  }
                  if (nodeName === 'mat-action-list') {
                      return 'action-list';
                  }
              }
              return null;
          };
      /**
       * @return {?}
       */
      MatList.prototype.ngOnChanges = /**
       * @return {?}
       */
          function () {
              this._stateChanges.next();
          };
      /**
       * @return {?}
       */
      MatList.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._stateChanges.complete();
          };
      MatList.decorators = [
          { type: core.Component, args: [{ selector: 'mat-list, mat-action-list',
                      exportAs: 'matList',
                      template: "<ng-content></ng-content>",
                      host: {
                          'class': 'mat-list mat-list-base'
                      },
                      styles: [".mat-subheader{display:flex;box-sizing:border-box;padding:16px;align-items:center}.mat-list-base .mat-subheader{margin:0}.mat-list-base{padding-top:8px;display:block;-webkit-tap-highlight-color:transparent}.mat-list-base .mat-subheader{height:48px;line-height:16px}.mat-list-base .mat-subheader:first-child{margin-top:-8px}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{display:block;height:48px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base .mat-list-item .mat-list-item-content,.mat-list-base .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base .mat-list-item .mat-list-item-content-reverse,.mat-list-base .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base .mat-list-item .mat-list-item-ripple,.mat-list-base .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar,.mat-list-base .mat-list-option.mat-list-item-with-avatar{height:56px}.mat-list-base .mat-list-item.mat-2-line,.mat-list-base .mat-list-option.mat-2-line{height:72px}.mat-list-base .mat-list-item.mat-3-line,.mat-list-base .mat-list-option.mat-3-line{height:88px}.mat-list-base .mat-list-item.mat-multi-line,.mat-list-base .mat-list-option.mat-multi-line{height:auto}.mat-list-base .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base .mat-list-item .mat-list-text,.mat-list-base .mat-list-option .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base .mat-list-item .mat-list-text>*,.mat-list-base .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list-base .mat-list-item .mat-list-text:empty,.mat-list-base .mat-list-option .mat-list-text:empty{display:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base .mat-list-item .mat-list-avatar,.mat-list-base .mat-list-option .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%;object-fit:cover}.mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:72px;width:calc(100% - 72px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:72px}.mat-list-base .mat-list-item .mat-list-icon,.mat-list-base .mat-list-option .mat-list-icon{flex-shrink:0;width:24px;height:24px;font-size:24px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:64px;width:calc(100% - 64px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:64px}.mat-list-base .mat-list-item .mat-divider,.mat-list-base .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base .mat-list-item .mat-divider,[dir=rtl] .mat-list-base .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-list-base[dense]{padding-top:4px;display:block}.mat-list-base[dense] .mat-subheader{height:40px;line-height:8px}.mat-list-base[dense] .mat-subheader:first-child{margin-top:-4px}.mat-list-base[dense] .mat-list-item,.mat-list-base[dense] .mat-list-option{display:block;height:40px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-item-content,.mat-list-base[dense] .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base[dense] .mat-list-item .mat-list-item-content-reverse,.mat-list-base[dense] .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base[dense] .mat-list-item .mat-list-item-ripple,.mat-list-base[dense] .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar{height:48px}.mat-list-base[dense] .mat-list-item.mat-2-line,.mat-list-base[dense] .mat-list-option.mat-2-line{height:60px}.mat-list-base[dense] .mat-list-item.mat-3-line,.mat-list-base[dense] .mat-list-option.mat-3-line{height:76px}.mat-list-base[dense] .mat-list-item.mat-multi-line,.mat-list-base[dense] .mat-list-option.mat-multi-line{height:auto}.mat-list-base[dense] .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base[dense] .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base[dense] .mat-list-item .mat-list-text,.mat-list-base[dense] .mat-list-option .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-text>*,.mat-list-base[dense] .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list-base[dense] .mat-list-item .mat-list-text:empty,.mat-list-base[dense] .mat-list-option .mat-list-text:empty{display:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base[dense] .mat-list-item .mat-list-avatar,.mat-list-base[dense] .mat-list-option .mat-list-avatar{flex-shrink:0;width:36px;height:36px;border-radius:50%;object-fit:cover}.mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:68px;width:calc(100% - 68px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:68px}.mat-list-base[dense] .mat-list-item .mat-list-icon,.mat-list-base[dense] .mat-list-option .mat-list-icon{flex-shrink:0;width:20px;height:20px;font-size:20px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:60px;width:calc(100% - 60px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:60px}.mat-list-base[dense] .mat-list-item .mat-divider,.mat-list-base[dense] .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-divider,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base[dense] .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-nav-list a{text-decoration:none;color:inherit}.mat-nav-list .mat-list-item{cursor:pointer;outline:0}mat-action-list button{background:0 0;color:inherit;border:none;font:inherit;outline:inherit;-webkit-tap-highlight-color:transparent}mat-action-list button::-moz-focus-inner{border:0}mat-action-list .mat-list-item{cursor:pointer;outline:inherit}.mat-list-option:not(.mat-list-item-disabled){cursor:pointer;outline:0}@media (-ms-high-contrast:active){.mat-selection-list:focus{outline-style:dotted}.mat-list-option:focus,.mat-list-option:hover,.mat-nav-list .mat-list-item:focus,.mat-nav-list .mat-list-item:hover,mat-action-list .mat-list-item:focus,mat-action-list .mat-list-item:hover{outline:dotted 1px}}@media (hover:none){.mat-list-option:not(.mat-list-item-disabled):hover,.mat-nav-list .mat-list-item:not(.mat-list-item-disabled):hover{background:0 0}}"],
                      inputs: ['disableRipple'],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatList.ctorParameters = function () {
          return [
              { type: core.ElementRef }
          ];
      };
      return MatList;
  }(_MatListMixinBase));
  /**
   * Directive whose purpose is to add the mat- CSS styling to this selector.
   * \@docs-private
   */
  var MatListAvatarCssMatStyler = /** @class */ (function () {
      function MatListAvatarCssMatStyler() {
      }
      MatListAvatarCssMatStyler.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mat-list-avatar], [matListAvatar]',
                      host: { 'class': 'mat-list-avatar' }
                  },] },
      ];
      return MatListAvatarCssMatStyler;
  }());
  /**
   * Directive whose purpose is to add the mat- CSS styling to this selector.
   * \@docs-private
   */
  var MatListIconCssMatStyler = /** @class */ (function () {
      function MatListIconCssMatStyler() {
      }
      MatListIconCssMatStyler.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mat-list-icon], [matListIcon]',
                      host: { 'class': 'mat-list-icon' }
                  },] },
      ];
      return MatListIconCssMatStyler;
  }());
  /**
   * An item within a Material Design list.
   */
  var MatListItem = /** @class */ (function (_super) {
      tslib_1.__extends(MatListItem, _super);
      function MatListItem(_element, navList, list, 
      // @breaking-change 8.0.0 `_changeDetectorRef` to be made into a required parameter.
      _changeDetectorRef) {
          var _this = _super.call(this) || this;
          _this._element = _element;
          _this._isInteractiveList = false;
          _this._destroyed = new rxjs.Subject();
          _this._isInteractiveList = !!(navList || (list && list._getListType() === 'action-list'));
          _this._list = navList || list;
          // If no type attributed is specified for <button>, set it to "button".
          // If a type attribute is already specified, do nothing.
          /** @type {?} */
          var element = _this._getHostElement();
          if (element.nodeName.toLowerCase() === 'button' && !element.hasAttribute('type')) {
              element.setAttribute('type', 'button');
          }
          // @breaking-change 8.0.0 Remove null check for _changeDetectorRef.
          if (_this._list && _changeDetectorRef) {
              // React to changes in the state of the parent list since
              // some of the item's properties depend on it (e.g. `disableRipple`).
              _this._list._stateChanges.pipe(operators.takeUntil(_this._destroyed)).subscribe(function () {
                  _changeDetectorRef.markForCheck();
              });
          }
          return _this;
      }
      /**
       * @return {?}
       */
      MatListItem.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              setLines(this._lines, this._element);
          };
      /**
       * @return {?}
       */
      MatListItem.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._destroyed.next();
              this._destroyed.complete();
          };
      /** Whether this list item should show a ripple effect when clicked. */
      /**
       * Whether this list item should show a ripple effect when clicked.
       * @return {?}
       */
      MatListItem.prototype._isRippleDisabled = /**
       * Whether this list item should show a ripple effect when clicked.
       * @return {?}
       */
          function () {
              return !this._isInteractiveList || this.disableRipple ||
                  !!(this._list && this._list.disableRipple);
          };
      /** Retrieves the DOM element of the component host. */
      /**
       * Retrieves the DOM element of the component host.
       * @return {?}
       */
      MatListItem.prototype._getHostElement = /**
       * Retrieves the DOM element of the component host.
       * @return {?}
       */
          function () {
              return this._element.nativeElement;
          };
      MatListItem.decorators = [
          { type: core.Component, args: [{ selector: 'mat-list-item, a[mat-list-item], button[mat-list-item]',
                      exportAs: 'matListItem',
                      host: {
                          'class': 'mat-list-item',
                          // @breaking-change 8.0.0 Remove `mat-list-item-avatar` in favor of `mat-list-item-with-avatar`.
                          '[class.mat-list-item-avatar]': '_avatar || _icon',
                          '[class.mat-list-item-with-avatar]': '_avatar || _icon',
                      },
                      inputs: ['disableRipple'],
                      template: "<div class=\"mat-list-item-content\"><div class=\"mat-list-item-ripple\" mat-ripple [matRippleTrigger]=\"_getHostElement()\" [matRippleDisabled]=\"_isRippleDisabled()\"></div><ng-content select=\"[mat-list-avatar], [mat-list-icon], [matListAvatar], [matListIcon]\"></ng-content><div class=\"mat-list-text\"><ng-content select=\"[mat-line], [matLine]\"></ng-content></div><ng-content></ng-content></div>",
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatListItem.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: MatNavList, decorators: [{ type: core.Optional }] },
              { type: MatList, decorators: [{ type: core.Optional }] },
              { type: core.ChangeDetectorRef }
          ];
      };
      MatListItem.propDecorators = {
          _lines: [{ type: core.ContentChildren, args: [MatLine,] }],
          _avatar: [{ type: core.ContentChild, args: [MatListAvatarCssMatStyler,] }],
          _icon: [{ type: core.ContentChild, args: [MatListIconCssMatStyler,] }]
      };
      return MatListItem;
  }(_MatListItemMixinBase));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@docs-private
   */
  var /**
   * \@docs-private
   */ MatSelectionListBase = /** @class */ (function () {
      function MatSelectionListBase() {
      }
      return MatSelectionListBase;
  }());
  /** @type {?} */
  var _MatSelectionListMixinBase = mixinDisableRipple(MatSelectionListBase);
  /**
   * \@docs-private
   */
  var /**
   * \@docs-private
   */ MatListOptionBase = /** @class */ (function () {
      function MatListOptionBase() {
      }
      return MatListOptionBase;
  }());
  /** @type {?} */
  var _MatListOptionMixinBase = mixinDisableRipple(MatListOptionBase);
  /**
   * \@docs-private
   * @type {?}
   */
  var MAT_SELECTION_LIST_VALUE_ACCESSOR = {
      provide: forms.NG_VALUE_ACCESSOR,
      useExisting: core.forwardRef(function () { return MatSelectionList; }),
      multi: true
  };
  /**
   * Change event that is being fired whenever the selected state of an option changes.
   */
  var /**
   * Change event that is being fired whenever the selected state of an option changes.
   */ MatSelectionListChange = /** @class */ (function () {
      function MatSelectionListChange(source, option) {
          this.source = source;
          this.option = option;
      }
      return MatSelectionListChange;
  }());
  /**
   * Component for list-options of selection-list. Each list-option can automatically
   * generate a checkbox and can put current item into the selectionModel of selection-list
   * if the current item is selected.
   */
  var MatListOption = /** @class */ (function (_super) {
      tslib_1.__extends(MatListOption, _super);
      function MatListOption(_element, _changeDetector, selectionList) {
          var _this = _super.call(this) || this;
          _this._element = _element;
          _this._changeDetector = _changeDetector;
          _this.selectionList = selectionList;
          _this._selected = false;
          _this._disabled = false;
          _this._hasFocus = false;
          /**
           * Whether the label should appear before or after the checkbox. Defaults to 'after'
           */
          _this.checkboxPosition = 'after';
          return _this;
      }
      Object.defineProperty(MatListOption.prototype, "value", {
          /** Value of the option */
          get: /**
           * Value of the option
           * @return {?}
           */ function () { return this._value; },
          set: /**
           * @param {?} newValue
           * @return {?}
           */ function (newValue) {
              if (this.selected && newValue !== this.value) {
                  this.selected = false;
              }
              this._value = newValue;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatListOption.prototype, "disabled", {
          /** Whether the option is disabled. */
          get: /**
           * Whether the option is disabled.
           * @return {?}
           */ function () { return this._disabled || (this.selectionList && this.selectionList.disabled); },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var newValue = coerceBooleanProperty(value);
              if (newValue !== this._disabled) {
                  this._disabled = newValue;
                  this._changeDetector.markForCheck();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatListOption.prototype, "selected", {
          /** Whether the option is selected. */
          get: /**
           * Whether the option is selected.
           * @return {?}
           */ function () { return this.selectionList.selectedOptions.isSelected(this); },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var isSelected = coerceBooleanProperty(value);
              if (isSelected !== this._selected) {
                  this._setSelected(isSelected);
                  this.selectionList._reportValueChange();
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatListOption.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              // List options that are selected at initialization can't be reported properly to the form
              // control. This is because it takes some time until the selection-list knows about all
              // available options. Also it can happen that the ControlValueAccessor has an initial value
              // that should be used instead. Deferring the value change report to the next tick ensures
              // that the form control value is not being overwritten.
              /** @type {?} */
              var wasSelected = this._selected;
              Promise.resolve().then(function () {
                  if (_this._selected || wasSelected) {
                      _this.selected = true;
                      _this._changeDetector.markForCheck();
                  }
              });
          };
      /**
       * @return {?}
       */
      MatListOption.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              setLines(this._lines, this._element);
          };
      /**
       * @return {?}
       */
      MatListOption.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              var _this = this;
              if (this.selected) {
                  // We have to delay this until the next tick in order
                  // to avoid changed after checked errors.
                  Promise.resolve().then(function () { return _this.selected = false; });
              }
              /** @type {?} */
              var hadFocus = this._hasFocus;
              /** @type {?} */
              var newActiveItem = this.selectionList._removeOptionFromList(this);
              // Only move focus if this option was focused at the time it was destroyed.
              if (hadFocus && newActiveItem) {
                  newActiveItem.focus();
              }
          };
      /** Toggles the selection state of the option. */
      /**
       * Toggles the selection state of the option.
       * @return {?}
       */
      MatListOption.prototype.toggle = /**
       * Toggles the selection state of the option.
       * @return {?}
       */
          function () {
              this.selected = !this.selected;
          };
      /** Allows for programmatic focusing of the option. */
      /**
       * Allows for programmatic focusing of the option.
       * @return {?}
       */
      MatListOption.prototype.focus = /**
       * Allows for programmatic focusing of the option.
       * @return {?}
       */
          function () {
              this._element.nativeElement.focus();
          };
      /**
       * Returns the list item's text label. Implemented as a part of the FocusKeyManager.
       * @docs-private
       */
      /**
       * Returns the list item's text label. Implemented as a part of the FocusKeyManager.
       * \@docs-private
       * @return {?}
       */
      MatListOption.prototype.getLabel = /**
       * Returns the list item's text label. Implemented as a part of the FocusKeyManager.
       * \@docs-private
       * @return {?}
       */
          function () {
              return this._text ? (this._text.nativeElement.textContent || '') : '';
          };
      /** Whether this list item should show a ripple effect when clicked. */
      /**
       * Whether this list item should show a ripple effect when clicked.
       * @return {?}
       */
      MatListOption.prototype._isRippleDisabled = /**
       * Whether this list item should show a ripple effect when clicked.
       * @return {?}
       */
          function () {
              return this.disabled || this.disableRipple || this.selectionList.disableRipple;
          };
      /**
       * @return {?}
       */
      MatListOption.prototype._handleClick = /**
       * @return {?}
       */
          function () {
              if (!this.disabled) {
                  this.toggle();
                  // Emit a change event if the selected state of the option changed through user interaction.
                  this.selectionList._emitChangeEvent(this);
              }
          };
      /**
       * @return {?}
       */
      MatListOption.prototype._handleFocus = /**
       * @return {?}
       */
          function () {
              this.selectionList._setFocusedOption(this);
              this._hasFocus = true;
          };
      /**
       * @return {?}
       */
      MatListOption.prototype._handleBlur = /**
       * @return {?}
       */
          function () {
              this.selectionList._onTouched();
              this._hasFocus = false;
          };
      /** Retrieves the DOM element of the component host. */
      /**
       * Retrieves the DOM element of the component host.
       * @return {?}
       */
      MatListOption.prototype._getHostElement = /**
       * Retrieves the DOM element of the component host.
       * @return {?}
       */
          function () {
              return this._element.nativeElement;
          };
      /** Sets the selected state of the option. Returns whether the value has changed. */
      /**
       * Sets the selected state of the option. Returns whether the value has changed.
       * @param {?} selected
       * @return {?}
       */
      MatListOption.prototype._setSelected = /**
       * Sets the selected state of the option. Returns whether the value has changed.
       * @param {?} selected
       * @return {?}
       */
          function (selected) {
              if (selected === this._selected) {
                  return false;
              }
              this._selected = selected;
              if (selected) {
                  this.selectionList.selectedOptions.select(this);
              }
              else {
                  this.selectionList.selectedOptions.deselect(this);
              }
              this._changeDetector.markForCheck();
              return true;
          };
      /**
       * Notifies Angular that the option needs to be checked in the next change detection run. Mainly
       * used to trigger an update of the list option if the disabled state of the selection list
       * changed.
       */
      /**
       * Notifies Angular that the option needs to be checked in the next change detection run. Mainly
       * used to trigger an update of the list option if the disabled state of the selection list
       * changed.
       * @return {?}
       */
      MatListOption.prototype._markForCheck = /**
       * Notifies Angular that the option needs to be checked in the next change detection run. Mainly
       * used to trigger an update of the list option if the disabled state of the selection list
       * changed.
       * @return {?}
       */
          function () {
              this._changeDetector.markForCheck();
          };
      MatListOption.decorators = [
          { type: core.Component, args: [{ selector: 'mat-list-option',
                      exportAs: 'matListOption',
                      inputs: ['disableRipple'],
                      host: {
                          'role': 'option',
                          'class': 'mat-list-item mat-list-option',
                          '(focus)': '_handleFocus()',
                          '(blur)': '_handleBlur()',
                          '(click)': '_handleClick()',
                          'tabindex': '-1',
                          '[class.mat-list-item-disabled]': 'disabled',
                          '[class.mat-list-item-with-avatar]': '_avatar || _icon',
                          '[attr.aria-selected]': 'selected.toString()',
                          '[attr.aria-disabled]': 'disabled.toString()',
                      },
                      template: "<div class=\"mat-list-item-content\" [class.mat-list-item-content-reverse]=\"checkboxPosition == 'after'\"><div mat-ripple class=\"mat-list-item-ripple\" [matRippleTrigger]=\"_getHostElement()\" [matRippleDisabled]=\"_isRippleDisabled()\"></div><mat-pseudo-checkbox [state]=\"selected ? 'checked' : 'unchecked'\" [disabled]=\"disabled\"></mat-pseudo-checkbox><div class=\"mat-list-text\" #text><ng-content></ng-content></div><ng-content select=\"[mat-list-avatar], [mat-list-icon], [matListAvatar], [matListIcon]\"></ng-content></div>",
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatListOption.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.ChangeDetectorRef },
              { type: MatSelectionList, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return MatSelectionList; }),] }] }
          ];
      };
      MatListOption.propDecorators = {
          _avatar: [{ type: core.ContentChild, args: [MatListAvatarCssMatStyler,] }],
          _icon: [{ type: core.ContentChild, args: [MatListIconCssMatStyler,] }],
          _lines: [{ type: core.ContentChildren, args: [MatLine,] }],
          _text: [{ type: core.ViewChild, args: ['text',] }],
          checkboxPosition: [{ type: core.Input }],
          value: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          selected: [{ type: core.Input }]
      };
      return MatListOption;
  }(_MatListOptionMixinBase));
  /**
   * Material Design list component where each item is a selectable option. Behaves as a listbox.
   */
  var MatSelectionList = /** @class */ (function (_super) {
      tslib_1.__extends(MatSelectionList, _super);
      function MatSelectionList(_element, tabIndex) {
          var _this = _super.call(this) || this;
          _this._element = _element;
          /**
           * Emits a change event whenever the selected state of an option changes.
           */
          _this.selectionChange = new core.EventEmitter();
          /**
           * Tabindex of the selection list.
           */
          _this.tabIndex = 0;
          _this._disabled = false;
          /**
           * The currently selected options.
           */
          _this.selectedOptions = new SelectionModel(true);
          /**
           * View to model callback that should be called whenever the selected options change.
           */
          _this._onChange = function (_) { };
          /**
           * Subscription to sync value changes in the SelectionModel back to the SelectionList.
           */
          _this._modelChanges = rxjs.Subscription.EMPTY;
          /**
           * View to model callback that should be called if the list or its options lost focus.
           */
          _this._onTouched = function () { };
          _this.tabIndex = parseInt(tabIndex) || 0;
          return _this;
      }
      Object.defineProperty(MatSelectionList.prototype, "disabled", {
          /** Whether the selection list is disabled. */
          get: /**
           * Whether the selection list is disabled.
           * @return {?}
           */ function () { return this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._disabled = coerceBooleanProperty(value);
              // The `MatSelectionList` and `MatListOption` are using the `OnPush` change detection
              // strategy. Therefore the options will not check for any changes if the `MatSelectionList`
              // changed its state. Since we know that a change to `disabled` property of the list affects
              // the state of the options, we manually mark each option for check.
              if (this.options) {
                  this.options.forEach(function (option) { return option._markForCheck(); });
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatSelectionList.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this._keyManager = new FocusKeyManager(this.options)
                  .withWrap()
                  .withTypeAhead()
                  // Allow disabled items to be focusable. For accessibility reasons, there must be a way for
                  // screenreader users, that allows reading the different options of the list.
                  .skipPredicate(function () { return false; })
                  .withAllowedModifierKeys(['shiftKey']);
              if (this._tempValues) {
                  this._setOptionsFromValues(this._tempValues);
                  this._tempValues = null;
              }
              // Sync external changes to the model back to the options.
              this._modelChanges = this.selectedOptions.onChange.subscribe(function (event) {
                  if (event.added) {
                      for (var _i = 0, _a = event.added; _i < _a.length; _i++) {
                          var item = _a[_i];
                          item.selected = true;
                      }
                  }
                  if (event.removed) {
                      for (var _b = 0, _c = event.removed; _b < _c.length; _b++) {
                          var item = _c[_b];
                          item.selected = false;
                      }
                  }
              });
          };
      /**
       * @return {?}
       */
      MatSelectionList.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._modelChanges.unsubscribe();
          };
      /** Focuses the last active list option. */
      /**
       * Focuses the last active list option.
       * @return {?}
       */
      MatSelectionList.prototype.focus = /**
       * Focuses the last active list option.
       * @return {?}
       */
          function () {
              this._element.nativeElement.focus();
          };
      /** Selects all of the options. */
      /**
       * Selects all of the options.
       * @return {?}
       */
      MatSelectionList.prototype.selectAll = /**
       * Selects all of the options.
       * @return {?}
       */
          function () {
              this._setAllOptionsSelected(true);
          };
      /** Deselects all of the options. */
      /**
       * Deselects all of the options.
       * @return {?}
       */
      MatSelectionList.prototype.deselectAll = /**
       * Deselects all of the options.
       * @return {?}
       */
          function () {
              this._setAllOptionsSelected(false);
          };
      /** Sets the focused option of the selection-list. */
      /**
       * Sets the focused option of the selection-list.
       * @param {?} option
       * @return {?}
       */
      MatSelectionList.prototype._setFocusedOption = /**
       * Sets the focused option of the selection-list.
       * @param {?} option
       * @return {?}
       */
          function (option) {
              this._keyManager.updateActiveItemIndex(this._getOptionIndex(option));
          };
      /**
       * Removes an option from the selection list and updates the active item.
       * @returns Currently-active item.
       */
      /**
       * Removes an option from the selection list and updates the active item.
       * @param {?} option
       * @return {?} Currently-active item.
       */
      MatSelectionList.prototype._removeOptionFromList = /**
       * Removes an option from the selection list and updates the active item.
       * @param {?} option
       * @return {?} Currently-active item.
       */
          function (option) {
              /** @type {?} */
              var optionIndex = this._getOptionIndex(option);
              if (optionIndex > -1 && this._keyManager.activeItemIndex === optionIndex) {
                  // Check whether the option is the last item
                  if (optionIndex > 0) {
                      this._keyManager.updateActiveItemIndex(optionIndex - 1);
                  }
                  else if (optionIndex === 0 && this.options.length > 1) {
                      this._keyManager.updateActiveItemIndex(Math.min(optionIndex + 1, this.options.length - 1));
                  }
              }
              return this._keyManager.activeItem;
          };
      /** Passes relevant key presses to our key manager. */
      /**
       * Passes relevant key presses to our key manager.
       * @param {?} event
       * @return {?}
       */
      MatSelectionList.prototype._keydown = /**
       * Passes relevant key presses to our key manager.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var keyCode = event.keyCode;
              /** @type {?} */
              var manager = this._keyManager;
              /** @type {?} */
              var previousFocusIndex = manager.activeItemIndex;
              /** @type {?} */
              var hasModifier = hasModifierKey(event);
              switch (keyCode) {
                  case SPACE:
                  case ENTER:
                      if (!hasModifier) {
                          this._toggleFocusedOption();
                          // Always prevent space from scrolling the page since the list has focus
                          event.preventDefault();
                      }
                      break;
                  case HOME:
                  case END:
                      if (!hasModifier) {
                          keyCode === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();
                          event.preventDefault();
                      }
                      break;
                  case A:
                      if (hasModifierKey(event, 'ctrlKey')) {
                          this.options.find(function (option) { return !option.selected; }) ? this.selectAll() : this.deselectAll();
                          event.preventDefault();
                      }
                      break;
                  default:
                      manager.onKeydown(event);
              }
              if ((keyCode === UP_ARROW || keyCode === DOWN_ARROW) && event.shiftKey &&
                  manager.activeItemIndex !== previousFocusIndex) {
                  this._toggleFocusedOption();
              }
          };
      /** Reports a value change to the ControlValueAccessor */
      /**
       * Reports a value change to the ControlValueAccessor
       * @return {?}
       */
      MatSelectionList.prototype._reportValueChange = /**
       * Reports a value change to the ControlValueAccessor
       * @return {?}
       */
          function () {
              if (this.options) {
                  this._onChange(this._getSelectedOptionValues());
              }
          };
      /** Emits a change event if the selected state of an option changed. */
      /**
       * Emits a change event if the selected state of an option changed.
       * @param {?} option
       * @return {?}
       */
      MatSelectionList.prototype._emitChangeEvent = /**
       * Emits a change event if the selected state of an option changed.
       * @param {?} option
       * @return {?}
       */
          function (option) {
              this.selectionChange.emit(new MatSelectionListChange(this, option));
          };
      /** Implemented as part of ControlValueAccessor. */
      /**
       * Implemented as part of ControlValueAccessor.
       * @param {?} values
       * @return {?}
       */
      MatSelectionList.prototype.writeValue = /**
       * Implemented as part of ControlValueAccessor.
       * @param {?} values
       * @return {?}
       */
          function (values) {
              if (this.options) {
                  this._setOptionsFromValues(values || []);
              }
              else {
                  this._tempValues = values;
              }
          };
      /** Implemented as a part of ControlValueAccessor. */
      /**
       * Implemented as a part of ControlValueAccessor.
       * @param {?} isDisabled
       * @return {?}
       */
      MatSelectionList.prototype.setDisabledState = /**
       * Implemented as a part of ControlValueAccessor.
       * @param {?} isDisabled
       * @return {?}
       */
          function (isDisabled) {
              this.disabled = isDisabled;
          };
      /** Implemented as part of ControlValueAccessor. */
      /**
       * Implemented as part of ControlValueAccessor.
       * @param {?} fn
       * @return {?}
       */
      MatSelectionList.prototype.registerOnChange = /**
       * Implemented as part of ControlValueAccessor.
       * @param {?} fn
       * @return {?}
       */
          function (fn) {
              this._onChange = fn;
          };
      /** Implemented as part of ControlValueAccessor. */
      /**
       * Implemented as part of ControlValueAccessor.
       * @param {?} fn
       * @return {?}
       */
      MatSelectionList.prototype.registerOnTouched = /**
       * Implemented as part of ControlValueAccessor.
       * @param {?} fn
       * @return {?}
       */
          function (fn) {
              this._onTouched = fn;
          };
      /** Sets the selected options based on the specified values. */
      /**
       * Sets the selected options based on the specified values.
       * @private
       * @param {?} values
       * @return {?}
       */
      MatSelectionList.prototype._setOptionsFromValues = /**
       * Sets the selected options based on the specified values.
       * @private
       * @param {?} values
       * @return {?}
       */
          function (values) {
              var _this = this;
              this.options.forEach(function (option) { return option._setSelected(false); });
              values.forEach(function (value) {
                  /** @type {?} */
                  var correspondingOption = _this.options.find(function (option) {
                      // Skip options that are already in the model. This allows us to handle cases
                      // where the same primitive value is selected multiple times.
                      if (option.selected) {
                          return false;
                      }
                      return _this.compareWith ? _this.compareWith(option.value, value) : option.value === value;
                  });
                  if (correspondingOption) {
                      correspondingOption._setSelected(true);
                  }
              });
          };
      /** Returns the values of the selected options. */
      /**
       * Returns the values of the selected options.
       * @private
       * @return {?}
       */
      MatSelectionList.prototype._getSelectedOptionValues = /**
       * Returns the values of the selected options.
       * @private
       * @return {?}
       */
          function () {
              return this.options.filter(function (option) { return option.selected; }).map(function (option) { return option.value; });
          };
      /** Toggles the state of the currently focused option if enabled. */
      /**
       * Toggles the state of the currently focused option if enabled.
       * @private
       * @return {?}
       */
      MatSelectionList.prototype._toggleFocusedOption = /**
       * Toggles the state of the currently focused option if enabled.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var focusedIndex = this._keyManager.activeItemIndex;
              if (focusedIndex != null && this._isValidIndex(focusedIndex)) {
                  /** @type {?} */
                  var focusedOption = this.options.toArray()[focusedIndex];
                  if (focusedOption && !focusedOption.disabled) {
                      focusedOption.toggle();
                      // Emit a change event because the focused option changed its state through user
                      // interaction.
                      this._emitChangeEvent(focusedOption);
                  }
              }
          };
      /**
       * Sets the selected state on all of the options
       * and emits an event if anything changed.
       */
      /**
       * Sets the selected state on all of the options
       * and emits an event if anything changed.
       * @private
       * @param {?} isSelected
       * @return {?}
       */
      MatSelectionList.prototype._setAllOptionsSelected = /**
       * Sets the selected state on all of the options
       * and emits an event if anything changed.
       * @private
       * @param {?} isSelected
       * @return {?}
       */
          function (isSelected) {
              // Keep track of whether anything changed, because we only want to
              // emit the changed event when something actually changed.
              /** @type {?} */
              var hasChanged = false;
              this.options.forEach(function (option) {
                  if (option._setSelected(isSelected)) {
                      hasChanged = true;
                  }
              });
              if (hasChanged) {
                  this._reportValueChange();
              }
          };
      /**
       * Utility to ensure all indexes are valid.
       * @param index The index to be checked.
       * @returns True if the index is valid for our list of options.
       */
      /**
       * Utility to ensure all indexes are valid.
       * @private
       * @param {?} index The index to be checked.
       * @return {?} True if the index is valid for our list of options.
       */
      MatSelectionList.prototype._isValidIndex = /**
       * Utility to ensure all indexes are valid.
       * @private
       * @param {?} index The index to be checked.
       * @return {?} True if the index is valid for our list of options.
       */
          function (index) {
              return index >= 0 && index < this.options.length;
          };
      /** Returns the index of the specified list option. */
      /**
       * Returns the index of the specified list option.
       * @private
       * @param {?} option
       * @return {?}
       */
      MatSelectionList.prototype._getOptionIndex = /**
       * Returns the index of the specified list option.
       * @private
       * @param {?} option
       * @return {?}
       */
          function (option) {
              return this.options.toArray().indexOf(option);
          };
      MatSelectionList.decorators = [
          { type: core.Component, args: [{ selector: 'mat-selection-list',
                      exportAs: 'matSelectionList',
                      inputs: ['disableRipple'],
                      host: {
                          'role': 'listbox',
                          '[tabIndex]': 'tabIndex',
                          'class': 'mat-selection-list mat-list-base',
                          '(focus)': 'focus()',
                          '(blur)': '_onTouched()',
                          '(keydown)': '_keydown($event)',
                          'aria-multiselectable': 'true',
                          '[attr.aria-disabled]': 'disabled.toString()',
                      },
                      template: '<ng-content></ng-content>',
                      styles: [".mat-subheader{display:flex;box-sizing:border-box;padding:16px;align-items:center}.mat-list-base .mat-subheader{margin:0}.mat-list-base{padding-top:8px;display:block;-webkit-tap-highlight-color:transparent}.mat-list-base .mat-subheader{height:48px;line-height:16px}.mat-list-base .mat-subheader:first-child{margin-top:-8px}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{display:block;height:48px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base .mat-list-item .mat-list-item-content,.mat-list-base .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base .mat-list-item .mat-list-item-content-reverse,.mat-list-base .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base .mat-list-item .mat-list-item-ripple,.mat-list-base .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar,.mat-list-base .mat-list-option.mat-list-item-with-avatar{height:56px}.mat-list-base .mat-list-item.mat-2-line,.mat-list-base .mat-list-option.mat-2-line{height:72px}.mat-list-base .mat-list-item.mat-3-line,.mat-list-base .mat-list-option.mat-3-line{height:88px}.mat-list-base .mat-list-item.mat-multi-line,.mat-list-base .mat-list-option.mat-multi-line{height:auto}.mat-list-base .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base .mat-list-item .mat-list-text,.mat-list-base .mat-list-option .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base .mat-list-item .mat-list-text>*,.mat-list-base .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list-base .mat-list-item .mat-list-text:empty,.mat-list-base .mat-list-option .mat-list-text:empty{display:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base .mat-list-item .mat-list-avatar,.mat-list-base .mat-list-option .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%;object-fit:cover}.mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:72px;width:calc(100% - 72px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:72px}.mat-list-base .mat-list-item .mat-list-icon,.mat-list-base .mat-list-option .mat-list-icon{flex-shrink:0;width:24px;height:24px;font-size:24px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:64px;width:calc(100% - 64px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:64px}.mat-list-base .mat-list-item .mat-divider,.mat-list-base .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base .mat-list-item .mat-divider,[dir=rtl] .mat-list-base .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-list-base[dense]{padding-top:4px;display:block}.mat-list-base[dense] .mat-subheader{height:40px;line-height:8px}.mat-list-base[dense] .mat-subheader:first-child{margin-top:-4px}.mat-list-base[dense] .mat-list-item,.mat-list-base[dense] .mat-list-option{display:block;height:40px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-item-content,.mat-list-base[dense] .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base[dense] .mat-list-item .mat-list-item-content-reverse,.mat-list-base[dense] .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base[dense] .mat-list-item .mat-list-item-ripple,.mat-list-base[dense] .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar{height:48px}.mat-list-base[dense] .mat-list-item.mat-2-line,.mat-list-base[dense] .mat-list-option.mat-2-line{height:60px}.mat-list-base[dense] .mat-list-item.mat-3-line,.mat-list-base[dense] .mat-list-option.mat-3-line{height:76px}.mat-list-base[dense] .mat-list-item.mat-multi-line,.mat-list-base[dense] .mat-list-option.mat-multi-line{height:auto}.mat-list-base[dense] .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base[dense] .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base[dense] .mat-list-item .mat-list-text,.mat-list-base[dense] .mat-list-option .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-text>*,.mat-list-base[dense] .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list-base[dense] .mat-list-item .mat-list-text:empty,.mat-list-base[dense] .mat-list-option .mat-list-text:empty{display:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base[dense] .mat-list-item .mat-list-avatar,.mat-list-base[dense] .mat-list-option .mat-list-avatar{flex-shrink:0;width:36px;height:36px;border-radius:50%;object-fit:cover}.mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:68px;width:calc(100% - 68px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:68px}.mat-list-base[dense] .mat-list-item .mat-list-icon,.mat-list-base[dense] .mat-list-option .mat-list-icon{flex-shrink:0;width:20px;height:20px;font-size:20px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:60px;width:calc(100% - 60px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:60px}.mat-list-base[dense] .mat-list-item .mat-divider,.mat-list-base[dense] .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-divider,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base[dense] .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-nav-list a{text-decoration:none;color:inherit}.mat-nav-list .mat-list-item{cursor:pointer;outline:0}mat-action-list button{background:0 0;color:inherit;border:none;font:inherit;outline:inherit;-webkit-tap-highlight-color:transparent}mat-action-list button::-moz-focus-inner{border:0}mat-action-list .mat-list-item{cursor:pointer;outline:inherit}.mat-list-option:not(.mat-list-item-disabled){cursor:pointer;outline:0}@media (-ms-high-contrast:active){.mat-selection-list:focus{outline-style:dotted}.mat-list-option:focus,.mat-list-option:hover,.mat-nav-list .mat-list-item:focus,.mat-nav-list .mat-list-item:hover,mat-action-list .mat-list-item:focus,mat-action-list .mat-list-item:hover{outline:dotted 1px}}@media (hover:none){.mat-list-option:not(.mat-list-item-disabled):hover,.mat-nav-list .mat-list-item:not(.mat-list-item-disabled):hover{background:0 0}}"],
                      encapsulation: core.ViewEncapsulation.None,
                      providers: [MAT_SELECTION_LIST_VALUE_ACCESSOR],
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      /** @nocollapse */
      MatSelectionList.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] }
          ];
      };
      MatSelectionList.propDecorators = {
          options: [{ type: core.ContentChildren, args: [MatListOption, { descendants: true },] }],
          selectionChange: [{ type: core.Output }],
          tabIndex: [{ type: core.Input }],
          compareWith: [{ type: core.Input }],
          disabled: [{ type: core.Input }]
      };
      return MatSelectionList;
  }(_MatSelectionListMixinBase));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Menu content that will be rendered lazily once the menu is opened.
   */
  var MatMenuContent = /** @class */ (function () {
      function MatMenuContent(_template, _componentFactoryResolver, _appRef, _injector, _viewContainerRef, _document) {
          this._template = _template;
          this._componentFactoryResolver = _componentFactoryResolver;
          this._appRef = _appRef;
          this._injector = _injector;
          this._viewContainerRef = _viewContainerRef;
          this._document = _document;
          /**
           * Emits when the menu content has been attached.
           */
          this._attached = new rxjs.Subject();
      }
      /**
       * Attaches the content with a particular context.
       * @docs-private
       */
      /**
       * Attaches the content with a particular context.
       * \@docs-private
       * @param {?=} context
       * @return {?}
       */
      MatMenuContent.prototype.attach = /**
       * Attaches the content with a particular context.
       * \@docs-private
       * @param {?=} context
       * @return {?}
       */
          function (context) {
              if (context === void 0) {
                  context = {};
              }
              if (!this._portal) {
                  this._portal = new TemplatePortal(this._template, this._viewContainerRef);
              }
              this.detach();
              if (!this._outlet) {
                  this._outlet = new DomPortalOutlet(this._document.createElement('div'), this._componentFactoryResolver, this._appRef, this._injector);
              }
              /** @type {?} */
              var element = this._template.elementRef.nativeElement;
              // Because we support opening the same menu from different triggers (which in turn have their
              // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we
              // risk it staying attached to a pane that's no longer in the DOM.
              ( /** @type {?} */(element.parentNode)).insertBefore(this._outlet.outletElement, element);
              this._portal.attach(this._outlet, context);
              this._attached.next();
          };
      /**
       * Detaches the content.
       * @docs-private
       */
      /**
       * Detaches the content.
       * \@docs-private
       * @return {?}
       */
      MatMenuContent.prototype.detach = /**
       * Detaches the content.
       * \@docs-private
       * @return {?}
       */
          function () {
              if (this._portal.isAttached) {
                  this._portal.detach();
              }
          };
      /**
       * @return {?}
       */
      MatMenuContent.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              if (this._outlet) {
                  this._outlet.dispose();
              }
          };
      MatMenuContent.decorators = [
          { type: core.Directive, args: [{
                      selector: 'ng-template[matMenuContent]'
                  },] },
      ];
      /** @nocollapse */
      MatMenuContent.ctorParameters = function () {
          return [
              { type: core.TemplateRef },
              { type: core.ComponentFactoryResolver },
              { type: core.ApplicationRef },
              { type: core.Injector },
              { type: core.ViewContainerRef },
              { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
          ];
      };
      return MatMenuContent;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Animations used by the mat-menu component.
   * Animation duration and timing values are based on:
   * https://material.io/guidelines/components/menus.html#menus-usage
   * \@docs-private
   * @type {?}
   */
  var matMenuAnimations = {
      /**
       * This animation controls the menu panel's entry and exit from the page.
       *
       * When the menu panel is added to the DOM, it scales in and fades in its border.
       *
       * When the menu panel is removed from the DOM, it simply fades out after a brief
       * delay to display the ripple.
       */
      transformMenu: trigger('transformMenu', [
          state('void', style({
              opacity: 0,
              transform: 'scale(0.8)'
          })),
          transition('void => enter', group([
              query('.mat-menu-content', animate('100ms linear', style({ opacity: 1 }))),
              animate('120ms cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'scale(1)' })),
          ])),
          transition('* => void', animate('100ms 25ms linear', style({ opacity: 0 })))
      ]),
      /**
       * This animation fades in the background color and content of the menu panel
       * after its containing element is scaled in.
       */
      fadeInItems: trigger('fadeInItems', [
          // TODO(crisbeto): this is inside the `transformMenu`
          // now. Remove next time we do breaking changes.
          state('showing', style({ opacity: 1 })),
          transition('void => *', [
              style({ opacity: 0 }),
              animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')
          ])
      ])
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Throws an exception for the case when menu trigger doesn't have a valid mat-menu instance
   * \@docs-private
   * @return {?}
   */
  function throwMatMenuMissingError() {
      throw Error("matMenuTriggerFor: must pass in an mat-menu instance.\n\n    Example:\n      <mat-menu #menu=\"matMenu\"></mat-menu>\n      <button [matMenuTriggerFor]=\"menu\"></button>");
  }
  /**
   * Throws an exception for the case when menu's x-position value isn't valid.
   * In other words, it doesn't match 'before' or 'after'.
   * \@docs-private
   * @return {?}
   */
  function throwMatMenuInvalidPositionX() {
      throw Error("xPosition value must be either 'before' or after'.\n      Example: <mat-menu xPosition=\"before\" #menu=\"matMenu\"></mat-menu>");
  }
  /**
   * Throws an exception for the case when menu's y-position value isn't valid.
   * In other words, it doesn't match 'above' or 'below'.
   * \@docs-private
   * @return {?}
   */
  function throwMatMenuInvalidPositionY() {
      throw Error("yPosition value must be either 'above' or below'.\n      Example: <mat-menu yPosition=\"above\" #menu=\"matMenu\"></mat-menu>");
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token used to provide the parent menu to menu-specific components.
   * \@docs-private
   * @type {?}
   */
  var MAT_MENU_PANEL = new core.InjectionToken('MAT_MENU_PANEL');
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Boilerplate for applying mixins to MatMenuItem.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatMenuItem.
  /**
   * \@docs-private
   */
  MatMenuItemBase = /** @class */ (function () {
      function MatMenuItemBase() {
      }
      return MatMenuItemBase;
  }());
  /** @type {?} */
  var _MatMenuItemMixinBase = mixinDisableRipple(mixinDisabled(MatMenuItemBase));
  /**
   * This directive is intended to be used inside an mat-menu tag.
   * It exists mostly to set the role attribute.
   */
  var MatMenuItem = /** @class */ (function (_super) {
      tslib_1.__extends(MatMenuItem, _super);
      function MatMenuItem(_elementRef, document, _focusMonitor, _parentMenu) {
          var _this = 
          // @breaking-change 8.0.0 make `_focusMonitor` and `document` required params.
          _super.call(this) || this;
          _this._elementRef = _elementRef;
          _this._focusMonitor = _focusMonitor;
          _this._parentMenu = _parentMenu;
          /**
           * ARIA role for the menu item.
           */
          _this.role = 'menuitem';
          /**
           * Stream that emits when the menu item is hovered.
           */
          _this._hovered = new rxjs.Subject();
          /**
           * Whether the menu item is highlighted.
           */
          _this._highlighted = false;
          /**
           * Whether the menu item acts as a trigger for a sub-menu.
           */
          _this._triggersSubmenu = false;
          if (_focusMonitor) {
              // Start monitoring the element so it gets the appropriate focused classes. We want
              // to show the focus style for menu items only when the focus was not caused by a
              // mouse or touch interaction.
              _focusMonitor.monitor(_this._elementRef, false);
          }
          if (_parentMenu && _parentMenu.addItem) {
              _parentMenu.addItem(_this);
          }
          _this._document = document;
          return _this;
      }
      /** Focuses the menu item. */
      /**
       * Focuses the menu item.
       * @param {?=} origin
       * @return {?}
       */
      MatMenuItem.prototype.focus = /**
       * Focuses the menu item.
       * @param {?=} origin
       * @return {?}
       */
          function (origin) {
              if (origin === void 0) {
                  origin = 'program';
              }
              if (this._focusMonitor) {
                  this._focusMonitor.focusVia(this._getHostElement(), origin);
              }
              else {
                  this._getHostElement().focus();
              }
          };
      /**
       * @return {?}
       */
      MatMenuItem.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              if (this._focusMonitor) {
                  this._focusMonitor.stopMonitoring(this._elementRef);
              }
              if (this._parentMenu && this._parentMenu.removeItem) {
                  this._parentMenu.removeItem(this);
              }
              this._hovered.complete();
          };
      /** Used to set the `tabindex`. */
      /**
       * Used to set the `tabindex`.
       * @return {?}
       */
      MatMenuItem.prototype._getTabIndex = /**
       * Used to set the `tabindex`.
       * @return {?}
       */
          function () {
              return this.disabled ? '-1' : '0';
          };
      /** Returns the host DOM element. */
      /**
       * Returns the host DOM element.
       * @return {?}
       */
      MatMenuItem.prototype._getHostElement = /**
       * Returns the host DOM element.
       * @return {?}
       */
          function () {
              return this._elementRef.nativeElement;
          };
      /** Prevents the default element actions if it is disabled. */
      /**
       * Prevents the default element actions if it is disabled.
       * @param {?} event
       * @return {?}
       */
      MatMenuItem.prototype._checkDisabled = /**
       * Prevents the default element actions if it is disabled.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (this.disabled) {
                  event.preventDefault();
                  event.stopPropagation();
              }
          };
      /** Emits to the hover stream. */
      /**
       * Emits to the hover stream.
       * @return {?}
       */
      MatMenuItem.prototype._handleMouseEnter = /**
       * Emits to the hover stream.
       * @return {?}
       */
          function () {
              this._hovered.next(this);
          };
      /** Gets the label to be used when determining whether the option should be focused. */
      /**
       * Gets the label to be used when determining whether the option should be focused.
       * @return {?}
       */
      MatMenuItem.prototype.getLabel = /**
       * Gets the label to be used when determining whether the option should be focused.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var element = this._elementRef.nativeElement;
              /** @type {?} */
              var textNodeType = this._document ? this._document.TEXT_NODE : 3;
              /** @type {?} */
              var output = '';
              if (element.childNodes) {
                  /** @type {?} */
                  var length_1 = element.childNodes.length;
                  // Go through all the top-level text nodes and extract their text.
                  // We skip anything that's not a text node to prevent the text from
                  // being thrown off by something like an icon.
                  for (var i = 0; i < length_1; i++) {
                      if (element.childNodes[i].nodeType === textNodeType) {
                          output += element.childNodes[i].textContent;
                      }
                  }
              }
              return output.trim();
          };
      MatMenuItem.decorators = [
          { type: core.Component, args: [{ selector: '[mat-menu-item]',
                      exportAs: 'matMenuItem',
                      inputs: ['disabled', 'disableRipple'],
                      host: {
                          '[attr.role]': 'role',
                          'class': 'mat-menu-item',
                          '[class.mat-menu-item-highlighted]': '_highlighted',
                          '[class.mat-menu-item-submenu-trigger]': '_triggersSubmenu',
                          '[attr.tabindex]': '_getTabIndex()',
                          '[attr.aria-disabled]': 'disabled.toString()',
                          '[attr.disabled]': 'disabled || null',
                          '(click)': '_checkDisabled($event)',
                          '(mouseenter)': '_handleMouseEnter()',
                      },
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                      template: "<ng-content></ng-content><div class=\"mat-menu-ripple\" matRipple [matRippleDisabled]=\"disableRipple || disabled\" [matRippleTrigger]=\"_getHostElement()\"></div>",
                  },] },
      ];
      /** @nocollapse */
      MatMenuItem.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
              { type: FocusMonitor },
              { type: undefined, decorators: [{ type: core.Inject, args: [MAT_MENU_PANEL,] }, { type: core.Optional }] }
          ];
      };
      MatMenuItem.propDecorators = {
          role: [{ type: core.Input }]
      };
      return MatMenuItem;
  }(_MatMenuItemMixinBase));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token to be used to override the default options for `mat-menu`.
   * @type {?}
   */
  var MAT_MENU_DEFAULT_OPTIONS = new core.InjectionToken('mat-menu-default-options', {
      providedIn: 'root',
      factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY
  });
  /**
   * \@docs-private
   * @return {?}
   */
  function MAT_MENU_DEFAULT_OPTIONS_FACTORY() {
      return {
          overlapTrigger: false,
          xPosition: 'after',
          yPosition: 'below',
          backdropClass: 'cdk-overlay-transparent-backdrop',
      };
  }
  /**
   * Start elevation for the menu panel.
   * \@docs-private
   * @type {?}
   */
  var MAT_MENU_BASE_ELEVATION = 4;
  var MatMenu = /** @class */ (function () {
      function MatMenu(_elementRef, _ngZone, _defaultOptions) {
          this._elementRef = _elementRef;
          this._ngZone = _ngZone;
          this._defaultOptions = _defaultOptions;
          this._xPosition = this._defaultOptions.xPosition;
          this._yPosition = this._defaultOptions.yPosition;
          /**
           * Menu items inside the current menu.
           */
          this._items = [];
          /**
           * Emits whenever the amount of menu items changes.
           */
          this._itemChanges = new rxjs.Subject();
          /**
           * Subscription to tab events on the menu panel
           */
          this._tabSubscription = rxjs.Subscription.EMPTY;
          /**
           * Config object to be passed into the menu's ngClass
           */
          this._classList = {};
          /**
           * Current state of the panel animation.
           */
          this._panelAnimationState = 'void';
          /**
           * Emits whenever an animation on the menu completes.
           */
          this._animationDone = new rxjs.Subject();
          /**
           * Class to be added to the backdrop element.
           */
          this.backdropClass = this._defaultOptions.backdropClass;
          this._overlapTrigger = this._defaultOptions.overlapTrigger;
          this._hasBackdrop = this._defaultOptions.hasBackdrop;
          /**
           * Event emitted when the menu is closed.
           */
          this.closed = new core.EventEmitter();
          /**
           * Event emitted when the menu is closed.
           * @deprecated Switch to `closed` instead
           * \@breaking-change 8.0.0
           */
          this.close = this.closed;
      }
      Object.defineProperty(MatMenu.prototype, "xPosition", {
          /** Position of the menu in the X axis. */
          get: /**
           * Position of the menu in the X axis.
           * @return {?}
           */ function () { return this._xPosition; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (value !== 'before' && value !== 'after') {
                  throwMatMenuInvalidPositionX();
              }
              this._xPosition = value;
              this.setPositionClasses();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatMenu.prototype, "yPosition", {
          /** Position of the menu in the Y axis. */
          get: /**
           * Position of the menu in the Y axis.
           * @return {?}
           */ function () { return this._yPosition; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (value !== 'above' && value !== 'below') {
                  throwMatMenuInvalidPositionY();
              }
              this._yPosition = value;
              this.setPositionClasses();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatMenu.prototype, "overlapTrigger", {
          /** Whether the menu should overlap its trigger. */
          get: /**
           * Whether the menu should overlap its trigger.
           * @return {?}
           */ function () { return this._overlapTrigger; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._overlapTrigger = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatMenu.prototype, "hasBackdrop", {
          /** Whether the menu has a backdrop. */
          get: /**
           * Whether the menu has a backdrop.
           * @return {?}
           */ function () { return this._hasBackdrop; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._hasBackdrop = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatMenu.prototype, "panelClass", {
          /**
           * This method takes classes set on the host mat-menu element and applies them on the
           * menu template that displays in the overlay container.  Otherwise, it's difficult
           * to style the containing menu from outside the component.
           * @param classes list of class names
           */
          set: /**
           * This method takes classes set on the host mat-menu element and applies them on the
           * menu template that displays in the overlay container.  Otherwise, it's difficult
           * to style the containing menu from outside the component.
           * @param {?} classes list of class names
           * @return {?}
           */ function (classes) {
              var _this = this;
              /** @type {?} */
              var previousPanelClass = this._previousPanelClass;
              if (previousPanelClass && previousPanelClass.length) {
                  previousPanelClass.split(' ').forEach(function (className) {
                      _this._classList[className] = false;
                  });
              }
              this._previousPanelClass = classes;
              if (classes && classes.length) {
                  classes.split(' ').forEach(function (className) {
                      _this._classList[className] = true;
                  });
                  this._elementRef.nativeElement.className = '';
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatMenu.prototype, "classList", {
          /**
           * This method takes classes set on the host mat-menu element and applies them on the
           * menu template that displays in the overlay container.  Otherwise, it's difficult
           * to style the containing menu from outside the component.
           * @deprecated Use `panelClass` instead.
           * @breaking-change 8.0.0
           */
          get: /**
           * This method takes classes set on the host mat-menu element and applies them on the
           * menu template that displays in the overlay container.  Otherwise, it's difficult
           * to style the containing menu from outside the component.
           * @deprecated Use `panelClass` instead.
           * \@breaking-change 8.0.0
           * @return {?}
           */ function () { return this.panelClass; },
          set: /**
           * @param {?} classes
           * @return {?}
           */ function (classes) { this.panelClass = classes; },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatMenu.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              this.setPositionClasses();
          };
      /**
       * @return {?}
       */
      MatMenu.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._keyManager = new FocusKeyManager(this._items).withWrap().withTypeAhead();
              this._tabSubscription = this._keyManager.tabOut.subscribe(function () { return _this.closed.emit('tab'); });
          };
      /**
       * @return {?}
       */
      MatMenu.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._tabSubscription.unsubscribe();
              this.closed.complete();
          };
      /** Stream that emits whenever the hovered menu item changes. */
      /**
       * Stream that emits whenever the hovered menu item changes.
       * @return {?}
       */
      MatMenu.prototype._hovered = /**
       * Stream that emits whenever the hovered menu item changes.
       * @return {?}
       */
          function () {
              return this._itemChanges.pipe(operators.startWith(this._items), operators.switchMap(function (items) { return rxjs.merge.apply(void 0, items.map(function (item) { return item._hovered; })); }));
          };
      /** Handle a keyboard event from the menu, delegating to the appropriate action. */
      /**
       * Handle a keyboard event from the menu, delegating to the appropriate action.
       * @param {?} event
       * @return {?}
       */
      MatMenu.prototype._handleKeydown = /**
       * Handle a keyboard event from the menu, delegating to the appropriate action.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var keyCode = event.keyCode;
              switch (keyCode) {
                  case ESCAPE:
                      this.closed.emit('keydown');
                      break;
                  case LEFT_ARROW:
                      if (this.parentMenu && this.direction === 'ltr') {
                          this.closed.emit('keydown');
                      }
                      break;
                  case RIGHT_ARROW:
                      if (this.parentMenu && this.direction === 'rtl') {
                          this.closed.emit('keydown');
                      }
                      break;
                  default:
                      if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {
                          this._keyManager.setFocusOrigin('keyboard');
                      }
                      this._keyManager.onKeydown(event);
              }
          };
      /**
       * Focus the first item in the menu.
       * @param origin Action from which the focus originated. Used to set the correct styling.
       */
      /**
       * Focus the first item in the menu.
       * @param {?=} origin Action from which the focus originated. Used to set the correct styling.
       * @return {?}
       */
      MatMenu.prototype.focusFirstItem = /**
       * Focus the first item in the menu.
       * @param {?=} origin Action from which the focus originated. Used to set the correct styling.
       * @return {?}
       */
          function (origin) {
              var _this = this;
              if (origin === void 0) {
                  origin = 'program';
              }
              // When the content is rendered lazily, it takes a bit before the items are inside the DOM.
              if (this.lazyContent) {
                  this._ngZone.onStable.asObservable()
                      .pipe(operators.take(1))
                      .subscribe(function () { return _this._keyManager.setFocusOrigin(origin).setFirstItemActive(); });
              }
              else {
                  this._keyManager.setFocusOrigin(origin).setFirstItemActive();
              }
          };
      /**
       * Resets the active item in the menu. This is used when the menu is opened, allowing
       * the user to start from the first option when pressing the down arrow.
       */
      /**
       * Resets the active item in the menu. This is used when the menu is opened, allowing
       * the user to start from the first option when pressing the down arrow.
       * @return {?}
       */
      MatMenu.prototype.resetActiveItem = /**
       * Resets the active item in the menu. This is used when the menu is opened, allowing
       * the user to start from the first option when pressing the down arrow.
       * @return {?}
       */
          function () {
              this._keyManager.setActiveItem(-1);
          };
      /**
       * Sets the menu panel elevation.
       * @param depth Number of parent menus that come before the menu.
       */
      /**
       * Sets the menu panel elevation.
       * @param {?} depth Number of parent menus that come before the menu.
       * @return {?}
       */
      MatMenu.prototype.setElevation = /**
       * Sets the menu panel elevation.
       * @param {?} depth Number of parent menus that come before the menu.
       * @return {?}
       */
          function (depth) {
              // The elevation starts at the base and increases by one for each level.
              /** @type {?} */
              var newElevation = "mat-elevation-z" + (MAT_MENU_BASE_ELEVATION + depth);
              /** @type {?} */
              var customElevation = Object.keys(this._classList).find(function (c) { return c.startsWith('mat-elevation-z'); });
              if (!customElevation || customElevation === this._previousElevation) {
                  if (this._previousElevation) {
                      this._classList[this._previousElevation] = false;
                  }
                  this._classList[newElevation] = true;
                  this._previousElevation = newElevation;
              }
          };
      /**
       * Registers a menu item with the menu.
       * @docs-private
       */
      /**
       * Registers a menu item with the menu.
       * \@docs-private
       * @param {?} item
       * @return {?}
       */
      MatMenu.prototype.addItem = /**
       * Registers a menu item with the menu.
       * \@docs-private
       * @param {?} item
       * @return {?}
       */
          function (item) {
              // We register the items through this method, rather than picking them up through
              // `ContentChildren`, because we need the items to be picked up by their closest
              // `mat-menu` ancestor. If we used `@ContentChildren(MatMenuItem, {descendants: true})`,
              // all descendant items will bleed into the top-level menu in the case where the consumer
              // has `mat-menu` instances nested inside each other.
              if (this._items.indexOf(item) === -1) {
                  this._items.push(item);
                  this._itemChanges.next(this._items);
              }
          };
      /**
       * Removes an item from the menu.
       * @docs-private
       */
      /**
       * Removes an item from the menu.
       * \@docs-private
       * @param {?} item
       * @return {?}
       */
      MatMenu.prototype.removeItem = /**
       * Removes an item from the menu.
       * \@docs-private
       * @param {?} item
       * @return {?}
       */
          function (item) {
              /** @type {?} */
              var index = this._items.indexOf(item);
              if (this._items.indexOf(item) > -1) {
                  this._items.splice(index, 1);
                  this._itemChanges.next(this._items);
              }
          };
      /**
       * Adds classes to the menu panel based on its position. Can be used by
       * consumers to add specific styling based on the position.
       * @param posX Position of the menu along the x axis.
       * @param posY Position of the menu along the y axis.
       * @docs-private
       */
      /**
       * Adds classes to the menu panel based on its position. Can be used by
       * consumers to add specific styling based on the position.
       * \@docs-private
       * @param {?=} posX Position of the menu along the x axis.
       * @param {?=} posY Position of the menu along the y axis.
       * @return {?}
       */
      MatMenu.prototype.setPositionClasses = /**
       * Adds classes to the menu panel based on its position. Can be used by
       * consumers to add specific styling based on the position.
       * \@docs-private
       * @param {?=} posX Position of the menu along the x axis.
       * @param {?=} posY Position of the menu along the y axis.
       * @return {?}
       */
          function (posX, posY) {
              if (posX === void 0) {
                  posX = this.xPosition;
              }
              if (posY === void 0) {
                  posY = this.yPosition;
              }
              /** @type {?} */
              var classes = this._classList;
              classes['mat-menu-before'] = posX === 'before';
              classes['mat-menu-after'] = posX === 'after';
              classes['mat-menu-above'] = posY === 'above';
              classes['mat-menu-below'] = posY === 'below';
          };
      /** Starts the enter animation. */
      /**
       * Starts the enter animation.
       * @return {?}
       */
      MatMenu.prototype._startAnimation = /**
       * Starts the enter animation.
       * @return {?}
       */
          function () {
              // @breaking-change 8.0.0 Combine with _resetAnimation.
              this._panelAnimationState = 'enter';
          };
      /** Resets the panel animation to its initial state. */
      /**
       * Resets the panel animation to its initial state.
       * @return {?}
       */
      MatMenu.prototype._resetAnimation = /**
       * Resets the panel animation to its initial state.
       * @return {?}
       */
          function () {
              // @breaking-change 8.0.0 Combine with _startAnimation.
              this._panelAnimationState = 'void';
          };
      /** Callback that is invoked when the panel animation completes. */
      /**
       * Callback that is invoked when the panel animation completes.
       * @param {?} event
       * @return {?}
       */
      MatMenu.prototype._onAnimationDone = /**
       * Callback that is invoked when the panel animation completes.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              this._animationDone.next(event);
              this._isAnimating = false;
          };
      /**
       * @param {?} event
       * @return {?}
       */
      MatMenu.prototype._onAnimationStart = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              this._isAnimating = true;
              // Scroll the content element to the top as soon as the animation starts. This is necessary,
              // because we move focus to the first item while it's still being animated, which can throw
              // the browser off when it determines the scroll position. Alternatively we can move focus
              // when the animation is done, however moving focus asynchronously will interrupt screen
              // readers which are in the process of reading out the menu already. We take the `element`
              // from the `event` since we can't use a `ViewChild` to access the pane.
              if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {
                  event.element.scrollTop = 0;
              }
          };
      MatMenu.decorators = [
          { type: core.Component, args: [{ selector: 'mat-menu',
                      template: "<ng-template><div class=\"mat-menu-panel\" [ngClass]=\"_classList\" (keydown)=\"_handleKeydown($event)\" (click)=\"closed.emit('click')\" [@transformMenu]=\"_panelAnimationState\" (@transformMenu.start)=\"_onAnimationStart($event)\" (@transformMenu.done)=\"_onAnimationDone($event)\" tabindex=\"-1\" role=\"menu\"><div class=\"mat-menu-content\"><ng-content></ng-content></div></div></ng-template>",
                      styles: [".mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:4px;outline:0}.mat-menu-panel.ng-animating{pointer-events:none}@media (-ms-high-contrast:active){.mat-menu-panel{outline:solid 1px}}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}@media (-ms-high-contrast:active){.mat-menu-item-highlighted,.mat-menu-item.cdk-keyboard-focused,.mat-menu-item.cdk-program-focused{outline:dotted 1px}}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:'';display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}button.mat-menu-item{width:100%}.mat-menu-item .mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}"],
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                      exportAs: 'matMenu',
                      animations: [
                          matMenuAnimations.transformMenu,
                          matMenuAnimations.fadeInItems
                      ],
                      providers: [
                          { provide: MAT_MENU_PANEL, useExisting: MatMenu }
                      ]
                  },] },
      ];
      /** @nocollapse */
      MatMenu.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.NgZone },
              { type: undefined, decorators: [{ type: core.Inject, args: [MAT_MENU_DEFAULT_OPTIONS,] }] }
          ];
      };
      MatMenu.propDecorators = {
          backdropClass: [{ type: core.Input }],
          xPosition: [{ type: core.Input }],
          yPosition: [{ type: core.Input }],
          templateRef: [{ type: core.ViewChild, args: [core.TemplateRef,] }],
          items: [{ type: core.ContentChildren, args: [MatMenuItem,] }],
          lazyContent: [{ type: core.ContentChild, args: [MatMenuContent,] }],
          overlapTrigger: [{ type: core.Input }],
          hasBackdrop: [{ type: core.Input }],
          panelClass: [{ type: core.Input, args: ['class',] }],
          classList: [{ type: core.Input }],
          closed: [{ type: core.Output }],
          close: [{ type: core.Output }]
      };
      return MatMenu;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token that determines the scroll handling while the menu is open.
   * @type {?}
   */
  var MAT_MENU_SCROLL_STRATEGY = new core.InjectionToken('mat-menu-scroll-strategy');
  /**
   * Default top padding of the menu panel.
   * @type {?}
   */
  var MENU_PANEL_TOP_PADDING = 8;
  /**
   * Options for binding a passive event listener.
   * @type {?}
   */
  var passiveEventListenerOptions = normalizePassiveListenerOptions({ passive: true });
  // TODO(andrewseguin): Remove the kebab versions in favor of camelCased attribute selectors
  /**
   * This directive is intended to be used in conjunction with an mat-menu tag.  It is
   * responsible for toggling the display of the provided menu instance.
   */
  var MatMenuTrigger = /** @class */ (function () {
      function MatMenuTrigger(_overlay, _element, _viewContainerRef, scrollStrategy, _parentMenu, _menuItemInstance, _dir, _focusMonitor) {
          var _this = this;
          this._overlay = _overlay;
          this._element = _element;
          this._viewContainerRef = _viewContainerRef;
          this._parentMenu = _parentMenu;
          this._menuItemInstance = _menuItemInstance;
          this._dir = _dir;
          this._focusMonitor = _focusMonitor;
          this._overlayRef = null;
          this._menuOpen = false;
          this._closingActionsSubscription = rxjs.Subscription.EMPTY;
          this._hoverSubscription = rxjs.Subscription.EMPTY;
          this._menuCloseSubscription = rxjs.Subscription.EMPTY;
          /**
           * Handles touch start events on the trigger.
           * Needs to be an arrow function so we can easily use addEventListener and removeEventListener.
           */
          this._handleTouchStart = function () { return _this._openedBy = 'touch'; };
          // Tracking input type is necessary so it's possible to only auto-focus
          // the first item of the list when the menu is opened via the keyboard
          this._openedBy = null;
          /**
           * Event emitted when the associated menu is opened.
           */
          this.menuOpened = new core.EventEmitter();
          /**
           * Event emitted when the associated menu is opened.
           * @deprecated Switch to `menuOpened` instead
           * \@breaking-change 8.0.0
           */
          // tslint:disable-next-line:no-output-on-prefix
          this.onMenuOpen = this.menuOpened;
          /**
           * Event emitted when the associated menu is closed.
           */
          this.menuClosed = new core.EventEmitter();
          /**
           * Event emitted when the associated menu is closed.
           * @deprecated Switch to `menuClosed` instead
           * \@breaking-change 8.0.0
           */
          // tslint:disable-next-line:no-output-on-prefix
          this.onMenuClose = this.menuClosed;
          _element.nativeElement.addEventListener('touchstart', this._handleTouchStart, passiveEventListenerOptions);
          if (_menuItemInstance) {
              _menuItemInstance._triggersSubmenu = this.triggersSubmenu();
          }
          this._scrollStrategy = scrollStrategy;
      }
      Object.defineProperty(MatMenuTrigger.prototype, "_deprecatedMatMenuTriggerFor", {
          /**
           * @deprecated
           * @breaking-change 8.0.0
           */
          get: /**
           * @deprecated
           * \@breaking-change 8.0.0
           * @return {?}
           */ function () { return this.menu; },
          set: /**
           * @param {?} v
           * @return {?}
           */ function (v) {
              this.menu = v;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatMenuTrigger.prototype, "menu", {
          /** References the menu instance that the trigger is associated with. */
          get: /**
           * References the menu instance that the trigger is associated with.
           * @return {?}
           */ function () { return this._menu; },
          set: /**
           * @param {?} menu
           * @return {?}
           */ function (menu) {
              var _this = this;
              if (menu === this._menu) {
                  return;
              }
              this._menu = menu;
              this._menuCloseSubscription.unsubscribe();
              if (menu) {
                  this._menuCloseSubscription = menu.close.asObservable().subscribe(function (reason) {
                      _this._destroyMenu();
                      // If a click closed the menu, we should close the entire chain of nested menus.
                      if ((reason === 'click' || reason === 'tab') && _this._parentMenu) {
                          _this._parentMenu.closed.emit(reason);
                      }
                  });
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatMenuTrigger.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this._checkMenu();
              this._handleHover();
          };
      /**
       * @return {?}
       */
      MatMenuTrigger.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              if (this._overlayRef) {
                  this._overlayRef.dispose();
                  this._overlayRef = null;
              }
              this._element.nativeElement.removeEventListener('touchstart', this._handleTouchStart, passiveEventListenerOptions);
              this._cleanUpSubscriptions();
              this._closingActionsSubscription.unsubscribe();
          };
      Object.defineProperty(MatMenuTrigger.prototype, "menuOpen", {
          /** Whether the menu is open. */
          get: /**
           * Whether the menu is open.
           * @return {?}
           */ function () {
              return this._menuOpen;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatMenuTrigger.prototype, "dir", {
          /** The text direction of the containing app. */
          get: /**
           * The text direction of the containing app.
           * @return {?}
           */ function () {
              return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
          },
          enumerable: true,
          configurable: true
      });
      /** Whether the menu triggers a sub-menu or a top-level one. */
      /**
       * Whether the menu triggers a sub-menu or a top-level one.
       * @return {?}
       */
      MatMenuTrigger.prototype.triggersSubmenu = /**
       * Whether the menu triggers a sub-menu or a top-level one.
       * @return {?}
       */
          function () {
              return !!(this._menuItemInstance && this._parentMenu);
          };
      /** Toggles the menu between the open and closed states. */
      /**
       * Toggles the menu between the open and closed states.
       * @return {?}
       */
      MatMenuTrigger.prototype.toggleMenu = /**
       * Toggles the menu between the open and closed states.
       * @return {?}
       */
          function () {
              return this._menuOpen ? this.closeMenu() : this.openMenu();
          };
      /** Opens the menu. */
      /**
       * Opens the menu.
       * @return {?}
       */
      MatMenuTrigger.prototype.openMenu = /**
       * Opens the menu.
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._menuOpen) {
                  return;
              }
              this._checkMenu();
              /** @type {?} */
              var overlayRef = this._createOverlay();
              /** @type {?} */
              var overlayConfig = overlayRef.getConfig();
              this._setPosition(( /** @type {?} */(overlayConfig.positionStrategy)));
              overlayConfig.hasBackdrop = this.menu.hasBackdrop == null ? !this.triggersSubmenu() :
                  this.menu.hasBackdrop;
              overlayRef.attach(this._getPortal());
              if (this.menu.lazyContent) {
                  this.menu.lazyContent.attach(this.menuData);
              }
              this._closingActionsSubscription = this._menuClosingActions().subscribe(function () { return _this.closeMenu(); });
              this._initMenu();
              if (this.menu instanceof MatMenu) {
                  this.menu._startAnimation();
              }
          };
      /** Closes the menu. */
      /**
       * Closes the menu.
       * @return {?}
       */
      MatMenuTrigger.prototype.closeMenu = /**
       * Closes the menu.
       * @return {?}
       */
          function () {
              this.menu.close.emit();
          };
      /**
       * Focuses the menu trigger.
       * @param origin Source of the menu trigger's focus.
       */
      /**
       * Focuses the menu trigger.
       * @param {?=} origin Source of the menu trigger's focus.
       * @return {?}
       */
      MatMenuTrigger.prototype.focus = /**
       * Focuses the menu trigger.
       * @param {?=} origin Source of the menu trigger's focus.
       * @return {?}
       */
          function (origin) {
              if (origin === void 0) {
                  origin = 'program';
              }
              if (this._focusMonitor) {
                  this._focusMonitor.focusVia(this._element, origin);
              }
              else {
                  this._element.nativeElement.focus();
              }
          };
      /** Closes the menu and does the necessary cleanup. */
      /**
       * Closes the menu and does the necessary cleanup.
       * @private
       * @return {?}
       */
      MatMenuTrigger.prototype._destroyMenu = /**
       * Closes the menu and does the necessary cleanup.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this._overlayRef || !this.menuOpen) {
                  return;
              }
              /** @type {?} */
              var menu = this.menu;
              this._closingActionsSubscription.unsubscribe();
              this._overlayRef.detach();
              if (menu instanceof MatMenu) {
                  menu._resetAnimation();
                  if (menu.lazyContent) {
                      // Wait for the exit animation to finish before detaching the content.
                      menu._animationDone
                          .pipe(operators.filter(function (event) { return event.toState === 'void'; }), operators.take(1), 
                      // Interrupt if the content got re-attached.
                      operators.takeUntil(menu.lazyContent._attached))
                          .subscribe(function () { return ( /** @type {?} */(menu.lazyContent)).detach(); }, undefined, function () {
                          // No matter whether the content got re-attached, reset the menu.
                          _this._resetMenu();
                      });
                  }
                  else {
                      this._resetMenu();
                  }
              }
              else {
                  this._resetMenu();
                  if (menu.lazyContent) {
                      menu.lazyContent.detach();
                  }
              }
          };
      /**
       * This method sets the menu state to open and focuses the first item if
       * the menu was opened via the keyboard.
       */
      /**
       * This method sets the menu state to open and focuses the first item if
       * the menu was opened via the keyboard.
       * @private
       * @return {?}
       */
      MatMenuTrigger.prototype._initMenu = /**
       * This method sets the menu state to open and focuses the first item if
       * the menu was opened via the keyboard.
       * @private
       * @return {?}
       */
          function () {
              this.menu.parentMenu = this.triggersSubmenu() ? this._parentMenu : undefined;
              this.menu.direction = this.dir;
              this._setMenuElevation();
              this._setIsMenuOpen(true);
              this.menu.focusFirstItem(this._openedBy || 'program');
          };
      /** Updates the menu elevation based on the amount of parent menus that it has. */
      /**
       * Updates the menu elevation based on the amount of parent menus that it has.
       * @private
       * @return {?}
       */
      MatMenuTrigger.prototype._setMenuElevation = /**
       * Updates the menu elevation based on the amount of parent menus that it has.
       * @private
       * @return {?}
       */
          function () {
              if (this.menu.setElevation) {
                  /** @type {?} */
                  var depth = 0;
                  /** @type {?} */
                  var parentMenu = this.menu.parentMenu;
                  while (parentMenu) {
                      depth++;
                      parentMenu = parentMenu.parentMenu;
                  }
                  this.menu.setElevation(depth);
              }
          };
      /**
       * This method resets the menu when it's closed, most importantly restoring
       * focus to the menu trigger if the menu was opened via the keyboard.
       */
      /**
       * This method resets the menu when it's closed, most importantly restoring
       * focus to the menu trigger if the menu was opened via the keyboard.
       * @private
       * @return {?}
       */
      MatMenuTrigger.prototype._resetMenu = /**
       * This method resets the menu when it's closed, most importantly restoring
       * focus to the menu trigger if the menu was opened via the keyboard.
       * @private
       * @return {?}
       */
          function () {
              this._setIsMenuOpen(false);
              // We should reset focus if the user is navigating using a keyboard or
              // if we have a top-level trigger which might cause focus to be lost
              // when clicking on the backdrop.
              if (!this._openedBy) {
                  // Note that the focus style will show up both for `program` and
                  // `keyboard` so we don't have to specify which one it is.
                  this.focus();
              }
              else if (!this.triggersSubmenu()) {
                  this.focus(this._openedBy);
              }
              this._openedBy = null;
          };
      // set state rather than toggle to support triggers sharing a menu
      // set state rather than toggle to support triggers sharing a menu
      /**
       * @private
       * @param {?} isOpen
       * @return {?}
       */
      MatMenuTrigger.prototype._setIsMenuOpen =
          // set state rather than toggle to support triggers sharing a menu
          /**
           * @private
           * @param {?} isOpen
           * @return {?}
           */
          function (isOpen) {
              this._menuOpen = isOpen;
              this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();
              if (this.triggersSubmenu()) {
                  this._menuItemInstance._highlighted = isOpen;
              }
          };
      /**
       * This method checks that a valid instance of MatMenu has been passed into
       * matMenuTriggerFor. If not, an exception is thrown.
       */
      /**
       * This method checks that a valid instance of MatMenu has been passed into
       * matMenuTriggerFor. If not, an exception is thrown.
       * @private
       * @return {?}
       */
      MatMenuTrigger.prototype._checkMenu = /**
       * This method checks that a valid instance of MatMenu has been passed into
       * matMenuTriggerFor. If not, an exception is thrown.
       * @private
       * @return {?}
       */
          function () {
              if (!this.menu) {
                  throwMatMenuMissingError();
              }
          };
      /**
       * This method creates the overlay from the provided menu's template and saves its
       * OverlayRef so that it can be attached to the DOM when openMenu is called.
       */
      /**
       * This method creates the overlay from the provided menu's template and saves its
       * OverlayRef so that it can be attached to the DOM when openMenu is called.
       * @private
       * @return {?}
       */
      MatMenuTrigger.prototype._createOverlay = /**
       * This method creates the overlay from the provided menu's template and saves its
       * OverlayRef so that it can be attached to the DOM when openMenu is called.
       * @private
       * @return {?}
       */
          function () {
              if (!this._overlayRef) {
                  /** @type {?} */
                  var config = this._getOverlayConfig();
                  this._subscribeToPositions(( /** @type {?} */(config.positionStrategy)));
                  this._overlayRef = this._overlay.create(config);
                  // Consume the `keydownEvents` in order to prevent them from going to another overlay.
                  // Ideally we'd also have our keyboard event logic in here, however doing so will
                  // break anybody that may have implemented the `MatMenuPanel` themselves.
                  this._overlayRef.keydownEvents().subscribe();
              }
              return this._overlayRef;
          };
      /**
       * This method builds the configuration object needed to create the overlay, the OverlayState.
       * @returns OverlayConfig
       */
      /**
       * This method builds the configuration object needed to create the overlay, the OverlayState.
       * @private
       * @return {?} OverlayConfig
       */
      MatMenuTrigger.prototype._getOverlayConfig = /**
       * This method builds the configuration object needed to create the overlay, the OverlayState.
       * @private
       * @return {?} OverlayConfig
       */
          function () {
              return new OverlayConfig({
                  positionStrategy: this._overlay.position()
                      .flexibleConnectedTo(this._element)
                      .withLockedPosition()
                      .withTransformOriginOn('.mat-menu-panel'),
                  backdropClass: this.menu.backdropClass || 'cdk-overlay-transparent-backdrop',
                  scrollStrategy: this._scrollStrategy(),
                  direction: this._dir
              });
          };
      /**
       * Listens to changes in the position of the overlay and sets the correct classes
       * on the menu based on the new position. This ensures the animation origin is always
       * correct, even if a fallback position is used for the overlay.
       */
      /**
       * Listens to changes in the position of the overlay and sets the correct classes
       * on the menu based on the new position. This ensures the animation origin is always
       * correct, even if a fallback position is used for the overlay.
       * @private
       * @param {?} position
       * @return {?}
       */
      MatMenuTrigger.prototype._subscribeToPositions = /**
       * Listens to changes in the position of the overlay and sets the correct classes
       * on the menu based on the new position. This ensures the animation origin is always
       * correct, even if a fallback position is used for the overlay.
       * @private
       * @param {?} position
       * @return {?}
       */
          function (position) {
              var _this = this;
              if (this.menu.setPositionClasses) {
                  position.positionChanges.subscribe(function (change) {
                      /** @type {?} */
                      var posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';
                      /** @type {?} */
                      var posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';
                      ( /** @type {?} */(_this.menu.setPositionClasses))(posX, posY);
                  });
              }
          };
      /**
       * Sets the appropriate positions on a position strategy
       * so the overlay connects with the trigger correctly.
       * @param positionStrategy Strategy whose position to update.
       */
      /**
       * Sets the appropriate positions on a position strategy
       * so the overlay connects with the trigger correctly.
       * @private
       * @param {?} positionStrategy Strategy whose position to update.
       * @return {?}
       */
      MatMenuTrigger.prototype._setPosition = /**
       * Sets the appropriate positions on a position strategy
       * so the overlay connects with the trigger correctly.
       * @private
       * @param {?} positionStrategy Strategy whose position to update.
       * @return {?}
       */
          function (positionStrategy) {
              var _a = this.menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'], originX = _a[0], originFallbackX = _a[1];
              var _b = this.menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'], overlayY = _b[0], overlayFallbackY = _b[1];
              var _c = [overlayY, overlayFallbackY], originY = _c[0], originFallbackY = _c[1];
              var _d = [originX, originFallbackX], overlayX = _d[0], overlayFallbackX = _d[1];
              /** @type {?} */
              var offsetY = 0;
              if (this.triggersSubmenu()) {
                  // When the menu is a sub-menu, it should always align itself
                  // to the edges of the trigger, instead of overlapping it.
                  overlayFallbackX = originX = this.menu.xPosition === 'before' ? 'start' : 'end';
                  originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';
                  offsetY = overlayY === 'bottom' ? MENU_PANEL_TOP_PADDING : -MENU_PANEL_TOP_PADDING;
              }
              else if (!this.menu.overlapTrigger) {
                  originY = overlayY === 'top' ? 'bottom' : 'top';
                  originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';
              }
              positionStrategy.withPositions([
                  { originX: originX, originY: originY, overlayX: overlayX, overlayY: overlayY, offsetY: offsetY },
                  { originX: originFallbackX, originY: originY, overlayX: overlayFallbackX, overlayY: overlayY, offsetY: offsetY },
                  {
                      originX: originX,
                      originY: originFallbackY,
                      overlayX: overlayX,
                      overlayY: overlayFallbackY,
                      offsetY: -offsetY
                  },
                  {
                      originX: originFallbackX,
                      originY: originFallbackY,
                      overlayX: overlayFallbackX,
                      overlayY: overlayFallbackY,
                      offsetY: -offsetY
                  }
              ]);
          };
      /** Cleans up the active subscriptions. */
      /**
       * Cleans up the active subscriptions.
       * @private
       * @return {?}
       */
      MatMenuTrigger.prototype._cleanUpSubscriptions = /**
       * Cleans up the active subscriptions.
       * @private
       * @return {?}
       */
          function () {
              this._closingActionsSubscription.unsubscribe();
              this._hoverSubscription.unsubscribe();
          };
      /** Returns a stream that emits whenever an action that should close the menu occurs. */
      /**
       * Returns a stream that emits whenever an action that should close the menu occurs.
       * @private
       * @return {?}
       */
      MatMenuTrigger.prototype._menuClosingActions = /**
       * Returns a stream that emits whenever an action that should close the menu occurs.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var backdrop = ( /** @type {?} */(this._overlayRef)).backdropClick();
              /** @type {?} */
              var detachments = ( /** @type {?} */(this._overlayRef)).detachments();
              /** @type {?} */
              var parentClose = this._parentMenu ? this._parentMenu.closed : rxjs.of();
              /** @type {?} */
              var hover = this._parentMenu ? this._parentMenu._hovered().pipe(operators.filter(function (active) { return active !== _this._menuItemInstance; }), operators.filter(function () { return _this._menuOpen; })) : rxjs.of();
              return rxjs.merge(backdrop, parentClose, hover, detachments);
          };
      /** Handles mouse presses on the trigger. */
      /**
       * Handles mouse presses on the trigger.
       * @param {?} event
       * @return {?}
       */
      MatMenuTrigger.prototype._handleMousedown = /**
       * Handles mouse presses on the trigger.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (!isFakeMousedownFromScreenReader(event)) {
                  // Since right or middle button clicks won't trigger the `click` event,
                  // we shouldn't consider the menu as opened by mouse in those cases.
                  this._openedBy = event.button === 0 ? 'mouse' : null;
                  // Since clicking on the trigger won't close the menu if it opens a sub-menu,
                  // we should prevent focus from moving onto it via click to avoid the
                  // highlight from lingering on the menu item.
                  if (this.triggersSubmenu()) {
                      event.preventDefault();
                  }
              }
          };
      /** Handles key presses on the trigger. */
      /**
       * Handles key presses on the trigger.
       * @param {?} event
       * @return {?}
       */
      MatMenuTrigger.prototype._handleKeydown = /**
       * Handles key presses on the trigger.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var keyCode = event.keyCode;
              if (this.triggersSubmenu() && ((keyCode === RIGHT_ARROW && this.dir === 'ltr') ||
                  (keyCode === LEFT_ARROW && this.dir === 'rtl'))) {
                  this.openMenu();
              }
          };
      /** Handles click events on the trigger. */
      /**
       * Handles click events on the trigger.
       * @param {?} event
       * @return {?}
       */
      MatMenuTrigger.prototype._handleClick = /**
       * Handles click events on the trigger.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (this.triggersSubmenu()) {
                  // Stop event propagation to avoid closing the parent menu.
                  event.stopPropagation();
                  this.openMenu();
              }
              else {
                  this.toggleMenu();
              }
          };
      /** Handles the cases where the user hovers over the trigger. */
      /**
       * Handles the cases where the user hovers over the trigger.
       * @private
       * @return {?}
       */
      MatMenuTrigger.prototype._handleHover = /**
       * Handles the cases where the user hovers over the trigger.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              // Subscribe to changes in the hovered item in order to toggle the panel.
              if (!this.triggersSubmenu()) {
                  return;
              }
              this._hoverSubscription = this._parentMenu._hovered()
                  // Since we might have multiple competing triggers for the same menu (e.g. a sub-menu
                  // with different data and triggers), we have to delay it by a tick to ensure that
                  // it won't be closed immediately after it is opened.
                  .pipe(operators.filter(function (active) { return active === _this._menuItemInstance && !active.disabled; }), operators.delay(0, rxjs.asapScheduler))
                  .subscribe(function () {
                  _this._openedBy = 'mouse';
                  // If the same menu is used between multiple triggers, it might still be animating
                  // while the new trigger tries to re-open it. Wait for the animation to finish
                  // before doing so. Also interrupt if the user moves to another item.
                  if (_this.menu instanceof MatMenu && _this.menu._isAnimating) {
                      // We need the `delay(0)` here in order to avoid
                      // 'changed after checked' errors in some cases. See #12194.
                      _this.menu._animationDone
                          .pipe(operators.take(1), operators.delay(0, rxjs.asapScheduler), operators.takeUntil(_this._parentMenu._hovered()))
                          .subscribe(function () { return _this.openMenu(); });
                  }
                  else {
                      _this.openMenu();
                  }
              });
          };
      /** Gets the portal that should be attached to the overlay. */
      /**
       * Gets the portal that should be attached to the overlay.
       * @private
       * @return {?}
       */
      MatMenuTrigger.prototype._getPortal = /**
       * Gets the portal that should be attached to the overlay.
       * @private
       * @return {?}
       */
          function () {
              // Note that we can avoid this check by keeping the portal on the menu panel.
              // While it would be cleaner, we'd have to introduce another required method on
              // `MatMenuPanel`, making it harder to consume.
              if (!this._portal || this._portal.templateRef !== this.menu.templateRef) {
                  this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);
              }
              return this._portal;
          };
      MatMenuTrigger.decorators = [
          { type: core.Directive, args: [{
                      selector: "[mat-menu-trigger-for], [matMenuTriggerFor]",
                      host: {
                          'aria-haspopup': 'true',
                          '[attr.aria-expanded]': 'menuOpen || null',
                          '(mousedown)': '_handleMousedown($event)',
                          '(keydown)': '_handleKeydown($event)',
                          '(click)': '_handleClick($event)',
                      },
                      exportAs: 'matMenuTrigger'
                  },] },
      ];
      /** @nocollapse */
      MatMenuTrigger.ctorParameters = function () {
          return [
              { type: Overlay },
              { type: core.ElementRef },
              { type: core.ViewContainerRef },
              { type: undefined, decorators: [{ type: core.Inject, args: [MAT_MENU_SCROLL_STRATEGY,] }] },
              { type: MatMenu, decorators: [{ type: core.Optional }] },
              { type: MatMenuItem, decorators: [{ type: core.Optional }, { type: core.Self }] },
              { type: Directionality, decorators: [{ type: core.Optional }] },
              { type: FocusMonitor }
          ];
      };
      MatMenuTrigger.propDecorators = {
          _deprecatedMatMenuTriggerFor: [{ type: core.Input, args: ['mat-menu-trigger-for',] }],
          menu: [{ type: core.Input, args: ['matMenuTriggerFor',] }],
          menuData: [{ type: core.Input, args: ['matMenuTriggerData',] }],
          menuOpened: [{ type: core.Output }],
          onMenuOpen: [{ type: core.Output }],
          menuClosed: [{ type: core.Output }],
          onMenuClose: [{ type: core.Output }]
      };
      return MatMenuTrigger;
  }());

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * The following are all the animations for the mat-select component, with each
   * const containing the metadata for one animation.
   *
   * The values below match the implementation of the AngularJS Material mat-select animation.
   * \@docs-private
   * @type {?}
   */
  var matSelectAnimations = {
      /**
       * This animation transforms the select's overlay panel on and off the page.
       *
       * When the panel is attached to the DOM, it expands its width by the amount of padding, scales it
       * up to 100% on the Y axis, fades in its border, and translates slightly up and to the
       * side to ensure the option text correctly overlaps the trigger text.
       *
       * When the panel is removed from the DOM, it simply fades out linearly.
       */
      transformPanel: trigger('transformPanel', [
          state('void', style({
              transform: 'scaleY(0.8)',
              minWidth: '100%',
              opacity: 0
          })),
          state('showing', style({
              opacity: 1,
              minWidth: 'calc(100% + 32px)',
              // 32px = 2 * 16px padding
              transform: 'scaleY(1)'
          })),
          state('showing-multiple', style({
              opacity: 1,
              minWidth: 'calc(100% + 64px)',
              // 64px = 48px padding on the left + 16px padding on the right
              transform: 'scaleY(1)'
          })),
          transition('void => *', animate('120ms cubic-bezier(0, 0, 0.2, 1)')),
          transition('* => void', animate('100ms 25ms linear', style({ opacity: 0 })))
      ]),
      /**
       * This animation fades in the background color and text content of the
       * select's options. It is time delayed to occur 100ms after the overlay
       * panel has transformed in.
       * @deprecated Not used anymore. To be removed.
       * \@breaking-change 8.0.0
       */
      fadeInContent: trigger('fadeInContent', [
          state('showing', style({ opacity: 1 })),
          transition('void => showing', [
              style({ opacity: 0 }),
              animate('150ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')
          ])
      ])
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Returns an exception to be thrown when attempting to change a select's `multiple` option
   * after initialization.
   * \@docs-private
   * @return {?}
   */
  function getMatSelectDynamicMultipleError() {
      return Error('Cannot change `multiple` mode of select after initialization.');
  }
  /**
   * Returns an exception to be thrown when attempting to assign a non-array value to a select
   * in `multiple` mode. Note that `undefined` and `null` are still valid values to allow for
   * resetting the value.
   * \@docs-private
   * @return {?}
   */
  function getMatSelectNonArrayValueError() {
      return Error('Value must be an array in multiple-selection mode.');
  }
  /**
   * Returns an exception to be thrown when assigning a non-function value to the comparator
   * used to determine if a value corresponds to an option. Note that whether the function
   * actually takes two values and returns a boolean is not checked.
   * @return {?}
   */
  function getMatSelectNonFunctionValueError() {
      return Error('`compareWith` must be a function.');
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var nextUniqueId$6 = 0;
  /**
   * The max height of the select's overlay panel
   * @type {?}
   */
  var SELECT_PANEL_MAX_HEIGHT = 256;
  /**
   * The panel's padding on the x-axis
   * @type {?}
   */
  var SELECT_PANEL_PADDING_X = 16;
  /**
   * The panel's x axis padding if it is indented (e.g. there is an option group).
   * @type {?}
   */
  var SELECT_PANEL_INDENT_PADDING_X = SELECT_PANEL_PADDING_X * 2;
  /**
   * The height of the select items in `em` units.
   * @type {?}
   */
  var SELECT_ITEM_HEIGHT_EM = 3;
  // TODO(josephperrott): Revert to a constant after 2018 spec updates are fully merged.
  /**
   * Distance between the panel edge and the option text in
   * multi-selection mode.
   *
   * Calculated as:
   * (SELECT_PANEL_PADDING_X * 1.5) + 20 = 44
   * The padding is multiplied by 1.5 because the checkbox's margin is half the padding.
   * The checkbox width is 16px.
   * @type {?}
   */
  var SELECT_MULTIPLE_PANEL_PADDING_X = 0;
  /**
   * The select panel will only "fit" inside the viewport if it is positioned at
   * this value or more away from the viewport boundary.
   * @type {?}
   */
  var SELECT_PANEL_VIEWPORT_PADDING = 8;
  /**
   * Injection token that determines the scroll handling while a select is open.
   * @type {?}
   */
  var MAT_SELECT_SCROLL_STRATEGY = new core.InjectionToken('mat-select-scroll-strategy');
  /**
   * Change event object that is emitted when the select value has changed.
   */
  var /**
   * Change event object that is emitted when the select value has changed.
   */ MatSelectChange = /** @class */ (function () {
      function MatSelectChange(source, value) {
          this.source = source;
          this.value = value;
      }
      return MatSelectChange;
  }());
  // Boilerplate for applying mixins to MatSelect.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatSelect.
  /**
   * \@docs-private
   */
  MatSelectBase = /** @class */ (function () {
      function MatSelectBase(_elementRef, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {
          this._elementRef = _elementRef;
          this._defaultErrorStateMatcher = _defaultErrorStateMatcher;
          this._parentForm = _parentForm;
          this._parentFormGroup = _parentFormGroup;
          this.ngControl = ngControl;
      }
      return MatSelectBase;
  }());
  /** @type {?} */
  var _MatSelectMixinBase = mixinDisableRipple(mixinTabIndex(mixinDisabled(mixinErrorState(MatSelectBase))));
  /**
   * Allows the user to customize the trigger that is displayed when the select has a value.
   */
  var MatSelectTrigger = /** @class */ (function () {
      function MatSelectTrigger() {
      }
      MatSelectTrigger.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-select-trigger'
                  },] },
      ];
      return MatSelectTrigger;
  }());
  var MatSelect = /** @class */ (function (_super) {
      tslib_1.__extends(MatSelect, _super);
      function MatSelect(_viewportRuler, _changeDetectorRef, _ngZone, _defaultErrorStateMatcher, elementRef, _dir, _parentForm, _parentFormGroup, _parentFormField, ngControl, tabIndex, scrollStrategyFactory, _liveAnnouncer) {
          var _this = _super.call(this, elementRef, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;
          _this._viewportRuler = _viewportRuler;
          _this._changeDetectorRef = _changeDetectorRef;
          _this._ngZone = _ngZone;
          _this._dir = _dir;
          _this._parentFormField = _parentFormField;
          _this.ngControl = ngControl;
          _this._liveAnnouncer = _liveAnnouncer;
          /**
           * Whether or not the overlay panel is open.
           */
          _this._panelOpen = false;
          /**
           * Whether filling out the select is required in the form.
           */
          _this._required = false;
          /**
           * The scroll position of the overlay panel, calculated to center the selected option.
           */
          _this._scrollTop = 0;
          /**
           * Whether the component is in multiple selection mode.
           */
          _this._multiple = false;
          /**
           * Comparison function to specify which option is displayed. Defaults to object equality.
           */
          _this._compareWith = function (o1, o2) { return o1 === o2; };
          /**
           * Unique id for this input.
           */
          _this._uid = "mat-select-" + nextUniqueId$6++;
          /**
           * Emits whenever the component is destroyed.
           */
          _this._destroy = new rxjs.Subject();
          /**
           * The cached font-size of the trigger element.
           */
          _this._triggerFontSize = 0;
          /**
           * `View -> model callback called when value changes`
           */
          _this._onChange = function () { };
          /**
           * `View -> model callback called when select has been touched`
           */
          _this._onTouched = function () { };
          /**
           * The IDs of child options to be passed to the aria-owns attribute.
           */
          _this._optionIds = '';
          /**
           * The value of the select panel's transform-origin property.
           */
          _this._transformOrigin = 'top';
          /**
           * Emits when the panel element is finished transforming in.
           */
          _this._panelDoneAnimatingStream = new rxjs.Subject();
          /**
           * The y-offset of the overlay panel in relation to the trigger's top start corner.
           * This must be adjusted to align the selected option text over the trigger text.
           * when the panel opens. Will change based on the y-position of the selected option.
           */
          _this._offsetY = 0;
          /**
           * This position config ensures that the top "start" corner of the overlay
           * is aligned with with the top "start" of the origin by default (overlapping
           * the trigger completely). If the panel cannot fit below the trigger, it
           * will fall back to a position above the trigger.
           */
          _this._positions = [
              {
                  originX: 'start',
                  originY: 'top',
                  overlayX: 'start',
                  overlayY: 'top',
              },
              {
                  originX: 'start',
                  originY: 'bottom',
                  overlayX: 'start',
                  overlayY: 'bottom',
              },
          ];
          /**
           * Whether the component is disabling centering of the active option over the trigger.
           */
          _this._disableOptionCentering = false;
          _this._focused = false;
          /**
           * A name for this control that can be used by `mat-form-field`.
           */
          _this.controlType = 'mat-select';
          /**
           * Aria label of the select. If not specified, the placeholder will be used as label.
           */
          _this.ariaLabel = '';
          /**
           * Combined stream of all of the child options' change events.
           */
          _this.optionSelectionChanges = rxjs.defer(function () {
              if (_this.options) {
                  return rxjs.merge.apply(void 0, _this.options.map(function (option) { return option.onSelectionChange; }));
              }
              return _this._ngZone.onStable
                  .asObservable()
                  .pipe(operators.take(1), operators.switchMap(function () { return _this.optionSelectionChanges; }));
          });
          /**
           * Event emitted when the select panel has been toggled.
           */
          _this.openedChange = new core.EventEmitter();
          /**
           * Event emitted when the select has been opened.
           */
          _this._openedStream = _this.openedChange.pipe(operators.filter(function (o) { return o; }), operators.map(function () { }));
          /**
           * Event emitted when the select has been closed.
           */
          _this._closedStream = _this.openedChange.pipe(operators.filter(function (o) { return !o; }), operators.map(function () { }));
          /**
           * Event emitted when the selected value has been changed by the user.
           */
          _this.selectionChange = new core.EventEmitter();
          /**
           * Event that emits whenever the raw value of the select changes. This is here primarily
           * to facilitate the two-way binding for the `value` input.
           * \@docs-private
           */
          _this.valueChange = new core.EventEmitter();
          if (_this.ngControl) {
              // Note: we provide the value accessor through here, instead of
              // the `providers` to avoid running into a circular import.
              _this.ngControl.valueAccessor = _this;
          }
          _this._scrollStrategyFactory = scrollStrategyFactory;
          _this._scrollStrategy = _this._scrollStrategyFactory();
          _this.tabIndex = parseInt(tabIndex) || 0;
          // Force setter to be called in case id was not specified.
          _this.id = _this.id;
          return _this;
      }
      Object.defineProperty(MatSelect.prototype, "focused", {
          /** Whether the select is focused. */
          get: /**
           * Whether the select is focused.
           * @return {?}
           */ function () {
              return this._focused || this._panelOpen;
          },
          /**
           * @deprecated Setter to be removed as this property is intended to be readonly.
           * @breaking-change 8.0.0
           */
          set: /**
           * @deprecated Setter to be removed as this property is intended to be readonly.
           * \@breaking-change 8.0.0
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._focused = value;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSelect.prototype, "placeholder", {
          /** Placeholder to be shown if no value has been selected. */
          get: /**
           * Placeholder to be shown if no value has been selected.
           * @return {?}
           */ function () { return this._placeholder; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._placeholder = value;
              this.stateChanges.next();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSelect.prototype, "required", {
          /** Whether the component is required. */
          get: /**
           * Whether the component is required.
           * @return {?}
           */ function () { return this._required; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._required = coerceBooleanProperty(value);
              this.stateChanges.next();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSelect.prototype, "multiple", {
          /** Whether the user should be allowed to select multiple options. */
          get: /**
           * Whether the user should be allowed to select multiple options.
           * @return {?}
           */ function () { return this._multiple; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (this._selectionModel) {
                  throw getMatSelectDynamicMultipleError();
              }
              this._multiple = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSelect.prototype, "disableOptionCentering", {
          /** Whether to center the active option over the trigger. */
          get: /**
           * Whether to center the active option over the trigger.
           * @return {?}
           */ function () { return this._disableOptionCentering; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._disableOptionCentering = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSelect.prototype, "compareWith", {
          /**
           * Function to compare the option values with the selected values. The first argument
           * is a value from an option. The second is a value from the selection. A boolean
           * should be returned.
           */
          get: /**
           * Function to compare the option values with the selected values. The first argument
           * is a value from an option. The second is a value from the selection. A boolean
           * should be returned.
           * @return {?}
           */ function () { return this._compareWith; },
          set: /**
           * @param {?} fn
           * @return {?}
           */ function (fn) {
              if (typeof fn !== 'function') {
                  throw getMatSelectNonFunctionValueError();
              }
              this._compareWith = fn;
              if (this._selectionModel) {
                  // A different comparator means the selection could change.
                  this._initializeSelection();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSelect.prototype, "value", {
          /** Value of the select control. */
          get: /**
           * Value of the select control.
           * @return {?}
           */ function () { return this._value; },
          set: /**
           * @param {?} newValue
           * @return {?}
           */ function (newValue) {
              if (newValue !== this._value) {
                  this.writeValue(newValue);
                  this._value = newValue;
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSelect.prototype, "id", {
          /** Unique id of the element. */
          get: /**
           * Unique id of the element.
           * @return {?}
           */ function () { return this._id; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._id = value || this._uid;
              this.stateChanges.next();
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatSelect.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._selectionModel = new SelectionModel(this.multiple);
              this.stateChanges.next();
              // We need `distinctUntilChanged` here, because some browsers will
              // fire the animation end event twice for the same animation. See:
              // https://github.com/angular/angular/issues/24084
              this._panelDoneAnimatingStream
                  .pipe(operators.distinctUntilChanged(), operators.takeUntil(this._destroy))
                  .subscribe(function () {
                  if (_this.panelOpen) {
                      _this._scrollTop = 0;
                      _this.openedChange.emit(true);
                  }
                  else {
                      _this.openedChange.emit(false);
                      _this.overlayDir.offsetX = 0;
                      _this._changeDetectorRef.markForCheck();
                  }
              });
          };
      /**
       * @return {?}
       */
      MatSelect.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._initKeyManager();
              this._selectionModel.onChange.pipe(operators.takeUntil(this._destroy)).subscribe(function (event) {
                  event.added.forEach(function (option) { return option.select(); });
                  event.removed.forEach(function (option) { return option.deselect(); });
              });
              this.options.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroy)).subscribe(function () {
                  _this._resetOptions();
                  _this._initializeSelection();
              });
          };
      /**
       * @return {?}
       */
      MatSelect.prototype.ngDoCheck = /**
       * @return {?}
       */
          function () {
              if (this.ngControl) {
                  this.updateErrorState();
              }
          };
      /**
       * @param {?} changes
       * @return {?}
       */
      MatSelect.prototype.ngOnChanges = /**
       * @param {?} changes
       * @return {?}
       */
          function (changes) {
              // Updating the disabled state is handled by `mixinDisabled`, but we need to additionally let
              // the parent form field know to run change detection when the disabled state changes.
              if (changes.disabled) {
                  this.stateChanges.next();
              }
          };
      /**
       * @return {?}
       */
      MatSelect.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._destroy.next();
              this._destroy.complete();
              this.stateChanges.complete();
          };
      /** Toggles the overlay panel open or closed. */
      /**
       * Toggles the overlay panel open or closed.
       * @return {?}
       */
      MatSelect.prototype.toggle = /**
       * Toggles the overlay panel open or closed.
       * @return {?}
       */
          function () {
              this.panelOpen ? this.close() : this.open();
          };
      /** Opens the overlay panel. */
      /**
       * Opens the overlay panel.
       * @return {?}
       */
      MatSelect.prototype.open = /**
       * Opens the overlay panel.
       * @return {?}
       */
          function () {
              var _this = this;
              if (this.disabled || !this.options || !this.options.length || this._panelOpen) {
                  return;
              }
              this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();
              // Note: The computed font-size will be a string pixel value (e.g. "16px").
              // `parseInt` ignores the trailing 'px' and converts this to a number.
              this._triggerFontSize = parseInt(getComputedStyle(this.trigger.nativeElement).fontSize || '0');
              this._panelOpen = true;
              this._keyManager.withHorizontalOrientation(null);
              this._calculateOverlayPosition();
              this._highlightCorrectOption();
              this._changeDetectorRef.markForCheck();
              // Set the font size on the panel element once it exists.
              this._ngZone.onStable.asObservable().pipe(operators.take(1)).subscribe(function () {
                  if (_this._triggerFontSize && _this.overlayDir.overlayRef &&
                      _this.overlayDir.overlayRef.overlayElement) {
                      _this.overlayDir.overlayRef.overlayElement.style.fontSize = _this._triggerFontSize + "px";
                  }
              });
          };
      /** Closes the overlay panel and focuses the host element. */
      /**
       * Closes the overlay panel and focuses the host element.
       * @return {?}
       */
      MatSelect.prototype.close = /**
       * Closes the overlay panel and focuses the host element.
       * @return {?}
       */
          function () {
              if (this._panelOpen) {
                  this._panelOpen = false;
                  this._keyManager.withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr');
                  this._changeDetectorRef.markForCheck();
                  this._onTouched();
              }
          };
      /**
       * Sets the select's value. Part of the ControlValueAccessor interface
       * required to integrate with Angular's core forms API.
       *
       * @param value New value to be written to the model.
       */
      /**
       * Sets the select's value. Part of the ControlValueAccessor interface
       * required to integrate with Angular's core forms API.
       *
       * @param {?} value New value to be written to the model.
       * @return {?}
       */
      MatSelect.prototype.writeValue = /**
       * Sets the select's value. Part of the ControlValueAccessor interface
       * required to integrate with Angular's core forms API.
       *
       * @param {?} value New value to be written to the model.
       * @return {?}
       */
          function (value) {
              if (this.options) {
                  this._setSelectionByValue(value);
              }
          };
      /**
       * Saves a callback function to be invoked when the select's value
       * changes from user input. Part of the ControlValueAccessor interface
       * required to integrate with Angular's core forms API.
       *
       * @param fn Callback to be triggered when the value changes.
       */
      /**
       * Saves a callback function to be invoked when the select's value
       * changes from user input. Part of the ControlValueAccessor interface
       * required to integrate with Angular's core forms API.
       *
       * @param {?} fn Callback to be triggered when the value changes.
       * @return {?}
       */
      MatSelect.prototype.registerOnChange = /**
       * Saves a callback function to be invoked when the select's value
       * changes from user input. Part of the ControlValueAccessor interface
       * required to integrate with Angular's core forms API.
       *
       * @param {?} fn Callback to be triggered when the value changes.
       * @return {?}
       */
          function (fn) {
              this._onChange = fn;
          };
      /**
       * Saves a callback function to be invoked when the select is blurred
       * by the user. Part of the ControlValueAccessor interface required
       * to integrate with Angular's core forms API.
       *
       * @param fn Callback to be triggered when the component has been touched.
       */
      /**
       * Saves a callback function to be invoked when the select is blurred
       * by the user. Part of the ControlValueAccessor interface required
       * to integrate with Angular's core forms API.
       *
       * @param {?} fn Callback to be triggered when the component has been touched.
       * @return {?}
       */
      MatSelect.prototype.registerOnTouched = /**
       * Saves a callback function to be invoked when the select is blurred
       * by the user. Part of the ControlValueAccessor interface required
       * to integrate with Angular's core forms API.
       *
       * @param {?} fn Callback to be triggered when the component has been touched.
       * @return {?}
       */
          function (fn) {
              this._onTouched = fn;
          };
      /**
       * Disables the select. Part of the ControlValueAccessor interface required
       * to integrate with Angular's core forms API.
       *
       * @param isDisabled Sets whether the component is disabled.
       */
      /**
       * Disables the select. Part of the ControlValueAccessor interface required
       * to integrate with Angular's core forms API.
       *
       * @param {?} isDisabled Sets whether the component is disabled.
       * @return {?}
       */
      MatSelect.prototype.setDisabledState = /**
       * Disables the select. Part of the ControlValueAccessor interface required
       * to integrate with Angular's core forms API.
       *
       * @param {?} isDisabled Sets whether the component is disabled.
       * @return {?}
       */
          function (isDisabled) {
              this.disabled = isDisabled;
              this._changeDetectorRef.markForCheck();
              this.stateChanges.next();
          };
      Object.defineProperty(MatSelect.prototype, "panelOpen", {
          /** Whether or not the overlay panel is open. */
          get: /**
           * Whether or not the overlay panel is open.
           * @return {?}
           */ function () {
              return this._panelOpen;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSelect.prototype, "selected", {
          /** The currently selected option. */
          get: /**
           * The currently selected option.
           * @return {?}
           */ function () {
              return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSelect.prototype, "triggerValue", {
          /** The value displayed in the trigger. */
          get: /**
           * The value displayed in the trigger.
           * @return {?}
           */ function () {
              if (this.empty) {
                  return '';
              }
              if (this._multiple) {
                  /** @type {?} */
                  var selectedOptions = this._selectionModel.selected.map(function (option) { return option.viewValue; });
                  if (this._isRtl()) {
                      selectedOptions.reverse();
                  }
                  // TODO(crisbeto): delimiter should be configurable for proper localization.
                  return selectedOptions.join(', ');
              }
              return this._selectionModel.selected[0].viewValue;
          },
          enumerable: true,
          configurable: true
      });
      /** Whether the element is in RTL mode. */
      /**
       * Whether the element is in RTL mode.
       * @return {?}
       */
      MatSelect.prototype._isRtl = /**
       * Whether the element is in RTL mode.
       * @return {?}
       */
          function () {
              return this._dir ? this._dir.value === 'rtl' : false;
          };
      /** Handles all keydown events on the select. */
      /**
       * Handles all keydown events on the select.
       * @param {?} event
       * @return {?}
       */
      MatSelect.prototype._handleKeydown = /**
       * Handles all keydown events on the select.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (!this.disabled) {
                  this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);
              }
          };
      /** Handles keyboard events while the select is closed. */
      /**
       * Handles keyboard events while the select is closed.
       * @private
       * @param {?} event
       * @return {?}
       */
      MatSelect.prototype._handleClosedKeydown = /**
       * Handles keyboard events while the select is closed.
       * @private
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var keyCode = event.keyCode;
              /** @type {?} */
              var isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW ||
                  keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW;
              /** @type {?} */
              var isOpenKey = keyCode === ENTER || keyCode === SPACE;
              /** @type {?} */
              var manager = this._keyManager;
              // Open the select on ALT + arrow key to match the native <select>
              if ((isOpenKey && !hasModifierKey(event)) || ((this.multiple || event.altKey) && isArrowKey)) {
                  event.preventDefault(); // prevents the page from scrolling down when pressing space
                  this.open();
              }
              else if (!this.multiple) {
                  /** @type {?} */
                  var selectedOption = this.selected;
                  if (keyCode === HOME || keyCode === END) {
                      keyCode === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();
                      event.preventDefault();
                  }
                  else {
                      manager.onKeydown(event);
                  }
                  // Since the value has changed, we need to announce it ourselves.
                  // @breaking-change 8.0.0 remove null check for _liveAnnouncer.
                  if (this._liveAnnouncer && selectedOption !== this.selected) {
                      this._liveAnnouncer.announce((( /** @type {?} */(this.selected))).viewValue);
                  }
              }
          };
      /** Handles keyboard events when the selected is open. */
      /**
       * Handles keyboard events when the selected is open.
       * @private
       * @param {?} event
       * @return {?}
       */
      MatSelect.prototype._handleOpenKeydown = /**
       * Handles keyboard events when the selected is open.
       * @private
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var keyCode = event.keyCode;
              /** @type {?} */
              var isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;
              /** @type {?} */
              var manager = this._keyManager;
              if (keyCode === HOME || keyCode === END) {
                  event.preventDefault();
                  keyCode === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();
              }
              else if (isArrowKey && event.altKey) {
                  // Close the select on ALT + arrow key to match the native <select>
                  event.preventDefault();
                  this.close();
              }
              else if ((keyCode === ENTER || keyCode === SPACE) && manager.activeItem &&
                  !hasModifierKey(event)) {
                  event.preventDefault();
                  manager.activeItem._selectViaInteraction();
              }
              else if (this._multiple && keyCode === A && event.ctrlKey) {
                  event.preventDefault();
                  /** @type {?} */
                  var hasDeselectedOptions_1 = this.options.some(function (opt) { return !opt.disabled && !opt.selected; });
                  this.options.forEach(function (option) {
                      if (!option.disabled) {
                          hasDeselectedOptions_1 ? option.select() : option.deselect();
                      }
                  });
              }
              else {
                  /** @type {?} */
                  var previouslyFocusedIndex = manager.activeItemIndex;
                  manager.onKeydown(event);
                  if (this._multiple && isArrowKey && event.shiftKey && manager.activeItem &&
                      manager.activeItemIndex !== previouslyFocusedIndex) {
                      manager.activeItem._selectViaInteraction();
                  }
              }
          };
      /**
       * @return {?}
       */
      MatSelect.prototype._onFocus = /**
       * @return {?}
       */
          function () {
              if (!this.disabled) {
                  this._focused = true;
                  this.stateChanges.next();
              }
          };
      /**
       * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
       * "blur" to the panel when it opens, causing a false positive.
       */
      /**
       * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
       * "blur" to the panel when it opens, causing a false positive.
       * @return {?}
       */
      MatSelect.prototype._onBlur = /**
       * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
       * "blur" to the panel when it opens, causing a false positive.
       * @return {?}
       */
          function () {
              this._focused = false;
              if (!this.disabled && !this.panelOpen) {
                  this._onTouched();
                  this._changeDetectorRef.markForCheck();
                  this.stateChanges.next();
              }
          };
      /**
       * Callback that is invoked when the overlay panel has been attached.
       */
      /**
       * Callback that is invoked when the overlay panel has been attached.
       * @return {?}
       */
      MatSelect.prototype._onAttached = /**
       * Callback that is invoked when the overlay panel has been attached.
       * @return {?}
       */
          function () {
              var _this = this;
              this.overlayDir.positionChange.pipe(operators.take(1)).subscribe(function () {
                  _this._setPseudoCheckboxPaddingSize();
                  _this._changeDetectorRef.detectChanges();
                  _this._calculateOverlayOffsetX();
                  _this.panel.nativeElement.scrollTop = _this._scrollTop;
              });
          };
      /** Returns the theme to be used on the panel. */
      /**
       * Returns the theme to be used on the panel.
       * @return {?}
       */
      MatSelect.prototype._getPanelTheme = /**
       * Returns the theme to be used on the panel.
       * @return {?}
       */
          function () {
              return this._parentFormField ? "mat-" + this._parentFormField.color : '';
          };
      // TODO(josephperrott): Remove after 2018 spec updates are fully merged.
      /** Sets the pseudo checkbox padding size based on the width of the pseudo checkbox. */
      // TODO(josephperrott): Remove after 2018 spec updates are fully merged.
      /**
       * Sets the pseudo checkbox padding size based on the width of the pseudo checkbox.
       * @private
       * @return {?}
       */
      MatSelect.prototype._setPseudoCheckboxPaddingSize =
          // TODO(josephperrott): Remove after 2018 spec updates are fully merged.
          /**
           * Sets the pseudo checkbox padding size based on the width of the pseudo checkbox.
           * @private
           * @return {?}
           */
          function () {
              if (!SELECT_MULTIPLE_PANEL_PADDING_X && this.multiple) {
                  /** @type {?} */
                  var pseudoCheckbox = this.panel.nativeElement.querySelector('.mat-pseudo-checkbox');
                  if (pseudoCheckbox) {
                      SELECT_MULTIPLE_PANEL_PADDING_X = SELECT_PANEL_PADDING_X * 1.5 + pseudoCheckbox.offsetWidth;
                  }
              }
          };
      Object.defineProperty(MatSelect.prototype, "empty", {
          /** Whether the select has a value. */
          get: /**
           * Whether the select has a value.
           * @return {?}
           */ function () {
              return !this._selectionModel || this._selectionModel.isEmpty();
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @private
       * @return {?}
       */
      MatSelect.prototype._initializeSelection = /**
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              // Defer setting the value in order to avoid the "Expression
              // has changed after it was checked" errors from Angular.
              Promise.resolve().then(function () {
                  _this._setSelectionByValue(_this.ngControl ? _this.ngControl.value : _this._value);
                  _this.stateChanges.next();
              });
          };
      /**
       * Sets the selected option based on a value. If no option can be
       * found with the designated value, the select trigger is cleared.
       */
      /**
       * Sets the selected option based on a value. If no option can be
       * found with the designated value, the select trigger is cleared.
       * @private
       * @param {?} value
       * @return {?}
       */
      MatSelect.prototype._setSelectionByValue = /**
       * Sets the selected option based on a value. If no option can be
       * found with the designated value, the select trigger is cleared.
       * @private
       * @param {?} value
       * @return {?}
       */
          function (value) {
              var _this = this;
              if (this.multiple && value) {
                  if (!Array.isArray(value)) {
                      throw getMatSelectNonArrayValueError();
                  }
                  this._selectionModel.clear();
                  value.forEach(function (currentValue) { return _this._selectValue(currentValue); });
                  this._sortValues();
              }
              else {
                  this._selectionModel.clear();
                  /** @type {?} */
                  var correspondingOption = this._selectValue(value);
                  // Shift focus to the active item. Note that we shouldn't do this in multiple
                  // mode, because we don't know what option the user interacted with last.
                  if (correspondingOption) {
                      this._keyManager.setActiveItem(correspondingOption);
                  }
              }
              this._changeDetectorRef.markForCheck();
          };
      /**
       * Finds and selects and option based on its value.
       * @returns Option that has the corresponding value.
       */
      /**
       * Finds and selects and option based on its value.
       * @private
       * @param {?} value
       * @return {?} Option that has the corresponding value.
       */
      MatSelect.prototype._selectValue = /**
       * Finds and selects and option based on its value.
       * @private
       * @param {?} value
       * @return {?} Option that has the corresponding value.
       */
          function (value) {
              var _this = this;
              /** @type {?} */
              var correspondingOption = this.options.find(function (option) {
                  try {
                      // Treat null as a special reset value.
                      return option.value != null && _this._compareWith(option.value, value);
                  }
                  catch (error) {
                      if (core.isDevMode()) {
                          // Notify developers of errors in their comparator.
                          console.warn(error);
                      }
                      return false;
                  }
              });
              if (correspondingOption) {
                  this._selectionModel.select(correspondingOption);
              }
              return correspondingOption;
          };
      /** Sets up a key manager to listen to keyboard events on the overlay panel. */
      /**
       * Sets up a key manager to listen to keyboard events on the overlay panel.
       * @private
       * @return {?}
       */
      MatSelect.prototype._initKeyManager = /**
       * Sets up a key manager to listen to keyboard events on the overlay panel.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              this._keyManager = new ActiveDescendantKeyManager(this.options)
                  .withTypeAhead()
                  .withVerticalOrientation()
                  .withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr')
                  .withAllowedModifierKeys(['shiftKey']);
              this._keyManager.tabOut.pipe(operators.takeUntil(this._destroy)).subscribe(function () {
                  // Restore focus to the trigger before closing. Ensures that the focus
                  // position won't be lost if the user got focus into the overlay.
                  _this.focus();
                  _this.close();
              });
              this._keyManager.change.pipe(operators.takeUntil(this._destroy)).subscribe(function () {
                  if (_this._panelOpen && _this.panel) {
                      _this._scrollActiveOptionIntoView();
                  }
                  else if (!_this._panelOpen && !_this.multiple && _this._keyManager.activeItem) {
                      _this._keyManager.activeItem._selectViaInteraction();
                  }
              });
          };
      /** Drops current option subscriptions and IDs and resets from scratch. */
      /**
       * Drops current option subscriptions and IDs and resets from scratch.
       * @private
       * @return {?}
       */
      MatSelect.prototype._resetOptions = /**
       * Drops current option subscriptions and IDs and resets from scratch.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var changedOrDestroyed = rxjs.merge(this.options.changes, this._destroy);
              this.optionSelectionChanges.pipe(operators.takeUntil(changedOrDestroyed)).subscribe(function (event) {
                  _this._onSelect(event.source, event.isUserInput);
                  if (event.isUserInput && !_this.multiple && _this._panelOpen) {
                      _this.close();
                      _this.focus();
                  }
              });
              // Listen to changes in the internal state of the options and react accordingly.
              // Handles cases like the labels of the selected options changing.
              rxjs.merge.apply(void 0, this.options.map(function (option) { return option._stateChanges; })).pipe(operators.takeUntil(changedOrDestroyed))
                  .subscribe(function () {
                  _this._changeDetectorRef.markForCheck();
                  _this.stateChanges.next();
              });
              this._setOptionIds();
          };
      /** Invoked when an option is clicked. */
      /**
       * Invoked when an option is clicked.
       * @private
       * @param {?} option
       * @param {?} isUserInput
       * @return {?}
       */
      MatSelect.prototype._onSelect = /**
       * Invoked when an option is clicked.
       * @private
       * @param {?} option
       * @param {?} isUserInput
       * @return {?}
       */
          function (option, isUserInput) {
              /** @type {?} */
              var wasSelected = this._selectionModel.isSelected(option);
              if (option.value == null && !this._multiple) {
                  option.deselect();
                  this._selectionModel.clear();
                  this._propagateChanges(option.value);
              }
              else {
                  option.selected ? this._selectionModel.select(option) : this._selectionModel.deselect(option);
                  if (isUserInput) {
                      this._keyManager.setActiveItem(option);
                  }
                  if (this.multiple) {
                      this._sortValues();
                      if (isUserInput) {
                          // In case the user selected the option with their mouse, we
                          // want to restore focus back to the trigger, in order to
                          // prevent the select keyboard controls from clashing with
                          // the ones from `mat-option`.
                          this.focus();
                      }
                  }
              }
              if (wasSelected !== this._selectionModel.isSelected(option)) {
                  this._propagateChanges();
              }
              this.stateChanges.next();
          };
      /** Sorts the selected values in the selected based on their order in the panel. */
      /**
       * Sorts the selected values in the selected based on their order in the panel.
       * @private
       * @return {?}
       */
      MatSelect.prototype._sortValues = /**
       * Sorts the selected values in the selected based on their order in the panel.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              if (this.multiple) {
                  /** @type {?} */
                  var options_1 = this.options.toArray();
                  this._selectionModel.sort(function (a, b) {
                      return _this.sortComparator ? _this.sortComparator(a, b, options_1) :
                          options_1.indexOf(a) - options_1.indexOf(b);
                  });
                  this.stateChanges.next();
              }
          };
      /** Emits change event to set the model value. */
      /**
       * Emits change event to set the model value.
       * @private
       * @param {?=} fallbackValue
       * @return {?}
       */
      MatSelect.prototype._propagateChanges = /**
       * Emits change event to set the model value.
       * @private
       * @param {?=} fallbackValue
       * @return {?}
       */
          function (fallbackValue) {
              /** @type {?} */
              var valueToEmit = null;
              if (this.multiple) {
                  valueToEmit = (( /** @type {?} */(this.selected))).map(function (option) { return option.value; });
              }
              else {
                  valueToEmit = this.selected ? (( /** @type {?} */(this.selected))).value : fallbackValue;
              }
              this._value = valueToEmit;
              this.valueChange.emit(valueToEmit);
              this._onChange(valueToEmit);
              this.selectionChange.emit(new MatSelectChange(this, valueToEmit));
              this._changeDetectorRef.markForCheck();
          };
      /** Records option IDs to pass to the aria-owns property. */
      /**
       * Records option IDs to pass to the aria-owns property.
       * @private
       * @return {?}
       */
      MatSelect.prototype._setOptionIds = /**
       * Records option IDs to pass to the aria-owns property.
       * @private
       * @return {?}
       */
          function () {
              this._optionIds = this.options.map(function (option) { return option.id; }).join(' ');
          };
      /**
       * Highlights the selected item. If no option is selected, it will highlight
       * the first item instead.
       */
      /**
       * Highlights the selected item. If no option is selected, it will highlight
       * the first item instead.
       * @private
       * @return {?}
       */
      MatSelect.prototype._highlightCorrectOption = /**
       * Highlights the selected item. If no option is selected, it will highlight
       * the first item instead.
       * @private
       * @return {?}
       */
          function () {
              if (this._keyManager) {
                  if (this.empty) {
                      this._keyManager.setFirstItemActive();
                  }
                  else {
                      this._keyManager.setActiveItem(this._selectionModel.selected[0]);
                  }
              }
          };
      /** Scrolls the active option into view. */
      /**
       * Scrolls the active option into view.
       * @private
       * @return {?}
       */
      MatSelect.prototype._scrollActiveOptionIntoView = /**
       * Scrolls the active option into view.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var activeOptionIndex = this._keyManager.activeItemIndex || 0;
              /** @type {?} */
              var labelCount = _countGroupLabelsBeforeOption(activeOptionIndex, this.options, this.optionGroups);
              this.panel.nativeElement.scrollTop = _getOptionScrollPosition(activeOptionIndex + labelCount, this._getItemHeight(), this.panel.nativeElement.scrollTop, SELECT_PANEL_MAX_HEIGHT);
          };
      /** Focuses the select element. */
      /**
       * Focuses the select element.
       * @return {?}
       */
      MatSelect.prototype.focus = /**
       * Focuses the select element.
       * @return {?}
       */
          function () {
              this._elementRef.nativeElement.focus();
          };
      /** Gets the index of the provided option in the option list. */
      /**
       * Gets the index of the provided option in the option list.
       * @private
       * @param {?} option
       * @return {?}
       */
      MatSelect.prototype._getOptionIndex = /**
       * Gets the index of the provided option in the option list.
       * @private
       * @param {?} option
       * @return {?}
       */
          function (option) {
              return this.options.reduce(function (result, current, index) {
                  return result === undefined ? (option === current ? index : undefined) : result;
              }, undefined);
          };
      /** Calculates the scroll position and x- and y-offsets of the overlay panel. */
      /**
       * Calculates the scroll position and x- and y-offsets of the overlay panel.
       * @private
       * @return {?}
       */
      MatSelect.prototype._calculateOverlayPosition = /**
       * Calculates the scroll position and x- and y-offsets of the overlay panel.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var itemHeight = this._getItemHeight();
              /** @type {?} */
              var items = this._getItemCount();
              /** @type {?} */
              var panelHeight = Math.min(items * itemHeight, SELECT_PANEL_MAX_HEIGHT);
              /** @type {?} */
              var scrollContainerHeight = items * itemHeight;
              // The farthest the panel can be scrolled before it hits the bottom
              /** @type {?} */
              var maxScroll = scrollContainerHeight - panelHeight;
              // If no value is selected we open the popup to the first item.
              /** @type {?} */
              var selectedOptionOffset = this.empty ? 0 : ( /** @type {?} */(this._getOptionIndex(this._selectionModel.selected[0])));
              selectedOptionOffset += _countGroupLabelsBeforeOption(selectedOptionOffset, this.options, this.optionGroups);
              // We must maintain a scroll buffer so the selected option will be scrolled to the
              // center of the overlay panel rather than the top.
              /** @type {?} */
              var scrollBuffer = panelHeight / 2;
              this._scrollTop = this._calculateOverlayScroll(selectedOptionOffset, scrollBuffer, maxScroll);
              this._offsetY = this._calculateOverlayOffsetY(selectedOptionOffset, scrollBuffer, maxScroll);
              this._checkOverlayWithinViewport(maxScroll);
          };
      /**
       * Calculates the scroll position of the select's overlay panel.
       *
       * Attempts to center the selected option in the panel. If the option is
       * too high or too low in the panel to be scrolled to the center, it clamps the
       * scroll position to the min or max scroll positions respectively.
       */
      /**
       * Calculates the scroll position of the select's overlay panel.
       *
       * Attempts to center the selected option in the panel. If the option is
       * too high or too low in the panel to be scrolled to the center, it clamps the
       * scroll position to the min or max scroll positions respectively.
       * @param {?} selectedIndex
       * @param {?} scrollBuffer
       * @param {?} maxScroll
       * @return {?}
       */
      MatSelect.prototype._calculateOverlayScroll = /**
       * Calculates the scroll position of the select's overlay panel.
       *
       * Attempts to center the selected option in the panel. If the option is
       * too high or too low in the panel to be scrolled to the center, it clamps the
       * scroll position to the min or max scroll positions respectively.
       * @param {?} selectedIndex
       * @param {?} scrollBuffer
       * @param {?} maxScroll
       * @return {?}
       */
          function (selectedIndex, scrollBuffer, maxScroll) {
              /** @type {?} */
              var itemHeight = this._getItemHeight();
              /** @type {?} */
              var optionOffsetFromScrollTop = itemHeight * selectedIndex;
              /** @type {?} */
              var halfOptionHeight = itemHeight / 2;
              // Starts at the optionOffsetFromScrollTop, which scrolls the option to the top of the
              // scroll container, then subtracts the scroll buffer to scroll the option down to
              // the center of the overlay panel. Half the option height must be re-added to the
              // scrollTop so the option is centered based on its middle, not its top edge.
              /** @type {?} */
              var optimalScrollPosition = optionOffsetFromScrollTop - scrollBuffer + halfOptionHeight;
              return Math.min(Math.max(0, optimalScrollPosition), maxScroll);
          };
      /** Returns the aria-label of the select component. */
      /**
       * Returns the aria-label of the select component.
       * @return {?}
       */
      MatSelect.prototype._getAriaLabel = /**
       * Returns the aria-label of the select component.
       * @return {?}
       */
          function () {
              // If an ariaLabelledby value has been set by the consumer, the select should not overwrite the
              // `aria-labelledby` value by setting the ariaLabel to the placeholder.
              return this.ariaLabelledby ? null : this.ariaLabel || this.placeholder;
          };
      /** Returns the aria-labelledby of the select component. */
      /**
       * Returns the aria-labelledby of the select component.
       * @return {?}
       */
      MatSelect.prototype._getAriaLabelledby = /**
       * Returns the aria-labelledby of the select component.
       * @return {?}
       */
          function () {
              if (this.ariaLabelledby) {
                  return this.ariaLabelledby;
              }
              // Note: we use `_getAriaLabel` here, because we want to check whether there's a
              // computed label. `this.ariaLabel` is only the user-specified label.
              if (!this._parentFormField || !this._parentFormField._hasFloatingLabel() ||
                  this._getAriaLabel()) {
                  return null;
              }
              return this._parentFormField._labelId || null;
          };
      /** Determines the `aria-activedescendant` to be set on the host. */
      /**
       * Determines the `aria-activedescendant` to be set on the host.
       * @return {?}
       */
      MatSelect.prototype._getAriaActiveDescendant = /**
       * Determines the `aria-activedescendant` to be set on the host.
       * @return {?}
       */
          function () {
              if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {
                  return this._keyManager.activeItem.id;
              }
              return null;
          };
      /**
       * Sets the x-offset of the overlay panel in relation to the trigger's top start corner.
       * This must be adjusted to align the selected option text over the trigger text when
       * the panel opens. Will change based on LTR or RTL text direction. Note that the offset
       * can't be calculated until the panel has been attached, because we need to know the
       * content width in order to constrain the panel within the viewport.
       */
      /**
       * Sets the x-offset of the overlay panel in relation to the trigger's top start corner.
       * This must be adjusted to align the selected option text over the trigger text when
       * the panel opens. Will change based on LTR or RTL text direction. Note that the offset
       * can't be calculated until the panel has been attached, because we need to know the
       * content width in order to constrain the panel within the viewport.
       * @private
       * @return {?}
       */
      MatSelect.prototype._calculateOverlayOffsetX = /**
       * Sets the x-offset of the overlay panel in relation to the trigger's top start corner.
       * This must be adjusted to align the selected option text over the trigger text when
       * the panel opens. Will change based on LTR or RTL text direction. Note that the offset
       * can't be calculated until the panel has been attached, because we need to know the
       * content width in order to constrain the panel within the viewport.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var overlayRect = this.overlayDir.overlayRef.overlayElement.getBoundingClientRect();
              /** @type {?} */
              var viewportSize = this._viewportRuler.getViewportSize();
              /** @type {?} */
              var isRtl = this._isRtl();
              /** @type {?} */
              var paddingWidth = this.multiple ? SELECT_MULTIPLE_PANEL_PADDING_X + SELECT_PANEL_PADDING_X :
                  SELECT_PANEL_PADDING_X * 2;
              /** @type {?} */
              var offsetX;
              // Adjust the offset, depending on the option padding.
              if (this.multiple) {
                  offsetX = SELECT_MULTIPLE_PANEL_PADDING_X;
              }
              else {
                  /** @type {?} */
                  var selected = this._selectionModel.selected[0] || this.options.first;
                  offsetX = selected && selected.group ? SELECT_PANEL_INDENT_PADDING_X : SELECT_PANEL_PADDING_X;
              }
              // Invert the offset in LTR.
              if (!isRtl) {
                  offsetX *= -1;
              }
              // Determine how much the select overflows on each side.
              /** @type {?} */
              var leftOverflow = 0 - (overlayRect.left + offsetX - (isRtl ? paddingWidth : 0));
              /** @type {?} */
              var rightOverflow = overlayRect.right + offsetX - viewportSize.width
                  + (isRtl ? 0 : paddingWidth);
              // If the element overflows on either side, reduce the offset to allow it to fit.
              if (leftOverflow > 0) {
                  offsetX += leftOverflow + SELECT_PANEL_VIEWPORT_PADDING;
              }
              else if (rightOverflow > 0) {
                  offsetX -= rightOverflow + SELECT_PANEL_VIEWPORT_PADDING;
              }
              // Set the offset directly in order to avoid having to go through change detection and
              // potentially triggering "changed after it was checked" errors. Round the value to avoid
              // blurry content in some browsers.
              this.overlayDir.offsetX = Math.round(offsetX);
              this.overlayDir.overlayRef.updatePosition();
          };
      /**
       * Calculates the y-offset of the select's overlay panel in relation to the
       * top start corner of the trigger. It has to be adjusted in order for the
       * selected option to be aligned over the trigger when the panel opens.
       */
      /**
       * Calculates the y-offset of the select's overlay panel in relation to the
       * top start corner of the trigger. It has to be adjusted in order for the
       * selected option to be aligned over the trigger when the panel opens.
       * @private
       * @param {?} selectedIndex
       * @param {?} scrollBuffer
       * @param {?} maxScroll
       * @return {?}
       */
      MatSelect.prototype._calculateOverlayOffsetY = /**
       * Calculates the y-offset of the select's overlay panel in relation to the
       * top start corner of the trigger. It has to be adjusted in order for the
       * selected option to be aligned over the trigger when the panel opens.
       * @private
       * @param {?} selectedIndex
       * @param {?} scrollBuffer
       * @param {?} maxScroll
       * @return {?}
       */
          function (selectedIndex, scrollBuffer, maxScroll) {
              /** @type {?} */
              var itemHeight = this._getItemHeight();
              /** @type {?} */
              var optionHeightAdjustment = (itemHeight - this._triggerRect.height) / 2;
              /** @type {?} */
              var maxOptionsDisplayed = Math.floor(SELECT_PANEL_MAX_HEIGHT / itemHeight);
              /** @type {?} */
              var optionOffsetFromPanelTop;
              // Disable offset if requested by user by returning 0 as value to offset
              if (this._disableOptionCentering) {
                  return 0;
              }
              if (this._scrollTop === 0) {
                  optionOffsetFromPanelTop = selectedIndex * itemHeight;
              }
              else if (this._scrollTop === maxScroll) {
                  /** @type {?} */
                  var firstDisplayedIndex = this._getItemCount() - maxOptionsDisplayed;
                  /** @type {?} */
                  var selectedDisplayIndex = selectedIndex - firstDisplayedIndex;
                  // The first item is partially out of the viewport. Therefore we need to calculate what
                  // portion of it is shown in the viewport and account for it in our offset.
                  /** @type {?} */
                  var partialItemHeight = itemHeight - (this._getItemCount() * itemHeight - SELECT_PANEL_MAX_HEIGHT) % itemHeight;
                  // Because the panel height is longer than the height of the options alone,
                  // there is always extra padding at the top or bottom of the panel. When
                  // scrolled to the very bottom, this padding is at the top of the panel and
                  // must be added to the offset.
                  optionOffsetFromPanelTop = selectedDisplayIndex * itemHeight + partialItemHeight;
              }
              else {
                  // If the option was scrolled to the middle of the panel using a scroll buffer,
                  // its offset will be the scroll buffer minus the half height that was added to
                  // center it.
                  optionOffsetFromPanelTop = scrollBuffer - itemHeight / 2;
              }
              // The final offset is the option's offset from the top, adjusted for the height difference,
              // multiplied by -1 to ensure that the overlay moves in the correct direction up the page.
              // The value is rounded to prevent some browsers from blurring the content.
              return Math.round(optionOffsetFromPanelTop * -1 - optionHeightAdjustment);
          };
      /**
       * Checks that the attempted overlay position will fit within the viewport.
       * If it will not fit, tries to adjust the scroll position and the associated
       * y-offset so the panel can open fully on-screen. If it still won't fit,
       * sets the offset back to 0 to allow the fallback position to take over.
       */
      /**
       * Checks that the attempted overlay position will fit within the viewport.
       * If it will not fit, tries to adjust the scroll position and the associated
       * y-offset so the panel can open fully on-screen. If it still won't fit,
       * sets the offset back to 0 to allow the fallback position to take over.
       * @private
       * @param {?} maxScroll
       * @return {?}
       */
      MatSelect.prototype._checkOverlayWithinViewport = /**
       * Checks that the attempted overlay position will fit within the viewport.
       * If it will not fit, tries to adjust the scroll position and the associated
       * y-offset so the panel can open fully on-screen. If it still won't fit,
       * sets the offset back to 0 to allow the fallback position to take over.
       * @private
       * @param {?} maxScroll
       * @return {?}
       */
          function (maxScroll) {
              /** @type {?} */
              var itemHeight = this._getItemHeight();
              /** @type {?} */
              var viewportSize = this._viewportRuler.getViewportSize();
              /** @type {?} */
              var topSpaceAvailable = this._triggerRect.top - SELECT_PANEL_VIEWPORT_PADDING;
              /** @type {?} */
              var bottomSpaceAvailable = viewportSize.height - this._triggerRect.bottom - SELECT_PANEL_VIEWPORT_PADDING;
              /** @type {?} */
              var panelHeightTop = Math.abs(this._offsetY);
              /** @type {?} */
              var totalPanelHeight = Math.min(this._getItemCount() * itemHeight, SELECT_PANEL_MAX_HEIGHT);
              /** @type {?} */
              var panelHeightBottom = totalPanelHeight - panelHeightTop - this._triggerRect.height;
              if (panelHeightBottom > bottomSpaceAvailable) {
                  this._adjustPanelUp(panelHeightBottom, bottomSpaceAvailable);
              }
              else if (panelHeightTop > topSpaceAvailable) {
                  this._adjustPanelDown(panelHeightTop, topSpaceAvailable, maxScroll);
              }
              else {
                  this._transformOrigin = this._getOriginBasedOnOption();
              }
          };
      /** Adjusts the overlay panel up to fit in the viewport. */
      /**
       * Adjusts the overlay panel up to fit in the viewport.
       * @private
       * @param {?} panelHeightBottom
       * @param {?} bottomSpaceAvailable
       * @return {?}
       */
      MatSelect.prototype._adjustPanelUp = /**
       * Adjusts the overlay panel up to fit in the viewport.
       * @private
       * @param {?} panelHeightBottom
       * @param {?} bottomSpaceAvailable
       * @return {?}
       */
          function (panelHeightBottom, bottomSpaceAvailable) {
              // Browsers ignore fractional scroll offsets, so we need to round.
              /** @type {?} */
              var distanceBelowViewport = Math.round(panelHeightBottom - bottomSpaceAvailable);
              // Scrolls the panel up by the distance it was extending past the boundary, then
              // adjusts the offset by that amount to move the panel up into the viewport.
              this._scrollTop -= distanceBelowViewport;
              this._offsetY -= distanceBelowViewport;
              this._transformOrigin = this._getOriginBasedOnOption();
              // If the panel is scrolled to the very top, it won't be able to fit the panel
              // by scrolling, so set the offset to 0 to allow the fallback position to take
              // effect.
              if (this._scrollTop <= 0) {
                  this._scrollTop = 0;
                  this._offsetY = 0;
                  this._transformOrigin = "50% bottom 0px";
              }
          };
      /** Adjusts the overlay panel down to fit in the viewport. */
      /**
       * Adjusts the overlay panel down to fit in the viewport.
       * @private
       * @param {?} panelHeightTop
       * @param {?} topSpaceAvailable
       * @param {?} maxScroll
       * @return {?}
       */
      MatSelect.prototype._adjustPanelDown = /**
       * Adjusts the overlay panel down to fit in the viewport.
       * @private
       * @param {?} panelHeightTop
       * @param {?} topSpaceAvailable
       * @param {?} maxScroll
       * @return {?}
       */
          function (panelHeightTop, topSpaceAvailable, maxScroll) {
              // Browsers ignore fractional scroll offsets, so we need to round.
              /** @type {?} */
              var distanceAboveViewport = Math.round(panelHeightTop - topSpaceAvailable);
              // Scrolls the panel down by the distance it was extending past the boundary, then
              // adjusts the offset by that amount to move the panel down into the viewport.
              this._scrollTop += distanceAboveViewport;
              this._offsetY += distanceAboveViewport;
              this._transformOrigin = this._getOriginBasedOnOption();
              // If the panel is scrolled to the very bottom, it won't be able to fit the
              // panel by scrolling, so set the offset to 0 to allow the fallback position
              // to take effect.
              if (this._scrollTop >= maxScroll) {
                  this._scrollTop = maxScroll;
                  this._offsetY = 0;
                  this._transformOrigin = "50% top 0px";
                  return;
              }
          };
      /** Sets the transform origin point based on the selected option. */
      /**
       * Sets the transform origin point based on the selected option.
       * @private
       * @return {?}
       */
      MatSelect.prototype._getOriginBasedOnOption = /**
       * Sets the transform origin point based on the selected option.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var itemHeight = this._getItemHeight();
              /** @type {?} */
              var optionHeightAdjustment = (itemHeight - this._triggerRect.height) / 2;
              /** @type {?} */
              var originY = Math.abs(this._offsetY) - optionHeightAdjustment + itemHeight / 2;
              return "50% " + originY + "px 0px";
          };
      /** Calculates the amount of items in the select. This includes options and group labels. */
      /**
       * Calculates the amount of items in the select. This includes options and group labels.
       * @private
       * @return {?}
       */
      MatSelect.prototype._getItemCount = /**
       * Calculates the amount of items in the select. This includes options and group labels.
       * @private
       * @return {?}
       */
          function () {
              return this.options.length + this.optionGroups.length;
          };
      /** Calculates the height of the select's options. */
      /**
       * Calculates the height of the select's options.
       * @private
       * @return {?}
       */
      MatSelect.prototype._getItemHeight = /**
       * Calculates the height of the select's options.
       * @private
       * @return {?}
       */
          function () {
              return this._triggerFontSize * SELECT_ITEM_HEIGHT_EM;
          };
      /**
       * Implemented as part of MatFormFieldControl.
       * @docs-private
       */
      /**
       * Implemented as part of MatFormFieldControl.
       * \@docs-private
       * @param {?} ids
       * @return {?}
       */
      MatSelect.prototype.setDescribedByIds = /**
       * Implemented as part of MatFormFieldControl.
       * \@docs-private
       * @param {?} ids
       * @return {?}
       */
          function (ids) {
              this._ariaDescribedby = ids.join(' ');
          };
      /**
       * Implemented as part of MatFormFieldControl.
       * @docs-private
       */
      /**
       * Implemented as part of MatFormFieldControl.
       * \@docs-private
       * @return {?}
       */
      MatSelect.prototype.onContainerClick = /**
       * Implemented as part of MatFormFieldControl.
       * \@docs-private
       * @return {?}
       */
          function () {
              this.focus();
              this.open();
          };
      Object.defineProperty(MatSelect.prototype, "shouldLabelFloat", {
          /**
           * Implemented as part of MatFormFieldControl.
           * @docs-private
           */
          get: /**
           * Implemented as part of MatFormFieldControl.
           * \@docs-private
           * @return {?}
           */ function () {
              return this._panelOpen || !this.empty;
          },
          enumerable: true,
          configurable: true
      });
      MatSelect.decorators = [
          { type: core.Component, args: [{ selector: 'mat-select',
                      exportAs: 'matSelect',
                      template: "<div cdk-overlay-origin class=\"mat-select-trigger\" aria-hidden=\"true\" (click)=\"toggle()\" #origin=\"cdkOverlayOrigin\" #trigger><div class=\"mat-select-value\" [ngSwitch]=\"empty\"><span class=\"mat-select-placeholder\" *ngSwitchCase=\"true\">{{placeholder || '\u00A0'}}</span> <span class=\"mat-select-value-text\" *ngSwitchCase=\"false\" [ngSwitch]=\"!!customTrigger\"><span *ngSwitchDefault>{{triggerValue || '\u00A0'}}</span><ng-content select=\"mat-select-trigger\" *ngSwitchCase=\"true\"></ng-content></span></div><div class=\"mat-select-arrow-wrapper\"><div class=\"mat-select-arrow\"></div></div></div><ng-template cdk-connected-overlay cdkConnectedOverlayLockPosition cdkConnectedOverlayHasBackdrop cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\" [cdkConnectedOverlayScrollStrategy]=\"_scrollStrategy\" [cdkConnectedOverlayOrigin]=\"origin\" [cdkConnectedOverlayOpen]=\"panelOpen\" [cdkConnectedOverlayPositions]=\"_positions\" [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width\" [cdkConnectedOverlayOffsetY]=\"_offsetY\" (backdropClick)=\"close()\" (attach)=\"_onAttached()\" (detach)=\"close()\"><div #panel class=\"mat-select-panel {{ _getPanelTheme() }}\" [ngClass]=\"panelClass\" [@transformPanel]=\"multiple ? 'showing-multiple' : 'showing'\" (@transformPanel.done)=\"_panelDoneAnimatingStream.next($event.toState)\" [style.transformOrigin]=\"_transformOrigin\" [style.font-size.px]=\"_triggerFontSize\" (keydown)=\"_handleKeydown($event)\"><ng-content></ng-content></div></ng-template>",
                      styles: [".mat-select{display:inline-block;width:100%;outline:0}.mat-select-trigger{display:inline-table;cursor:pointer;position:relative;box-sizing:border-box}.mat-select-disabled .mat-select-trigger{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-select-value{display:table-cell;max-width:0;width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-select-arrow-wrapper{display:table-cell;vertical-align:middle}.mat-form-field-appearance-fill .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-outline .mat-select-arrow-wrapper{transform:translateY(-25%)}.mat-form-field-appearance-standard.mat-form-field-has-label .mat-select:not(.mat-select-empty) .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:transform .4s cubic-bezier(.25,.8,.25,1)}._mat-animation-noopable.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:none}.mat-select-arrow{width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;margin:0 4px}.mat-select-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;padding-top:0;padding-bottom:0;max-height:256px;min-width:100%;border-radius:4px}@media (-ms-high-contrast:active){.mat-select-panel{outline:solid 1px}}.mat-select-panel .mat-optgroup-label,.mat-select-panel .mat-option{font-size:inherit;line-height:3em;height:3em}.mat-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-form-field-flex{cursor:pointer}.mat-form-field-type-mat-select .mat-form-field-label{width:calc(100% - 18px)}.mat-select-placeholder{transition:color .4s .133s cubic-bezier(.25,.8,.25,1)}._mat-animation-noopable .mat-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-select-placeholder{color:transparent;-webkit-text-fill-color:transparent;transition:none;display:block}"],
                      inputs: ['disabled', 'disableRipple', 'tabIndex'],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      host: {
                          'role': 'listbox',
                          '[attr.id]': 'id',
                          '[attr.tabindex]': 'tabIndex',
                          '[attr.aria-label]': '_getAriaLabel()',
                          '[attr.aria-labelledby]': '_getAriaLabelledby()',
                          '[attr.aria-required]': 'required.toString()',
                          '[attr.aria-disabled]': 'disabled.toString()',
                          '[attr.aria-invalid]': 'errorState',
                          '[attr.aria-owns]': 'panelOpen ? _optionIds : null',
                          '[attr.aria-multiselectable]': 'multiple',
                          '[attr.aria-describedby]': '_ariaDescribedby || null',
                          '[attr.aria-activedescendant]': '_getAriaActiveDescendant()',
                          '[class.mat-select-disabled]': 'disabled',
                          '[class.mat-select-invalid]': 'errorState',
                          '[class.mat-select-required]': 'required',
                          '[class.mat-select-empty]': 'empty',
                          'class': 'mat-select',
                          '(keydown)': '_handleKeydown($event)',
                          '(focus)': '_onFocus()',
                          '(blur)': '_onBlur()',
                      },
                      animations: [
                          matSelectAnimations.transformPanel
                      ],
                      providers: [
                          { provide: MatFormFieldControl, useExisting: MatSelect },
                          { provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatSelect }
                      ],
                  },] },
      ];
      /** @nocollapse */
      MatSelect.ctorParameters = function () {
          return [
              { type: ViewportRuler },
              { type: core.ChangeDetectorRef },
              { type: core.NgZone },
              { type: ErrorStateMatcher },
              { type: core.ElementRef },
              { type: Directionality, decorators: [{ type: core.Optional }] },
              { type: forms.NgForm, decorators: [{ type: core.Optional }] },
              { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] },
              { type: MatFormField, decorators: [{ type: core.Optional }] },
              { type: forms.NgControl, decorators: [{ type: core.Self }, { type: core.Optional }] },
              { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] },
              { type: undefined, decorators: [{ type: core.Inject, args: [MAT_SELECT_SCROLL_STRATEGY,] }] },
              { type: LiveAnnouncer }
          ];
      };
      MatSelect.propDecorators = {
          trigger: [{ type: core.ViewChild, args: ['trigger',] }],
          panel: [{ type: core.ViewChild, args: ['panel',] }],
          overlayDir: [{ type: core.ViewChild, args: [CdkConnectedOverlay,] }],
          options: [{ type: core.ContentChildren, args: [MatOption, { descendants: true },] }],
          optionGroups: [{ type: core.ContentChildren, args: [MatOptgroup,] }],
          panelClass: [{ type: core.Input }],
          customTrigger: [{ type: core.ContentChild, args: [MatSelectTrigger,] }],
          placeholder: [{ type: core.Input }],
          required: [{ type: core.Input }],
          multiple: [{ type: core.Input }],
          disableOptionCentering: [{ type: core.Input }],
          compareWith: [{ type: core.Input }],
          value: [{ type: core.Input }],
          ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
          ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],
          errorStateMatcher: [{ type: core.Input }],
          sortComparator: [{ type: core.Input }],
          id: [{ type: core.Input }],
          openedChange: [{ type: core.Output }],
          _openedStream: [{ type: core.Output, args: ['opened',] }],
          _closedStream: [{ type: core.Output, args: ['closed',] }],
          selectionChange: [{ type: core.Output }],
          valueChange: [{ type: core.Output }]
      };
      return MatSelect;
  }(_MatSelectMixinBase));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Animations used by MatTooltip.
   * \@docs-private
   * @type {?}
   */
  var matTooltipAnimations = {
      /**
       * Animation that transitions a tooltip in and out.
       */
      tooltipState: trigger('state', [
          state('initial, void, hidden', style({ opacity: 0, transform: 'scale(0)' })),
          state('visible', style({ transform: 'scale(1)' })),
          transition('* => visible', animate('200ms cubic-bezier(0, 0, 0.2, 1)', keyframes([
              style({ opacity: 0, transform: 'scale(0)', offset: 0 }),
              style({ opacity: 0.5, transform: 'scale(0.99)', offset: 0.5 }),
              style({ opacity: 1, transform: 'scale(1)', offset: 1 })
          ]))),
          transition('* => hidden', animate('100ms cubic-bezier(0, 0, 0.2, 1)', style({ opacity: 0 }))),
      ])
  };
  /**
   * CSS class that will be attached to the overlay panel.
   * @type {?}
   */
  var TOOLTIP_PANEL_CLASS = 'mat-tooltip-panel';
  /**
   * Creates an error to be thrown if the user supplied an invalid tooltip position.
   * \@docs-private
   * @param {?} position
   * @return {?}
   */
  function getMatTooltipInvalidPositionError(position) {
      return Error("Tooltip position \"" + position + "\" is invalid.");
  }
  /**
   * Injection token that determines the scroll handling while a tooltip is visible.
   * @type {?}
   */
  var MAT_TOOLTIP_SCROLL_STRATEGY = new core.InjectionToken('mat-tooltip-scroll-strategy');
  /**
   * Injection token to be used to override the default options for `matTooltip`.
   * @type {?}
   */
  var MAT_TOOLTIP_DEFAULT_OPTIONS = new core.InjectionToken('mat-tooltip-default-options', {
      providedIn: 'root',
      factory: MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY
  });
  /**
   * \@docs-private
   * @return {?}
   */
  function MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY() {
      return {
          showDelay: 0,
          hideDelay: 0,
          touchendHideDelay: 1500,
      };
  }
  /**
   * Directive that attaches a material design tooltip to the host element. Animates the showing and
   * hiding of a tooltip provided position (defaults to below the element).
   *
   * https://material.io/design/components/tooltips.html
   */
  var MatTooltip = /** @class */ (function () {
      function MatTooltip(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, platform, _ariaDescriber, _focusMonitor, scrollStrategy, _dir, _defaultOptions, hammerLoader) {
          var _this = this;
          this._overlay = _overlay;
          this._elementRef = _elementRef;
          this._scrollDispatcher = _scrollDispatcher;
          this._viewContainerRef = _viewContainerRef;
          this._ngZone = _ngZone;
          this._ariaDescriber = _ariaDescriber;
          this._focusMonitor = _focusMonitor;
          this._dir = _dir;
          this._defaultOptions = _defaultOptions;
          this._position = 'below';
          this._disabled = false;
          /**
           * The default delay in ms before showing the tooltip after show is called
           */
          this.showDelay = this._defaultOptions.showDelay;
          /**
           * The default delay in ms before hiding the tooltip after hide is called
           */
          this.hideDelay = this._defaultOptions.hideDelay;
          this._message = '';
          this._manualListeners = new Map();
          /**
           * Emits when the component is destroyed.
           */
          this._destroyed = new rxjs.Subject();
          this._scrollStrategy = scrollStrategy;
          /** @type {?} */
          var element = _elementRef.nativeElement;
          /** @type {?} */
          var elementStyle = ( /** @type {?} */(element.style));
          /** @type {?} */
          var hasGestures = typeof window === 'undefined' || (( /** @type {?} */(window))).Hammer || hammerLoader;
          // The mouse events shouldn't be bound on mobile devices, because they can prevent the
          // first tap from firing its click event or can cause the tooltip to open for clicks.
          if (!platform.IOS && !platform.ANDROID) {
              this._manualListeners
                  .set('mouseenter', function () { return _this.show(); })
                  .set('mouseleave', function () { return _this.hide(); });
          }
          else if (!hasGestures) {
              // If Hammerjs isn't loaded, fall back to showing on `touchstart`, otherwise
              // there's no way for the user to trigger the tooltip on a touch device.
              this._manualListeners.set('touchstart', function () { return _this.show(); });
          }
          this._manualListeners.forEach(function (listener, event) { return element.addEventListener(event, listener); });
          if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
              // When we bind a gesture event on an element (in this case `longpress`), HammerJS
              // will add some inline styles by default, including `user-select: none`. This is
              // problematic on iOS and in Safari, because it will prevent users from typing in inputs.
              // Since `user-select: none` is not needed for the `longpress` event and can cause unexpected
              // behavior for text fields, we always clear the `user-select` to avoid such issues.
              elementStyle.webkitUserSelect = elementStyle.userSelect = elementStyle.msUserSelect = '';
          }
          // Hammer applies `-webkit-user-drag: none` on all elements by default,
          // which breaks the native drag&drop. If the consumer explicitly made
          // the element draggable, clear the `-webkit-user-drag`.
          if (element.draggable && elementStyle.webkitUserDrag === 'none') {
              elementStyle.webkitUserDrag = '';
          }
          _focusMonitor.monitor(_elementRef).pipe(operators.takeUntil(this._destroyed)).subscribe(function (origin) {
              // Note that the focus monitor runs outside the Angular zone.
              if (!origin) {
                  _ngZone.run(function () { return _this.hide(0); });
              }
              else if (origin === 'keyboard') {
                  _ngZone.run(function () { return _this.show(); });
              }
          });
          if (_defaultOptions && _defaultOptions.position) {
              this.position = _defaultOptions.position;
          }
      }
      Object.defineProperty(MatTooltip.prototype, "position", {
          /** Allows the user to define the position of the tooltip relative to the parent element */
          get: /**
           * Allows the user to define the position of the tooltip relative to the parent element
           * @return {?}
           */ function () { return this._position; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (value !== this._position) {
                  this._position = value;
                  if (this._overlayRef) {
                      this._updatePosition();
                      if (this._tooltipInstance) {
                          ( /** @type {?} */(this._tooltipInstance)).show(0);
                      }
                      this._overlayRef.updatePosition();
                  }
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatTooltip.prototype, "disabled", {
          /** Disables the display of the tooltip. */
          get: /**
           * Disables the display of the tooltip.
           * @return {?}
           */ function () { return this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._disabled = coerceBooleanProperty(value);
              // If tooltip is disabled, hide immediately.
              if (this._disabled) {
                  this.hide(0);
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatTooltip.prototype, "message", {
          /** The message to be displayed in the tooltip */
          get: /**
           * The message to be displayed in the tooltip
           * @return {?}
           */ function () { return this._message; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this._message);
              // If the message is not a string (e.g. number), convert it to a string and trim it.
              this._message = value != null ? ("" + value).trim() : '';
              if (!this._message && this._isTooltipVisible()) {
                  this.hide(0);
              }
              else {
                  this._updateTooltipMessage();
                  this._ariaDescriber.describe(this._elementRef.nativeElement, this.message);
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatTooltip.prototype, "tooltipClass", {
          /** Classes to be passed to the tooltip. Supports the same syntax as `ngClass`. */
          get: /**
           * Classes to be passed to the tooltip. Supports the same syntax as `ngClass`.
           * @return {?}
           */ function () { return this._tooltipClass; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._tooltipClass = value;
              if (this._tooltipInstance) {
                  this._setTooltipClass(this._tooltipClass);
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Dispose the tooltip when destroyed.
       */
      /**
       * Dispose the tooltip when destroyed.
       * @return {?}
       */
      MatTooltip.prototype.ngOnDestroy = /**
       * Dispose the tooltip when destroyed.
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._overlayRef) {
                  this._overlayRef.dispose();
                  this._tooltipInstance = null;
              }
              // Clean up the event listeners set in the constructor
              this._manualListeners.forEach(function (listener, event) {
                  _this._elementRef.nativeElement.removeEventListener(event, listener);
              });
              this._manualListeners.clear();
              this._destroyed.next();
              this._destroyed.complete();
              this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this.message);
              this._focusMonitor.stopMonitoring(this._elementRef);
          };
      /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */
      /**
       * Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input
       * @param {?=} delay
       * @return {?}
       */
      MatTooltip.prototype.show = /**
       * Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input
       * @param {?=} delay
       * @return {?}
       */
          function (delay) {
              var _this = this;
              if (delay === void 0) {
                  delay = this.showDelay;
              }
              if (this.disabled || !this.message || (this._isTooltipVisible() &&
                  !( /** @type {?} */(this._tooltipInstance))._showTimeoutId && !( /** @type {?} */(this._tooltipInstance))._hideTimeoutId)) {
                  return;
              }
              /** @type {?} */
              var overlayRef = this._createOverlay();
              this._detach();
              this._portal = this._portal || new ComponentPortal(TooltipComponent, this._viewContainerRef);
              this._tooltipInstance = overlayRef.attach(this._portal).instance;
              this._tooltipInstance.afterHidden()
                  .pipe(operators.takeUntil(this._destroyed))
                  .subscribe(function () { return _this._detach(); });
              this._setTooltipClass(this._tooltipClass);
              this._updateTooltipMessage();
              ( /** @type {?} */(this._tooltipInstance)).show(delay);
          };
      /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */
      /**
       * Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input
       * @param {?=} delay
       * @return {?}
       */
      MatTooltip.prototype.hide = /**
       * Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input
       * @param {?=} delay
       * @return {?}
       */
          function (delay) {
              if (delay === void 0) {
                  delay = this.hideDelay;
              }
              if (this._tooltipInstance) {
                  this._tooltipInstance.hide(delay);
              }
          };
      /** Shows/hides the tooltip */
      /**
       * Shows/hides the tooltip
       * @return {?}
       */
      MatTooltip.prototype.toggle = /**
       * Shows/hides the tooltip
       * @return {?}
       */
          function () {
              this._isTooltipVisible() ? this.hide() : this.show();
          };
      /** Returns true if the tooltip is currently visible to the user */
      /**
       * Returns true if the tooltip is currently visible to the user
       * @return {?}
       */
      MatTooltip.prototype._isTooltipVisible = /**
       * Returns true if the tooltip is currently visible to the user
       * @return {?}
       */
          function () {
              return !!this._tooltipInstance && this._tooltipInstance.isVisible();
          };
      /** Handles the keydown events on the host element. */
      /**
       * Handles the keydown events on the host element.
       * @param {?} e
       * @return {?}
       */
      MatTooltip.prototype._handleKeydown = /**
       * Handles the keydown events on the host element.
       * @param {?} e
       * @return {?}
       */
          function (e) {
              if (this._isTooltipVisible() && e.keyCode === ESCAPE) {
                  e.stopPropagation();
                  this.hide(0);
              }
          };
      /** Handles the touchend events on the host element. */
      /**
       * Handles the touchend events on the host element.
       * @return {?}
       */
      MatTooltip.prototype._handleTouchend = /**
       * Handles the touchend events on the host element.
       * @return {?}
       */
          function () {
              this.hide(this._defaultOptions.touchendHideDelay);
          };
      /** Create the overlay config and position strategy */
      /**
       * Create the overlay config and position strategy
       * @private
       * @return {?}
       */
      MatTooltip.prototype._createOverlay = /**
       * Create the overlay config and position strategy
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._overlayRef) {
                  return this._overlayRef;
              }
              // Create connected position strategy that listens for scroll events to reposition.
              /** @type {?} */
              var strategy = this._overlay.position()
                  .flexibleConnectedTo(this._elementRef)
                  .withTransformOriginOn('.mat-tooltip')
                  .withFlexibleDimensions(false)
                  .withViewportMargin(8);
              /** @type {?} */
              var scrollableAncestors = this._scrollDispatcher
                  .getAncestorScrollContainers(this._elementRef);
              strategy.withScrollableContainers(scrollableAncestors);
              strategy.positionChanges.pipe(operators.takeUntil(this._destroyed)).subscribe(function (change) {
                  if (_this._tooltipInstance) {
                      if (change.scrollableViewProperties.isOverlayClipped && _this._tooltipInstance.isVisible()) {
                          // After position changes occur and the overlay is clipped by
                          // a parent scrollable then close the tooltip.
                          _this._ngZone.run(function () { return _this.hide(0); });
                      }
                  }
              });
              this._overlayRef = this._overlay.create({
                  direction: this._dir,
                  positionStrategy: strategy,
                  panelClass: TOOLTIP_PANEL_CLASS,
                  scrollStrategy: this._scrollStrategy()
              });
              this._updatePosition();
              this._overlayRef.detachments()
                  .pipe(operators.takeUntil(this._destroyed))
                  .subscribe(function () { return _this._detach(); });
              return this._overlayRef;
          };
      /** Detaches the currently-attached tooltip. */
      /**
       * Detaches the currently-attached tooltip.
       * @private
       * @return {?}
       */
      MatTooltip.prototype._detach = /**
       * Detaches the currently-attached tooltip.
       * @private
       * @return {?}
       */
          function () {
              if (this._overlayRef && this._overlayRef.hasAttached()) {
                  this._overlayRef.detach();
              }
              this._tooltipInstance = null;
          };
      /** Updates the position of the current tooltip. */
      /**
       * Updates the position of the current tooltip.
       * @private
       * @return {?}
       */
      MatTooltip.prototype._updatePosition = /**
       * Updates the position of the current tooltip.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var position = ( /** @type {?} */(( /** @type {?} */(this._overlayRef)).getConfig().positionStrategy));
              /** @type {?} */
              var origin = this._getOrigin();
              /** @type {?} */
              var overlay = this._getOverlayPosition();
              position.withPositions([
                  tslib_1.__assign({}, origin.main, overlay.main),
                  tslib_1.__assign({}, origin.fallback, overlay.fallback)
              ]);
          };
      /**
       * Returns the origin position and a fallback position based on the user's position preference.
       * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).
       */
      /**
       * Returns the origin position and a fallback position based on the user's position preference.
       * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).
       * @return {?}
       */
      MatTooltip.prototype._getOrigin = /**
       * Returns the origin position and a fallback position based on the user's position preference.
       * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).
       * @return {?}
       */
          function () {
              /** @type {?} */
              var isLtr = !this._dir || this._dir.value == 'ltr';
              /** @type {?} */
              var position = this.position;
              /** @type {?} */
              var originPosition;
              if (position == 'above' || position == 'below') {
                  originPosition = { originX: 'center', originY: position == 'above' ? 'top' : 'bottom' };
              }
              else if (position == 'before' ||
                  (position == 'left' && isLtr) ||
                  (position == 'right' && !isLtr)) {
                  originPosition = { originX: 'start', originY: 'center' };
              }
              else if (position == 'after' ||
                  (position == 'right' && isLtr) ||
                  (position == 'left' && !isLtr)) {
                  originPosition = { originX: 'end', originY: 'center' };
              }
              else {
                  throw getMatTooltipInvalidPositionError(position);
              }
              var _a = this._invertPosition(originPosition.originX, originPosition.originY), x = _a.x, y = _a.y;
              return {
                  main: originPosition,
                  fallback: { originX: x, originY: y }
              };
          };
      /** Returns the overlay position and a fallback position based on the user's preference */
      /**
       * Returns the overlay position and a fallback position based on the user's preference
       * @return {?}
       */
      MatTooltip.prototype._getOverlayPosition = /**
       * Returns the overlay position and a fallback position based on the user's preference
       * @return {?}
       */
          function () {
              /** @type {?} */
              var isLtr = !this._dir || this._dir.value == 'ltr';
              /** @type {?} */
              var position = this.position;
              /** @type {?} */
              var overlayPosition;
              if (position == 'above') {
                  overlayPosition = { overlayX: 'center', overlayY: 'bottom' };
              }
              else if (position == 'below') {
                  overlayPosition = { overlayX: 'center', overlayY: 'top' };
              }
              else if (position == 'before' ||
                  (position == 'left' && isLtr) ||
                  (position == 'right' && !isLtr)) {
                  overlayPosition = { overlayX: 'end', overlayY: 'center' };
              }
              else if (position == 'after' ||
                  (position == 'right' && isLtr) ||
                  (position == 'left' && !isLtr)) {
                  overlayPosition = { overlayX: 'start', overlayY: 'center' };
              }
              else {
                  throw getMatTooltipInvalidPositionError(position);
              }
              var _a = this._invertPosition(overlayPosition.overlayX, overlayPosition.overlayY), x = _a.x, y = _a.y;
              return {
                  main: overlayPosition,
                  fallback: { overlayX: x, overlayY: y }
              };
          };
      /** Updates the tooltip message and repositions the overlay according to the new message length */
      /**
       * Updates the tooltip message and repositions the overlay according to the new message length
       * @private
       * @return {?}
       */
      MatTooltip.prototype._updateTooltipMessage = /**
       * Updates the tooltip message and repositions the overlay according to the new message length
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              // Must wait for the message to be painted to the tooltip so that the overlay can properly
              // calculate the correct positioning based on the size of the text.
              if (this._tooltipInstance) {
                  this._tooltipInstance.message = this.message;
                  this._tooltipInstance._markForCheck();
                  this._ngZone.onMicrotaskEmpty.asObservable().pipe(operators.take(1), operators.takeUntil(this._destroyed)).subscribe(function () {
                      if (_this._tooltipInstance) {
                          ( /** @type {?} */(_this._overlayRef)).updatePosition();
                      }
                  });
              }
          };
      /** Updates the tooltip class */
      /**
       * Updates the tooltip class
       * @private
       * @param {?} tooltipClass
       * @return {?}
       */
      MatTooltip.prototype._setTooltipClass = /**
       * Updates the tooltip class
       * @private
       * @param {?} tooltipClass
       * @return {?}
       */
          function (tooltipClass) {
              if (this._tooltipInstance) {
                  this._tooltipInstance.tooltipClass = tooltipClass;
                  this._tooltipInstance._markForCheck();
              }
          };
      /** Inverts an overlay position. */
      /**
       * Inverts an overlay position.
       * @private
       * @param {?} x
       * @param {?} y
       * @return {?}
       */
      MatTooltip.prototype._invertPosition = /**
       * Inverts an overlay position.
       * @private
       * @param {?} x
       * @param {?} y
       * @return {?}
       */
          function (x, y) {
              if (this.position === 'above' || this.position === 'below') {
                  if (y === 'top') {
                      y = 'bottom';
                  }
                  else if (y === 'bottom') {
                      y = 'top';
                  }
              }
              else {
                  if (x === 'end') {
                      x = 'start';
                  }
                  else if (x === 'start') {
                      x = 'end';
                  }
              }
              return { x: x, y: y };
          };
      MatTooltip.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matTooltip]',
                      exportAs: 'matTooltip',
                      host: {
                          '(longpress)': 'show()',
                          '(keydown)': '_handleKeydown($event)',
                          '(touchend)': '_handleTouchend()',
                      },
                  },] },
      ];
      /** @nocollapse */
      MatTooltip.ctorParameters = function () {
          return [
              { type: Overlay },
              { type: core.ElementRef },
              { type: ScrollDispatcher },
              { type: core.ViewContainerRef },
              { type: core.NgZone },
              { type: Platform },
              { type: AriaDescriber },
              { type: FocusMonitor },
              { type: undefined, decorators: [{ type: core.Inject, args: [MAT_TOOLTIP_SCROLL_STRATEGY,] }] },
              { type: Directionality, decorators: [{ type: core.Optional }] },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_TOOLTIP_DEFAULT_OPTIONS,] }] },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [platformBrowser.HAMMER_LOADER,] }] }
          ];
      };
      MatTooltip.propDecorators = {
          position: [{ type: core.Input, args: ['matTooltipPosition',] }],
          disabled: [{ type: core.Input, args: ['matTooltipDisabled',] }],
          showDelay: [{ type: core.Input, args: ['matTooltipShowDelay',] }],
          hideDelay: [{ type: core.Input, args: ['matTooltipHideDelay',] }],
          message: [{ type: core.Input, args: ['matTooltip',] }],
          tooltipClass: [{ type: core.Input, args: ['matTooltipClass',] }]
      };
      return MatTooltip;
  }());
  /**
   * Internal component that wraps the tooltip's content.
   * \@docs-private
   */
  var TooltipComponent = /** @class */ (function () {
      function TooltipComponent(_changeDetectorRef, _breakpointObserver) {
          this._changeDetectorRef = _changeDetectorRef;
          this._breakpointObserver = _breakpointObserver;
          /**
           * Property watched by the animation framework to show or hide the tooltip
           */
          this._visibility = 'initial';
          /**
           * Whether interactions on the page should close the tooltip
           */
          this._closeOnInteraction = false;
          /**
           * Subject for notifying that the tooltip has been hidden from the view
           */
          this._onHide = new rxjs.Subject();
          /**
           * Stream that emits whether the user has a handset-sized display.
           */
          this._isHandset = this._breakpointObserver.observe(Breakpoints.Handset);
      }
      /**
       * Shows the tooltip with an animation originating from the provided origin
       * @param delay Amount of milliseconds to the delay showing the tooltip.
       */
      /**
       * Shows the tooltip with an animation originating from the provided origin
       * @param {?} delay Amount of milliseconds to the delay showing the tooltip.
       * @return {?}
       */
      TooltipComponent.prototype.show = /**
       * Shows the tooltip with an animation originating from the provided origin
       * @param {?} delay Amount of milliseconds to the delay showing the tooltip.
       * @return {?}
       */
          function (delay) {
              var _this = this;
              // Cancel the delayed hide if it is scheduled
              if (this._hideTimeoutId) {
                  clearTimeout(this._hideTimeoutId);
                  this._hideTimeoutId = null;
              }
              // Body interactions should cancel the tooltip if there is a delay in showing.
              this._closeOnInteraction = true;
              this._showTimeoutId = setTimeout(function () {
                  _this._visibility = 'visible';
                  _this._showTimeoutId = null;
                  // Mark for check so if any parent component has set the
                  // ChangeDetectionStrategy to OnPush it will be checked anyways
                  _this._markForCheck();
              }, delay);
          };
      /**
       * Begins the animation to hide the tooltip after the provided delay in ms.
       * @param delay Amount of milliseconds to delay showing the tooltip.
       */
      /**
       * Begins the animation to hide the tooltip after the provided delay in ms.
       * @param {?} delay Amount of milliseconds to delay showing the tooltip.
       * @return {?}
       */
      TooltipComponent.prototype.hide = /**
       * Begins the animation to hide the tooltip after the provided delay in ms.
       * @param {?} delay Amount of milliseconds to delay showing the tooltip.
       * @return {?}
       */
          function (delay) {
              var _this = this;
              // Cancel the delayed show if it is scheduled
              if (this._showTimeoutId) {
                  clearTimeout(this._showTimeoutId);
                  this._showTimeoutId = null;
              }
              this._hideTimeoutId = setTimeout(function () {
                  _this._visibility = 'hidden';
                  _this._hideTimeoutId = null;
                  // Mark for check so if any parent component has set the
                  // ChangeDetectionStrategy to OnPush it will be checked anyways
                  _this._markForCheck();
              }, delay);
          };
      /** Returns an observable that notifies when the tooltip has been hidden from view. */
      /**
       * Returns an observable that notifies when the tooltip has been hidden from view.
       * @return {?}
       */
      TooltipComponent.prototype.afterHidden = /**
       * Returns an observable that notifies when the tooltip has been hidden from view.
       * @return {?}
       */
          function () {
              return this._onHide.asObservable();
          };
      /** Whether the tooltip is being displayed. */
      /**
       * Whether the tooltip is being displayed.
       * @return {?}
       */
      TooltipComponent.prototype.isVisible = /**
       * Whether the tooltip is being displayed.
       * @return {?}
       */
          function () {
              return this._visibility === 'visible';
          };
      /**
       * @return {?}
       */
      TooltipComponent.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._onHide.complete();
          };
      /**
       * @return {?}
       */
      TooltipComponent.prototype._animationStart = /**
       * @return {?}
       */
          function () {
              this._closeOnInteraction = false;
          };
      /**
       * @param {?} event
       * @return {?}
       */
      TooltipComponent.prototype._animationDone = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var toState = ( /** @type {?} */(event.toState));
              if (toState === 'hidden' && !this.isVisible()) {
                  this._onHide.next();
              }
              if (toState === 'visible' || toState === 'hidden') {
                  this._closeOnInteraction = true;
              }
          };
      /**
       * Interactions on the HTML body should close the tooltip immediately as defined in the
       * material design spec.
       * https://material.io/design/components/tooltips.html#behavior
       */
      /**
       * Interactions on the HTML body should close the tooltip immediately as defined in the
       * material design spec.
       * https://material.io/design/components/tooltips.html#behavior
       * @return {?}
       */
      TooltipComponent.prototype._handleBodyInteraction = /**
       * Interactions on the HTML body should close the tooltip immediately as defined in the
       * material design spec.
       * https://material.io/design/components/tooltips.html#behavior
       * @return {?}
       */
          function () {
              if (this._closeOnInteraction) {
                  this.hide(0);
              }
          };
      /**
       * Marks that the tooltip needs to be checked in the next change detection run.
       * Mainly used for rendering the initial text before positioning a tooltip, which
       * can be problematic in components with OnPush change detection.
       */
      /**
       * Marks that the tooltip needs to be checked in the next change detection run.
       * Mainly used for rendering the initial text before positioning a tooltip, which
       * can be problematic in components with OnPush change detection.
       * @return {?}
       */
      TooltipComponent.prototype._markForCheck = /**
       * Marks that the tooltip needs to be checked in the next change detection run.
       * Mainly used for rendering the initial text before positioning a tooltip, which
       * can be problematic in components with OnPush change detection.
       * @return {?}
       */
          function () {
              this._changeDetectorRef.markForCheck();
          };
      TooltipComponent.decorators = [
          { type: core.Component, args: [{ selector: 'mat-tooltip-component',
                      template: "<div class=\"mat-tooltip\" [ngClass]=\"tooltipClass\" [class.mat-tooltip-handset]=\"(_isHandset | async)?.matches\" [@state]=\"_visibility\" (@state.start)=\"_animationStart()\" (@state.done)=\"_animationDone($event)\">{{message}}</div>",
                      styles: [".mat-tooltip-panel{pointer-events:none!important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}@media (-ms-high-contrast:active){.mat-tooltip{outline:solid 1px}}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}"],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      animations: [matTooltipAnimations.tooltipState],
                      host: {
                          // Forces the element to have a layout in IE and Edge. This fixes issues where the element
                          // won't be rendered if the animations are disabled or there is no web animations polyfill.
                          '[style.zoom]': '_visibility === "visible" ? 1 : null',
                          '(body:click)': 'this._handleBodyInteraction()',
                          'aria-hidden': 'true',
                      }
                  },] },
      ];
      /** @nocollapse */
      TooltipComponent.ctorParameters = function () {
          return [
              { type: core.ChangeDetectorRef },
              { type: BreakpointObserver }
          ];
      };
      return TooltipComponent;
  }());

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * To modify the labels and text displayed, create a new instance of MatPaginatorIntl and
   * include it in a custom provider
   */
  var MatPaginatorIntl = /** @class */ (function () {
      function MatPaginatorIntl() {
          /**
           * Stream to emit from when labels are changed. Use this to notify components when the labels have
           * changed after initialization.
           */
          this.changes = new rxjs.Subject();
          /**
           * A label for the page size selector.
           */
          this.itemsPerPageLabel = 'Items per page:';
          /**
           * A label for the button that increments the current page.
           */
          this.nextPageLabel = 'Next page';
          /**
           * A label for the button that decrements the current page.
           */
          this.previousPageLabel = 'Previous page';
          /**
           * A label for the button that moves to the first page.
           */
          this.firstPageLabel = 'First page';
          /**
           * A label for the button that moves to the last page.
           */
          this.lastPageLabel = 'Last page';
          /**
           * A label for the range of items within the current page and the length of the whole list.
           */
          this.getRangeLabel = function (page, pageSize, length) {
              if (length == 0 || pageSize == 0) {
                  return "0 of " + length;
              }
              length = Math.max(length, 0);
              /** @type {?} */
              var startIndex = page * pageSize;
              // If the start index exceeds the list length, do not try and fix the end index to the end.
              /** @type {?} */
              var endIndex = startIndex < length ?
                  Math.min(startIndex + pageSize, length) :
                  startIndex + pageSize;
              return startIndex + 1 + " - " + endIndex + " of " + length;
          };
      }
      MatPaginatorIntl.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */ MatPaginatorIntl.ngInjectableDef = core.defineInjectable({ factory: function MatPaginatorIntl_Factory() { return new MatPaginatorIntl(); }, token: MatPaginatorIntl, providedIn: "root" });
      return MatPaginatorIntl;
  }());
  /**
   * \@docs-private
   * @param {?} parentIntl
   * @return {?}
   */
  function MAT_PAGINATOR_INTL_PROVIDER_FACTORY(parentIntl) {
      return parentIntl || new MatPaginatorIntl();
  }
  /**
   * \@docs-private
   * @type {?}
   */
  var MAT_PAGINATOR_INTL_PROVIDER = {
      // If there is already an MatPaginatorIntl available, use that. Otherwise, provide a new one.
      provide: MatPaginatorIntl,
      deps: [[new core.Optional(), new core.SkipSelf(), MatPaginatorIntl]],
      useFactory: MAT_PAGINATOR_INTL_PROVIDER_FACTORY
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * The default page size if there is no page size and there are no provided page size options.
   * @type {?}
   */
  var DEFAULT_PAGE_SIZE = 50;
  // Boilerplate for applying mixins to MatPaginator.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatPaginator.
  /**
   * \@docs-private
   */
  MatPaginatorBase = /** @class */ (function () {
      function MatPaginatorBase() {
      }
      return MatPaginatorBase;
  }());
  /** @type {?} */
  var _MatPaginatorBase = mixinDisabled(mixinInitialized(MatPaginatorBase));
  /**
   * Component to provide navigation between paged information. Displays the size of the current
   * page, user-selectable options to change that size, what items are being shown, and
   * navigational button to go to the previous or next page.
   */
  var MatPaginator = /** @class */ (function (_super) {
      tslib_1.__extends(MatPaginator, _super);
      function MatPaginator(_intl, _changeDetectorRef) {
          var _this = _super.call(this) || this;
          _this._intl = _intl;
          _this._changeDetectorRef = _changeDetectorRef;
          _this._pageIndex = 0;
          _this._length = 0;
          _this._pageSizeOptions = [];
          _this._hidePageSize = false;
          _this._showFirstLastButtons = false;
          /**
           * Event emitted when the paginator changes the page size or page index.
           */
          _this.page = new core.EventEmitter();
          _this._intlChanges = _intl.changes.subscribe(function () { return _this._changeDetectorRef.markForCheck(); });
          return _this;
      }
      Object.defineProperty(MatPaginator.prototype, "pageIndex", {
          /** The zero-based page index of the displayed list of items. Defaulted to 0. */
          get: /**
           * The zero-based page index of the displayed list of items. Defaulted to 0.
           * @return {?}
           */ function () { return this._pageIndex; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._pageIndex = Math.max(coerceNumberProperty(value), 0);
              this._changeDetectorRef.markForCheck();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatPaginator.prototype, "length", {
          /** The length of the total number of items that are being paginated. Defaulted to 0. */
          get: /**
           * The length of the total number of items that are being paginated. Defaulted to 0.
           * @return {?}
           */ function () { return this._length; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._length = coerceNumberProperty(value);
              this._changeDetectorRef.markForCheck();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatPaginator.prototype, "pageSize", {
          /** Number of items to display on a page. By default set to 50. */
          get: /**
           * Number of items to display on a page. By default set to 50.
           * @return {?}
           */ function () { return this._pageSize; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._pageSize = Math.max(coerceNumberProperty(value), 0);
              this._updateDisplayedPageSizeOptions();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatPaginator.prototype, "pageSizeOptions", {
          /** The set of provided page size options to display to the user. */
          get: /**
           * The set of provided page size options to display to the user.
           * @return {?}
           */ function () { return this._pageSizeOptions; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._pageSizeOptions = (value || []).map(function (p) { return coerceNumberProperty(p); });
              this._updateDisplayedPageSizeOptions();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatPaginator.prototype, "hidePageSize", {
          /** Whether to hide the page size selection UI from the user. */
          get: /**
           * Whether to hide the page size selection UI from the user.
           * @return {?}
           */ function () { return this._hidePageSize; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._hidePageSize = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatPaginator.prototype, "showFirstLastButtons", {
          /** Whether to show the first/last buttons UI to the user. */
          get: /**
           * Whether to show the first/last buttons UI to the user.
           * @return {?}
           */ function () { return this._showFirstLastButtons; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._showFirstLastButtons = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatPaginator.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              this._initialized = true;
              this._updateDisplayedPageSizeOptions();
              this._markInitialized();
          };
      /**
       * @return {?}
       */
      MatPaginator.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._intlChanges.unsubscribe();
          };
      /** Advances to the next page if it exists. */
      /**
       * Advances to the next page if it exists.
       * @return {?}
       */
      MatPaginator.prototype.nextPage = /**
       * Advances to the next page if it exists.
       * @return {?}
       */
          function () {
              if (!this.hasNextPage()) {
                  return;
              }
              /** @type {?} */
              var previousPageIndex = this.pageIndex;
              this.pageIndex++;
              this._emitPageEvent(previousPageIndex);
          };
      /** Move back to the previous page if it exists. */
      /**
       * Move back to the previous page if it exists.
       * @return {?}
       */
      MatPaginator.prototype.previousPage = /**
       * Move back to the previous page if it exists.
       * @return {?}
       */
          function () {
              if (!this.hasPreviousPage()) {
                  return;
              }
              /** @type {?} */
              var previousPageIndex = this.pageIndex;
              this.pageIndex--;
              this._emitPageEvent(previousPageIndex);
          };
      /** Move to the first page if not already there. */
      /**
       * Move to the first page if not already there.
       * @return {?}
       */
      MatPaginator.prototype.firstPage = /**
       * Move to the first page if not already there.
       * @return {?}
       */
          function () {
              // hasPreviousPage being false implies at the start
              if (!this.hasPreviousPage()) {
                  return;
              }
              /** @type {?} */
              var previousPageIndex = this.pageIndex;
              this.pageIndex = 0;
              this._emitPageEvent(previousPageIndex);
          };
      /** Move to the last page if not already there. */
      /**
       * Move to the last page if not already there.
       * @return {?}
       */
      MatPaginator.prototype.lastPage = /**
       * Move to the last page if not already there.
       * @return {?}
       */
          function () {
              // hasNextPage being false implies at the end
              if (!this.hasNextPage()) {
                  return;
              }
              /** @type {?} */
              var previousPageIndex = this.pageIndex;
              this.pageIndex = this.getNumberOfPages() - 1;
              this._emitPageEvent(previousPageIndex);
          };
      /** Whether there is a previous page. */
      /**
       * Whether there is a previous page.
       * @return {?}
       */
      MatPaginator.prototype.hasPreviousPage = /**
       * Whether there is a previous page.
       * @return {?}
       */
          function () {
              return this.pageIndex >= 1 && this.pageSize != 0;
          };
      /** Whether there is a next page. */
      /**
       * Whether there is a next page.
       * @return {?}
       */
      MatPaginator.prototype.hasNextPage = /**
       * Whether there is a next page.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var maxPageIndex = this.getNumberOfPages() - 1;
              return this.pageIndex < maxPageIndex && this.pageSize != 0;
          };
      /** Calculate the number of pages */
      /**
       * Calculate the number of pages
       * @return {?}
       */
      MatPaginator.prototype.getNumberOfPages = /**
       * Calculate the number of pages
       * @return {?}
       */
          function () {
              if (!this.pageSize) {
                  return 0;
              }
              return Math.ceil(this.length / this.pageSize);
          };
      /**
       * Changes the page size so that the first item displayed on the page will still be
       * displayed using the new page size.
       *
       * For example, if the page size is 10 and on the second page (items indexed 10-19) then
       * switching so that the page size is 5 will set the third page as the current page so
       * that the 10th item will still be displayed.
       */
      /**
       * Changes the page size so that the first item displayed on the page will still be
       * displayed using the new page size.
       *
       * For example, if the page size is 10 and on the second page (items indexed 10-19) then
       * switching so that the page size is 5 will set the third page as the current page so
       * that the 10th item will still be displayed.
       * @param {?} pageSize
       * @return {?}
       */
      MatPaginator.prototype._changePageSize = /**
       * Changes the page size so that the first item displayed on the page will still be
       * displayed using the new page size.
       *
       * For example, if the page size is 10 and on the second page (items indexed 10-19) then
       * switching so that the page size is 5 will set the third page as the current page so
       * that the 10th item will still be displayed.
       * @param {?} pageSize
       * @return {?}
       */
          function (pageSize) {
              // Current page needs to be updated to reflect the new page size. Navigate to the page
              // containing the previous page's first item.
              /** @type {?} */
              var startIndex = this.pageIndex * this.pageSize;
              /** @type {?} */
              var previousPageIndex = this.pageIndex;
              this.pageIndex = Math.floor(startIndex / pageSize) || 0;
              this.pageSize = pageSize;
              this._emitPageEvent(previousPageIndex);
          };
      /** Checks whether the buttons for going forwards should be disabled. */
      /**
       * Checks whether the buttons for going forwards should be disabled.
       * @return {?}
       */
      MatPaginator.prototype._nextButtonsDisabled = /**
       * Checks whether the buttons for going forwards should be disabled.
       * @return {?}
       */
          function () {
              return this.disabled || !this.hasNextPage();
          };
      /** Checks whether the buttons for going backwards should be disabled. */
      /**
       * Checks whether the buttons for going backwards should be disabled.
       * @return {?}
       */
      MatPaginator.prototype._previousButtonsDisabled = /**
       * Checks whether the buttons for going backwards should be disabled.
       * @return {?}
       */
          function () {
              return this.disabled || !this.hasPreviousPage();
          };
      /**
       * Updates the list of page size options to display to the user. Includes making sure that
       * the page size is an option and that the list is sorted.
       */
      /**
       * Updates the list of page size options to display to the user. Includes making sure that
       * the page size is an option and that the list is sorted.
       * @private
       * @return {?}
       */
      MatPaginator.prototype._updateDisplayedPageSizeOptions = /**
       * Updates the list of page size options to display to the user. Includes making sure that
       * the page size is an option and that the list is sorted.
       * @private
       * @return {?}
       */
          function () {
              if (!this._initialized) {
                  return;
              }
              // If no page size is provided, use the first page size option or the default page size.
              if (!this.pageSize) {
                  this._pageSize = this.pageSizeOptions.length != 0 ?
                      this.pageSizeOptions[0] :
                      DEFAULT_PAGE_SIZE;
              }
              this._displayedPageSizeOptions = this.pageSizeOptions.slice();
              if (this._displayedPageSizeOptions.indexOf(this.pageSize) === -1) {
                  this._displayedPageSizeOptions.push(this.pageSize);
              }
              // Sort the numbers using a number-specific sort function.
              this._displayedPageSizeOptions.sort(function (a, b) { return a - b; });
              this._changeDetectorRef.markForCheck();
          };
      /** Emits an event notifying that a change of the paginator's properties has been triggered. */
      /**
       * Emits an event notifying that a change of the paginator's properties has been triggered.
       * @private
       * @param {?} previousPageIndex
       * @return {?}
       */
      MatPaginator.prototype._emitPageEvent = /**
       * Emits an event notifying that a change of the paginator's properties has been triggered.
       * @private
       * @param {?} previousPageIndex
       * @return {?}
       */
          function (previousPageIndex) {
              this.page.emit({
                  previousPageIndex: previousPageIndex,
                  pageIndex: this.pageIndex,
                  pageSize: this.pageSize,
                  length: this.length
              });
          };
      MatPaginator.decorators = [
          { type: core.Component, args: [{ selector: 'mat-paginator',
                      exportAs: 'matPaginator',
                      template: "<div class=\"mat-paginator-outer-container\"><div class=\"mat-paginator-container\"><div class=\"mat-paginator-page-size\" *ngIf=\"!hidePageSize\"><div class=\"mat-paginator-page-size-label\">{{_intl.itemsPerPageLabel}}</div><mat-form-field *ngIf=\"_displayedPageSizeOptions.length > 1\" [color]=\"color\" class=\"mat-paginator-page-size-select\"><mat-select [value]=\"pageSize\" [disabled]=\"disabled\" [aria-label]=\"_intl.itemsPerPageLabel\" (selectionChange)=\"_changePageSize($event.value)\"><mat-option *ngFor=\"let pageSizeOption of _displayedPageSizeOptions\" [value]=\"pageSizeOption\">{{pageSizeOption}}</mat-option></mat-select></mat-form-field><div *ngIf=\"_displayedPageSizeOptions.length <= 1\">{{pageSize}}</div></div><div class=\"mat-paginator-range-actions\"><div class=\"mat-paginator-range-label\">{{_intl.getRangeLabel(pageIndex, pageSize, length)}}</div><button mat-icon-button type=\"button\" class=\"mat-paginator-navigation-first\" (click)=\"firstPage()\" [attr.aria-label]=\"_intl.firstPageLabel\" [matTooltip]=\"_intl.firstPageLabel\" [matTooltipDisabled]=\"_previousButtonsDisabled()\" [matTooltipPosition]=\"'above'\" [disabled]=\"_previousButtonsDisabled()\" *ngIf=\"showFirstLastButtons\"><svg class=\"mat-paginator-icon\" viewBox=\"0 0 24 24\" focusable=\"false\"><path d=\"M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z\"/></svg></button> <button mat-icon-button type=\"button\" class=\"mat-paginator-navigation-previous\" (click)=\"previousPage()\" [attr.aria-label]=\"_intl.previousPageLabel\" [matTooltip]=\"_intl.previousPageLabel\" [matTooltipDisabled]=\"_previousButtonsDisabled()\" [matTooltipPosition]=\"'above'\" [disabled]=\"_previousButtonsDisabled()\"><svg class=\"mat-paginator-icon\" viewBox=\"0 0 24 24\" focusable=\"false\"><path d=\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\"/></svg></button> <button mat-icon-button type=\"button\" class=\"mat-paginator-navigation-next\" (click)=\"nextPage()\" [attr.aria-label]=\"_intl.nextPageLabel\" [matTooltip]=\"_intl.nextPageLabel\" [matTooltipDisabled]=\"_nextButtonsDisabled()\" [matTooltipPosition]=\"'above'\" [disabled]=\"_nextButtonsDisabled()\"><svg class=\"mat-paginator-icon\" viewBox=\"0 0 24 24\" focusable=\"false\"><path d=\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"/></svg></button> <button mat-icon-button type=\"button\" class=\"mat-paginator-navigation-last\" (click)=\"lastPage()\" [attr.aria-label]=\"_intl.lastPageLabel\" [matTooltip]=\"_intl.lastPageLabel\" [matTooltipDisabled]=\"_nextButtonsDisabled()\" [matTooltipPosition]=\"'above'\" [disabled]=\"_nextButtonsDisabled()\" *ngIf=\"showFirstLastButtons\"><svg class=\"mat-paginator-icon\" viewBox=\"0 0 24 24\" focusable=\"false\"><path d=\"M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z\"/></svg></button></div></div></div>",
                      styles: [".mat-paginator{display:block}.mat-paginator-outer-container{display:flex}.mat-paginator-container{display:flex;align-items:center;justify-content:flex-end;min-height:56px;padding:0 8px;flex-wrap:wrap-reverse;width:100%}.mat-paginator-page-size{display:flex;align-items:baseline;margin-right:8px}[dir=rtl] .mat-paginator-page-size{margin-right:0;margin-left:8px}.mat-paginator-page-size-label{margin:0 4px}.mat-paginator-page-size-select{margin:6px 4px 0 4px;width:56px}.mat-paginator-page-size-select.mat-form-field-appearance-outline{width:64px}.mat-paginator-page-size-select.mat-form-field-appearance-fill{width:64px}.mat-paginator-range-label{margin:0 32px 0 24px}.mat-paginator-range-actions{display:flex;align-items:center}.mat-paginator-icon{width:28px;fill:currentColor}[dir=rtl] .mat-paginator-icon{transform:rotate(180deg)}"],
                      inputs: ['disabled'],
                      host: {
                          'class': 'mat-paginator',
                      },
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                  },] },
      ];
      /** @nocollapse */
      MatPaginator.ctorParameters = function () {
          return [
              { type: MatPaginatorIntl },
              { type: core.ChangeDetectorRef }
          ];
      };
      MatPaginator.propDecorators = {
          color: [{ type: core.Input }],
          pageIndex: [{ type: core.Input }],
          length: [{ type: core.Input }],
          pageSize: [{ type: core.Input }],
          pageSizeOptions: [{ type: core.Input }],
          hidePageSize: [{ type: core.Input }],
          showFirstLastButtons: [{ type: core.Input }],
          page: [{ type: core.Output }]
      };
      return MatPaginator;
  }(_MatPaginatorBase));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // TODO(josephperrott): Benchpress tests.
  // TODO(josephperrott): Add ARIA attributes for progress bar "for".
  // Boilerplate for applying mixins to MatProgressBar.
  /**
   * \@docs-private
   */
  var 
  // TODO(josephperrott): Benchpress tests.
  // TODO(josephperrott): Add ARIA attributes for progress bar "for".
  // Boilerplate for applying mixins to MatProgressBar.
  /**
   * \@docs-private
   */
  MatProgressBarBase = /** @class */ (function () {
      function MatProgressBarBase(_elementRef) {
          this._elementRef = _elementRef;
      }
      return MatProgressBarBase;
  }());
  /** @type {?} */
  var _MatProgressBarMixinBase = mixinColor(MatProgressBarBase, 'primary');
  /**
   * Injection token used to provide the current location to `MatProgressBar`.
   * Used to handle server-side rendering and to stub out during unit tests.
   * \@docs-private
   * @type {?}
   */
  var MAT_PROGRESS_BAR_LOCATION = new core.InjectionToken('mat-progress-bar-location', { providedIn: 'root', factory: MAT_PROGRESS_BAR_LOCATION_FACTORY });
  /**
   * \@docs-private
   * @return {?}
   */
  function MAT_PROGRESS_BAR_LOCATION_FACTORY() {
      /** @type {?} */
      var _document = core.inject(common.DOCUMENT);
      /** @type {?} */
      var _location = _document ? _document.location : null;
      return {
          // Note that this needs to be a function, rather than a property, because Angular
          // will only resolve it once, but we want the current path on each call.
          getPathname: function () { return _location ? (_location.pathname + _location.search) : ''; }
      };
  }
  /**
   * Counter used to generate unique IDs for progress bars.
   * @type {?}
   */
  var progressbarId = 0;
  /**
   * `<mat-progress-bar>` component.
   */
  var MatProgressBar = /** @class */ (function (_super) {
      tslib_1.__extends(MatProgressBar, _super);
      function MatProgressBar(_elementRef, _ngZone, _animationMode, 
      /**
       * @deprecated `location` parameter to be made required.
       * @breaking-change 8.0.0
       */
      location) {
          var _this = _super.call(this, _elementRef) || this;
          _this._elementRef = _elementRef;
          _this._ngZone = _ngZone;
          _this._animationMode = _animationMode;
          /**
           * Flag that indicates whether NoopAnimations mode is set to true.
           */
          _this._isNoopAnimation = false;
          _this._value = 0;
          _this._bufferValue = 0;
          /**
           * Event emitted when animation of the primary progress bar completes. This event will not
           * be emitted when animations are disabled, nor will it be emitted for modes with continuous
           * animations (indeterminate and query).
           */
          _this.animationEnd = new core.EventEmitter();
          /**
           * Reference to animation end subscription to be unsubscribed on destroy.
           */
          _this._animationEndSubscription = rxjs.Subscription.EMPTY;
          /**
           * Mode of the progress bar.
           *
           * Input must be one of these values: determinate, indeterminate, buffer, query, defaults to
           * 'determinate'.
           * Mirrored to mode attribute.
           */
          _this.mode = 'determinate';
          /**
           * ID of the progress bar.
           */
          _this.progressbarId = "mat-progress-bar-" + progressbarId++;
          // We need to prefix the SVG reference with the current path, otherwise they won't work
          // in Safari if the page has a `<base>` tag. Note that we need quotes inside the `url()`,
          // because named route URLs can contain parentheses (see #12338). Also we don't use since
          // we can't tell the difference between whether
          // the consumer is using the hash location strategy or not, because `Location` normalizes
          // both `/#/foo/bar` and `/foo/bar` to the same thing.
          /** @type {?} */
          var path = location ? location.getPathname().split('#')[0] : '';
          _this._rectangleFillValue = "url('" + path + "#" + _this.progressbarId + "')";
          _this._isNoopAnimation = _animationMode === 'NoopAnimations';
          return _this;
      }
      Object.defineProperty(MatProgressBar.prototype, "value", {
          /** Value of the progress bar. Defaults to zero. Mirrored to aria-valuenow. */
          get: /**
           * Value of the progress bar. Defaults to zero. Mirrored to aria-valuenow.
           * @return {?}
           */ function () { return this._value; },
          set: /**
           * @param {?} v
           * @return {?}
           */ function (v) {
              this._value = clamp(v || 0);
              // When noop animation is set to true, trigger animationEnd directly.
              if (this._isNoopAnimation) {
                  this.emitAnimationEnd();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatProgressBar.prototype, "bufferValue", {
          /** Buffer value of the progress bar. Defaults to zero. */
          get: /**
           * Buffer value of the progress bar. Defaults to zero.
           * @return {?}
           */ function () { return this._bufferValue; },
          set: /**
           * @param {?} v
           * @return {?}
           */ function (v) { this._bufferValue = clamp(v || 0); },
          enumerable: true,
          configurable: true
      });
      /** Gets the current transform value for the progress bar's primary indicator. */
      /**
       * Gets the current transform value for the progress bar's primary indicator.
       * @return {?}
       */
      MatProgressBar.prototype._primaryTransform = /**
       * Gets the current transform value for the progress bar's primary indicator.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var scale = this.value / 100;
              return { transform: "scaleX(" + scale + ")" };
          };
      /**
       * Gets the current transform value for the progress bar's buffer indicator. Only used if the
       * progress mode is set to buffer, otherwise returns an undefined, causing no transformation.
       */
      /**
       * Gets the current transform value for the progress bar's buffer indicator. Only used if the
       * progress mode is set to buffer, otherwise returns an undefined, causing no transformation.
       * @return {?}
       */
      MatProgressBar.prototype._bufferTransform = /**
       * Gets the current transform value for the progress bar's buffer indicator. Only used if the
       * progress mode is set to buffer, otherwise returns an undefined, causing no transformation.
       * @return {?}
       */
          function () {
              if (this.mode === 'buffer') {
                  /** @type {?} */
                  var scale = this.bufferValue / 100;
                  return { transform: "scaleX(" + scale + ")" };
              }
          };
      /**
       * @return {?}
       */
      MatProgressBar.prototype.ngAfterViewInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this._isNoopAnimation) {
                  // Run outside angular so change detection didn't get triggered on every transition end
                  // instead only on the animation that we care about (primary value bar's transitionend)
                  this._ngZone.runOutsideAngular((function () {
                      _this._animationEndSubscription =
                          rxjs.fromEvent(_this._primaryValueBar.nativeElement, 'transitionend')
                              .pipe(operators.filter((function (e) {
                              return e.target === _this._primaryValueBar.nativeElement;
                          })))
                              .subscribe(function (_) { return _this._ngZone.run(function () { return _this.emitAnimationEnd(); }); });
                  }));
              }
          };
      /**
       * @return {?}
       */
      MatProgressBar.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._animationEndSubscription.unsubscribe();
          };
      /** Emit an animationEnd event if in determinate or buffer mode. */
      /**
       * Emit an animationEnd event if in determinate or buffer mode.
       * @private
       * @return {?}
       */
      MatProgressBar.prototype.emitAnimationEnd = /**
       * Emit an animationEnd event if in determinate or buffer mode.
       * @private
       * @return {?}
       */
          function () {
              if (this.mode === 'determinate' || this.mode === 'buffer') {
                  this.animationEnd.next({ value: this.value });
              }
          };
      MatProgressBar.decorators = [
          { type: core.Component, args: [{ selector: 'mat-progress-bar',
                      exportAs: 'matProgressBar',
                      host: {
                          'role': 'progressbar',
                          'aria-valuemin': '0',
                          'aria-valuemax': '100',
                          '[attr.aria-valuenow]': 'value',
                          '[attr.mode]': 'mode',
                          'class': 'mat-progress-bar',
                          '[class._mat-animation-noopable]': "_isNoopAnimation",
                      },
                      inputs: ['color'],
                      template: "<svg width=\"100%\" height=\"4\" focusable=\"false\" class=\"mat-progress-bar-background mat-progress-bar-element\"><defs><pattern [id]=\"progressbarId\" x=\"4\" y=\"0\" width=\"8\" height=\"4\" patternUnits=\"userSpaceOnUse\"><circle cx=\"2\" cy=\"2\" r=\"2\"/></pattern></defs><rect [attr.fill]=\"_rectangleFillValue\" width=\"100%\" height=\"100%\"/></svg><div class=\"mat-progress-bar-buffer mat-progress-bar-element\" [ngStyle]=\"_bufferTransform()\"></div><div class=\"mat-progress-bar-primary mat-progress-bar-fill mat-progress-bar-element\" [ngStyle]=\"_primaryTransform()\" #primaryValueBar></div><div class=\"mat-progress-bar-secondary mat-progress-bar-fill mat-progress-bar-element\"></div>",
                      styles: [".mat-progress-bar{display:block;height:4px;overflow:hidden;position:relative;transition:opacity 250ms linear;width:100%}._mat-animation-noopable.mat-progress-bar{transition:none;animation:none}.mat-progress-bar .mat-progress-bar-element,.mat-progress-bar .mat-progress-bar-fill::after{height:100%;position:absolute;width:100%}.mat-progress-bar .mat-progress-bar-background{width:calc(100% + 10px)}@media (-ms-high-contrast:active){.mat-progress-bar .mat-progress-bar-background{display:none}}.mat-progress-bar .mat-progress-bar-buffer{transform-origin:top left;transition:transform 250ms ease}@media (-ms-high-contrast:active){.mat-progress-bar .mat-progress-bar-buffer{border-top:solid 5px;opacity:.5}}.mat-progress-bar .mat-progress-bar-secondary{display:none}.mat-progress-bar .mat-progress-bar-fill{animation:none;transform-origin:top left;transition:transform 250ms ease}@media (-ms-high-contrast:active){.mat-progress-bar .mat-progress-bar-fill{border-top:solid 4px}}.mat-progress-bar .mat-progress-bar-fill::after{animation:none;content:'';display:inline-block;left:0}.mat-progress-bar[dir=rtl],[dir=rtl] .mat-progress-bar{transform:rotateY(180deg)}.mat-progress-bar[mode=query]{transform:rotateZ(180deg)}.mat-progress-bar[mode=query][dir=rtl],[dir=rtl] .mat-progress-bar[mode=query]{transform:rotateZ(180deg) rotateY(180deg)}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-fill,.mat-progress-bar[mode=query] .mat-progress-bar-fill{transition:none}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary,.mat-progress-bar[mode=query] .mat-progress-bar-primary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-translate 2s infinite linear;left:-145.166611%}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-primary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-primary-indeterminate-scale 2s infinite linear}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary,.mat-progress-bar[mode=query] .mat-progress-bar-secondary{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-translate 2s infinite linear;left:-54.888891%;display:block}.mat-progress-bar[mode=indeterminate] .mat-progress-bar-secondary.mat-progress-bar-fill::after,.mat-progress-bar[mode=query] .mat-progress-bar-secondary.mat-progress-bar-fill::after{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-secondary-indeterminate-scale 2s infinite linear}.mat-progress-bar[mode=buffer] .mat-progress-bar-background{-webkit-backface-visibility:hidden;backface-visibility:hidden;animation:mat-progress-bar-background-scroll 250ms infinite linear;display:block}.mat-progress-bar._mat-animation-noopable .mat-progress-bar-background,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-buffer,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-primary.mat-progress-bar-fill::after,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary,.mat-progress-bar._mat-animation-noopable .mat-progress-bar-secondary.mat-progress-bar-fill::after{animation:none;transition:none}@keyframes mat-progress-bar-primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(.5,0,.70173,.49582);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(.30244,.38135,.55,.95635);transform:translateX(83.67142%)}100%{transform:translateX(200.61106%)}}@keyframes mat-progress-bar-primary-indeterminate-scale{0%{transform:scaleX(.08)}36.65%{animation-timing-function:cubic-bezier(.33473,.12482,.78584,1);transform:scaleX(.08)}69.15%{animation-timing-function:cubic-bezier(.06,.11,.6,1);transform:scaleX(.66148)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:translateX(37.65191%)}48.35%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:translateX(84.38617%)}100%{transform:translateX(160.27778%)}}@keyframes mat-progress-bar-secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(.15,0,.51506,.40969);transform:scaleX(.08)}19.15%{animation-timing-function:cubic-bezier(.31033,.28406,.8,.73371);transform:scaleX(.4571)}44.15%{animation-timing-function:cubic-bezier(.4,.62704,.6,.90203);transform:scaleX(.72796)}100%{transform:scaleX(.08)}}@keyframes mat-progress-bar-background-scroll{to{transform:translateX(-8px)}}"],
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                  },] },
      ];
      /** @nocollapse */
      MatProgressBar.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.NgZone },
              { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_PROGRESS_BAR_LOCATION,] }] }
          ];
      };
      MatProgressBar.propDecorators = {
          value: [{ type: core.Input }],
          bufferValue: [{ type: core.Input }],
          _primaryValueBar: [{ type: core.ViewChild, args: ['primaryValueBar',] }],
          animationEnd: [{ type: core.Output }],
          mode: [{ type: core.Input }]
      };
      return MatProgressBar;
  }(_MatProgressBarMixinBase));
  /**
   * Clamps a value to be between two numbers, by default 0 and 100.
   * @param {?} v
   * @param {?=} min
   * @param {?=} max
   * @return {?}
   */
  function clamp(v, min, max) {
      if (min === void 0) {
          min = 0;
      }
      if (max === void 0) {
          max = 100;
      }
      return Math.max(min, Math.min(max, v));
  }

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Base reference size of the spinner.
   * \@docs-private
   * @type {?}
   */
  var BASE_SIZE = 100;
  /**
   * Base reference stroke width of the spinner.
   * \@docs-private
   * @type {?}
   */
  var BASE_STROKE_WIDTH = 10;
  // Boilerplate for applying mixins to MatProgressSpinner.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatProgressSpinner.
  /**
   * \@docs-private
   */
  MatProgressSpinnerBase = /** @class */ (function () {
      function MatProgressSpinnerBase(_elementRef) {
          this._elementRef = _elementRef;
      }
      return MatProgressSpinnerBase;
  }());
  /** @type {?} */
  var _MatProgressSpinnerMixinBase = mixinColor(MatProgressSpinnerBase, 'primary');
  /**
   * Injection token to be used to override the default options for `mat-progress-spinner`.
   * @type {?}
   */
  var MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS = new core.InjectionToken('mat-progress-spinner-default-options', {
      providedIn: 'root',
      factory: MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY,
  });
  /**
   * \@docs-private
   * @return {?}
   */
  function MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY() {
      return { diameter: BASE_SIZE };
  }
  // .0001 percentage difference is necessary in order to avoid unwanted animation frames
  // for example because the animation duration is 4 seconds, .1% accounts to 4ms
  // which are enough to see the flicker described in
  // https://github.com/angular/material2/issues/8984
  /** @type {?} */
  var INDETERMINATE_ANIMATION_TEMPLATE = "\n @keyframes mat-progress-spinner-stroke-rotate-DIAMETER {\n    0%      { stroke-dashoffset: START_VALUE;  transform: rotate(0); }\n    12.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(0); }\n    12.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(72.5deg); }\n    25%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(72.5deg); }\n\n    25.0001%   { stroke-dashoffset: START_VALUE;  transform: rotate(270deg); }\n    37.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(270deg); }\n    37.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(161.5deg); }\n    50%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(161.5deg); }\n\n    50.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(180deg); }\n    62.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(180deg); }\n    62.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(251.5deg); }\n    75%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(251.5deg); }\n\n    75.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(90deg); }\n    87.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(90deg); }\n    87.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(341.5deg); }\n    100%    { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(341.5deg); }\n  }\n";
  /**
   * `<mat-progress-spinner>` component.
   */
  var MatProgressSpinner = /** @class */ (function (_super) {
      tslib_1.__extends(MatProgressSpinner, _super);
      function MatProgressSpinner(_elementRef, platform, _document, animationMode, defaults) {
          var _this = _super.call(this, _elementRef) || this;
          _this._elementRef = _elementRef;
          _this._document = _document;
          _this.animationMode = animationMode;
          _this.defaults = defaults;
          _this._value = 0;
          _this._fallbackAnimation = false;
          /**
           * Whether the _mat-animation-noopable class should be applied, disabling animations.
           */
          _this._noopAnimations = _this.animationMode === 'NoopAnimations' && (!!_this.defaults && !_this.defaults._forceAnimations);
          _this._diameter = BASE_SIZE;
          /**
           * Mode of the progress circle
           */
          _this.mode = 'determinate';
          _this._fallbackAnimation = platform.EDGE || platform.TRIDENT;
          if (defaults) {
              if (defaults.diameter) {
                  _this.diameter = defaults.diameter;
              }
              if (defaults.strokeWidth) {
                  _this.strokeWidth = defaults.strokeWidth;
              }
          }
          // On IE and Edge, we can't animate the `stroke-dashoffset`
          // reliably so we fall back to a non-spec animation.
          /** @type {?} */
          var animationClass = "mat-progress-spinner-indeterminate" + (_this._fallbackAnimation ? '-fallback' : '') + "-animation";
          _elementRef.nativeElement.classList.add(animationClass);
          return _this;
      }
      Object.defineProperty(MatProgressSpinner.prototype, "diameter", {
          /** The diameter of the progress spinner (will set width and height of svg). */
          get: /**
           * The diameter of the progress spinner (will set width and height of svg).
           * @return {?}
           */ function () { return this._diameter; },
          set: /**
           * @param {?} size
           * @return {?}
           */ function (size) {
              this._diameter = coerceNumberProperty(size);
              if (!this._fallbackAnimation && !MatProgressSpinner.diameters.has(this._diameter)) {
                  this._attachStyleNode();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatProgressSpinner.prototype, "strokeWidth", {
          /** Stroke width of the progress spinner. */
          get: /**
           * Stroke width of the progress spinner.
           * @return {?}
           */ function () {
              return this._strokeWidth || this.diameter / 10;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._strokeWidth = coerceNumberProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatProgressSpinner.prototype, "value", {
          /** Value of the progress circle. */
          get: /**
           * Value of the progress circle.
           * @return {?}
           */ function () {
              return this.mode === 'determinate' ? this._value : 0;
          },
          set: /**
           * @param {?} newValue
           * @return {?}
           */ function (newValue) {
              this._value = Math.max(0, Math.min(100, coerceNumberProperty(newValue)));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatProgressSpinner.prototype, "_circleRadius", {
          /** The radius of the spinner, adjusted for stroke width. */
          get: /**
           * The radius of the spinner, adjusted for stroke width.
           * @return {?}
           */ function () {
              return (this.diameter - BASE_STROKE_WIDTH) / 2;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatProgressSpinner.prototype, "_viewBox", {
          /** The view box of the spinner's svg element. */
          get: /**
           * The view box of the spinner's svg element.
           * @return {?}
           */ function () {
              /** @type {?} */
              var viewBox = this._circleRadius * 2 + this.strokeWidth;
              return "0 0 " + viewBox + " " + viewBox;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatProgressSpinner.prototype, "_strokeCircumference", {
          /** The stroke circumference of the svg circle. */
          get: /**
           * The stroke circumference of the svg circle.
           * @return {?}
           */ function () {
              return 2 * Math.PI * this._circleRadius;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatProgressSpinner.prototype, "_strokeDashOffset", {
          /** The dash offset of the svg circle. */
          get: /**
           * The dash offset of the svg circle.
           * @return {?}
           */ function () {
              if (this.mode === 'determinate') {
                  return this._strokeCircumference * (100 - this._value) / 100;
              }
              // In fallback mode set the circle to 80% and rotate it with CSS.
              if (this._fallbackAnimation && this.mode === 'indeterminate') {
                  return this._strokeCircumference * 0.2;
              }
              return null;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatProgressSpinner.prototype, "_circleStrokeWidth", {
          /** Stroke width of the circle in percent. */
          get: /**
           * Stroke width of the circle in percent.
           * @return {?}
           */ function () {
              return this.strokeWidth / this.diameter * 100;
          },
          enumerable: true,
          configurable: true
      });
      /** Dynamically generates a style tag containing the correct animation for this diameter. */
      /**
       * Dynamically generates a style tag containing the correct animation for this diameter.
       * @private
       * @return {?}
       */
      MatProgressSpinner.prototype._attachStyleNode = /**
       * Dynamically generates a style tag containing the correct animation for this diameter.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var styleTag = MatProgressSpinner.styleTag;
              if (!styleTag) {
                  styleTag = this._document.createElement('style');
                  this._document.head.appendChild(styleTag);
                  MatProgressSpinner.styleTag = styleTag;
              }
              if (styleTag && styleTag.sheet) {
                  (( /** @type {?} */(styleTag.sheet))).insertRule(this._getAnimationText(), 0);
              }
              MatProgressSpinner.diameters.add(this.diameter);
          };
      /** Generates animation styles adjusted for the spinner's diameter. */
      /**
       * Generates animation styles adjusted for the spinner's diameter.
       * @private
       * @return {?}
       */
      MatProgressSpinner.prototype._getAnimationText = /**
       * Generates animation styles adjusted for the spinner's diameter.
       * @private
       * @return {?}
       */
          function () {
              return INDETERMINATE_ANIMATION_TEMPLATE
                  // Animation should begin at 5% and end at 80%
                  .replace(/START_VALUE/g, "" + 0.95 * this._strokeCircumference)
                  .replace(/END_VALUE/g, "" + 0.2 * this._strokeCircumference)
                  .replace(/DIAMETER/g, "" + this.diameter);
          };
      /**
       * Tracks diameters of existing instances to de-dupe generated styles (default d = 100)
       */
      MatProgressSpinner.diameters = new Set([BASE_SIZE]);
      /**
       * Used for storing all of the generated keyframe animations.
       * \@dynamic
       */
      MatProgressSpinner.styleTag = null;
      MatProgressSpinner.decorators = [
          { type: core.Component, args: [{ selector: 'mat-progress-spinner',
                      exportAs: 'matProgressSpinner',
                      host: {
                          'role': 'progressbar',
                          'class': 'mat-progress-spinner',
                          '[class._mat-animation-noopable]': "_noopAnimations",
                          '[style.width.px]': 'diameter',
                          '[style.height.px]': 'diameter',
                          '[attr.aria-valuemin]': 'mode === "determinate" ? 0 : null',
                          '[attr.aria-valuemax]': 'mode === "determinate" ? 100 : null',
                          '[attr.aria-valuenow]': 'value',
                          '[attr.mode]': 'mode',
                      },
                      inputs: ['color'],
                      template: "<svg [style.width.px]=\"diameter\" [style.height.px]=\"diameter\" [attr.viewBox]=\"_viewBox\" preserveAspectRatio=\"xMidYMid meet\" focusable=\"false\" [ngSwitch]=\"mode === 'indeterminate'\"><circle *ngSwitchCase=\"true\" cx=\"50%\" cy=\"50%\" [attr.r]=\"_circleRadius\" [style.animation-name]=\"'mat-progress-spinner-stroke-rotate-' + diameter\" [style.stroke-dashoffset.px]=\"_strokeDashOffset\" [style.stroke-dasharray.px]=\"_strokeCircumference\" [style.stroke-width.%]=\"_circleStrokeWidth\"></circle><circle *ngSwitchCase=\"false\" cx=\"50%\" cy=\"50%\" [attr.r]=\"_circleRadius\" [style.stroke-dashoffset.px]=\"_strokeDashOffset\" [style.stroke-dasharray.px]=\"_strokeCircumference\" [style.stroke-width.%]=\"_circleStrokeWidth\"></circle></svg>",
                      styles: [".mat-progress-spinner{display:block;position:relative}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{animation:mat-progress-spinner-linear-rotate 2s linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4s;animation-timing-function:cubic-bezier(.35,0,.25,1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{animation:mat-progress-spinner-stroke-rotate-fallback 10s cubic-bezier(.87,.03,.33,1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.60617px;transform:rotate(0)}12.5%{stroke-dashoffset:56.54867px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.54867px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.60617px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.60617px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.54867px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.54867px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.60617px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.60617px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.54867px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.54867px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.60617px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.60617px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.54867px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.54867px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.60617px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}"],
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                  },] },
      ];
      /** @nocollapse */
      MatProgressSpinner.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: Platform },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] },
              { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] },
              { type: undefined, decorators: [{ type: core.Inject, args: [MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS,] }] }
          ];
      };
      MatProgressSpinner.propDecorators = {
          diameter: [{ type: core.Input }],
          strokeWidth: [{ type: core.Input }],
          mode: [{ type: core.Input }],
          value: [{ type: core.Input }]
      };
      return MatProgressSpinner;
  }(_MatProgressSpinnerMixinBase));
  /**
   * `<mat-spinner>` component.
   *
   * This is a component definition to be used as a convenience reference to create an
   * indeterminate `<mat-progress-spinner>` instance.
   */
  var MatSpinner = /** @class */ (function (_super) {
      tslib_1.__extends(MatSpinner, _super);
      function MatSpinner(elementRef, platform, document, 
      // @breaking-change 8.0.0 animationMode and defaults parameters to be made required.
      animationMode, defaults) {
          var _this = _super.call(this, elementRef, platform, document, animationMode, defaults) || this;
          _this.mode = 'indeterminate';
          return _this;
      }
      MatSpinner.decorators = [
          { type: core.Component, args: [{ selector: 'mat-spinner',
                      host: {
                          'role': 'progressbar',
                          'mode': 'indeterminate',
                          'class': 'mat-spinner mat-progress-spinner',
                          '[class._mat-animation-noopable]': "_noopAnimations",
                          '[style.width.px]': 'diameter',
                          '[style.height.px]': 'diameter',
                      },
                      inputs: ['color'],
                      template: "<svg [style.width.px]=\"diameter\" [style.height.px]=\"diameter\" [attr.viewBox]=\"_viewBox\" preserveAspectRatio=\"xMidYMid meet\" focusable=\"false\" [ngSwitch]=\"mode === 'indeterminate'\"><circle *ngSwitchCase=\"true\" cx=\"50%\" cy=\"50%\" [attr.r]=\"_circleRadius\" [style.animation-name]=\"'mat-progress-spinner-stroke-rotate-' + diameter\" [style.stroke-dashoffset.px]=\"_strokeDashOffset\" [style.stroke-dasharray.px]=\"_strokeCircumference\" [style.stroke-width.%]=\"_circleStrokeWidth\"></circle><circle *ngSwitchCase=\"false\" cx=\"50%\" cy=\"50%\" [attr.r]=\"_circleRadius\" [style.stroke-dashoffset.px]=\"_strokeDashOffset\" [style.stroke-dasharray.px]=\"_strokeCircumference\" [style.stroke-width.%]=\"_circleStrokeWidth\"></circle></svg>",
                      styles: [".mat-progress-spinner{display:block;position:relative}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transform-origin:center;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{animation:mat-progress-spinner-linear-rotate 2s linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4s;animation-timing-function:cubic-bezier(.35,0,.25,1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{animation:mat-progress-spinner-stroke-rotate-fallback 10s cubic-bezier(.87,.03,.33,1) infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate]{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition-property:stroke}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-fallback-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.60617px;transform:rotate(0)}12.5%{stroke-dashoffset:56.54867px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.54867px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.60617px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.60617px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.54867px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.54867px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.60617px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.60617px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.54867px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.54867px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.60617px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.60617px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.54867px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.54867px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.60617px;transform:rotateX(180deg) rotate(341.5deg)}}@keyframes mat-progress-spinner-stroke-rotate-fallback{0%{transform:rotate(0)}25%{transform:rotate(1170deg)}50%{transform:rotate(2340deg)}75%{transform:rotate(3510deg)}100%{transform:rotate(4680deg)}}"],
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                  },] },
      ];
      /** @nocollapse */
      MatSpinner.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: Platform },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] },
              { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] },
              { type: undefined, decorators: [{ type: core.Inject, args: [MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS,] }] }
          ];
      };
      return MatSpinner;
  }(MatProgressSpinner));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Increasing integer for generating unique ids for radio components.
  /** @type {?} */
  var nextUniqueId$7 = 0;
  /**
   * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This
   * allows it to support [(ngModel)] and ngControl.
   * \@docs-private
   * @type {?}
   */
  var MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {
      provide: forms.NG_VALUE_ACCESSOR,
      useExisting: core.forwardRef(function () { return MatRadioGroup; }),
      multi: true
  };
  /**
   * Change event object emitted by MatRadio and MatRadioGroup.
   */
  var /**
   * Change event object emitted by MatRadio and MatRadioGroup.
   */ MatRadioChange = /** @class */ (function () {
      function MatRadioChange(source, value) {
          this.source = source;
          this.value = value;
      }
      return MatRadioChange;
  }());
  /**
   * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.
   */
  var MatRadioGroup = /** @class */ (function () {
      function MatRadioGroup(_changeDetector) {
          this._changeDetector = _changeDetector;
          /**
           * Selected value for the radio group.
           */
          this._value = null;
          /**
           * The HTML name attribute applied to radio buttons in this group.
           */
          this._name = "mat-radio-group-" + nextUniqueId$7++;
          /**
           * The currently selected radio button. Should match value.
           */
          this._selected = null;
          /**
           * Whether the `value` has been set to its initial value.
           */
          this._isInitialized = false;
          /**
           * Whether the labels should appear after or before the radio-buttons. Defaults to 'after'
           */
          this._labelPosition = 'after';
          /**
           * Whether the radio group is disabled.
           */
          this._disabled = false;
          /**
           * Whether the radio group is required.
           */
          this._required = false;
          /**
           * The method to be called in order to update ngModel
           */
          this._controlValueAccessorChangeFn = function () { };
          /**
           * onTouch function registered via registerOnTouch (ControlValueAccessor).
           * \@docs-private
           */
          this.onTouched = function () { };
          /**
           * Event emitted when the group value changes.
           * Change events are only emitted when the value changes due to user interaction with
           * a radio button (the same behavior as `<input type-"radio">`).
           */
          this.change = new core.EventEmitter();
      }
      Object.defineProperty(MatRadioGroup.prototype, "name", {
          /** Name of the radio button group. All radio buttons inside this group will use this name. */
          get: /**
           * Name of the radio button group. All radio buttons inside this group will use this name.
           * @return {?}
           */ function () { return this._name; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._name = value;
              this._updateRadioButtonNames();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatRadioGroup.prototype, "labelPosition", {
          /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */
          get: /**
           * Whether the labels should appear after or before the radio-buttons. Defaults to 'after'
           * @return {?}
           */ function () {
              return this._labelPosition;
          },
          set: /**
           * @param {?} v
           * @return {?}
           */ function (v) {
              this._labelPosition = v === 'before' ? 'before' : 'after';
              this._markRadiosForCheck();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatRadioGroup.prototype, "value", {
          /**
           * Value for the radio-group. Should equal the value of the selected radio button if there is
           * a corresponding radio button with a matching value. If there is not such a corresponding
           * radio button, this value persists to be applied in case a new radio button is added with a
           * matching value.
           */
          get: /**
           * Value for the radio-group. Should equal the value of the selected radio button if there is
           * a corresponding radio button with a matching value. If there is not such a corresponding
           * radio button, this value persists to be applied in case a new radio button is added with a
           * matching value.
           * @return {?}
           */ function () { return this._value; },
          set: /**
           * @param {?} newValue
           * @return {?}
           */ function (newValue) {
              if (this._value !== newValue) {
                  // Set this before proceeding to ensure no circular loop occurs with selection.
                  this._value = newValue;
                  this._updateSelectedRadioFromValue();
                  this._checkSelectedRadioButton();
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatRadioGroup.prototype._checkSelectedRadioButton = /**
       * @return {?}
       */
          function () {
              if (this._selected && !this._selected.checked) {
                  this._selected.checked = true;
              }
          };
      Object.defineProperty(MatRadioGroup.prototype, "selected", {
          /**
           * The currently selected radio button. If set to a new radio button, the radio group value
           * will be updated to match the new selected button.
           */
          get: /**
           * The currently selected radio button. If set to a new radio button, the radio group value
           * will be updated to match the new selected button.
           * @return {?}
           */ function () { return this._selected; },
          set: /**
           * @param {?} selected
           * @return {?}
           */ function (selected) {
              this._selected = selected;
              this.value = selected ? selected.value : null;
              this._checkSelectedRadioButton();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatRadioGroup.prototype, "disabled", {
          /** Whether the radio group is disabled */
          get: /**
           * Whether the radio group is disabled
           * @return {?}
           */ function () { return this._disabled; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._disabled = coerceBooleanProperty(value);
              this._markRadiosForCheck();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatRadioGroup.prototype, "required", {
          /** Whether the radio group is required */
          get: /**
           * Whether the radio group is required
           * @return {?}
           */ function () { return this._required; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._required = coerceBooleanProperty(value);
              this._markRadiosForCheck();
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Initialize properties once content children are available.
       * This allows us to propagate relevant attributes to associated buttons.
       */
      /**
       * Initialize properties once content children are available.
       * This allows us to propagate relevant attributes to associated buttons.
       * @return {?}
       */
      MatRadioGroup.prototype.ngAfterContentInit = /**
       * Initialize properties once content children are available.
       * This allows us to propagate relevant attributes to associated buttons.
       * @return {?}
       */
          function () {
              // Mark this component as initialized in AfterContentInit because the initial value can
              // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the
              // NgModel occurs *after* the OnInit of the MatRadioGroup.
              this._isInitialized = true;
          };
      /**
       * Mark this group as being "touched" (for ngModel). Meant to be called by the contained
       * radio buttons upon their blur.
       */
      /**
       * Mark this group as being "touched" (for ngModel). Meant to be called by the contained
       * radio buttons upon their blur.
       * @return {?}
       */
      MatRadioGroup.prototype._touch = /**
       * Mark this group as being "touched" (for ngModel). Meant to be called by the contained
       * radio buttons upon their blur.
       * @return {?}
       */
          function () {
              if (this.onTouched) {
                  this.onTouched();
              }
          };
      /**
       * @private
       * @return {?}
       */
      MatRadioGroup.prototype._updateRadioButtonNames = /**
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._radios) {
                  this._radios.forEach(function (radio) {
                      radio.name = _this.name;
                      radio._markForCheck();
                  });
              }
          };
      /** Updates the `selected` radio button from the internal _value state. */
      /**
       * Updates the `selected` radio button from the internal _value state.
       * @private
       * @return {?}
       */
      MatRadioGroup.prototype._updateSelectedRadioFromValue = /**
       * Updates the `selected` radio button from the internal _value state.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              // If the value already matches the selected radio, do nothing.
              /** @type {?} */
              var isAlreadySelected = this._selected !== null && this._selected.value === this._value;
              if (this._radios && !isAlreadySelected) {
                  this._selected = null;
                  this._radios.forEach(function (radio) {
                      radio.checked = _this.value === radio.value;
                      if (radio.checked) {
                          _this._selected = radio;
                      }
                  });
              }
          };
      /** Dispatch change event with current selection and group value. */
      /**
       * Dispatch change event with current selection and group value.
       * @return {?}
       */
      MatRadioGroup.prototype._emitChangeEvent = /**
       * Dispatch change event with current selection and group value.
       * @return {?}
       */
          function () {
              if (this._isInitialized) {
                  this.change.emit(new MatRadioChange(( /** @type {?} */(this._selected)), this._value));
              }
          };
      /**
       * @return {?}
       */
      MatRadioGroup.prototype._markRadiosForCheck = /**
       * @return {?}
       */
          function () {
              if (this._radios) {
                  this._radios.forEach(function (radio) { return radio._markForCheck(); });
              }
          };
      /**
       * Sets the model value. Implemented as part of ControlValueAccessor.
       * @param value
       */
      /**
       * Sets the model value. Implemented as part of ControlValueAccessor.
       * @param {?} value
       * @return {?}
       */
      MatRadioGroup.prototype.writeValue = /**
       * Sets the model value. Implemented as part of ControlValueAccessor.
       * @param {?} value
       * @return {?}
       */
          function (value) {
              this.value = value;
              this._changeDetector.markForCheck();
          };
      /**
       * Registers a callback to be triggered when the model value changes.
       * Implemented as part of ControlValueAccessor.
       * @param fn Callback to be registered.
       */
      /**
       * Registers a callback to be triggered when the model value changes.
       * Implemented as part of ControlValueAccessor.
       * @param {?} fn Callback to be registered.
       * @return {?}
       */
      MatRadioGroup.prototype.registerOnChange = /**
       * Registers a callback to be triggered when the model value changes.
       * Implemented as part of ControlValueAccessor.
       * @param {?} fn Callback to be registered.
       * @return {?}
       */
          function (fn) {
              this._controlValueAccessorChangeFn = fn;
          };
      /**
       * Registers a callback to be triggered when the control is touched.
       * Implemented as part of ControlValueAccessor.
       * @param fn Callback to be registered.
       */
      /**
       * Registers a callback to be triggered when the control is touched.
       * Implemented as part of ControlValueAccessor.
       * @param {?} fn Callback to be registered.
       * @return {?}
       */
      MatRadioGroup.prototype.registerOnTouched = /**
       * Registers a callback to be triggered when the control is touched.
       * Implemented as part of ControlValueAccessor.
       * @param {?} fn Callback to be registered.
       * @return {?}
       */
          function (fn) {
              this.onTouched = fn;
          };
      /**
       * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.
       * @param isDisabled Whether the control should be disabled.
       */
      /**
       * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.
       * @param {?} isDisabled Whether the control should be disabled.
       * @return {?}
       */
      MatRadioGroup.prototype.setDisabledState = /**
       * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.
       * @param {?} isDisabled Whether the control should be disabled.
       * @return {?}
       */
          function (isDisabled) {
              this.disabled = isDisabled;
              this._changeDetector.markForCheck();
          };
      MatRadioGroup.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-radio-group',
                      exportAs: 'matRadioGroup',
                      providers: [MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR],
                      host: {
                          'role': 'radiogroup',
                          'class': 'mat-radio-group',
                      },
                  },] },
      ];
      /** @nocollapse */
      MatRadioGroup.ctorParameters = function () {
          return [
              { type: core.ChangeDetectorRef }
          ];
      };
      MatRadioGroup.propDecorators = {
          change: [{ type: core.Output }],
          _radios: [{ type: core.ContentChildren, args: [core.forwardRef(function () { return MatRadioButton; }), { descendants: true },] }],
          name: [{ type: core.Input }],
          labelPosition: [{ type: core.Input }],
          value: [{ type: core.Input }],
          selected: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          required: [{ type: core.Input }]
      };
      return MatRadioGroup;
  }());
  // Boilerplate for applying mixins to MatRadioButton.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatRadioButton.
  /**
   * \@docs-private
   */
  MatRadioButtonBase = /** @class */ (function () {
      function MatRadioButtonBase(_elementRef) {
          this._elementRef = _elementRef;
      }
      return MatRadioButtonBase;
  }());
  // As per Material design specifications the selection control radio should use the accent color
  // palette by default. https://material.io/guidelines/components/selection-controls.html
  /** @type {?} */
  var _MatRadioButtonMixinBase = mixinColor(mixinDisableRipple(mixinTabIndex(MatRadioButtonBase)), 'accent');
  /**
   * A Material design radio-button. Typically placed inside of `<mat-radio-group>` elements.
   */
  var MatRadioButton = /** @class */ (function (_super) {
      tslib_1.__extends(MatRadioButton, _super);
      function MatRadioButton(radioGroup, elementRef, _changeDetector, _focusMonitor, _radioDispatcher, _animationMode) {
          var _this = _super.call(this, elementRef) || this;
          _this._changeDetector = _changeDetector;
          _this._focusMonitor = _focusMonitor;
          _this._radioDispatcher = _radioDispatcher;
          _this._animationMode = _animationMode;
          _this._uniqueId = "mat-radio-" + ++nextUniqueId$7;
          /**
           * The unique ID for the radio button.
           */
          _this.id = _this._uniqueId;
          /**
           * Event emitted when the checked state of this radio button changes.
           * Change events are only emitted when the value changes due to user interaction with
           * the radio button (the same behavior as `<input type-"radio">`).
           */
          _this.change = new core.EventEmitter();
          /**
           * Whether this radio is checked.
           */
          _this._checked = false;
          /**
           * Value assigned to this radio.
           */
          _this._value = null;
          /**
           * Unregister function for _radioDispatcher
           */
          _this._removeUniqueSelectionListener = function () { };
          // Assertions. Ideally these should be stripped out by the compiler.
          // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.
          _this.radioGroup = radioGroup;
          _this._removeUniqueSelectionListener =
              _radioDispatcher.listen(function (id, name) {
                  if (id !== _this.id && name === _this.name) {
                      _this.checked = false;
                  }
              });
          return _this;
      }
      Object.defineProperty(MatRadioButton.prototype, "checked", {
          /** Whether this radio button is checked. */
          get: /**
           * Whether this radio button is checked.
           * @return {?}
           */ function () { return this._checked; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var newCheckedState = coerceBooleanProperty(value);
              if (this._checked !== newCheckedState) {
                  this._checked = newCheckedState;
                  if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {
                      this.radioGroup.selected = this;
                  }
                  else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {
                      // When unchecking the selected radio button, update the selected radio
                      // property on the group.
                      this.radioGroup.selected = null;
                  }
                  if (newCheckedState) {
                      // Notify all radio buttons with the same name to un-check.
                      this._radioDispatcher.notify(this.id, this.name);
                  }
                  this._changeDetector.markForCheck();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatRadioButton.prototype, "value", {
          /** The value of this radio button. */
          get: /**
           * The value of this radio button.
           * @return {?}
           */ function () { return this._value; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (this._value !== value) {
                  this._value = value;
                  if (this.radioGroup !== null) {
                      if (!this.checked) {
                          // Update checked when the value changed to match the radio group's value
                          this.checked = this.radioGroup.value === value;
                      }
                      if (this.checked) {
                          this.radioGroup.selected = this;
                      }
                  }
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatRadioButton.prototype, "labelPosition", {
          /** Whether the label should appear after or before the radio button. Defaults to 'after' */
          get: /**
           * Whether the label should appear after or before the radio button. Defaults to 'after'
           * @return {?}
           */ function () {
              return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._labelPosition = value;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatRadioButton.prototype, "disabled", {
          /** Whether the radio button is disabled. */
          get: /**
           * Whether the radio button is disabled.
           * @return {?}
           */ function () {
              return this._disabled || (this.radioGroup !== null && this.radioGroup.disabled);
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var newDisabledState = coerceBooleanProperty(value);
              if (this._disabled !== newDisabledState) {
                  this._disabled = newDisabledState;
                  this._changeDetector.markForCheck();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatRadioButton.prototype, "required", {
          /** Whether the radio button is required. */
          get: /**
           * Whether the radio button is required.
           * @return {?}
           */ function () {
              return this._required || (this.radioGroup && this.radioGroup.required);
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._required = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatRadioButton.prototype, "inputId", {
          /** ID of the native input element inside `<mat-radio-button>` */
          get: /**
           * ID of the native input element inside `<mat-radio-button>`
           * @return {?}
           */ function () { return (this.id || this._uniqueId) + "-input"; },
          enumerable: true,
          configurable: true
      });
      /** Focuses the radio button. */
      /**
       * Focuses the radio button.
       * @return {?}
       */
      MatRadioButton.prototype.focus = /**
       * Focuses the radio button.
       * @return {?}
       */
          function () {
              this._focusMonitor.focusVia(this._inputElement, 'keyboard');
          };
      /**
       * Marks the radio button as needing checking for change detection.
       * This method is exposed because the parent radio group will directly
       * update bound properties of the radio button.
       */
      /**
       * Marks the radio button as needing checking for change detection.
       * This method is exposed because the parent radio group will directly
       * update bound properties of the radio button.
       * @return {?}
       */
      MatRadioButton.prototype._markForCheck = /**
       * Marks the radio button as needing checking for change detection.
       * This method is exposed because the parent radio group will directly
       * update bound properties of the radio button.
       * @return {?}
       */
          function () {
              // When group value changes, the button will not be notified. Use `markForCheck` to explicit
              // update radio button's status
              this._changeDetector.markForCheck();
          };
      /**
       * @return {?}
       */
      MatRadioButton.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              if (this.radioGroup) {
                  // If the radio is inside a radio group, determine if it should be checked
                  this.checked = this.radioGroup.value === this._value;
                  // Copy name from parent radio group
                  this.name = this.radioGroup.name;
              }
          };
      /**
       * @return {?}
       */
      MatRadioButton.prototype.ngAfterViewInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._focusMonitor
                  .monitor(this._elementRef, true)
                  .subscribe(function (focusOrigin) {
                  if (!focusOrigin && _this.radioGroup) {
                      _this.radioGroup._touch();
                  }
              });
          };
      /**
       * @return {?}
       */
      MatRadioButton.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._focusMonitor.stopMonitoring(this._elementRef);
              this._removeUniqueSelectionListener();
          };
      /** Dispatch change event with current value. */
      /**
       * Dispatch change event with current value.
       * @private
       * @return {?}
       */
      MatRadioButton.prototype._emitChangeEvent = /**
       * Dispatch change event with current value.
       * @private
       * @return {?}
       */
          function () {
              this.change.emit(new MatRadioChange(this, this._value));
          };
      /**
       * @return {?}
       */
      MatRadioButton.prototype._isRippleDisabled = /**
       * @return {?}
       */
          function () {
              return this.disableRipple || this.disabled;
          };
      /**
       * @param {?} event
       * @return {?}
       */
      MatRadioButton.prototype._onInputClick = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              // We have to stop propagation for click events on the visual hidden input element.
              // By default, when a user clicks on a label element, a generated click event will be
              // dispatched on the associated input element. Since we are using a label element as our
              // root container, the click event on the `radio-button` will be executed twice.
              // The real click event will bubble up, and the generated click event also tries to bubble up.
              // This will lead to multiple click events.
              // Preventing bubbling for the second event will solve that issue.
              event.stopPropagation();
          };
      /**
       * Triggered when the radio button received a click or the input recognized any change.
       * Clicking on a label element, will trigger a change event on the associated input.
       */
      /**
       * Triggered when the radio button received a click or the input recognized any change.
       * Clicking on a label element, will trigger a change event on the associated input.
       * @param {?} event
       * @return {?}
       */
      MatRadioButton.prototype._onInputChange = /**
       * Triggered when the radio button received a click or the input recognized any change.
       * Clicking on a label element, will trigger a change event on the associated input.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              // We always have to stop propagation on the change event.
              // Otherwise the change event, from the input element, will bubble up and
              // emit its event object to the `change` output.
              event.stopPropagation();
              /** @type {?} */
              var groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;
              this.checked = true;
              this._emitChangeEvent();
              if (this.radioGroup) {
                  this.radioGroup._controlValueAccessorChangeFn(this.value);
                  this.radioGroup._touch();
                  if (groupValueChanged) {
                      this.radioGroup._emitChangeEvent();
                  }
              }
          };
      MatRadioButton.decorators = [
          { type: core.Component, args: [{ selector: 'mat-radio-button',
                      template: "<label [attr.for]=\"inputId\" class=\"mat-radio-label\" #label><div class=\"mat-radio-container\"><div class=\"mat-radio-outer-circle\"></div><div class=\"mat-radio-inner-circle\"></div><div mat-ripple class=\"mat-radio-ripple\" [matRippleTrigger]=\"label\" [matRippleDisabled]=\"_isRippleDisabled()\" [matRippleCentered]=\"true\" [matRippleRadius]=\"20\" [matRippleAnimation]=\"{enterDuration: 150}\"><div class=\"mat-ripple-element mat-radio-persistent-ripple\"></div></div><input #input class=\"mat-radio-input cdk-visually-hidden\" type=\"radio\" [id]=\"inputId\" [checked]=\"checked\" [disabled]=\"disabled\" [tabIndex]=\"tabIndex\" [attr.name]=\"name\" [required]=\"required\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledby\" [attr.aria-describedby]=\"ariaDescribedby\" (change)=\"_onInputChange($event)\" (click)=\"_onInputClick($event)\"></div><div class=\"mat-radio-label-content\" [class.mat-radio-label-before]=\"labelPosition == 'before'\"><span style=\"display:none\">&nbsp;</span><ng-content></ng-content></div></label>",
                      styles: [".mat-radio-button{display:inline-block;-webkit-tap-highlight-color:transparent;outline:0}.mat-radio-label{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;vertical-align:middle}.mat-radio-container{box-sizing:border-box;display:inline-block;position:relative;width:20px;height:20px;flex-shrink:0}.mat-radio-outer-circle{box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:border-color ease 280ms;width:20px;border-width:2px;border-style:solid;border-radius:50%}._mat-animation-noopable .mat-radio-outer-circle{transition:none}.mat-radio-inner-circle{border-radius:50%;box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:transform ease 280ms,background-color ease 280ms;width:20px;transform:scale(.001)}._mat-animation-noopable .mat-radio-inner-circle{transition:none}.mat-radio-checked .mat-radio-inner-circle{transform:scale(.5)}@media (-ms-high-contrast:active){.mat-radio-checked .mat-radio-inner-circle{border:solid 10px}}.mat-radio-label-content{-webkit-user-select:auto;-moz-user-select:auto;-ms-user-select:auto;user-select:auto;display:inline-block;order:0;line-height:inherit;padding-left:8px;padding-right:0}[dir=rtl] .mat-radio-label-content{padding-right:8px;padding-left:0}.mat-radio-label-content.mat-radio-label-before{order:-1;padding-left:0;padding-right:8px}[dir=rtl] .mat-radio-label-content.mat-radio-label-before{padding-right:0;padding-left:8px}.mat-radio-disabled,.mat-radio-disabled .mat-radio-label{cursor:default}.mat-radio-button .mat-radio-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-radio-button .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple){opacity:.16}.mat-radio-persistent-ripple{width:100%;height:100%;transform:none}.mat-radio-container:hover .mat-radio-persistent-ripple{opacity:.04}.mat-radio-button:not(.mat-radio-disabled).cdk-focused .mat-radio-persistent-ripple{opacity:.12}.mat-radio-disabled .mat-radio-container:hover .mat-radio-persistent-ripple,.mat-radio-persistent-ripple{opacity:0}@media (hover:none){.mat-radio-container:hover .mat-radio-persistent-ripple{display:none}}.mat-radio-input{bottom:0;left:50%}"],
                      inputs: ['color', 'disableRipple', 'tabIndex'],
                      encapsulation: core.ViewEncapsulation.None,
                      exportAs: 'matRadioButton',
                      host: {
                          'class': 'mat-radio-button',
                          '[class.mat-radio-checked]': 'checked',
                          '[class.mat-radio-disabled]': 'disabled',
                          '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                          // Needs to be -1 so the `focus` event still fires.
                          '[attr.tabindex]': '-1',
                          '[attr.id]': 'id',
                          // Note: under normal conditions focus shouldn't land on this element, however it may be
                          // programmatically set, for example inside of a focus trap, in this case we want to forward
                          // the focus to the native element.
                          '(focus)': '_inputElement.nativeElement.focus()',
                      },
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatRadioButton.ctorParameters = function () {
          return [
              { type: MatRadioGroup, decorators: [{ type: core.Optional }] },
              { type: core.ElementRef },
              { type: core.ChangeDetectorRef },
              { type: FocusMonitor },
              { type: UniqueSelectionDispatcher },
              { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] }
          ];
      };
      MatRadioButton.propDecorators = {
          id: [{ type: core.Input }],
          name: [{ type: core.Input }],
          ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
          ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],
          ariaDescribedby: [{ type: core.Input, args: ['aria-describedby',] }],
          checked: [{ type: core.Input }],
          value: [{ type: core.Input }],
          labelPosition: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          required: [{ type: core.Input }],
          change: [{ type: core.Output }],
          _inputElement: [{ type: core.ViewChild, args: ['input',] }]
      };
      return MatRadioButton;
  }(_MatRadioButtonMixinBase));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Animations used by the Material drawers.
   * \@docs-private
   * @type {?}
   */
  var matDrawerAnimations = {
      /**
       * Animation that slides a drawer in and out.
       */
      transformDrawer: trigger('transform', [
          // We remove the `transform` here completely, rather than setting it to zero, because:
          // 1. Having a transform can cause elements with ripples or an animated
          //    transform to shift around in Chrome with an RTL layout (see #10023).
          // 2. 3d transforms causes text to appear blurry on IE and Edge.
          state('open, open-instant', style({
              'transform': 'none',
              'visibility': 'visible',
          })),
          state('void', style({
              // Avoids the shadow showing up when closed in SSR.
              'box-shadow': 'none',
              'visibility': 'hidden',
          })),
          transition('void => open-instant', animate('0ms')),
          transition('void <=> open, open-instant => void', animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)'))
      ])
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Throws an exception when two MatDrawer are matching the same position.
   * \@docs-private
   * @param {?} position
   * @return {?}
   */
  function throwMatDuplicatedDrawerError(position) {
      throw Error("A drawer was already declared for 'position=\"" + position + "\"'");
  }
  /**
   * Configures whether drawers should use auto sizing by default.
   * @type {?}
   */
  var MAT_DRAWER_DEFAULT_AUTOSIZE = new core.InjectionToken('MAT_DRAWER_DEFAULT_AUTOSIZE', {
      providedIn: 'root',
      factory: MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY,
  });
  /**
   * \@docs-private
   * @return {?}
   */
  function MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY() {
      return false;
  }
  var MatDrawerContent = /** @class */ (function (_super) {
      tslib_1.__extends(MatDrawerContent, _super);
      function MatDrawerContent(_changeDetectorRef, _container, elementRef, scrollDispatcher, ngZone) {
          var _this = _super.call(this, elementRef, scrollDispatcher, ngZone) || this;
          _this._changeDetectorRef = _changeDetectorRef;
          _this._container = _container;
          return _this;
      }
      /**
       * @return {?}
       */
      MatDrawerContent.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._container._contentMarginChanges.subscribe(function () {
                  _this._changeDetectorRef.markForCheck();
              });
          };
      MatDrawerContent.decorators = [
          { type: core.Component, args: [{ selector: 'mat-drawer-content',
                      template: '<ng-content></ng-content>',
                      host: {
                          'class': 'mat-drawer-content',
                          '[style.margin-left.px]': '_container._contentMargins.left',
                          '[style.margin-right.px]': '_container._contentMargins.right',
                      },
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                  },] },
      ];
      /** @nocollapse */
      MatDrawerContent.ctorParameters = function () {
          return [
              { type: core.ChangeDetectorRef },
              { type: MatDrawerContainer, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return MatDrawerContainer; }),] }] },
              { type: core.ElementRef },
              { type: ScrollDispatcher },
              { type: core.NgZone }
          ];
      };
      return MatDrawerContent;
  }(CdkScrollable));
  /**
   * This component corresponds to a drawer that can be opened on the drawer container.
   */
  var MatDrawer = /** @class */ (function () {
      function MatDrawer(_elementRef, _focusTrapFactory, _focusMonitor, _platform, _ngZone, _doc) {
          var _this = this;
          this._elementRef = _elementRef;
          this._focusTrapFactory = _focusTrapFactory;
          this._focusMonitor = _focusMonitor;
          this._platform = _platform;
          this._ngZone = _ngZone;
          this._doc = _doc;
          this._elementFocusedBeforeDrawerWasOpened = null;
          /**
           * Whether the drawer is initialized. Used for disabling the initial animation.
           */
          this._enableAnimations = false;
          this._position = 'start';
          this._mode = 'over';
          this._disableClose = false;
          this._autoFocus = true;
          /**
           * Emits whenever the drawer has started animating.
           */
          this._animationStarted = new rxjs.Subject();
          /**
           * Emits whenever the drawer is done animating.
           */
          this._animationEnd = new rxjs.Subject();
          /**
           * Current state of the sidenav animation.
           */
          this._animationState = 'void';
          /**
           * Event emitted when the drawer open state is changed.
           */
          this.openedChange =
              // Note this has to be async in order to avoid some issues with two-bindings (see #8872).
              new core.EventEmitter(/* isAsync */ true);
          /**
           * Emits when the component is destroyed.
           */
          this._destroyed = new rxjs.Subject();
          /**
           * Event emitted when the drawer's position changes.
           */
          // tslint:disable-next-line:no-output-on-prefix
          this.onPositionChanged = new core.EventEmitter();
          /**
           * An observable that emits when the drawer mode changes. This is used by the drawer container to
           * to know when to when the mode changes so it can adapt the margins on the content.
           */
          this._modeChanged = new rxjs.Subject();
          this._opened = false;
          this.openedChange.subscribe(function (opened) {
              if (opened) {
                  if (_this._doc) {
                      _this._elementFocusedBeforeDrawerWasOpened = ( /** @type {?} */(_this._doc.activeElement));
                  }
                  if (_this._isFocusTrapEnabled && _this._focusTrap) {
                      _this._trapFocus();
                  }
              }
              else {
                  _this._restoreFocus();
              }
          });
          /**
           * Listen to `keydown` events outside the zone so that change detection is not run every
           * time a key is pressed. Instead we re-enter the zone only if the `ESC` key is pressed
           * and we don't have close disabled.
           */
          this._ngZone.runOutsideAngular(function () {
              rxjs.fromEvent(_this._elementRef.nativeElement, 'keydown').pipe(operators.filter(function (event) { return event.keyCode === ESCAPE && !_this.disableClose; }), operators.takeUntil(_this._destroyed)).subscribe(function (event) {
                  return _this._ngZone.run(function () {
                      _this.close();
                      event.stopPropagation();
                  });
              });
          });
          // We need a Subject with distinctUntilChanged, because the `done` event
          // fires twice on some browsers. See https://github.com/angular/angular/issues/24084
          this._animationEnd.pipe(operators.distinctUntilChanged(function (x, y) {
              return x.fromState === y.fromState && x.toState === y.toState;
          })).subscribe(function (event) {
              var fromState = event.fromState, toState = event.toState;
              if ((toState.indexOf('open') === 0 && fromState === 'void') ||
                  (toState === 'void' && fromState.indexOf('open') === 0)) {
                  _this.openedChange.emit(_this._opened);
              }
          });
      }
      Object.defineProperty(MatDrawer.prototype, "position", {
          /** The side that the drawer is attached to. */
          get: /**
           * The side that the drawer is attached to.
           * @return {?}
           */ function () { return this._position; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              // Make sure we have a valid value.
              value = value === 'end' ? 'end' : 'start';
              if (value != this._position) {
                  this._position = value;
                  this.onPositionChanged.emit();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDrawer.prototype, "mode", {
          /** Mode of the drawer; one of 'over', 'push' or 'side'. */
          get: /**
           * Mode of the drawer; one of 'over', 'push' or 'side'.
           * @return {?}
           */ function () { return this._mode; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._mode = value;
              this._modeChanged.next();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDrawer.prototype, "disableClose", {
          /** Whether the drawer can be closed with the escape key or by clicking on the backdrop. */
          get: /**
           * Whether the drawer can be closed with the escape key or by clicking on the backdrop.
           * @return {?}
           */ function () { return this._disableClose; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._disableClose = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDrawer.prototype, "autoFocus", {
          /** Whether the drawer should focus the first focusable element automatically when opened. */
          get: /**
           * Whether the drawer should focus the first focusable element automatically when opened.
           * @return {?}
           */ function () { return this._autoFocus; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._autoFocus = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDrawer.prototype, "_openedStream", {
          /** Event emitted when the drawer has been opened. */
          get: /**
           * Event emitted when the drawer has been opened.
           * @return {?}
           */ function () {
              return this.openedChange.pipe(operators.filter(function (o) { return o; }), operators.map(function () { }));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDrawer.prototype, "openedStart", {
          /** Event emitted when the drawer has started opening. */
          get: /**
           * Event emitted when the drawer has started opening.
           * @return {?}
           */ function () {
              return this._animationStarted.pipe(operators.filter(function (e) { return e.fromState !== e.toState && e.toState.indexOf('open') === 0; }), operators.map(function () { }));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDrawer.prototype, "_closedStream", {
          /** Event emitted when the drawer has been closed. */
          get: /**
           * Event emitted when the drawer has been closed.
           * @return {?}
           */ function () {
              return this.openedChange.pipe(operators.filter(function (o) { return !o; }), operators.map(function () { }));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDrawer.prototype, "closedStart", {
          /** Event emitted when the drawer has started closing. */
          get: /**
           * Event emitted when the drawer has started closing.
           * @return {?}
           */ function () {
              return this._animationStarted.pipe(operators.filter(function (e) { return e.fromState !== e.toState && e.toState === 'void'; }), operators.map(function () { }));
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDrawer.prototype, "_isFocusTrapEnabled", {
          get: /**
           * @return {?}
           */ function () {
              // The focus trap is only enabled when the drawer is open in any mode other than side.
              return this.opened && this.mode !== 'side';
          },
          enumerable: true,
          configurable: true
      });
      /** Traps focus inside the drawer. */
      /**
       * Traps focus inside the drawer.
       * @private
       * @return {?}
       */
      MatDrawer.prototype._trapFocus = /**
       * Traps focus inside the drawer.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this.autoFocus) {
                  return;
              }
              this._focusTrap.focusInitialElementWhenReady().then(function (hasMovedFocus) {
                  // If there were no focusable elements, focus the sidenav itself so the keyboard navigation
                  // still works. We need to check that `focus` is a function due to Universal.
                  if (!hasMovedFocus && typeof _this._elementRef.nativeElement.focus === 'function') {
                      _this._elementRef.nativeElement.focus();
                  }
              });
          };
      /**
       * If focus is currently inside the drawer, restores it to where it was before the drawer
       * opened.
       */
      /**
       * If focus is currently inside the drawer, restores it to where it was before the drawer
       * opened.
       * @private
       * @return {?}
       */
      MatDrawer.prototype._restoreFocus = /**
       * If focus is currently inside the drawer, restores it to where it was before the drawer
       * opened.
       * @private
       * @return {?}
       */
          function () {
              if (!this.autoFocus) {
                  return;
              }
              /** @type {?} */
              var activeEl = this._doc && this._doc.activeElement;
              if (activeEl && this._elementRef.nativeElement.contains(activeEl)) {
                  if (this._elementFocusedBeforeDrawerWasOpened instanceof HTMLElement) {
                      this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, this._openedVia);
                  }
                  else {
                      this._elementRef.nativeElement.blur();
                  }
              }
              this._elementFocusedBeforeDrawerWasOpened = null;
              this._openedVia = null;
          };
      /**
       * @return {?}
       */
      MatDrawer.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);
              this._focusTrap.enabled = this._isFocusTrapEnabled;
          };
      /**
       * @return {?}
       */
      MatDrawer.prototype.ngAfterContentChecked = /**
       * @return {?}
       */
          function () {
              // Enable the animations after the lifecycle hooks have run, in order to avoid animating
              // drawers that are open by default. When we're on the server, we shouldn't enable the
              // animations, because we don't want the drawer to animate the first time the user sees
              // the page.
              if (this._platform.isBrowser) {
                  this._enableAnimations = true;
              }
          };
      /**
       * @return {?}
       */
      MatDrawer.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              if (this._focusTrap) {
                  this._focusTrap.destroy();
              }
              this._animationStarted.complete();
              this._animationEnd.complete();
              this._destroyed.next();
              this._destroyed.complete();
          };
      Object.defineProperty(MatDrawer.prototype, "opened", {
          /**
           * Whether the drawer is opened. We overload this because we trigger an event when it
           * starts or end.
           */
          get: /**
           * Whether the drawer is opened. We overload this because we trigger an event when it
           * starts or end.
           * @return {?}
           */ function () { return this._opened; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this.toggle(coerceBooleanProperty(value)); },
          enumerable: true,
          configurable: true
      });
      /**
       * Open the drawer.
       * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.
       * Used for focus management after the sidenav is closed.
       */
      /**
       * Open the drawer.
       * @param {?=} openedVia Whether the drawer was opened by a key press, mouse click or programmatically.
       * Used for focus management after the sidenav is closed.
       * @return {?}
       */
      MatDrawer.prototype.open = /**
       * Open the drawer.
       * @param {?=} openedVia Whether the drawer was opened by a key press, mouse click or programmatically.
       * Used for focus management after the sidenav is closed.
       * @return {?}
       */
          function (openedVia) {
              return this.toggle(true, openedVia);
          };
      /** Close the drawer. */
      /**
       * Close the drawer.
       * @return {?}
       */
      MatDrawer.prototype.close = /**
       * Close the drawer.
       * @return {?}
       */
          function () {
              return this.toggle(false);
          };
      /**
       * Toggle this drawer.
       * @param isOpen Whether the drawer should be open.
       * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.
       * Used for focus management after the sidenav is closed.
       */
      /**
       * Toggle this drawer.
       * @param {?=} isOpen Whether the drawer should be open.
       * @param {?=} openedVia Whether the drawer was opened by a key press, mouse click or programmatically.
       * Used for focus management after the sidenav is closed.
       * @return {?}
       */
      MatDrawer.prototype.toggle = /**
       * Toggle this drawer.
       * @param {?=} isOpen Whether the drawer should be open.
       * @param {?=} openedVia Whether the drawer was opened by a key press, mouse click or programmatically.
       * Used for focus management after the sidenav is closed.
       * @return {?}
       */
          function (isOpen, openedVia) {
              var _this = this;
              if (isOpen === void 0) {
                  isOpen = !this.opened;
              }
              if (openedVia === void 0) {
                  openedVia = 'program';
              }
              this._opened = isOpen;
              if (isOpen) {
                  this._animationState = this._enableAnimations ? 'open' : 'open-instant';
                  this._openedVia = openedVia;
              }
              else {
                  this._animationState = 'void';
                  this._restoreFocus();
              }
              if (this._focusTrap) {
                  this._focusTrap.enabled = this._isFocusTrapEnabled;
              }
              return new Promise(function (resolve) {
                  _this.openedChange.pipe(operators.take(1)).subscribe(function (open) { return resolve(open ? 'open' : 'close'); });
              });
          };
      Object.defineProperty(MatDrawer.prototype, "_width", {
          get: /**
           * @return {?}
           */ function () {
              return this._elementRef.nativeElement ? (this._elementRef.nativeElement.offsetWidth || 0) : 0;
          },
          enumerable: true,
          configurable: true
      });
      MatDrawer.decorators = [
          { type: core.Component, args: [{ selector: 'mat-drawer',
                      exportAs: 'matDrawer',
                      template: "<div class=\"mat-drawer-inner-container\"><ng-content></ng-content></div>",
                      animations: [matDrawerAnimations.transformDrawer],
                      host: {
                          'class': 'mat-drawer',
                          '[@transform]': '_animationState',
                          '(@transform.start)': '_animationStarted.next($event)',
                          '(@transform.done)': '_animationEnd.next($event)',
                          // must prevent the browser from aligning text based on value
                          '[attr.align]': 'null',
                          '[class.mat-drawer-end]': 'position === "end"',
                          '[class.mat-drawer-over]': 'mode === "over"',
                          '[class.mat-drawer-push]': 'mode === "push"',
                          '[class.mat-drawer-side]': 'mode === "side"',
                          'tabIndex': '-1',
                      },
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                  },] },
      ];
      /** @nocollapse */
      MatDrawer.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: FocusTrapFactory },
              { type: FocusMonitor },
              { type: Platform },
              { type: core.NgZone },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] }
          ];
      };
      MatDrawer.propDecorators = {
          position: [{ type: core.Input }],
          mode: [{ type: core.Input }],
          disableClose: [{ type: core.Input }],
          autoFocus: [{ type: core.Input }],
          openedChange: [{ type: core.Output }],
          _openedStream: [{ type: core.Output, args: ['opened',] }],
          openedStart: [{ type: core.Output }],
          _closedStream: [{ type: core.Output, args: ['closed',] }],
          closedStart: [{ type: core.Output }],
          onPositionChanged: [{ type: core.Output, args: ['positionChanged',] }],
          opened: [{ type: core.Input }]
      };
      return MatDrawer;
  }());
  /**
   * `<mat-drawer-container>` component.
   *
   * This is the parent component to one or two `<mat-drawer>`s that validates the state internally
   * and coordinates the backdrop and content styling.
   */
  var MatDrawerContainer = /** @class */ (function () {
      function MatDrawerContainer(_dir, _element, _ngZone, _changeDetectorRef, defaultAutosize, _animationMode, 
      /**
       * @deprecated viewportRuler to become a required parameter.
       * @breaking-change 8.0.0
       */
      viewportRuler) {
          if (defaultAutosize === void 0) {
              defaultAutosize = false;
          }
          var _this = this;
          this._dir = _dir;
          this._element = _element;
          this._ngZone = _ngZone;
          this._changeDetectorRef = _changeDetectorRef;
          this._animationMode = _animationMode;
          /**
           * Event emitted when the drawer backdrop is clicked.
           */
          this.backdropClick = new core.EventEmitter();
          /**
           * Emits when the component is destroyed.
           */
          this._destroyed = new rxjs.Subject();
          /**
           * Emits on every ngDoCheck. Used for debouncing reflows.
           */
          this._doCheckSubject = new rxjs.Subject();
          /**
           * Margins to be applied to the content. These are used to push / shrink the drawer content when a
           * drawer is open. We use margin rather than transform even for push mode because transform breaks
           * fixed position elements inside of the transformed element.
           */
          this._contentMargins = { left: null, right: null };
          this._contentMarginChanges = new rxjs.Subject();
          // If a `Dir` directive exists up the tree, listen direction changes
          // and update the left/right properties to point to the proper start/end.
          if (_dir) {
              _dir.change.pipe(operators.takeUntil(this._destroyed)).subscribe(function () {
                  _this._validateDrawers();
                  _this._updateContentMargins();
              });
          }
          // Since the minimum width of the sidenav depends on the viewport width,
          // we need to recompute the margins if the viewport changes.
          if (viewportRuler) {
              viewportRuler.change()
                  .pipe(operators.takeUntil(this._destroyed))
                  .subscribe(function () { return _this._updateContentMargins(); });
          }
          this._autosize = defaultAutosize;
      }
      Object.defineProperty(MatDrawerContainer.prototype, "start", {
          /** The drawer child with the `start` position. */
          get: /**
           * The drawer child with the `start` position.
           * @return {?}
           */ function () { return this._start; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDrawerContainer.prototype, "end", {
          /** The drawer child with the `end` position. */
          get: /**
           * The drawer child with the `end` position.
           * @return {?}
           */ function () { return this._end; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDrawerContainer.prototype, "autosize", {
          /**
           * Whether to automatically resize the container whenever
           * the size of any of its drawers changes.
           *
           * **Use at your own risk!** Enabling this option can cause layout thrashing by measuring
           * the drawers on every change detection cycle. Can be configured globally via the
           * `MAT_DRAWER_DEFAULT_AUTOSIZE` token.
           */
          get: /**
           * Whether to automatically resize the container whenever
           * the size of any of its drawers changes.
           *
           * **Use at your own risk!** Enabling this option can cause layout thrashing by measuring
           * the drawers on every change detection cycle. Can be configured globally via the
           * `MAT_DRAWER_DEFAULT_AUTOSIZE` token.
           * @return {?}
           */ function () { return this._autosize; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._autosize = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDrawerContainer.prototype, "hasBackdrop", {
          /**
           * Whether the drawer container should have a backdrop while one of the sidenavs is open.
           * If explicitly set to `true`, the backdrop will be enabled for drawers in the `side`
           * mode as well.
           */
          get: /**
           * Whether the drawer container should have a backdrop while one of the sidenavs is open.
           * If explicitly set to `true`, the backdrop will be enabled for drawers in the `side`
           * mode as well.
           * @return {?}
           */ function () {
              if (this._backdropOverride == null) {
                  return !this._start || this._start.mode !== 'side' || !this._end || this._end.mode !== 'side';
              }
              return this._backdropOverride;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._backdropOverride = value == null ? null : coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatDrawerContainer.prototype, "scrollable", {
          /** Reference to the CdkScrollable instance that wraps the scrollable content. */
          get: /**
           * Reference to the CdkScrollable instance that wraps the scrollable content.
           * @return {?}
           */ function () {
              return this._userContent || this._content;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatDrawerContainer.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._drawers.changes.pipe(operators.startWith(null)).subscribe(function () {
                  _this._validateDrawers();
                  _this._drawers.forEach(function (drawer) {
                      _this._watchDrawerToggle(drawer);
                      _this._watchDrawerPosition(drawer);
                      _this._watchDrawerMode(drawer);
                  });
                  if (!_this._drawers.length ||
                      _this._isDrawerOpen(_this._start) ||
                      _this._isDrawerOpen(_this._end)) {
                      _this._updateContentMargins();
                  }
                  _this._changeDetectorRef.markForCheck();
              });
              this._doCheckSubject.pipe(operators.debounceTime(10), // Arbitrary debounce time, less than a frame at 60fps
              operators.takeUntil(this._destroyed)).subscribe(function () { return _this._updateContentMargins(); });
          };
      /**
       * @return {?}
       */
      MatDrawerContainer.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._doCheckSubject.complete();
              this._destroyed.next();
              this._destroyed.complete();
          };
      /** Calls `open` of both start and end drawers */
      /**
       * Calls `open` of both start and end drawers
       * @return {?}
       */
      MatDrawerContainer.prototype.open = /**
       * Calls `open` of both start and end drawers
       * @return {?}
       */
          function () {
              this._drawers.forEach(function (drawer) { return drawer.open(); });
          };
      /** Calls `close` of both start and end drawers */
      /**
       * Calls `close` of both start and end drawers
       * @return {?}
       */
      MatDrawerContainer.prototype.close = /**
       * Calls `close` of both start and end drawers
       * @return {?}
       */
          function () {
              this._drawers.forEach(function (drawer) { return drawer.close(); });
          };
      /**
       * @return {?}
       */
      MatDrawerContainer.prototype.ngDoCheck = /**
       * @return {?}
       */
          function () {
              var _this = this;
              // If users opted into autosizing, do a check every change detection cycle.
              if (this._autosize && this._isPushed()) {
                  // Run outside the NgZone, otherwise the debouncer will throw us into an infinite loop.
                  this._ngZone.runOutsideAngular(function () { return _this._doCheckSubject.next(); });
              }
          };
      /**
       * Subscribes to drawer events in order to set a class on the main container element when the
       * drawer is open and the backdrop is visible. This ensures any overflow on the container element
       * is properly hidden.
       */
      /**
       * Subscribes to drawer events in order to set a class on the main container element when the
       * drawer is open and the backdrop is visible. This ensures any overflow on the container element
       * is properly hidden.
       * @private
       * @param {?} drawer
       * @return {?}
       */
      MatDrawerContainer.prototype._watchDrawerToggle = /**
       * Subscribes to drawer events in order to set a class on the main container element when the
       * drawer is open and the backdrop is visible. This ensures any overflow on the container element
       * is properly hidden.
       * @private
       * @param {?} drawer
       * @return {?}
       */
          function (drawer) {
              var _this = this;
              drawer._animationStarted.pipe(operators.filter(function (event) { return event.fromState !== event.toState; }), operators.takeUntil(this._drawers.changes))
                  .subscribe(function (event) {
                  // Set the transition class on the container so that the animations occur. This should not
                  // be set initially because animations should only be triggered via a change in state.
                  if (event.toState !== 'open-instant' && _this._animationMode !== 'NoopAnimations') {
                      _this._element.nativeElement.classList.add('mat-drawer-transition');
                  }
                  _this._updateContentMargins();
                  _this._changeDetectorRef.markForCheck();
              });
              if (drawer.mode !== 'side') {
                  drawer.openedChange.pipe(operators.takeUntil(this._drawers.changes)).subscribe(function () {
                      return _this._setContainerClass(drawer.opened);
                  });
              }
          };
      /**
       * Subscribes to drawer onPositionChanged event in order to
       * re-validate drawers when the position changes.
       */
      /**
       * Subscribes to drawer onPositionChanged event in order to
       * re-validate drawers when the position changes.
       * @private
       * @param {?} drawer
       * @return {?}
       */
      MatDrawerContainer.prototype._watchDrawerPosition = /**
       * Subscribes to drawer onPositionChanged event in order to
       * re-validate drawers when the position changes.
       * @private
       * @param {?} drawer
       * @return {?}
       */
          function (drawer) {
              var _this = this;
              if (!drawer) {
                  return;
              }
              // NOTE: We need to wait for the microtask queue to be empty before validating,
              // since both drawers may be swapping positions at the same time.
              drawer.onPositionChanged.pipe(operators.takeUntil(this._drawers.changes)).subscribe(function () {
                  _this._ngZone.onMicrotaskEmpty.asObservable().pipe(operators.take(1)).subscribe(function () {
                      _this._validateDrawers();
                  });
              });
          };
      /** Subscribes to changes in drawer mode so we can run change detection. */
      /**
       * Subscribes to changes in drawer mode so we can run change detection.
       * @private
       * @param {?} drawer
       * @return {?}
       */
      MatDrawerContainer.prototype._watchDrawerMode = /**
       * Subscribes to changes in drawer mode so we can run change detection.
       * @private
       * @param {?} drawer
       * @return {?}
       */
          function (drawer) {
              var _this = this;
              if (drawer) {
                  drawer._modeChanged.pipe(operators.takeUntil(rxjs.merge(this._drawers.changes, this._destroyed)))
                      .subscribe(function () {
                      _this._updateContentMargins();
                      _this._changeDetectorRef.markForCheck();
                  });
              }
          };
      /** Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element. */
      /**
       * Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element.
       * @private
       * @param {?} isAdd
       * @return {?}
       */
      MatDrawerContainer.prototype._setContainerClass = /**
       * Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element.
       * @private
       * @param {?} isAdd
       * @return {?}
       */
          function (isAdd) {
              if (isAdd) {
                  this._element.nativeElement.classList.add('mat-drawer-opened');
              }
              else {
                  this._element.nativeElement.classList.remove('mat-drawer-opened');
              }
          };
      /** Validate the state of the drawer children components. */
      /**
       * Validate the state of the drawer children components.
       * @private
       * @return {?}
       */
      MatDrawerContainer.prototype._validateDrawers = /**
       * Validate the state of the drawer children components.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              this._start = this._end = null;
              // Ensure that we have at most one start and one end drawer.
              this._drawers.forEach(function (drawer) {
                  if (drawer.position == 'end') {
                      if (_this._end != null) {
                          throwMatDuplicatedDrawerError('end');
                      }
                      _this._end = drawer;
                  }
                  else {
                      if (_this._start != null) {
                          throwMatDuplicatedDrawerError('start');
                      }
                      _this._start = drawer;
                  }
              });
              this._right = this._left = null;
              // Detect if we're LTR or RTL.
              if (this._dir && this._dir.value === 'rtl') {
                  this._left = this._end;
                  this._right = this._start;
              }
              else {
                  this._left = this._start;
                  this._right = this._end;
              }
          };
      /** Whether the container is being pushed to the side by one of the drawers. */
      /**
       * Whether the container is being pushed to the side by one of the drawers.
       * @private
       * @return {?}
       */
      MatDrawerContainer.prototype._isPushed = /**
       * Whether the container is being pushed to the side by one of the drawers.
       * @private
       * @return {?}
       */
          function () {
              return (this._isDrawerOpen(this._start) && this._start.mode != 'over') ||
                  (this._isDrawerOpen(this._end) && this._end.mode != 'over');
          };
      /**
       * @return {?}
       */
      MatDrawerContainer.prototype._onBackdropClicked = /**
       * @return {?}
       */
          function () {
              this.backdropClick.emit();
              this._closeModalDrawer();
          };
      /**
       * @return {?}
       */
      MatDrawerContainer.prototype._closeModalDrawer = /**
       * @return {?}
       */
          function () {
              var _this = this;
              // Close all open drawers where closing is not disabled and the mode is not `side`.
              [this._start, this._end]
                  .filter(function (drawer) { return drawer && !drawer.disableClose && _this._canHaveBackdrop(drawer); })
                  .forEach(function (drawer) { return ( /** @type {?} */(drawer)).close(); });
          };
      /**
       * @return {?}
       */
      MatDrawerContainer.prototype._isShowingBackdrop = /**
       * @return {?}
       */
          function () {
              return (this._isDrawerOpen(this._start) && this._canHaveBackdrop(this._start)) ||
                  (this._isDrawerOpen(this._end) && this._canHaveBackdrop(this._end));
          };
      /**
       * @private
       * @param {?} drawer
       * @return {?}
       */
      MatDrawerContainer.prototype._canHaveBackdrop = /**
       * @private
       * @param {?} drawer
       * @return {?}
       */
          function (drawer) {
              return drawer.mode !== 'side' || !!this._backdropOverride;
          };
      /**
       * @private
       * @param {?} drawer
       * @return {?}
       */
      MatDrawerContainer.prototype._isDrawerOpen = /**
       * @private
       * @param {?} drawer
       * @return {?}
       */
          function (drawer) {
              return drawer != null && drawer.opened;
          };
      /**
       * Recalculates and updates the inline styles for the content. Note that this should be used
       * sparingly, because it causes a reflow.
       */
      /**
       * Recalculates and updates the inline styles for the content. Note that this should be used
       * sparingly, because it causes a reflow.
       * @private
       * @return {?}
       */
      MatDrawerContainer.prototype._updateContentMargins = /**
       * Recalculates and updates the inline styles for the content. Note that this should be used
       * sparingly, because it causes a reflow.
       * @private
       * @return {?}
       */
          function () {
              // 1. For drawers in `over` mode, they don't affect the content.
              // 2. For drawers in `side` mode they should shrink the content. We do this by adding to the
              //    left margin (for left drawer) or right margin (for right the drawer).
              // 3. For drawers in `push` mode the should shift the content without resizing it. We do this by
              //    adding to the left or right margin and simultaneously subtracting the same amount of
              //    margin from the other side.
              var _this = this;
              // 1. For drawers in `over` mode, they don't affect the content.
              // 2. For drawers in `side` mode they should shrink the content. We do this by adding to the
              //    left margin (for left drawer) or right margin (for right the drawer).
              // 3. For drawers in `push` mode the should shift the content without resizing it. We do this by
              //    adding to the left or right margin and simultaneously subtracting the same amount of
              //    margin from the other side.
              /** @type {?} */
              var left = 0;
              /** @type {?} */
              var right = 0;
              if (this._left && this._left.opened) {
                  if (this._left.mode == 'side') {
                      left += this._left._width;
                  }
                  else if (this._left.mode == 'push') {
                      /** @type {?} */
                      var width = this._left._width;
                      left += width;
                      right -= width;
                  }
              }
              if (this._right && this._right.opened) {
                  if (this._right.mode == 'side') {
                      right += this._right._width;
                  }
                  else if (this._right.mode == 'push') {
                      /** @type {?} */
                      var width = this._right._width;
                      right += width;
                      left -= width;
                  }
              }
              // If either `right` or `left` is zero, don't set a style to the element. This
              // allows users to specify a custom size via CSS class in SSR scenarios where the
              // measured widths will always be zero. Note that we reset to `null` here, rather
              // than below, in order to ensure that the types in the `if` below are consistent.
              left = left || ( /** @type {?} */(null));
              right = right || ( /** @type {?} */(null));
              if (left !== this._contentMargins.left || right !== this._contentMargins.right) {
                  this._contentMargins = { left: left, right: right };
                  // Pull back into the NgZone since in some cases we could be outside. We need to be careful
                  // to do it only when something changed, otherwise we can end up hitting the zone too often.
                  this._ngZone.run(function () { return _this._contentMarginChanges.next(_this._contentMargins); });
              }
          };
      MatDrawerContainer.decorators = [
          { type: core.Component, args: [{ selector: 'mat-drawer-container',
                      exportAs: 'matDrawerContainer',
                      template: "<div class=\"mat-drawer-backdrop\" (click)=\"_onBackdropClicked()\" *ngIf=\"hasBackdrop\" [class.mat-drawer-shown]=\"_isShowingBackdrop()\"></div><ng-content select=\"mat-drawer\"></ng-content><ng-content select=\"mat-drawer-content\"></ng-content><mat-drawer-content *ngIf=\"!_content\"><ng-content></ng-content></mat-drawer-content>",
                      styles: [".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-opened{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:background-color,visibility}@media (-ms-high-contrast:active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%,0,0)}@media (-ms-high-contrast:active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media (-ms-high-contrast:active){.mat-drawer.mat-drawer-end,[dir=rtl] .mat-drawer{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%,0,0)}[dir=rtl] .mat-drawer{transform:translate3d(100%,0,0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%,0,0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}"],
                      host: {
                          'class': 'mat-drawer-container',
                          '[class.mat-drawer-container-explicit-backdrop]': '_backdropOverride',
                      },
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                  },] },
      ];
      /** @nocollapse */
      MatDrawerContainer.ctorParameters = function () {
          return [
              { type: Directionality, decorators: [{ type: core.Optional }] },
              { type: core.ElementRef },
              { type: core.NgZone },
              { type: core.ChangeDetectorRef },
              { type: undefined, decorators: [{ type: core.Inject, args: [MAT_DRAWER_DEFAULT_AUTOSIZE,] }] },
              { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] },
              { type: ViewportRuler, decorators: [{ type: core.Optional }] }
          ];
      };
      MatDrawerContainer.propDecorators = {
          _drawers: [{ type: core.ContentChildren, args: [MatDrawer,] }],
          _content: [{ type: core.ContentChild, args: [MatDrawerContent,] }],
          _userContent: [{ type: core.ViewChild, args: [MatDrawerContent,] }],
          autosize: [{ type: core.Input }],
          hasBackdrop: [{ type: core.Input }],
          backdropClick: [{ type: core.Output }]
      };
      return MatDrawerContainer;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var MatSidenavContent = /** @class */ (function (_super) {
      tslib_1.__extends(MatSidenavContent, _super);
      function MatSidenavContent(changeDetectorRef, container, elementRef, scrollDispatcher, ngZone) {
          return _super.call(this, changeDetectorRef, container, elementRef, scrollDispatcher, ngZone) || this;
      }
      MatSidenavContent.decorators = [
          { type: core.Component, args: [{ selector: 'mat-sidenav-content',
                      template: '<ng-content></ng-content>',
                      host: {
                          'class': 'mat-drawer-content mat-sidenav-content',
                          '[style.margin-left.px]': '_container._contentMargins.left',
                          '[style.margin-right.px]': '_container._contentMargins.right',
                      },
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                  },] },
      ];
      /** @nocollapse */
      MatSidenavContent.ctorParameters = function () {
          return [
              { type: core.ChangeDetectorRef },
              { type: MatSidenavContainer, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return MatSidenavContainer; }),] }] },
              { type: core.ElementRef },
              { type: ScrollDispatcher },
              { type: core.NgZone }
          ];
      };
      return MatSidenavContent;
  }(MatDrawerContent));
  var MatSidenav = /** @class */ (function (_super) {
      tslib_1.__extends(MatSidenav, _super);
      function MatSidenav() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this._fixedInViewport = false;
          _this._fixedTopGap = 0;
          _this._fixedBottomGap = 0;
          return _this;
      }
      Object.defineProperty(MatSidenav.prototype, "fixedInViewport", {
          /** Whether the sidenav is fixed in the viewport. */
          get: /**
           * Whether the sidenav is fixed in the viewport.
           * @return {?}
           */ function () { return this._fixedInViewport; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._fixedInViewport = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSidenav.prototype, "fixedTopGap", {
          /**
           * The gap between the top of the sidenav and the top of the viewport when the sidenav is in fixed
           * mode.
           */
          get: /**
           * The gap between the top of the sidenav and the top of the viewport when the sidenav is in fixed
           * mode.
           * @return {?}
           */ function () { return this._fixedTopGap; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._fixedTopGap = coerceNumberProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSidenav.prototype, "fixedBottomGap", {
          /**
           * The gap between the bottom of the sidenav and the bottom of the viewport when the sidenav is in
           * fixed mode.
           */
          get: /**
           * The gap between the bottom of the sidenav and the bottom of the viewport when the sidenav is in
           * fixed mode.
           * @return {?}
           */ function () { return this._fixedBottomGap; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._fixedBottomGap = coerceNumberProperty(value); },
          enumerable: true,
          configurable: true
      });
      MatSidenav.decorators = [
          { type: core.Component, args: [{ selector: 'mat-sidenav',
                      exportAs: 'matSidenav',
                      template: "<div class=\"mat-drawer-inner-container\"><ng-content></ng-content></div>",
                      animations: [matDrawerAnimations.transformDrawer],
                      host: {
                          'class': 'mat-drawer mat-sidenav',
                          'tabIndex': '-1',
                          '[@transform]': '_animationState',
                          '(@transform.start)': '_animationStarted.next($event)',
                          '(@transform.done)': '_animationEnd.next($event)',
                          // must prevent the browser from aligning text based on value
                          '[attr.align]': 'null',
                          '[class.mat-drawer-end]': 'position === "end"',
                          '[class.mat-drawer-over]': 'mode === "over"',
                          '[class.mat-drawer-push]': 'mode === "push"',
                          '[class.mat-drawer-side]': 'mode === "side"',
                          '[class.mat-sidenav-fixed]': 'fixedInViewport',
                          '[style.top.px]': 'fixedInViewport ? fixedTopGap : null',
                          '[style.bottom.px]': 'fixedInViewport ? fixedBottomGap : null',
                      },
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                  },] },
      ];
      MatSidenav.propDecorators = {
          fixedInViewport: [{ type: core.Input }],
          fixedTopGap: [{ type: core.Input }],
          fixedBottomGap: [{ type: core.Input }]
      };
      return MatSidenav;
  }(MatDrawer));
  var MatSidenavContainer = /** @class */ (function (_super) {
      tslib_1.__extends(MatSidenavContainer, _super);
      function MatSidenavContainer() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MatSidenavContainer.decorators = [
          { type: core.Component, args: [{ selector: 'mat-sidenav-container',
                      exportAs: 'matSidenavContainer',
                      template: "<div class=\"mat-drawer-backdrop\" (click)=\"_onBackdropClicked()\" *ngIf=\"hasBackdrop\" [class.mat-drawer-shown]=\"_isShowingBackdrop()\"></div><ng-content select=\"mat-sidenav\"></ng-content><ng-content select=\"mat-sidenav-content\"></ng-content><mat-sidenav-content *ngIf=\"!_content\" cdkScrollable><ng-content></ng-content></mat-sidenav-content>",
                      styles: [".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-opened{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:background-color,visibility}@media (-ms-high-contrast:active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%,0,0)}@media (-ms-high-contrast:active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media (-ms-high-contrast:active){.mat-drawer.mat-drawer-end,[dir=rtl] .mat-drawer{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%,0,0)}[dir=rtl] .mat-drawer{transform:translate3d(100%,0,0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%,0,0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}"],
                      host: {
                          'class': 'mat-drawer-container mat-sidenav-container',
                          '[class.mat-drawer-container-explicit-backdrop]': '_backdropOverride',
                      },
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                  },] },
      ];
      MatSidenavContainer.propDecorators = {
          _drawers: [{ type: core.ContentChildren, args: [MatSidenav,] }],
          _content: [{ type: core.ContentChild, args: [MatSidenavContent,] }]
      };
      return MatSidenavContainer;
  }(MatDrawerContainer));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token to be used to override the default options for `mat-slide-toggle`.
   * @type {?}
   */
  var MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS = new core.InjectionToken('mat-slide-toggle-default-options', {
      providedIn: 'root',
      factory: function () { return ({ disableToggleValue: false, disableDragValue: false }); }
  });
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Increasing integer for generating unique ids for slide-toggle components.
  /** @type {?} */
  var nextUniqueId$8 = 0;
  /**
   * \@docs-private
   * @type {?}
   */
  var MAT_SLIDE_TOGGLE_VALUE_ACCESSOR = {
      provide: forms.NG_VALUE_ACCESSOR,
      useExisting: core.forwardRef(function () { return MatSlideToggle; }),
      multi: true
  };
  /**
   * Change event object emitted by a MatSlideToggle.
   */
  var /**
   * Change event object emitted by a MatSlideToggle.
   */ MatSlideToggleChange = /** @class */ (function () {
      function MatSlideToggleChange(source, checked) {
          this.source = source;
          this.checked = checked;
      }
      return MatSlideToggleChange;
  }());
  // Boilerplate for applying mixins to MatSlideToggle.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatSlideToggle.
  /**
   * \@docs-private
   */
  MatSlideToggleBase = /** @class */ (function () {
      function MatSlideToggleBase(_elementRef) {
          this._elementRef = _elementRef;
      }
      return MatSlideToggleBase;
  }());
  /** @type {?} */
  var _MatSlideToggleMixinBase = mixinTabIndex(mixinColor(mixinDisableRipple(mixinDisabled(MatSlideToggleBase)), 'accent'));
  /**
   * Represents a slidable "switch" toggle that can be moved between on and off.
   */
  var MatSlideToggle = /** @class */ (function (_super) {
      tslib_1.__extends(MatSlideToggle, _super);
      function MatSlideToggle(elementRef, 
      /**
       * @deprecated The `_platform` parameter to be removed.
       * @breaking-change 8.0.0
       */
      _platform, _focusMonitor, _changeDetectorRef, tabIndex, _ngZone, defaults, _animationMode, _dir) {
          var _this = _super.call(this, elementRef) || this;
          _this._focusMonitor = _focusMonitor;
          _this._changeDetectorRef = _changeDetectorRef;
          _this._ngZone = _ngZone;
          _this.defaults = defaults;
          _this._animationMode = _animationMode;
          _this._dir = _dir;
          _this.onChange = function (_) { };
          _this.onTouched = function () { };
          _this._uniqueId = "mat-slide-toggle-" + ++nextUniqueId$8;
          _this._required = false;
          _this._checked = false;
          /**
           * Whether the thumb is currently being dragged.
           */
          _this._dragging = false;
          /**
           * Name value will be applied to the input element if present.
           */
          _this.name = null;
          /**
           * A unique id for the slide-toggle input. If none is supplied, it will be auto-generated.
           */
          _this.id = _this._uniqueId;
          /**
           * Whether the label should appear after or before the slide-toggle. Defaults to 'after'.
           */
          _this.labelPosition = 'after';
          /**
           * Used to set the aria-label attribute on the underlying input element.
           */
          _this.ariaLabel = null;
          /**
           * Used to set the aria-labelledby attribute on the underlying input element.
           */
          _this.ariaLabelledby = null;
          /**
           * An event will be dispatched each time the slide-toggle changes its value.
           */
          _this.change = new core.EventEmitter();
          /**
           * An event will be dispatched each time the slide-toggle input is toggled.
           * This event is always emitted when the user toggles the slide toggle, but this does not mean
           * the slide toggle's value has changed. The event does not fire when the user drags to change
           * the slide toggle value.
           */
          _this.toggleChange = new core.EventEmitter();
          /**
           * An event will be dispatched each time the slide-toggle is dragged.
           * This event is always emitted when the user drags the slide toggle to make a change greater
           * than 50%. It does not mean the slide toggle's value is changed. The event is not emitted when
           * the user toggles the slide toggle to change its value.
           */
          _this.dragChange = new core.EventEmitter();
          _this.tabIndex = parseInt(tabIndex) || 0;
          return _this;
      }
      Object.defineProperty(MatSlideToggle.prototype, "required", {
          /** Whether the slide-toggle is required. */
          get: /**
           * Whether the slide-toggle is required.
           * @return {?}
           */ function () { return this._required; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._required = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSlideToggle.prototype, "checked", {
          /** Whether the slide-toggle element is checked or not. */
          get: /**
           * Whether the slide-toggle element is checked or not.
           * @return {?}
           */ function () { return this._checked; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._checked = coerceBooleanProperty(value);
              this._changeDetectorRef.markForCheck();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSlideToggle.prototype, "inputId", {
          /** Returns the unique id for the visual hidden input. */
          get: /**
           * Returns the unique id for the visual hidden input.
           * @return {?}
           */ function () { return (this.id || this._uniqueId) + "-input"; },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatSlideToggle.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._focusMonitor
                  .monitor(this._elementRef, true)
                  .subscribe(function (focusOrigin) {
                  if (!focusOrigin) {
                      // When a focused element becomes disabled, the browser *immediately* fires a blur event.
                      // Angular does not expect events to be raised during change detection, so any state
                      // change (such as a form control's 'ng-touched') will cause a changed-after-checked
                      // error. See https://github.com/angular/angular/issues/17793. To work around this,
                      // we defer telling the form control it has been touched until the next tick.
                      Promise.resolve().then(function () { return _this.onTouched(); });
                  }
              });
          };
      /**
       * @return {?}
       */
      MatSlideToggle.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._focusMonitor.stopMonitoring(this._elementRef);
          };
      /** Method being called whenever the underlying input emits a change event. */
      /**
       * Method being called whenever the underlying input emits a change event.
       * @param {?} event
       * @return {?}
       */
      MatSlideToggle.prototype._onChangeEvent = /**
       * Method being called whenever the underlying input emits a change event.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              // We always have to stop propagation on the change event.
              // Otherwise the change event, from the input element, will bubble up and
              // emit its event object to the component's `change` output.
              event.stopPropagation();
              if (!this._dragging) {
                  this.toggleChange.emit();
              }
              // Releasing the pointer over the `<label>` element while dragging triggers another
              // click event on the `<label>` element. This means that the checked state of the underlying
              // input changed unintentionally and needs to be changed back. Or when the slide toggle's config
              // disabled toggle change event by setting `disableToggleValue: true`, the slide toggle's value
              // does not change, and the checked state of the underlying input needs to be changed back.
              if (this._dragging || this.defaults.disableToggleValue) {
                  this._inputElement.nativeElement.checked = this.checked;
                  return;
              }
              // Sync the value from the underlying input element with the component instance.
              this.checked = this._inputElement.nativeElement.checked;
              // Emit our custom change event only if the underlying input emitted one. This ensures that
              // there is no change event, when the checked state changes programmatically.
              this._emitChangeEvent();
          };
      /** Method being called whenever the slide-toggle has been clicked. */
      /**
       * Method being called whenever the slide-toggle has been clicked.
       * @param {?} event
       * @return {?}
       */
      MatSlideToggle.prototype._onInputClick = /**
       * Method being called whenever the slide-toggle has been clicked.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              // We have to stop propagation for click events on the visual hidden input element.
              // By default, when a user clicks on a label element, a generated click event will be
              // dispatched on the associated input element. Since we are using a label element as our
              // root container, the click event on the `slide-toggle` will be executed twice.
              // The real click event will bubble up, and the generated click event also tries to bubble up.
              // This will lead to multiple click events.
              // Preventing bubbling for the second event will solve that issue.
              event.stopPropagation();
          };
      /** Implemented as part of ControlValueAccessor. */
      /**
       * Implemented as part of ControlValueAccessor.
       * @param {?} value
       * @return {?}
       */
      MatSlideToggle.prototype.writeValue = /**
       * Implemented as part of ControlValueAccessor.
       * @param {?} value
       * @return {?}
       */
          function (value) {
              this.checked = !!value;
          };
      /** Implemented as part of ControlValueAccessor. */
      /**
       * Implemented as part of ControlValueAccessor.
       * @param {?} fn
       * @return {?}
       */
      MatSlideToggle.prototype.registerOnChange = /**
       * Implemented as part of ControlValueAccessor.
       * @param {?} fn
       * @return {?}
       */
          function (fn) {
              this.onChange = fn;
          };
      /** Implemented as part of ControlValueAccessor. */
      /**
       * Implemented as part of ControlValueAccessor.
       * @param {?} fn
       * @return {?}
       */
      MatSlideToggle.prototype.registerOnTouched = /**
       * Implemented as part of ControlValueAccessor.
       * @param {?} fn
       * @return {?}
       */
          function (fn) {
              this.onTouched = fn;
          };
      /** Implemented as a part of ControlValueAccessor. */
      /**
       * Implemented as a part of ControlValueAccessor.
       * @param {?} isDisabled
       * @return {?}
       */
      MatSlideToggle.prototype.setDisabledState = /**
       * Implemented as a part of ControlValueAccessor.
       * @param {?} isDisabled
       * @return {?}
       */
          function (isDisabled) {
              this.disabled = isDisabled;
              this._changeDetectorRef.markForCheck();
          };
      /** Focuses the slide-toggle. */
      /**
       * Focuses the slide-toggle.
       * @return {?}
       */
      MatSlideToggle.prototype.focus = /**
       * Focuses the slide-toggle.
       * @return {?}
       */
          function () {
              this._focusMonitor.focusVia(this._inputElement, 'keyboard');
          };
      /** Toggles the checked state of the slide-toggle. */
      /**
       * Toggles the checked state of the slide-toggle.
       * @return {?}
       */
      MatSlideToggle.prototype.toggle = /**
       * Toggles the checked state of the slide-toggle.
       * @return {?}
       */
          function () {
              this.checked = !this.checked;
              this.onChange(this.checked);
          };
      /**
       * Emits a change event on the `change` output. Also notifies the FormControl about the change.
       */
      /**
       * Emits a change event on the `change` output. Also notifies the FormControl about the change.
       * @private
       * @return {?}
       */
      MatSlideToggle.prototype._emitChangeEvent = /**
       * Emits a change event on the `change` output. Also notifies the FormControl about the change.
       * @private
       * @return {?}
       */
          function () {
              this.onChange(this.checked);
              this.change.emit(new MatSlideToggleChange(this, this.checked));
          };
      /** Retrieves the percentage of thumb from the moved distance. Percentage as fraction of 100. */
      /**
       * Retrieves the percentage of thumb from the moved distance. Percentage as fraction of 100.
       * @private
       * @param {?} distance
       * @return {?}
       */
      MatSlideToggle.prototype._getDragPercentage = /**
       * Retrieves the percentage of thumb from the moved distance. Percentage as fraction of 100.
       * @private
       * @param {?} distance
       * @return {?}
       */
          function (distance) {
              /** @type {?} */
              var percentage = (distance / this._thumbBarWidth) * 100;
              // When the toggle was initially checked, then we have to start the drag at the end.
              if (this._previousChecked) {
                  percentage += 100;
              }
              return Math.max(0, Math.min(percentage, 100));
          };
      /**
       * @return {?}
       */
      MatSlideToggle.prototype._onDragStart = /**
       * @return {?}
       */
          function () {
              if (!this.disabled && !this._dragging) {
                  /** @type {?} */
                  var thumbEl = this._thumbEl.nativeElement;
                  this._thumbBarWidth = this._thumbBarEl.nativeElement.clientWidth - thumbEl.clientWidth;
                  thumbEl.classList.add('mat-dragging');
                  this._previousChecked = this.checked;
                  this._dragging = true;
              }
          };
      /**
       * @param {?} event
       * @return {?}
       */
      MatSlideToggle.prototype._onDrag = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (this._dragging) {
                  /** @type {?} */
                  var direction = this._dir && this._dir.value === 'rtl' ? -1 : 1;
                  this._dragPercentage = this._getDragPercentage(event.deltaX * direction);
                  // Calculate the moved distance based on the thumb bar width.
                  /** @type {?} */
                  var dragX = (this._dragPercentage / 100) * this._thumbBarWidth * direction;
                  this._thumbEl.nativeElement.style.transform = "translate3d(" + dragX + "px, 0, 0)";
              }
          };
      /**
       * @return {?}
       */
      MatSlideToggle.prototype._onDragEnd = /**
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._dragging) {
                  /** @type {?} */
                  var newCheckedValue = this._dragPercentage > 50;
                  if (newCheckedValue !== this.checked) {
                      this.dragChange.emit();
                      if (!this.defaults.disableDragValue) {
                          this.checked = newCheckedValue;
                          this._emitChangeEvent();
                      }
                  }
                  // The drag should be stopped outside of the current event handler, otherwise the
                  // click event will be fired before it and will revert the drag change.
                  this._ngZone.runOutsideAngular(function () {
                      return setTimeout(function () {
                          if (_this._dragging) {
                              _this._dragging = false;
                              _this._thumbEl.nativeElement.classList.remove('mat-dragging');
                              // Reset the transform because the component will take care
                              // of the thumb position after drag.
                              _this._thumbEl.nativeElement.style.transform = '';
                          }
                      });
                  });
              }
          };
      /** Method being called whenever the label text changes. */
      /**
       * Method being called whenever the label text changes.
       * @return {?}
       */
      MatSlideToggle.prototype._onLabelTextChange = /**
       * Method being called whenever the label text changes.
       * @return {?}
       */
          function () {
              // Since the event of the `cdkObserveContent` directive runs outside of the zone, the
              // slide-toggle component will be only marked for check, but no actual change detection runs
              // automatically. Instead of going back into the zone in order to trigger a change detection
              // which causes *all* components to be checked (if explicitly marked or not using OnPush),
              // we only trigger an explicit change detection for the slide-toggle view and it's children.
              this._changeDetectorRef.detectChanges();
          };
      MatSlideToggle.decorators = [
          { type: core.Component, args: [{ selector: 'mat-slide-toggle',
                      exportAs: 'matSlideToggle',
                      host: {
                          'class': 'mat-slide-toggle',
                          '[id]': 'id',
                          '[attr.tabindex]': '-1',
                          // Needs to be `-1` so it can still receive programmatic focus.
                          '[class.mat-checked]': 'checked',
                          '[class.mat-disabled]': 'disabled',
                          '[class.mat-slide-toggle-label-before]': 'labelPosition == "before"',
                          '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                          '(focus)': '_inputElement.nativeElement.focus()',
                      },
                      template: "<label [attr.for]=\"inputId\" class=\"mat-slide-toggle-label\" #label><div #toggleBar class=\"mat-slide-toggle-bar\" [class.mat-slide-toggle-bar-no-side-margin]=\"!labelContent.textContent || !labelContent.textContent.trim()\"><input #input class=\"mat-slide-toggle-input cdk-visually-hidden\" type=\"checkbox\" role=\"switch\" [id]=\"inputId\" [required]=\"required\" [tabIndex]=\"tabIndex\" [checked]=\"checked\" [disabled]=\"disabled\" [attr.name]=\"name\" [attr.aria-checked]=\"checked.toString()\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledby\" (change)=\"_onChangeEvent($event)\" (click)=\"_onInputClick($event)\"><div class=\"mat-slide-toggle-thumb-container\" #thumbContainer (slidestart)=\"_onDragStart()\" (slide)=\"_onDrag($event)\" (slideend)=\"_onDragEnd()\"><div class=\"mat-slide-toggle-thumb\"></div><div class=\"mat-slide-toggle-ripple\" mat-ripple [matRippleTrigger]=\"label\" [matRippleDisabled]=\"disableRipple || disabled\" [matRippleCentered]=\"true\" [matRippleRadius]=\"20\" [matRippleAnimation]=\"{enterDuration: 150}\"><div class=\"mat-ripple-element mat-slide-toggle-persistent-ripple\"></div></div></div></div><span class=\"mat-slide-toggle-content\" #labelContent (cdkObserveContent)=\"_onLabelTextChange()\"><span style=\"display:none\">&nbsp;</span><ng-content></ng-content></span></label>",
                      styles: [".mat-slide-toggle{display:inline-block;height:24px;max-width:100%;line-height:24px;white-space:nowrap;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(16px,0,0)}[dir=rtl] .mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(-16px,0,0)}.mat-slide-toggle.mat-disabled{opacity:.38}.mat-slide-toggle.mat-disabled .mat-slide-toggle-label,.mat-slide-toggle.mat-disabled .mat-slide-toggle-thumb-container{cursor:default}.mat-slide-toggle-label{display:flex;flex:1;flex-direction:row;align-items:center;height:inherit;cursor:pointer}.mat-slide-toggle-content{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-slide-toggle-label-before .mat-slide-toggle-label{order:1}.mat-slide-toggle-label-before .mat-slide-toggle-bar{order:2}.mat-slide-toggle-bar,[dir=rtl] .mat-slide-toggle-label-before .mat-slide-toggle-bar{margin-right:8px;margin-left:0}.mat-slide-toggle-label-before .mat-slide-toggle-bar,[dir=rtl] .mat-slide-toggle-bar{margin-left:8px;margin-right:0}.mat-slide-toggle-bar-no-side-margin{margin-left:0;margin-right:0}.mat-slide-toggle-thumb-container{position:absolute;z-index:1;width:20px;height:20px;top:-3px;left:0;transform:translate3d(0,0,0);transition:all 80ms linear;transition-property:transform;cursor:-webkit-grab;cursor:grab}.mat-slide-toggle-thumb-container.mat-dragging,.mat-slide-toggle-thumb-container:active{cursor:-webkit-grabbing;cursor:grabbing;transition-duration:0s}._mat-animation-noopable .mat-slide-toggle-thumb-container{transition:none}[dir=rtl] .mat-slide-toggle-thumb-container{left:auto;right:0}.mat-slide-toggle-thumb{height:20px;width:20px;border-radius:50%}.mat-slide-toggle-bar{position:relative;width:36px;height:14px;flex-shrink:0;border-radius:8px}.mat-slide-toggle-input{bottom:0;left:10px}[dir=rtl] .mat-slide-toggle-input{left:auto;right:10px}.mat-slide-toggle-bar,.mat-slide-toggle-thumb{transition:all 80ms linear;transition-property:background-color;transition-delay:50ms}._mat-animation-noopable .mat-slide-toggle-bar,._mat-animation-noopable .mat-slide-toggle-thumb{transition:none}.mat-slide-toggle .mat-slide-toggle-ripple{position:absolute;top:calc(50% - 20px);left:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-slide-toggle .mat-slide-toggle-ripple .mat-ripple-element:not(.mat-slide-toggle-persistent-ripple){opacity:.12}.mat-slide-toggle-persistent-ripple{width:100%;height:100%;transform:none}.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:.04}.mat-slide-toggle:not(.mat-disabled).cdk-focused .mat-slide-toggle-persistent-ripple{opacity:.12}.mat-slide-toggle-persistent-ripple,.mat-slide-toggle.mat-disabled .mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:0}@media (hover:none){.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{display:none}}@media (-ms-high-contrast:active){.mat-slide-toggle-thumb{background:#fff;border:1px solid #000}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb{background:#000;border:1px solid #fff}.mat-slide-toggle-bar{background:#fff}.mat-slide-toggle.cdk-keyboard-focused .mat-slide-toggle-bar{outline:1px dotted;outline-offset:5px}}@media (-ms-high-contrast:black-on-white){.mat-slide-toggle-bar{border:1px solid #000}}"],
                      providers: [MAT_SLIDE_TOGGLE_VALUE_ACCESSOR],
                      inputs: ['disabled', 'disableRipple', 'color', 'tabIndex'],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatSlideToggle.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: Platform },
              { type: FocusMonitor },
              { type: core.ChangeDetectorRef },
              { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] },
              { type: core.NgZone },
              { type: undefined, decorators: [{ type: core.Inject, args: [MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS,] }] },
              { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] },
              { type: Directionality, decorators: [{ type: core.Optional }] }
          ];
      };
      MatSlideToggle.propDecorators = {
          _thumbEl: [{ type: core.ViewChild, args: ['thumbContainer',] }],
          _thumbBarEl: [{ type: core.ViewChild, args: ['toggleBar',] }],
          name: [{ type: core.Input }],
          id: [{ type: core.Input }],
          labelPosition: [{ type: core.Input }],
          ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
          ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],
          required: [{ type: core.Input }],
          checked: [{ type: core.Input }],
          change: [{ type: core.Output }],
          toggleChange: [{ type: core.Output }],
          dragChange: [{ type: core.Output }],
          _inputElement: [{ type: core.ViewChild, args: ['input',] }]
      };
      return MatSlideToggle;
  }(_MatSlideToggleMixinBase));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Visually, a 30px separation between tick marks looks best. This is very subjective but it is
   * the default separation we chose.
   * @type {?}
   */
  var MIN_AUTO_TICK_SEPARATION = 30;
  /**
   * The thumb gap size for a disabled slider.
   * @type {?}
   */
  var DISABLED_THUMB_GAP = 7;
  /**
   * The thumb gap size for a non-active slider at its minimum value.
   * @type {?}
   */
  var MIN_VALUE_NONACTIVE_THUMB_GAP = 7;
  /**
   * The thumb gap size for an active slider at its minimum value.
   * @type {?}
   */
  var MIN_VALUE_ACTIVE_THUMB_GAP = 10;
  /**
   * Provider Expression that allows mat-slider to register as a ControlValueAccessor.
   * This allows it to support [(ngModel)] and [formControl].
   * \@docs-private
   * @type {?}
   */
  var MAT_SLIDER_VALUE_ACCESSOR = {
      provide: forms.NG_VALUE_ACCESSOR,
      useExisting: core.forwardRef(function () { return MatSlider; }),
      multi: true
  };
  /**
   * A simple change event emitted by the MatSlider component.
   */
  var /**
   * A simple change event emitted by the MatSlider component.
   */ MatSliderChange = /** @class */ (function () {
      function MatSliderChange() {
      }
      return MatSliderChange;
  }());
  // Boilerplate for applying mixins to MatSlider.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatSlider.
  /**
   * \@docs-private
   */
  MatSliderBase = /** @class */ (function () {
      function MatSliderBase(_elementRef) {
          this._elementRef = _elementRef;
      }
      return MatSliderBase;
  }());
  /** @type {?} */
  var _MatSliderMixinBase = mixinTabIndex(mixinColor(mixinDisabled(MatSliderBase), 'accent'));
  /**
   * Allows users to select from a range of values by moving the slider thumb. It is similar in
   * behavior to the native `<input type="range">` element.
   */
  var MatSlider = /** @class */ (function (_super) {
      tslib_1.__extends(MatSlider, _super);
      function MatSlider(elementRef, _focusMonitor, _changeDetectorRef, _dir, tabIndex, _animationMode) {
          var _this = _super.call(this, elementRef) || this;
          _this._focusMonitor = _focusMonitor;
          _this._changeDetectorRef = _changeDetectorRef;
          _this._dir = _dir;
          _this._animationMode = _animationMode;
          _this._invert = false;
          _this._max = 100;
          _this._min = 0;
          _this._step = 1;
          _this._thumbLabel = false;
          _this._tickInterval = 0;
          _this._value = null;
          _this._vertical = false;
          /**
           * Event emitted when the slider value has changed.
           */
          _this.change = new core.EventEmitter();
          /**
           * Event emitted when the slider thumb moves.
           */
          _this.input = new core.EventEmitter();
          /**
           * Emits when the raw value of the slider changes. This is here primarily
           * to facilitate the two-way binding for the `value` input.
           * \@docs-private
           */
          _this.valueChange = new core.EventEmitter();
          /**
           * onTouch function registered via registerOnTouch (ControlValueAccessor).
           */
          _this.onTouched = function () { };
          _this._percent = 0;
          /**
           * Whether or not the thumb is sliding.
           * Used to determine if there should be a transition for the thumb and fill track.
           */
          _this._isSliding = false;
          /**
           * Whether or not the slider is active (clicked or sliding).
           * Used to shrink and grow the thumb as according to the Material Design spec.
           */
          _this._isActive = false;
          /**
           * The size of a tick interval as a percentage of the size of the track.
           */
          _this._tickIntervalPercent = 0;
          /**
           * The dimensions of the slider.
           */
          _this._sliderDimensions = null;
          _this._controlValueAccessorChangeFn = function () { };
          /**
           * Subscription to the Directionality change EventEmitter.
           */
          _this._dirChangeSubscription = rxjs.Subscription.EMPTY;
          _this.tabIndex = parseInt(tabIndex) || 0;
          return _this;
      }
      Object.defineProperty(MatSlider.prototype, "invert", {
          /** Whether the slider is inverted. */
          get: /**
           * Whether the slider is inverted.
           * @return {?}
           */ function () { return this._invert; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._invert = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSlider.prototype, "max", {
          /** The maximum value that the slider can have. */
          get: /**
           * The maximum value that the slider can have.
           * @return {?}
           */ function () { return this._max; },
          set: /**
           * @param {?} v
           * @return {?}
           */ function (v) {
              this._max = coerceNumberProperty(v, this._max);
              this._percent = this._calculatePercentage(this._value);
              // Since this also modifies the percentage, we need to let the change detection know.
              this._changeDetectorRef.markForCheck();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSlider.prototype, "min", {
          /** The minimum value that the slider can have. */
          get: /**
           * The minimum value that the slider can have.
           * @return {?}
           */ function () { return this._min; },
          set: /**
           * @param {?} v
           * @return {?}
           */ function (v) {
              this._min = coerceNumberProperty(v, this._min);
              // If the value wasn't explicitly set by the user, set it to the min.
              if (this._value === null) {
                  this.value = this._min;
              }
              this._percent = this._calculatePercentage(this._value);
              // Since this also modifies the percentage, we need to let the change detection know.
              this._changeDetectorRef.markForCheck();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSlider.prototype, "step", {
          /** The values at which the thumb will snap. */
          get: /**
           * The values at which the thumb will snap.
           * @return {?}
           */ function () { return this._step; },
          set: /**
           * @param {?} v
           * @return {?}
           */ function (v) {
              this._step = coerceNumberProperty(v, this._step);
              if (this._step % 1 !== 0) {
                  this._roundToDecimal = ( /** @type {?} */(this._step.toString().split('.').pop())).length;
              }
              // Since this could modify the label, we need to notify the change detection.
              this._changeDetectorRef.markForCheck();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSlider.prototype, "thumbLabel", {
          /** Whether or not to show the thumb label. */
          get: /**
           * Whether or not to show the thumb label.
           * @return {?}
           */ function () { return this._thumbLabel; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._thumbLabel = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSlider.prototype, "tickInterval", {
          /**
           * How often to show ticks. Relative to the step so that a tick always appears on a step.
           * Ex: Tick interval of 4 with a step of 3 will draw a tick every 4 steps (every 12 values).
           */
          get: /**
           * How often to show ticks. Relative to the step so that a tick always appears on a step.
           * Ex: Tick interval of 4 with a step of 3 will draw a tick every 4 steps (every 12 values).
           * @return {?}
           */ function () { return this._tickInterval; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (value === 'auto') {
                  this._tickInterval = 'auto';
              }
              else if (typeof value === 'number' || typeof value === 'string') {
                  this._tickInterval = coerceNumberProperty(value, ( /** @type {?} */(this._tickInterval)));
              }
              else {
                  this._tickInterval = 0;
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSlider.prototype, "value", {
          /** Value of the slider. */
          get: /**
           * Value of the slider.
           * @return {?}
           */ function () {
              // If the value needs to be read and it is still uninitialized, initialize it to the min.
              if (this._value === null) {
                  this.value = this._min;
              }
              return this._value;
          },
          set: /**
           * @param {?} v
           * @return {?}
           */ function (v) {
              if (v !== this._value) {
                  /** @type {?} */
                  var value = coerceNumberProperty(v);
                  // While incrementing by a decimal we can end up with values like 33.300000000000004.
                  // Truncate it to ensure that it matches the label and to make it easier to work with.
                  if (this._roundToDecimal) {
                      value = parseFloat(value.toFixed(this._roundToDecimal));
                  }
                  this._value = value;
                  this._percent = this._calculatePercentage(this._value);
                  // Since this also modifies the percentage, we need to let the change detection know.
                  this._changeDetectorRef.markForCheck();
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSlider.prototype, "vertical", {
          /** Whether the slider is vertical. */
          get: /**
           * Whether the slider is vertical.
           * @return {?}
           */ function () { return this._vertical; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._vertical = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSlider.prototype, "displayValue", {
          /** The value to be used for display purposes. */
          get: /**
           * The value to be used for display purposes.
           * @return {?}
           */ function () {
              if (this.displayWith) {
                  return this.displayWith(this.value);
              }
              // Note that this could be improved further by rounding something like 0.999 to 1 or
              // 0.899 to 0.9, however it is very performance sensitive, because it gets called on
              // every change detection cycle.
              if (this._roundToDecimal && this.value && this.value % 1 !== 0) {
                  return this.value.toFixed(this._roundToDecimal);
              }
              return this.value || 0;
          },
          enumerable: true,
          configurable: true
      });
      /** set focus to the host element */
      /**
       * set focus to the host element
       * @return {?}
       */
      MatSlider.prototype.focus = /**
       * set focus to the host element
       * @return {?}
       */
          function () {
              this._focusHostElement();
          };
      /** blur the host element */
      /**
       * blur the host element
       * @return {?}
       */
      MatSlider.prototype.blur = /**
       * blur the host element
       * @return {?}
       */
          function () {
              this._blurHostElement();
          };
      Object.defineProperty(MatSlider.prototype, "percent", {
          /** The percentage of the slider that coincides with the value. */
          get: /**
           * The percentage of the slider that coincides with the value.
           * @return {?}
           */ function () { return this._clamp(this._percent); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSlider.prototype, "_invertAxis", {
          /**
           * Whether the axis of the slider is inverted.
           * (i.e. whether moving the thumb in the positive x or y direction decreases the slider's value).
           */
          get: /**
           * Whether the axis of the slider is inverted.
           * (i.e. whether moving the thumb in the positive x or y direction decreases the slider's value).
           * @return {?}
           */ function () {
              // Standard non-inverted mode for a vertical slider should be dragging the thumb from bottom to
              // top. However from a y-axis standpoint this is inverted.
              return this.vertical ? !this.invert : this.invert;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSlider.prototype, "_isMinValue", {
          /** Whether the slider is at its minimum value. */
          get: /**
           * Whether the slider is at its minimum value.
           * @return {?}
           */ function () {
              return this.percent === 0;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSlider.prototype, "_thumbGap", {
          /**
           * The amount of space to leave between the slider thumb and the track fill & track background
           * elements.
           */
          get: /**
           * The amount of space to leave between the slider thumb and the track fill & track background
           * elements.
           * @return {?}
           */ function () {
              if (this.disabled) {
                  return DISABLED_THUMB_GAP;
              }
              if (this._isMinValue && !this.thumbLabel) {
                  return this._isActive ? MIN_VALUE_ACTIVE_THUMB_GAP : MIN_VALUE_NONACTIVE_THUMB_GAP;
              }
              return 0;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSlider.prototype, "_trackBackgroundStyles", {
          /** CSS styles for the track background element. */
          get: /**
           * CSS styles for the track background element.
           * @return {?}
           */ function () {
              /** @type {?} */
              var axis = this.vertical ? 'Y' : 'X';
              /** @type {?} */
              var scale = this.vertical ? "1, " + (1 - this.percent) + ", 1" : 1 - this.percent + ", 1, 1";
              /** @type {?} */
              var sign = this._shouldInvertMouseCoords() ? '-' : '';
              return {
                  // scale3d avoids some rendering issues in Chrome. See #12071.
                  transform: "translate" + axis + "(" + sign + this._thumbGap + "px) scale3d(" + scale + ")"
              };
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSlider.prototype, "_trackFillStyles", {
          /** CSS styles for the track fill element. */
          get: /**
           * CSS styles for the track fill element.
           * @return {?}
           */ function () {
              /** @type {?} */
              var axis = this.vertical ? 'Y' : 'X';
              /** @type {?} */
              var scale = this.vertical ? "1, " + this.percent + ", 1" : this.percent + ", 1, 1";
              /** @type {?} */
              var sign = this._shouldInvertMouseCoords() ? '' : '-';
              return {
                  // scale3d avoids some rendering issues in Chrome. See #12071.
                  transform: "translate" + axis + "(" + sign + this._thumbGap + "px) scale3d(" + scale + ")"
              };
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSlider.prototype, "_ticksContainerStyles", {
          /** CSS styles for the ticks container element. */
          get: /**
           * CSS styles for the ticks container element.
           * @return {?}
           */ function () {
              /** @type {?} */
              var axis = this.vertical ? 'Y' : 'X';
              // For a horizontal slider in RTL languages we push the ticks container off the left edge
              // instead of the right edge to avoid causing a horizontal scrollbar to appear.
              /** @type {?} */
              var sign = !this.vertical && this._getDirection() == 'rtl' ? '' : '-';
              /** @type {?} */
              var offset = this._tickIntervalPercent / 2 * 100;
              return {
                  'transform': "translate" + axis + "(" + sign + offset + "%)"
              };
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSlider.prototype, "_ticksStyles", {
          /** CSS styles for the ticks element. */
          get: /**
           * CSS styles for the ticks element.
           * @return {?}
           */ function () {
              /** @type {?} */
              var tickSize = this._tickIntervalPercent * 100;
              /** @type {?} */
              var backgroundSize = this.vertical ? "2px " + tickSize + "%" : tickSize + "% 2px";
              /** @type {?} */
              var axis = this.vertical ? 'Y' : 'X';
              // Depending on the direction we pushed the ticks container, push the ticks the opposite
              // direction to re-center them but clip off the end edge. In RTL languages we need to flip the
              // ticks 180 degrees so we're really cutting off the end edge abd not the start.
              /** @type {?} */
              var sign = !this.vertical && this._getDirection() == 'rtl' ? '-' : '';
              /** @type {?} */
              var rotate = !this.vertical && this._getDirection() == 'rtl' ? ' rotate(180deg)' : '';
              /** @type {?} */
              var styles = {
                  'backgroundSize': backgroundSize,
                  // Without translateZ ticks sometimes jitter as the slider moves on Chrome & Firefox.
                  'transform': "translateZ(0) translate" + axis + "(" + sign + tickSize / 2 + "%)" + rotate
              };
              if (this._isMinValue && this._thumbGap) {
                  /** @type {?} */
                  var side = this.vertical ?
                      (this._invertAxis ? 'Bottom' : 'Top') :
                      (this._invertAxis ? 'Right' : 'Left');
                  styles["padding" + side] = this._thumbGap + "px";
              }
              return styles;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSlider.prototype, "_thumbContainerStyles", {
          get: /**
           * @return {?}
           */ function () {
              /** @type {?} */
              var axis = this.vertical ? 'Y' : 'X';
              // For a horizontal slider in RTL languages we push the thumb container off the left edge
              // instead of the right edge to avoid causing a horizontal scrollbar to appear.
              /** @type {?} */
              var invertOffset = (this._getDirection() == 'rtl' && !this.vertical) ? !this._invertAxis : this._invertAxis;
              /** @type {?} */
              var offset = (invertOffset ? this.percent : 1 - this.percent) * 100;
              return {
                  'transform': "translate" + axis + "(-" + offset + "%)"
              };
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Whether mouse events should be converted to a slider position by calculating their distance
       * from the right or bottom edge of the slider as opposed to the top or left.
       */
      /**
       * Whether mouse events should be converted to a slider position by calculating their distance
       * from the right or bottom edge of the slider as opposed to the top or left.
       * @private
       * @return {?}
       */
      MatSlider.prototype._shouldInvertMouseCoords = /**
       * Whether mouse events should be converted to a slider position by calculating their distance
       * from the right or bottom edge of the slider as opposed to the top or left.
       * @private
       * @return {?}
       */
          function () {
              return (this._getDirection() == 'rtl' && !this.vertical) ? !this._invertAxis : this._invertAxis;
          };
      /** The language direction for this slider element. */
      /**
       * The language direction for this slider element.
       * @private
       * @return {?}
       */
      MatSlider.prototype._getDirection = /**
       * The language direction for this slider element.
       * @private
       * @return {?}
       */
          function () {
              return (this._dir && this._dir.value == 'rtl') ? 'rtl' : 'ltr';
          };
      /**
       * @return {?}
       */
      MatSlider.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._focusMonitor
                  .monitor(this._elementRef, true)
                  .subscribe(function (origin) {
                  _this._isActive = !!origin && origin !== 'keyboard';
                  _this._changeDetectorRef.detectChanges();
              });
              if (this._dir) {
                  this._dirChangeSubscription = this._dir.change.subscribe(function () {
                      _this._changeDetectorRef.markForCheck();
                  });
              }
          };
      /**
       * @return {?}
       */
      MatSlider.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._focusMonitor.stopMonitoring(this._elementRef);
              this._dirChangeSubscription.unsubscribe();
          };
      /**
       * @return {?}
       */
      MatSlider.prototype._onMouseenter = /**
       * @return {?}
       */
          function () {
              if (this.disabled) {
                  return;
              }
              // We save the dimensions of the slider here so we can use them to update the spacing of the
              // ticks and determine where on the slider click and slide events happen.
              this._sliderDimensions = this._getSliderDimensions();
              this._updateTickIntervalPercent();
          };
      /**
       * @param {?} event
       * @return {?}
       */
      MatSlider.prototype._onMousedown = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              // Don't do anything if the slider is disabled or the
              // user is using anything other than the main mouse button.
              if (this.disabled || event.button !== 0) {
                  return;
              }
              /** @type {?} */
              var oldValue = this.value;
              this._isSliding = false;
              this._focusHostElement();
              this._updateValueFromPosition({ x: event.clientX, y: event.clientY });
              // Emit a change and input event if the value changed.
              if (oldValue != this.value) {
                  this._emitInputEvent();
                  this._emitChangeEvent();
              }
          };
      /**
       * @param {?} event
       * @return {?}
       */
      MatSlider.prototype._onSlide = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (this.disabled) {
                  return;
              }
              // The slide start event sometimes fails to fire on iOS, so if we're not already in the sliding
              // state, call the slide start handler manually.
              if (!this._isSliding) {
                  this._onSlideStart(null);
              }
              // Prevent the slide from selecting anything else.
              event.preventDefault();
              /** @type {?} */
              var oldValue = this.value;
              this._updateValueFromPosition({ x: event.center.x, y: event.center.y });
              // Native range elements always emit `input` events when the value changed while sliding.
              if (oldValue != this.value) {
                  this._emitInputEvent();
              }
          };
      /**
       * @param {?} event
       * @return {?}
       */
      MatSlider.prototype._onSlideStart = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (this.disabled || this._isSliding) {
                  return;
              }
              // Simulate mouseenter in case this is a mobile device.
              this._onMouseenter();
              this._isSliding = true;
              this._focusHostElement();
              this._valueOnSlideStart = this.value;
              if (event) {
                  this._updateValueFromPosition({ x: event.center.x, y: event.center.y });
                  event.preventDefault();
              }
          };
      /**
       * @return {?}
       */
      MatSlider.prototype._onSlideEnd = /**
       * @return {?}
       */
          function () {
              this._isSliding = false;
              if (this._valueOnSlideStart != this.value && !this.disabled) {
                  this._emitChangeEvent();
              }
              this._valueOnSlideStart = null;
          };
      /**
       * @return {?}
       */
      MatSlider.prototype._onFocus = /**
       * @return {?}
       */
          function () {
              // We save the dimensions of the slider here so we can use them to update the spacing of the
              // ticks and determine where on the slider click and slide events happen.
              this._sliderDimensions = this._getSliderDimensions();
              this._updateTickIntervalPercent();
          };
      /**
       * @return {?}
       */
      MatSlider.prototype._onBlur = /**
       * @return {?}
       */
          function () {
              this.onTouched();
          };
      /**
       * @param {?} event
       * @return {?}
       */
      MatSlider.prototype._onKeydown = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              if (this.disabled || hasModifierKey(event)) {
                  return;
              }
              /** @type {?} */
              var oldValue = this.value;
              switch (event.keyCode) {
                  case PAGE_UP:
                      this._increment(10);
                      break;
                  case PAGE_DOWN:
                      this._increment(-10);
                      break;
                  case END:
                      this.value = this.max;
                      break;
                  case HOME:
                      this.value = this.min;
                      break;
                  case LEFT_ARROW:
                      // NOTE: For a sighted user it would make more sense that when they press an arrow key on an
                      // inverted slider the thumb moves in that direction. However for a blind user, nothing
                      // about the slider indicates that it is inverted. They will expect left to be decrement,
                      // regardless of how it appears on the screen. For speakers ofRTL languages, they probably
                      // expect left to mean increment. Therefore we flip the meaning of the side arrow keys for
                      // RTL. For inverted sliders we prefer a good a11y experience to having it "look right" for
                      // sighted users, therefore we do not swap the meaning.
                      this._increment(this._getDirection() == 'rtl' ? 1 : -1);
                      break;
                  case UP_ARROW:
                      this._increment(1);
                      break;
                  case RIGHT_ARROW:
                      // See comment on LEFT_ARROW about the conditions under which we flip the meaning.
                      this._increment(this._getDirection() == 'rtl' ? -1 : 1);
                      break;
                  case DOWN_ARROW:
                      this._increment(-1);
                      break;
                  default:
                      // Return if the key is not one that we explicitly handle to avoid calling preventDefault on
                      // it.
                      return;
              }
              if (oldValue != this.value) {
                  this._emitInputEvent();
                  this._emitChangeEvent();
              }
              this._isSliding = true;
              event.preventDefault();
          };
      /**
       * @return {?}
       */
      MatSlider.prototype._onKeyup = /**
       * @return {?}
       */
          function () {
              this._isSliding = false;
          };
      /** Increments the slider by the given number of steps (negative number decrements). */
      /**
       * Increments the slider by the given number of steps (negative number decrements).
       * @private
       * @param {?} numSteps
       * @return {?}
       */
      MatSlider.prototype._increment = /**
       * Increments the slider by the given number of steps (negative number decrements).
       * @private
       * @param {?} numSteps
       * @return {?}
       */
          function (numSteps) {
              this.value = this._clamp((this.value || 0) + this.step * numSteps, this.min, this.max);
          };
      /** Calculate the new value from the new physical location. The value will always be snapped. */
      /**
       * Calculate the new value from the new physical location. The value will always be snapped.
       * @private
       * @param {?} pos
       * @return {?}
       */
      MatSlider.prototype._updateValueFromPosition = /**
       * Calculate the new value from the new physical location. The value will always be snapped.
       * @private
       * @param {?} pos
       * @return {?}
       */
          function (pos) {
              if (!this._sliderDimensions) {
                  return;
              }
              /** @type {?} */
              var offset = this.vertical ? this._sliderDimensions.top : this._sliderDimensions.left;
              /** @type {?} */
              var size = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;
              /** @type {?} */
              var posComponent = this.vertical ? pos.y : pos.x;
              // The exact value is calculated from the event and used to find the closest snap value.
              /** @type {?} */
              var percent = this._clamp((posComponent - offset) / size);
              if (this._shouldInvertMouseCoords()) {
                  percent = 1 - percent;
              }
              // Since the steps may not divide cleanly into the max value, if the user
              // slid to 0 or 100 percent, we jump to the min/max value. This approach
              // is slightly more intuitive than using `Math.ceil` below, because it
              // follows the user's pointer closer.
              if (percent === 0) {
                  this.value = this.min;
              }
              else if (percent === 1) {
                  this.value = this.max;
              }
              else {
                  /** @type {?} */
                  var exactValue = this._calculateValue(percent);
                  // This calculation finds the closest step by finding the closest
                  // whole number divisible by the step relative to the min.
                  /** @type {?} */
                  var closestValue = Math.round((exactValue - this.min) / this.step) * this.step + this.min;
                  // The value needs to snap to the min and max.
                  this.value = this._clamp(closestValue, this.min, this.max);
              }
          };
      /** Emits a change event if the current value is different from the last emitted value. */
      /**
       * Emits a change event if the current value is different from the last emitted value.
       * @private
       * @return {?}
       */
      MatSlider.prototype._emitChangeEvent = /**
       * Emits a change event if the current value is different from the last emitted value.
       * @private
       * @return {?}
       */
          function () {
              this._controlValueAccessorChangeFn(this.value);
              this.valueChange.emit(this.value);
              this.change.emit(this._createChangeEvent());
          };
      /** Emits an input event when the current value is different from the last emitted value. */
      /**
       * Emits an input event when the current value is different from the last emitted value.
       * @private
       * @return {?}
       */
      MatSlider.prototype._emitInputEvent = /**
       * Emits an input event when the current value is different from the last emitted value.
       * @private
       * @return {?}
       */
          function () {
              this.input.emit(this._createChangeEvent());
          };
      /** Updates the amount of space between ticks as a percentage of the width of the slider. */
      /**
       * Updates the amount of space between ticks as a percentage of the width of the slider.
       * @private
       * @return {?}
       */
      MatSlider.prototype._updateTickIntervalPercent = /**
       * Updates the amount of space between ticks as a percentage of the width of the slider.
       * @private
       * @return {?}
       */
          function () {
              if (!this.tickInterval || !this._sliderDimensions) {
                  return;
              }
              if (this.tickInterval == 'auto') {
                  /** @type {?} */
                  var trackSize = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;
                  /** @type {?} */
                  var pixelsPerStep = trackSize * this.step / (this.max - this.min);
                  /** @type {?} */
                  var stepsPerTick = Math.ceil(MIN_AUTO_TICK_SEPARATION / pixelsPerStep);
                  /** @type {?} */
                  var pixelsPerTick = stepsPerTick * this.step;
                  this._tickIntervalPercent = pixelsPerTick / trackSize;
              }
              else {
                  this._tickIntervalPercent = this.tickInterval * this.step / (this.max - this.min);
              }
          };
      /** Creates a slider change object from the specified value. */
      /**
       * Creates a slider change object from the specified value.
       * @private
       * @param {?=} value
       * @return {?}
       */
      MatSlider.prototype._createChangeEvent = /**
       * Creates a slider change object from the specified value.
       * @private
       * @param {?=} value
       * @return {?}
       */
          function (value) {
              if (value === void 0) {
                  value = this.value;
              }
              /** @type {?} */
              var event = new MatSliderChange();
              event.source = this;
              event.value = value;
              return event;
          };
      /** Calculates the percentage of the slider that a value is. */
      /**
       * Calculates the percentage of the slider that a value is.
       * @private
       * @param {?} value
       * @return {?}
       */
      MatSlider.prototype._calculatePercentage = /**
       * Calculates the percentage of the slider that a value is.
       * @private
       * @param {?} value
       * @return {?}
       */
          function (value) {
              return ((value || 0) - this.min) / (this.max - this.min);
          };
      /** Calculates the value a percentage of the slider corresponds to. */
      /**
       * Calculates the value a percentage of the slider corresponds to.
       * @private
       * @param {?} percentage
       * @return {?}
       */
      MatSlider.prototype._calculateValue = /**
       * Calculates the value a percentage of the slider corresponds to.
       * @private
       * @param {?} percentage
       * @return {?}
       */
          function (percentage) {
              return this.min + percentage * (this.max - this.min);
          };
      /** Return a number between two numbers. */
      /**
       * Return a number between two numbers.
       * @private
       * @param {?} value
       * @param {?=} min
       * @param {?=} max
       * @return {?}
       */
      MatSlider.prototype._clamp = /**
       * Return a number between two numbers.
       * @private
       * @param {?} value
       * @param {?=} min
       * @param {?=} max
       * @return {?}
       */
          function (value, min, max) {
              if (min === void 0) {
                  min = 0;
              }
              if (max === void 0) {
                  max = 1;
              }
              return Math.max(min, Math.min(value, max));
          };
      /**
       * Get the bounding client rect of the slider track element.
       * The track is used rather than the native element to ignore the extra space that the thumb can
       * take up.
       */
      /**
       * Get the bounding client rect of the slider track element.
       * The track is used rather than the native element to ignore the extra space that the thumb can
       * take up.
       * @private
       * @return {?}
       */
      MatSlider.prototype._getSliderDimensions = /**
       * Get the bounding client rect of the slider track element.
       * The track is used rather than the native element to ignore the extra space that the thumb can
       * take up.
       * @private
       * @return {?}
       */
          function () {
              return this._sliderWrapper ? this._sliderWrapper.nativeElement.getBoundingClientRect() : null;
          };
      /**
       * Focuses the native element.
       * Currently only used to allow a blur event to fire but will be used with keyboard input later.
       */
      /**
       * Focuses the native element.
       * Currently only used to allow a blur event to fire but will be used with keyboard input later.
       * @private
       * @return {?}
       */
      MatSlider.prototype._focusHostElement = /**
       * Focuses the native element.
       * Currently only used to allow a blur event to fire but will be used with keyboard input later.
       * @private
       * @return {?}
       */
          function () {
              this._elementRef.nativeElement.focus();
          };
      /** Blurs the native element. */
      /**
       * Blurs the native element.
       * @private
       * @return {?}
       */
      MatSlider.prototype._blurHostElement = /**
       * Blurs the native element.
       * @private
       * @return {?}
       */
          function () {
              this._elementRef.nativeElement.blur();
          };
      /**
       * Sets the model value. Implemented as part of ControlValueAccessor.
       * @param value
       */
      /**
       * Sets the model value. Implemented as part of ControlValueAccessor.
       * @param {?} value
       * @return {?}
       */
      MatSlider.prototype.writeValue = /**
       * Sets the model value. Implemented as part of ControlValueAccessor.
       * @param {?} value
       * @return {?}
       */
          function (value) {
              this.value = value;
          };
      /**
       * Registers a callback to be triggered when the value has changed.
       * Implemented as part of ControlValueAccessor.
       * @param fn Callback to be registered.
       */
      /**
       * Registers a callback to be triggered when the value has changed.
       * Implemented as part of ControlValueAccessor.
       * @param {?} fn Callback to be registered.
       * @return {?}
       */
      MatSlider.prototype.registerOnChange = /**
       * Registers a callback to be triggered when the value has changed.
       * Implemented as part of ControlValueAccessor.
       * @param {?} fn Callback to be registered.
       * @return {?}
       */
          function (fn) {
              this._controlValueAccessorChangeFn = fn;
          };
      /**
       * Registers a callback to be triggered when the component is touched.
       * Implemented as part of ControlValueAccessor.
       * @param fn Callback to be registered.
       */
      /**
       * Registers a callback to be triggered when the component is touched.
       * Implemented as part of ControlValueAccessor.
       * @param {?} fn Callback to be registered.
       * @return {?}
       */
      MatSlider.prototype.registerOnTouched = /**
       * Registers a callback to be triggered when the component is touched.
       * Implemented as part of ControlValueAccessor.
       * @param {?} fn Callback to be registered.
       * @return {?}
       */
          function (fn) {
              this.onTouched = fn;
          };
      /**
       * Sets whether the component should be disabled.
       * Implemented as part of ControlValueAccessor.
       * @param isDisabled
       */
      /**
       * Sets whether the component should be disabled.
       * Implemented as part of ControlValueAccessor.
       * @param {?} isDisabled
       * @return {?}
       */
      MatSlider.prototype.setDisabledState = /**
       * Sets whether the component should be disabled.
       * Implemented as part of ControlValueAccessor.
       * @param {?} isDisabled
       * @return {?}
       */
          function (isDisabled) {
              this.disabled = isDisabled;
          };
      MatSlider.decorators = [
          { type: core.Component, args: [{ selector: 'mat-slider',
                      exportAs: 'matSlider',
                      providers: [MAT_SLIDER_VALUE_ACCESSOR],
                      host: {
                          '(focus)': '_onFocus()',
                          '(blur)': '_onBlur()',
                          '(mousedown)': '_onMousedown($event)',
                          '(keydown)': '_onKeydown($event)',
                          '(keyup)': '_onKeyup()',
                          '(mouseenter)': '_onMouseenter()',
                          '(slide)': '_onSlide($event)',
                          '(slideend)': '_onSlideEnd()',
                          '(slidestart)': '_onSlideStart($event)',
                          'class': 'mat-slider',
                          'role': 'slider',
                          '[tabIndex]': 'tabIndex',
                          '[attr.aria-disabled]': 'disabled',
                          '[attr.aria-valuemax]': 'max',
                          '[attr.aria-valuemin]': 'min',
                          '[attr.aria-valuenow]': 'value',
                          '[attr.aria-orientation]': 'vertical ? "vertical" : "horizontal"',
                          '[class.mat-slider-disabled]': 'disabled',
                          '[class.mat-slider-has-ticks]': 'tickInterval',
                          '[class.mat-slider-horizontal]': '!vertical',
                          '[class.mat-slider-axis-inverted]': '_invertAxis',
                          '[class.mat-slider-sliding]': '_isSliding',
                          '[class.mat-slider-thumb-label-showing]': 'thumbLabel',
                          '[class.mat-slider-vertical]': 'vertical',
                          '[class.mat-slider-min-value]': '_isMinValue',
                          '[class.mat-slider-hide-last-tick]': 'disabled || _isMinValue && _thumbGap && _invertAxis',
                          '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                      },
                      template: "<div class=\"mat-slider-wrapper\" #sliderWrapper><div class=\"mat-slider-track-wrapper\"><div class=\"mat-slider-track-background\" [ngStyle]=\"_trackBackgroundStyles\"></div><div class=\"mat-slider-track-fill\" [ngStyle]=\"_trackFillStyles\"></div></div><div class=\"mat-slider-ticks-container\" [ngStyle]=\"_ticksContainerStyles\"><div class=\"mat-slider-ticks\" [ngStyle]=\"_ticksStyles\"></div></div><div class=\"mat-slider-thumb-container\" [ngStyle]=\"_thumbContainerStyles\"><div class=\"mat-slider-focus-ring\"></div><div class=\"mat-slider-thumb\"></div><div class=\"mat-slider-thumb-label\"><span class=\"mat-slider-thumb-label-text\">{{displayValue}}</span></div></div></div>",
                      styles: [".mat-slider{display:inline-block;position:relative;box-sizing:border-box;padding:8px;outline:0;vertical-align:middle}.mat-slider-wrapper{position:absolute}.mat-slider-track-wrapper{position:absolute;top:0;left:0;overflow:hidden}.mat-slider-track-fill{position:absolute;transform-origin:0 0;transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-track-background{position:absolute;transform-origin:100% 100%;transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-ticks-container{position:absolute;left:0;top:0;overflow:hidden}.mat-slider-ticks{background-repeat:repeat;background-clip:content-box;box-sizing:border-box;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb-container{position:absolute;z-index:1;transition:transform .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-focus-ring{position:absolute;width:30px;height:30px;border-radius:50%;transform:scale(0);opacity:0;transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1),opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider.cdk-keyboard-focused .mat-slider-focus-ring,.mat-slider.cdk-program-focused .mat-slider-focus-ring{transform:scale(1);opacity:1}.mat-slider:not(.mat-slider-disabled) .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled) .mat-slider-thumb-label{cursor:-webkit-grab;cursor:grab}.mat-slider-sliding:not(.mat-slider-disabled) .mat-slider-thumb,.mat-slider-sliding:not(.mat-slider-disabled) .mat-slider-thumb-label,.mat-slider:not(.mat-slider-disabled) .mat-slider-thumb-label:active,.mat-slider:not(.mat-slider-disabled) .mat-slider-thumb:active{cursor:-webkit-grabbing;cursor:grabbing}.mat-slider-thumb{position:absolute;right:-10px;bottom:-10px;box-sizing:border-box;width:20px;height:20px;border:3px solid transparent;border-radius:50%;transform:scale(.7);transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1),border-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb-label{display:none;align-items:center;justify-content:center;position:absolute;width:28px;height:28px;border-radius:50%;transition:transform .4s cubic-bezier(.25,.8,.25,1),border-radius .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}@media (-ms-high-contrast:active){.mat-slider-thumb-label{outline:solid 1px}}.mat-slider-thumb-label-text{z-index:1;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-sliding .mat-slider-thumb-container,.mat-slider-sliding .mat-slider-track-background,.mat-slider-sliding .mat-slider-track-fill{transition-duration:0s}.mat-slider-has-ticks .mat-slider-wrapper::after{content:'';position:absolute;border-width:0;border-style:solid;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after,.mat-slider-has-ticks:hover:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after{opacity:1}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-disabled) .mat-slider-ticks,.mat-slider-has-ticks:hover:not(.mat-slider-disabled) .mat-slider-ticks{opacity:1}.mat-slider-thumb-label-showing .mat-slider-focus-ring{display:none}.mat-slider-thumb-label-showing .mat-slider-thumb-label{display:flex}.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:100% 100%}.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:0 0}.mat-slider:not(.mat-slider-disabled).cdk-focused.mat-slider-thumb-label-showing .mat-slider-thumb{transform:scale(0)}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label{border-radius:50% 50% 0}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label-text{opacity:1}.mat-slider:not(.mat-slider-disabled).cdk-mouse-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-program-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-touch-focused .mat-slider-thumb{border-width:2px;transform:scale(1)}.mat-slider-disabled .mat-slider-focus-ring{transform:scale(0);opacity:0}.mat-slider-disabled .mat-slider-thumb{border-width:4px;transform:scale(.5)}.mat-slider-disabled .mat-slider-thumb-label{display:none}.mat-slider-horizontal{height:48px;min-width:128px}.mat-slider-horizontal .mat-slider-wrapper{height:2px;top:23px;left:8px;right:8px}.mat-slider-horizontal .mat-slider-wrapper::after{height:2px;border-left-width:2px;right:0;top:0}.mat-slider-horizontal .mat-slider-track-wrapper{height:2px;width:100%}.mat-slider-horizontal .mat-slider-track-fill{height:2px;width:100%;transform:scaleX(0)}.mat-slider-horizontal .mat-slider-track-background{height:2px;width:100%;transform:scaleX(1)}.mat-slider-horizontal .mat-slider-ticks-container{height:2px;width:100%}@media (-ms-high-contrast:active){.mat-slider-horizontal .mat-slider-ticks-container{height:0;outline:solid 2px;top:1px}}.mat-slider-horizontal .mat-slider-ticks{height:2px;width:100%}.mat-slider-horizontal .mat-slider-thumb-container{width:100%;height:0;top:50%}.mat-slider-horizontal .mat-slider-focus-ring{top:-15px;right:-15px}.mat-slider-horizontal .mat-slider-thumb-label{right:-14px;top:-40px;transform:translateY(26px) scale(.01) rotate(45deg)}.mat-slider-horizontal .mat-slider-thumb-label-text{transform:rotate(-45deg)}.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label{transform:rotate(45deg)}@media (-ms-high-contrast:active){.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label,.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label-text{transform:none}}.mat-slider-vertical{width:48px;min-height:128px}.mat-slider-vertical .mat-slider-wrapper{width:2px;top:8px;bottom:8px;left:23px}.mat-slider-vertical .mat-slider-wrapper::after{width:2px;border-top-width:2px;bottom:0;left:0}.mat-slider-vertical .mat-slider-track-wrapper{height:100%;width:2px}.mat-slider-vertical .mat-slider-track-fill{height:100%;width:2px;transform:scaleY(0)}.mat-slider-vertical .mat-slider-track-background{height:100%;width:2px;transform:scaleY(1)}.mat-slider-vertical .mat-slider-ticks-container{width:2px;height:100%}@media (-ms-high-contrast:active){.mat-slider-vertical .mat-slider-ticks-container{width:0;outline:solid 2px;left:1px}}.mat-slider-vertical .mat-slider-focus-ring{bottom:-15px;left:-15px}.mat-slider-vertical .mat-slider-ticks{width:2px;height:100%}.mat-slider-vertical .mat-slider-thumb-container{height:100%;width:0;left:50%}.mat-slider-vertical .mat-slider-thumb{-webkit-backface-visibility:hidden;backface-visibility:hidden}.mat-slider-vertical .mat-slider-thumb-label{bottom:-14px;left:-40px;transform:translateX(26px) scale(.01) rotate(-45deg)}.mat-slider-vertical .mat-slider-thumb-label-text{transform:rotate(45deg)}.mat-slider-vertical.cdk-focused .mat-slider-thumb-label{transform:rotate(-45deg)}[dir=rtl] .mat-slider-wrapper::after{left:0;right:auto}[dir=rtl] .mat-slider-horizontal .mat-slider-track-fill{transform-origin:100% 100%}[dir=rtl] .mat-slider-horizontal .mat-slider-track-background{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:100% 100%}.mat-slider._mat-animation-noopable .mat-slider-focus-ring,.mat-slider._mat-animation-noopable .mat-slider-has-ticks .mat-slider-wrapper::after,.mat-slider._mat-animation-noopable .mat-slider-thumb,.mat-slider._mat-animation-noopable .mat-slider-thumb-container,.mat-slider._mat-animation-noopable .mat-slider-thumb-label,.mat-slider._mat-animation-noopable .mat-slider-thumb-label-text,.mat-slider._mat-animation-noopable .mat-slider-ticks,.mat-slider._mat-animation-noopable .mat-slider-track-background,.mat-slider._mat-animation-noopable .mat-slider-track-fill{transition:none}"],
                      inputs: ['disabled', 'color', 'tabIndex'],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatSlider.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: FocusMonitor },
              { type: core.ChangeDetectorRef },
              { type: Directionality, decorators: [{ type: core.Optional }] },
              { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] },
              { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] }
          ];
      };
      MatSlider.propDecorators = {
          invert: [{ type: core.Input }],
          max: [{ type: core.Input }],
          min: [{ type: core.Input }],
          step: [{ type: core.Input }],
          thumbLabel: [{ type: core.Input }],
          tickInterval: [{ type: core.Input }],
          value: [{ type: core.Input }],
          displayWith: [{ type: core.Input }],
          vertical: [{ type: core.Input }],
          change: [{ type: core.Output }],
          input: [{ type: core.Output }],
          valueChange: [{ type: core.Output }],
          _sliderWrapper: [{ type: core.ViewChild, args: ['sliderWrapper',] }]
      };
      return MatSlider;
  }(_MatSliderMixinBase));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Reference to a snack bar dispatched from the snack bar service.
   * @template T
   */
  var /**
   * Reference to a snack bar dispatched from the snack bar service.
   * @template T
   */ MatSnackBarRef = /** @class */ (function () {
      function MatSnackBarRef(containerInstance, _overlayRef) {
          var _this = this;
          this._overlayRef = _overlayRef;
          /**
           * Subject for notifying the user that the snack bar has been dismissed.
           */
          this._afterDismissed = new rxjs.Subject();
          /**
           * Subject for notifying the user that the snack bar has opened and appeared.
           */
          this._afterOpened = new rxjs.Subject();
          /**
           * Subject for notifying the user that the snack bar action was called.
           */
          this._onAction = new rxjs.Subject();
          /**
           * Whether the snack bar was dismissed using the action button.
           */
          this._dismissedByAction = false;
          this.containerInstance = containerInstance;
          // Dismiss snackbar on action.
          this.onAction().subscribe(function () { return _this.dismiss(); });
          containerInstance._onExit.subscribe(function () { return _this._finishDismiss(); });
      }
      /** Dismisses the snack bar. */
      /**
       * Dismisses the snack bar.
       * @return {?}
       */
      MatSnackBarRef.prototype.dismiss = /**
       * Dismisses the snack bar.
       * @return {?}
       */
          function () {
              if (!this._afterDismissed.closed) {
                  this.containerInstance.exit();
              }
              clearTimeout(this._durationTimeoutId);
          };
      /** Marks the snackbar action clicked. */
      /**
       * Marks the snackbar action clicked.
       * @return {?}
       */
      MatSnackBarRef.prototype.dismissWithAction = /**
       * Marks the snackbar action clicked.
       * @return {?}
       */
          function () {
              if (!this._onAction.closed) {
                  this._dismissedByAction = true;
                  this._onAction.next();
                  this._onAction.complete();
              }
          };
      /**
       * Marks the snackbar action clicked.
       * @deprecated Use `dismissWithAction` instead.
       * @breaking-change 8.0.0
       */
      /**
       * Marks the snackbar action clicked.
       * @deprecated Use `dismissWithAction` instead.
       * \@breaking-change 8.0.0
       * @return {?}
       */
      MatSnackBarRef.prototype.closeWithAction = /**
       * Marks the snackbar action clicked.
       * @deprecated Use `dismissWithAction` instead.
       * \@breaking-change 8.0.0
       * @return {?}
       */
          function () {
              this.dismissWithAction();
          };
      /** Dismisses the snack bar after some duration */
      /**
       * Dismisses the snack bar after some duration
       * @param {?} duration
       * @return {?}
       */
      MatSnackBarRef.prototype._dismissAfter = /**
       * Dismisses the snack bar after some duration
       * @param {?} duration
       * @return {?}
       */
          function (duration) {
              var _this = this;
              this._durationTimeoutId = setTimeout(function () { return _this.dismiss(); }, duration);
          };
      /** Marks the snackbar as opened */
      /**
       * Marks the snackbar as opened
       * @return {?}
       */
      MatSnackBarRef.prototype._open = /**
       * Marks the snackbar as opened
       * @return {?}
       */
          function () {
              if (!this._afterOpened.closed) {
                  this._afterOpened.next();
                  this._afterOpened.complete();
              }
          };
      /** Cleans up the DOM after closing. */
      /**
       * Cleans up the DOM after closing.
       * @private
       * @return {?}
       */
      MatSnackBarRef.prototype._finishDismiss = /**
       * Cleans up the DOM after closing.
       * @private
       * @return {?}
       */
          function () {
              this._overlayRef.dispose();
              if (!this._onAction.closed) {
                  this._onAction.complete();
              }
              this._afterDismissed.next({ dismissedByAction: this._dismissedByAction });
              this._afterDismissed.complete();
              this._dismissedByAction = false;
          };
      /** Gets an observable that is notified when the snack bar is finished closing. */
      /**
       * Gets an observable that is notified when the snack bar is finished closing.
       * @return {?}
       */
      MatSnackBarRef.prototype.afterDismissed = /**
       * Gets an observable that is notified when the snack bar is finished closing.
       * @return {?}
       */
          function () {
              return this._afterDismissed.asObservable();
          };
      /** Gets an observable that is notified when the snack bar has opened and appeared. */
      /**
       * Gets an observable that is notified when the snack bar has opened and appeared.
       * @return {?}
       */
      MatSnackBarRef.prototype.afterOpened = /**
       * Gets an observable that is notified when the snack bar has opened and appeared.
       * @return {?}
       */
          function () {
              return this.containerInstance._onEnter;
          };
      /** Gets an observable that is notified when the snack bar action is called. */
      /**
       * Gets an observable that is notified when the snack bar action is called.
       * @return {?}
       */
      MatSnackBarRef.prototype.onAction = /**
       * Gets an observable that is notified when the snack bar action is called.
       * @return {?}
       */
          function () {
              return this._onAction.asObservable();
          };
      return MatSnackBarRef;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token that can be used to access the data that was passed in to a snack bar.
   * @type {?}
   */
  var MAT_SNACK_BAR_DATA = new core.InjectionToken('MatSnackBarData');
  /**
   * Configuration used when opening a snack-bar.
   * @template D
   */
  var /**
   * Configuration used when opening a snack-bar.
   * @template D
   */ MatSnackBarConfig = /** @class */ (function () {
      function MatSnackBarConfig() {
          /**
           * The politeness level for the MatAriaLiveAnnouncer announcement.
           */
          this.politeness = 'assertive';
          /**
           * Message to be announced by the LiveAnnouncer. When opening a snackbar without a custom
           * component or template, the announcement message will default to the specified message.
           */
          this.announcementMessage = '';
          /**
           * The length of time in milliseconds to wait before automatically dismissing the snack bar.
           */
          this.duration = 0;
          /**
           * Data being injected into the child component.
           */
          this.data = null;
          /**
           * The horizontal position to place the snack bar.
           */
          this.horizontalPosition = 'center';
          /**
           * The vertical position to place the snack bar.
           */
          this.verticalPosition = 'bottom';
      }
      return MatSnackBarConfig;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * A component used to open as the default snack bar, matching material spec.
   * This should only be used internally by the snack bar service.
   */
  var SimpleSnackBar = /** @class */ (function () {
      function SimpleSnackBar(snackBarRef, data) {
          this.snackBarRef = snackBarRef;
          this.data = data;
      }
      /** Performs the action on the snack bar. */
      /**
       * Performs the action on the snack bar.
       * @return {?}
       */
      SimpleSnackBar.prototype.action = /**
       * Performs the action on the snack bar.
       * @return {?}
       */
          function () {
              this.snackBarRef.dismissWithAction();
          };
      Object.defineProperty(SimpleSnackBar.prototype, "hasAction", {
          /** If the action button should be shown. */
          get: /**
           * If the action button should be shown.
           * @return {?}
           */ function () {
              return !!this.data.action;
          },
          enumerable: true,
          configurable: true
      });
      SimpleSnackBar.decorators = [
          { type: core.Component, args: [{ selector: 'simple-snack-bar',
                      template: "<span>{{data.message}}</span><div class=\"mat-simple-snackbar-action\" *ngIf=\"hasAction\"><button mat-button (click)=\"action()\">{{data.action}}</button></div>",
                      styles: [".mat-simple-snackbar{display:flex;justify-content:space-between;align-items:center;height:100%;line-height:20px;opacity:1}.mat-simple-snackbar-action{flex-shrink:0;margin:-8px -8px -8px 8px}.mat-simple-snackbar-action button{max-height:36px;min-width:0}[dir=rtl] .mat-simple-snackbar-action{margin-left:-8px;margin-right:8px}"],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      host: {
                          'class': 'mat-simple-snackbar',
                      }
                  },] },
      ];
      /** @nocollapse */
      SimpleSnackBar.ctorParameters = function () {
          return [
              { type: MatSnackBarRef },
              { type: undefined, decorators: [{ type: core.Inject, args: [MAT_SNACK_BAR_DATA,] }] }
          ];
      };
      return SimpleSnackBar;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Animations used by the Material snack bar.
   * \@docs-private
   * @type {?}
   */
  var matSnackBarAnimations = {
      /**
       * Animation that shows and hides a snack bar.
       */
      snackBarState: trigger('state', [
          state('void, hidden', style({
              transform: 'scale(0.8)',
              opacity: 0,
          })),
          state('visible', style({
              transform: 'scale(1)',
              opacity: 1,
          })),
          transition('* => visible', animate('150ms cubic-bezier(0, 0, 0.2, 1)')),
          transition('* => void, * => hidden', animate('75ms cubic-bezier(0.4, 0.0, 1, 1)', style({
              opacity: 0
          }))),
      ])
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Internal component that wraps user-provided snack bar content.
   * \@docs-private
   */
  var MatSnackBarContainer = /** @class */ (function (_super) {
      tslib_1.__extends(MatSnackBarContainer, _super);
      function MatSnackBarContainer(_ngZone, _elementRef, _changeDetectorRef, snackBarConfig) {
          var _this = _super.call(this) || this;
          _this._ngZone = _ngZone;
          _this._elementRef = _elementRef;
          _this._changeDetectorRef = _changeDetectorRef;
          _this.snackBarConfig = snackBarConfig;
          /**
           * Whether the component has been destroyed.
           */
          _this._destroyed = false;
          /**
           * Subject for notifying that the snack bar has exited from view.
           */
          _this._onExit = new rxjs.Subject();
          /**
           * Subject for notifying that the snack bar has finished entering the view.
           */
          _this._onEnter = new rxjs.Subject();
          /**
           * The state of the snack bar animations.
           */
          _this._animationState = 'void';
          // Based on the ARIA spec, `alert` and `status` roles have an
          // implicit `assertive` and `polite` politeness respectively.
          if (snackBarConfig.politeness === 'assertive' && !snackBarConfig.announcementMessage) {
              _this._role = 'alert';
          }
          else if (snackBarConfig.politeness === 'off') {
              _this._role = null;
          }
          else {
              _this._role = 'status';
          }
          return _this;
      }
      /** Attach a component portal as content to this snack bar container. */
      /**
       * Attach a component portal as content to this snack bar container.
       * @template T
       * @param {?} portal
       * @return {?}
       */
      MatSnackBarContainer.prototype.attachComponentPortal = /**
       * Attach a component portal as content to this snack bar container.
       * @template T
       * @param {?} portal
       * @return {?}
       */
          function (portal) {
              this._assertNotAttached();
              this._applySnackBarClasses();
              return this._portalOutlet.attachComponentPortal(portal);
          };
      /** Attach a template portal as content to this snack bar container. */
      /**
       * Attach a template portal as content to this snack bar container.
       * @template C
       * @param {?} portal
       * @return {?}
       */
      MatSnackBarContainer.prototype.attachTemplatePortal = /**
       * Attach a template portal as content to this snack bar container.
       * @template C
       * @param {?} portal
       * @return {?}
       */
          function (portal) {
              this._assertNotAttached();
              this._applySnackBarClasses();
              return this._portalOutlet.attachTemplatePortal(portal);
          };
      /** Handle end of animations, updating the state of the snackbar. */
      /**
       * Handle end of animations, updating the state of the snackbar.
       * @param {?} event
       * @return {?}
       */
      MatSnackBarContainer.prototype.onAnimationEnd = /**
       * Handle end of animations, updating the state of the snackbar.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              var fromState = event.fromState, toState = event.toState;
              if ((toState === 'void' && fromState !== 'void') || toState === 'hidden') {
                  this._completeExit();
              }
              if (toState === 'visible') {
                  // Note: we shouldn't use `this` inside the zone callback,
                  // because it can cause a memory leak.
                  /** @type {?} */
                  var onEnter_1 = this._onEnter;
                  this._ngZone.run(function () {
                      onEnter_1.next();
                      onEnter_1.complete();
                  });
              }
          };
      /** Begin animation of snack bar entrance into view. */
      /**
       * Begin animation of snack bar entrance into view.
       * @return {?}
       */
      MatSnackBarContainer.prototype.enter = /**
       * Begin animation of snack bar entrance into view.
       * @return {?}
       */
          function () {
              if (!this._destroyed) {
                  this._animationState = 'visible';
                  this._changeDetectorRef.detectChanges();
              }
          };
      /** Begin animation of the snack bar exiting from view. */
      /**
       * Begin animation of the snack bar exiting from view.
       * @return {?}
       */
      MatSnackBarContainer.prototype.exit = /**
       * Begin animation of the snack bar exiting from view.
       * @return {?}
       */
          function () {
              // Note: this one transitions to `hidden`, rather than `void`, in order to handle the case
              // where multiple snack bars are opened in quick succession (e.g. two consecutive calls to
              // `MatSnackBar.open`).
              this._animationState = 'hidden';
              return this._onExit;
          };
      /** Makes sure the exit callbacks have been invoked when the element is destroyed. */
      /**
       * Makes sure the exit callbacks have been invoked when the element is destroyed.
       * @return {?}
       */
      MatSnackBarContainer.prototype.ngOnDestroy = /**
       * Makes sure the exit callbacks have been invoked when the element is destroyed.
       * @return {?}
       */
          function () {
              this._destroyed = true;
              this._completeExit();
          };
      /**
       * Waits for the zone to settle before removing the element. Helps prevent
       * errors where we end up removing an element which is in the middle of an animation.
       */
      /**
       * Waits for the zone to settle before removing the element. Helps prevent
       * errors where we end up removing an element which is in the middle of an animation.
       * @private
       * @return {?}
       */
      MatSnackBarContainer.prototype._completeExit = /**
       * Waits for the zone to settle before removing the element. Helps prevent
       * errors where we end up removing an element which is in the middle of an animation.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              this._ngZone.onMicrotaskEmpty.asObservable().pipe(operators.take(1)).subscribe(function () {
                  _this._onExit.next();
                  _this._onExit.complete();
              });
          };
      /** Applies the various positioning and user-configured CSS classes to the snack bar. */
      /**
       * Applies the various positioning and user-configured CSS classes to the snack bar.
       * @private
       * @return {?}
       */
      MatSnackBarContainer.prototype._applySnackBarClasses = /**
       * Applies the various positioning and user-configured CSS classes to the snack bar.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var element = this._elementRef.nativeElement;
              /** @type {?} */
              var panelClasses = this.snackBarConfig.panelClass;
              if (panelClasses) {
                  if (Array.isArray(panelClasses)) {
                      // Note that we can't use a spread here, because IE doesn't support multiple arguments.
                      panelClasses.forEach(function (cssClass) { return element.classList.add(cssClass); });
                  }
                  else {
                      element.classList.add(panelClasses);
                  }
              }
              if (this.snackBarConfig.horizontalPosition === 'center') {
                  element.classList.add('mat-snack-bar-center');
              }
              if (this.snackBarConfig.verticalPosition === 'top') {
                  element.classList.add('mat-snack-bar-top');
              }
          };
      /** Asserts that no content is already attached to the container. */
      /**
       * Asserts that no content is already attached to the container.
       * @private
       * @return {?}
       */
      MatSnackBarContainer.prototype._assertNotAttached = /**
       * Asserts that no content is already attached to the container.
       * @private
       * @return {?}
       */
          function () {
              if (this._portalOutlet.hasAttached()) {
                  throw Error('Attempting to attach snack bar content after content is already attached');
              }
          };
      MatSnackBarContainer.decorators = [
          { type: core.Component, args: [{ selector: 'snack-bar-container',
                      template: "<ng-template cdkPortalOutlet></ng-template>",
                      styles: [".mat-snack-bar-container{border-radius:4px;box-sizing:border-box;display:block;margin:24px;max-width:33vw;min-width:344px;padding:14px 16px;min-height:48px;transform-origin:center}@media (-ms-high-contrast:active){.mat-snack-bar-container{border:solid 1px}}.mat-snack-bar-handset{width:100%}.mat-snack-bar-handset .mat-snack-bar-container{margin:8px;max-width:100%;min-width:0;width:100%}"],
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                      animations: [matSnackBarAnimations.snackBarState],
                      host: {
                          '[attr.role]': '_role',
                          'class': 'mat-snack-bar-container',
                          '[@state]': '_animationState',
                          '(@state.done)': 'onAnimationEnd($event)'
                      },
                  },] },
      ];
      /** @nocollapse */
      MatSnackBarContainer.ctorParameters = function () {
          return [
              { type: core.NgZone },
              { type: core.ElementRef },
              { type: core.ChangeDetectorRef },
              { type: MatSnackBarConfig }
          ];
      };
      MatSnackBarContainer.propDecorators = {
          _portalOutlet: [{ type: core.ViewChild, args: [CdkPortalOutlet,] }]
      };
      return MatSnackBarContainer;
  }(BasePortalOutlet));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var MatSnackBarModule = /** @class */ (function () {
      function MatSnackBarModule() {
      }
      MatSnackBarModule.decorators = [
          { type: core.NgModule, args: [{
                      imports: [
                          OverlayModule,
                          PortalModule,
                          common.CommonModule,
                          MatButtonModule,
                          MatCommonModule,
                      ],
                      exports: [MatSnackBarContainer, MatCommonModule],
                      declarations: [MatSnackBarContainer, SimpleSnackBar],
                      entryComponents: [MatSnackBarContainer, SimpleSnackBar],
                  },] },
      ];
      return MatSnackBarModule;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token that can be used to specify default snack bar.
   * @type {?}
   */
  var MAT_SNACK_BAR_DEFAULT_OPTIONS = new core.InjectionToken('mat-snack-bar-default-options', {
      providedIn: 'root',
      factory: MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY,
  });
  /**
   * \@docs-private
   * @return {?}
   */
  function MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY() {
      return new MatSnackBarConfig();
  }
  /**
   * Service to dispatch Material Design snack bar messages.
   */
  var MatSnackBar = /** @class */ (function () {
      function MatSnackBar(_overlay, _live, _injector, _breakpointObserver, _parentSnackBar, _defaultConfig) {
          this._overlay = _overlay;
          this._live = _live;
          this._injector = _injector;
          this._breakpointObserver = _breakpointObserver;
          this._parentSnackBar = _parentSnackBar;
          this._defaultConfig = _defaultConfig;
          /**
           * Reference to the current snack bar in the view *at this level* (in the Angular injector tree).
           * If there is a parent snack-bar service, all operations should delegate to that parent
           * via `_openedSnackBarRef`.
           */
          this._snackBarRefAtThisLevel = null;
      }
      Object.defineProperty(MatSnackBar.prototype, "_openedSnackBarRef", {
          /** Reference to the currently opened snackbar at *any* level. */
          get: /**
           * Reference to the currently opened snackbar at *any* level.
           * @return {?}
           */ function () {
              /** @type {?} */
              var parent = this._parentSnackBar;
              return parent ? parent._openedSnackBarRef : this._snackBarRefAtThisLevel;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (this._parentSnackBar) {
                  this._parentSnackBar._openedSnackBarRef = value;
              }
              else {
                  this._snackBarRefAtThisLevel = value;
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Creates and dispatches a snack bar with a custom component for the content, removing any
       * currently opened snack bars.
       *
       * @param component Component to be instantiated.
       * @param config Extra configuration for the snack bar.
       */
      /**
       * Creates and dispatches a snack bar with a custom component for the content, removing any
       * currently opened snack bars.
       *
       * @template T
       * @param {?} component Component to be instantiated.
       * @param {?=} config Extra configuration for the snack bar.
       * @return {?}
       */
      MatSnackBar.prototype.openFromComponent = /**
       * Creates and dispatches a snack bar with a custom component for the content, removing any
       * currently opened snack bars.
       *
       * @template T
       * @param {?} component Component to be instantiated.
       * @param {?=} config Extra configuration for the snack bar.
       * @return {?}
       */
          function (component, config) {
              return ( /** @type {?} */(this._attach(component, config)));
          };
      /**
       * Creates and dispatches a snack bar with a custom template for the content, removing any
       * currently opened snack bars.
       *
       * @param template Template to be instantiated.
       * @param config Extra configuration for the snack bar.
       */
      /**
       * Creates and dispatches a snack bar with a custom template for the content, removing any
       * currently opened snack bars.
       *
       * @param {?} template Template to be instantiated.
       * @param {?=} config Extra configuration for the snack bar.
       * @return {?}
       */
      MatSnackBar.prototype.openFromTemplate = /**
       * Creates and dispatches a snack bar with a custom template for the content, removing any
       * currently opened snack bars.
       *
       * @param {?} template Template to be instantiated.
       * @param {?=} config Extra configuration for the snack bar.
       * @return {?}
       */
          function (template, config) {
              return this._attach(template, config);
          };
      /**
       * Opens a snackbar with a message and an optional action.
       * @param message The message to show in the snackbar.
       * @param action The label for the snackbar action.
       * @param config Additional configuration options for the snackbar.
       */
      /**
       * Opens a snackbar with a message and an optional action.
       * @param {?} message The message to show in the snackbar.
       * @param {?=} action The label for the snackbar action.
       * @param {?=} config Additional configuration options for the snackbar.
       * @return {?}
       */
      MatSnackBar.prototype.open = /**
       * Opens a snackbar with a message and an optional action.
       * @param {?} message The message to show in the snackbar.
       * @param {?=} action The label for the snackbar action.
       * @param {?=} config Additional configuration options for the snackbar.
       * @return {?}
       */
          function (message, action, config) {
              if (action === void 0) {
                  action = '';
              }
              /** @type {?} */
              var _config = tslib_1.__assign({}, this._defaultConfig, config);
              // Since the user doesn't have access to the component, we can
              // override the data to pass in our own message and action.
              _config.data = { message: message, action: action };
              if (!_config.announcementMessage) {
                  _config.announcementMessage = message;
              }
              return this.openFromComponent(SimpleSnackBar, _config);
          };
      /**
       * Dismisses the currently-visible snack bar.
       */
      /**
       * Dismisses the currently-visible snack bar.
       * @return {?}
       */
      MatSnackBar.prototype.dismiss = /**
       * Dismisses the currently-visible snack bar.
       * @return {?}
       */
          function () {
              if (this._openedSnackBarRef) {
                  this._openedSnackBarRef.dismiss();
              }
          };
      /**
       * @return {?}
       */
      MatSnackBar.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              // Only dismiss the snack bar at the current level on destroy.
              if (this._snackBarRefAtThisLevel) {
                  this._snackBarRefAtThisLevel.dismiss();
              }
          };
      /**
       * Attaches the snack bar container component to the overlay.
       */
      /**
       * Attaches the snack bar container component to the overlay.
       * @private
       * @param {?} overlayRef
       * @param {?} config
       * @return {?}
       */
      MatSnackBar.prototype._attachSnackBarContainer = /**
       * Attaches the snack bar container component to the overlay.
       * @private
       * @param {?} overlayRef
       * @param {?} config
       * @return {?}
       */
          function (overlayRef, config) {
              /** @type {?} */
              var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
              /** @type {?} */
              var injector = new PortalInjector(userInjector || this._injector, new WeakMap([
                  [MatSnackBarConfig, config]
              ]));
              /** @type {?} */
              var containerPortal = new ComponentPortal(MatSnackBarContainer, config.viewContainerRef, injector);
              /** @type {?} */
              var containerRef = overlayRef.attach(containerPortal);
              containerRef.instance.snackBarConfig = config;
              return containerRef.instance;
          };
      /**
       * Places a new component or a template as the content of the snack bar container.
       */
      /**
       * Places a new component or a template as the content of the snack bar container.
       * @private
       * @template T
       * @param {?} content
       * @param {?=} userConfig
       * @return {?}
       */
      MatSnackBar.prototype._attach = /**
       * Places a new component or a template as the content of the snack bar container.
       * @private
       * @template T
       * @param {?} content
       * @param {?=} userConfig
       * @return {?}
       */
          function (content, userConfig) {
              /** @type {?} */
              var config = tslib_1.__assign({}, new MatSnackBarConfig(), this._defaultConfig, userConfig);
              /** @type {?} */
              var overlayRef = this._createOverlay(config);
              /** @type {?} */
              var container = this._attachSnackBarContainer(overlayRef, config);
              /** @type {?} */
              var snackBarRef = new MatSnackBarRef(container, overlayRef);
              if (content instanceof core.TemplateRef) {
                  /** @type {?} */
                  var portal = new TemplatePortal(content, ( /** @type {?} */(null)), ( /** @type {?} */({
                      $implicit: config.data,
                      snackBarRef: snackBarRef
                  })));
                  snackBarRef.instance = container.attachTemplatePortal(portal);
              }
              else {
                  /** @type {?} */
                  var injector = this._createInjector(config, snackBarRef);
                  /** @type {?} */
                  var portal = new ComponentPortal(content, undefined, injector);
                  /** @type {?} */
                  var contentRef = container.attachComponentPortal(portal);
                  // We can't pass this via the injector, because the injector is created earlier.
                  snackBarRef.instance = contentRef.instance;
              }
              // Subscribe to the breakpoint observer and attach the mat-snack-bar-handset class as
              // appropriate. This class is applied to the overlay element because the overlay must expand to
              // fill the width of the screen for full width snackbars.
              this._breakpointObserver.observe(Breakpoints.Handset).pipe(operators.takeUntil(overlayRef.detachments().pipe(operators.take(1)))).subscribe(function (state$$1) {
                  if (state$$1.matches) {
                      overlayRef.overlayElement.classList.add('mat-snack-bar-handset');
                  }
                  else {
                      overlayRef.overlayElement.classList.remove('mat-snack-bar-handset');
                  }
              });
              this._animateSnackBar(snackBarRef, config);
              this._openedSnackBarRef = snackBarRef;
              return this._openedSnackBarRef;
          };
      /** Animates the old snack bar out and the new one in. */
      /**
       * Animates the old snack bar out and the new one in.
       * @private
       * @param {?} snackBarRef
       * @param {?} config
       * @return {?}
       */
      MatSnackBar.prototype._animateSnackBar = /**
       * Animates the old snack bar out and the new one in.
       * @private
       * @param {?} snackBarRef
       * @param {?} config
       * @return {?}
       */
          function (snackBarRef, config) {
              var _this = this;
              // When the snackbar is dismissed, clear the reference to it.
              snackBarRef.afterDismissed().subscribe(function () {
                  // Clear the snackbar ref if it hasn't already been replaced by a newer snackbar.
                  if (_this._openedSnackBarRef == snackBarRef) {
                      _this._openedSnackBarRef = null;
                  }
                  if (config.announcementMessage) {
                      _this._live.clear();
                  }
              });
              if (this._openedSnackBarRef) {
                  // If a snack bar is already in view, dismiss it and enter the
                  // new snack bar after exit animation is complete.
                  this._openedSnackBarRef.afterDismissed().subscribe(function () {
                      snackBarRef.containerInstance.enter();
                  });
                  this._openedSnackBarRef.dismiss();
              }
              else {
                  // If no snack bar is in view, enter the new snack bar.
                  snackBarRef.containerInstance.enter();
              }
              // If a dismiss timeout is provided, set up dismiss based on after the snackbar is opened.
              if (config.duration && config.duration > 0) {
                  snackBarRef.afterOpened().subscribe(function () { return snackBarRef._dismissAfter(( /** @type {?} */(config.duration))); });
              }
              if (config.announcementMessage) {
                  this._live.announce(config.announcementMessage, config.politeness);
              }
          };
      /**
       * Creates a new overlay and places it in the correct location.
       * @param config The user-specified snack bar config.
       */
      /**
       * Creates a new overlay and places it in the correct location.
       * @private
       * @param {?} config The user-specified snack bar config.
       * @return {?}
       */
      MatSnackBar.prototype._createOverlay = /**
       * Creates a new overlay and places it in the correct location.
       * @private
       * @param {?} config The user-specified snack bar config.
       * @return {?}
       */
          function (config) {
              /** @type {?} */
              var overlayConfig = new OverlayConfig();
              overlayConfig.direction = config.direction;
              /** @type {?} */
              var positionStrategy = this._overlay.position().global();
              // Set horizontal position.
              /** @type {?} */
              var isRtl = config.direction === 'rtl';
              /** @type {?} */
              var isLeft = (config.horizontalPosition === 'left' ||
                  (config.horizontalPosition === 'start' && !isRtl) ||
                  (config.horizontalPosition === 'end' && isRtl));
              /** @type {?} */
              var isRight = !isLeft && config.horizontalPosition !== 'center';
              if (isLeft) {
                  positionStrategy.left('0');
              }
              else if (isRight) {
                  positionStrategy.right('0');
              }
              else {
                  positionStrategy.centerHorizontally();
              }
              // Set horizontal position.
              if (config.verticalPosition === 'top') {
                  positionStrategy.top('0');
              }
              else {
                  positionStrategy.bottom('0');
              }
              overlayConfig.positionStrategy = positionStrategy;
              return this._overlay.create(overlayConfig);
          };
      /**
       * Creates an injector to be used inside of a snack bar component.
       * @param config Config that was used to create the snack bar.
       * @param snackBarRef Reference to the snack bar.
       */
      /**
       * Creates an injector to be used inside of a snack bar component.
       * @private
       * @template T
       * @param {?} config Config that was used to create the snack bar.
       * @param {?} snackBarRef Reference to the snack bar.
       * @return {?}
       */
      MatSnackBar.prototype._createInjector = /**
       * Creates an injector to be used inside of a snack bar component.
       * @private
       * @template T
       * @param {?} config Config that was used to create the snack bar.
       * @param {?} snackBarRef Reference to the snack bar.
       * @return {?}
       */
          function (config, snackBarRef) {
              /** @type {?} */
              var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
              return new PortalInjector(userInjector || this._injector, new WeakMap([
                  [MatSnackBarRef, snackBarRef],
                  [MAT_SNACK_BAR_DATA, config.data]
              ]));
          };
      MatSnackBar.decorators = [
          { type: core.Injectable, args: [{ providedIn: MatSnackBarModule },] },
      ];
      /** @nocollapse */
      MatSnackBar.ctorParameters = function () {
          return [
              { type: Overlay },
              { type: LiveAnnouncer },
              { type: core.Injector },
              { type: BreakpointObserver },
              { type: MatSnackBar, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
              { type: MatSnackBarConfig, decorators: [{ type: core.Inject, args: [MAT_SNACK_BAR_DEFAULT_OPTIONS,] }] }
          ];
      };
      /** @nocollapse */ MatSnackBar.ngInjectableDef = core.defineInjectable({ factory: function MatSnackBar_Factory() { return new MatSnackBar(core.inject(Overlay), core.inject(LiveAnnouncer), core.inject(core.INJECTOR), core.inject(BreakpointObserver), core.inject(MatSnackBar, 12), core.inject(MAT_SNACK_BAR_DEFAULT_OPTIONS)); }, token: MatSnackBar, providedIn: MatSnackBarModule });
      return MatSnackBar;
  }());

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@docs-private
   * @param {?} id
   * @return {?}
   */
  function getSortDuplicateSortableIdError(id) {
      return Error("Cannot have two MatSortables with the same id (" + id + ").");
  }
  /**
   * \@docs-private
   * @return {?}
   */
  function getSortHeaderNotContainedWithinSortError() {
      return Error("MatSortHeader must be placed within a parent element with the MatSort directive.");
  }
  /**
   * \@docs-private
   * @return {?}
   */
  function getSortHeaderMissingIdError() {
      return Error("MatSortHeader must be provided with a unique id.");
  }
  /**
   * \@docs-private
   * @param {?} direction
   * @return {?}
   */
  function getSortInvalidDirectionError(direction) {
      return Error(direction + " is not a valid sort direction ('asc' or 'desc').");
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Boilerplate for applying mixins to MatSort.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatSort.
  /**
   * \@docs-private
   */
  MatSortBase = /** @class */ (function () {
      function MatSortBase() {
      }
      return MatSortBase;
  }());
  /** @type {?} */
  var _MatSortMixinBase = mixinInitialized(mixinDisabled(MatSortBase));
  /**
   * Container for MatSortables to manage the sort state and provide default sort parameters.
   */
  var MatSort = /** @class */ (function (_super) {
      tslib_1.__extends(MatSort, _super);
      function MatSort() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          /**
           * Collection of all registered sortables that this directive manages.
           */
          _this.sortables = new Map();
          /**
           * Used to notify any child components listening to state changes.
           */
          _this._stateChanges = new rxjs.Subject();
          /**
           * The direction to set when an MatSortable is initially sorted.
           * May be overriden by the MatSortable's sort start.
           */
          _this.start = 'asc';
          _this._direction = '';
          /**
           * Event emitted when the user changes either the active sort or sort direction.
           */
          _this.sortChange = new core.EventEmitter();
          return _this;
      }
      Object.defineProperty(MatSort.prototype, "direction", {
          /** The sort direction of the currently active MatSortable. */
          get: /**
           * The sort direction of the currently active MatSortable.
           * @return {?}
           */ function () { return this._direction; },
          set: /**
           * @param {?} direction
           * @return {?}
           */ function (direction) {
              if (core.isDevMode() && direction && direction !== 'asc' && direction !== 'desc') {
                  throw getSortInvalidDirectionError(direction);
              }
              this._direction = direction;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatSort.prototype, "disableClear", {
          /**
           * Whether to disable the user from clearing the sort by finishing the sort direction cycle.
           * May be overriden by the MatSortable's disable clear input.
           */
          get: /**
           * Whether to disable the user from clearing the sort by finishing the sort direction cycle.
           * May be overriden by the MatSortable's disable clear input.
           * @return {?}
           */ function () { return this._disableClear; },
          set: /**
           * @param {?} v
           * @return {?}
           */ function (v) { this._disableClear = coerceBooleanProperty(v); },
          enumerable: true,
          configurable: true
      });
      /**
       * Register function to be used by the contained MatSortables. Adds the MatSortable to the
       * collection of MatSortables.
       */
      /**
       * Register function to be used by the contained MatSortables. Adds the MatSortable to the
       * collection of MatSortables.
       * @param {?} sortable
       * @return {?}
       */
      MatSort.prototype.register = /**
       * Register function to be used by the contained MatSortables. Adds the MatSortable to the
       * collection of MatSortables.
       * @param {?} sortable
       * @return {?}
       */
          function (sortable) {
              if (!sortable.id) {
                  throw getSortHeaderMissingIdError();
              }
              if (this.sortables.has(sortable.id)) {
                  throw getSortDuplicateSortableIdError(sortable.id);
              }
              this.sortables.set(sortable.id, sortable);
          };
      /**
       * Unregister function to be used by the contained MatSortables. Removes the MatSortable from the
       * collection of contained MatSortables.
       */
      /**
       * Unregister function to be used by the contained MatSortables. Removes the MatSortable from the
       * collection of contained MatSortables.
       * @param {?} sortable
       * @return {?}
       */
      MatSort.prototype.deregister = /**
       * Unregister function to be used by the contained MatSortables. Removes the MatSortable from the
       * collection of contained MatSortables.
       * @param {?} sortable
       * @return {?}
       */
          function (sortable) {
              this.sortables.delete(sortable.id);
          };
      /** Sets the active sort id and determines the new sort direction. */
      /**
       * Sets the active sort id and determines the new sort direction.
       * @param {?} sortable
       * @return {?}
       */
      MatSort.prototype.sort = /**
       * Sets the active sort id and determines the new sort direction.
       * @param {?} sortable
       * @return {?}
       */
          function (sortable) {
              if (this.active != sortable.id) {
                  this.active = sortable.id;
                  this.direction = sortable.start ? sortable.start : this.start;
              }
              else {
                  this.direction = this.getNextSortDirection(sortable);
              }
              this.sortChange.emit({ active: this.active, direction: this.direction });
          };
      /** Returns the next sort direction of the active sortable, checking for potential overrides. */
      /**
       * Returns the next sort direction of the active sortable, checking for potential overrides.
       * @param {?} sortable
       * @return {?}
       */
      MatSort.prototype.getNextSortDirection = /**
       * Returns the next sort direction of the active sortable, checking for potential overrides.
       * @param {?} sortable
       * @return {?}
       */
          function (sortable) {
              if (!sortable) {
                  return '';
              }
              // Get the sort direction cycle with the potential sortable overrides.
              /** @type {?} */
              var disableClear = sortable.disableClear != null ? sortable.disableClear : this.disableClear;
              /** @type {?} */
              var sortDirectionCycle = getSortDirectionCycle(sortable.start || this.start, disableClear);
              // Get and return the next direction in the cycle
              /** @type {?} */
              var nextDirectionIndex = sortDirectionCycle.indexOf(this.direction) + 1;
              if (nextDirectionIndex >= sortDirectionCycle.length) {
                  nextDirectionIndex = 0;
              }
              return sortDirectionCycle[nextDirectionIndex];
          };
      /**
       * @return {?}
       */
      MatSort.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              this._markInitialized();
          };
      /**
       * @return {?}
       */
      MatSort.prototype.ngOnChanges = /**
       * @return {?}
       */
          function () {
              this._stateChanges.next();
          };
      /**
       * @return {?}
       */
      MatSort.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._stateChanges.complete();
          };
      MatSort.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matSort]',
                      exportAs: 'matSort',
                      inputs: ['disabled: matSortDisabled']
                  },] },
      ];
      MatSort.propDecorators = {
          active: [{ type: core.Input, args: ['matSortActive',] }],
          start: [{ type: core.Input, args: ['matSortStart',] }],
          direction: [{ type: core.Input, args: ['matSortDirection',] }],
          disableClear: [{ type: core.Input, args: ['matSortDisableClear',] }],
          sortChange: [{ type: core.Output, args: ['matSortChange',] }]
      };
      return MatSort;
  }(_MatSortMixinBase));
  /**
   * Returns the sort direction cycle to use given the provided parameters of order and clear.
   * @param {?} start
   * @param {?} disableClear
   * @return {?}
   */
  function getSortDirectionCycle(start, disableClear) {
      /** @type {?} */
      var sortOrder = ['asc', 'desc'];
      if (start == 'desc') {
          sortOrder.reverse();
      }
      if (!disableClear) {
          sortOrder.push('');
      }
      return sortOrder;
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var SORT_ANIMATION_TRANSITION = AnimationDurations.ENTERING + ' ' +
      AnimationCurves.STANDARD_CURVE;
  /**
   * Animations used by MatSort.
   * \@docs-private
   * @type {?}
   */
  var matSortAnimations = {
      /**
       * Animation that moves the sort indicator.
       */
      indicator: trigger('indicator', [
          state('active-asc, asc', style({ transform: 'translateY(0px)' })),
          // 10px is the height of the sort indicator, minus the width of the pointers
          state('active-desc, desc', style({ transform: 'translateY(10px)' })),
          transition('active-asc <=> active-desc', animate(SORT_ANIMATION_TRANSITION))
      ]),
      /**
       * Animation that rotates the left pointer of the indicator based on the sorting direction.
       */
      leftPointer: trigger('leftPointer', [
          state('active-asc, asc', style({ transform: 'rotate(-45deg)' })),
          state('active-desc, desc', style({ transform: 'rotate(45deg)' })),
          transition('active-asc <=> active-desc', animate(SORT_ANIMATION_TRANSITION))
      ]),
      /**
       * Animation that rotates the right pointer of the indicator based on the sorting direction.
       */
      rightPointer: trigger('rightPointer', [
          state('active-asc, asc', style({ transform: 'rotate(45deg)' })),
          state('active-desc, desc', style({ transform: 'rotate(-45deg)' })),
          transition('active-asc <=> active-desc', animate(SORT_ANIMATION_TRANSITION))
      ]),
      /**
       * Animation that controls the arrow opacity.
       */
      arrowOpacity: trigger('arrowOpacity', [
          state('desc-to-active, asc-to-active, active', style({ opacity: 1 })),
          state('desc-to-hint, asc-to-hint, hint', style({ opacity: .54 })),
          state('hint-to-desc, active-to-desc, desc, hint-to-asc, active-to-asc, asc, void', style({ opacity: 0 })),
          // Transition between all states except for immediate transitions
          transition('* => asc, * => desc, * => active, * => hint, * => void', animate('0ms')),
          transition('* <=> *', animate(SORT_ANIMATION_TRANSITION)),
      ]),
      /**
       * Animation for the translation of the arrow as a whole. States are separated into two
       * groups: ones with animations and others that are immediate. Immediate states are asc, desc,
       * peek, and active. The other states define a specific animation (source-to-destination)
       * and are determined as a function of their prev user-perceived state and what the next state
       * should be.
       */
      arrowPosition: trigger('arrowPosition', [
          // Hidden Above => Hint Center
          transition('* => desc-to-hint, * => desc-to-active', animate(SORT_ANIMATION_TRANSITION, keyframes([
              style({ transform: 'translateY(-25%)' }),
              style({ transform: 'translateY(0)' })
          ]))),
          // Hint Center => Hidden Below
          transition('* => hint-to-desc, * => active-to-desc', animate(SORT_ANIMATION_TRANSITION, keyframes([
              style({ transform: 'translateY(0)' }),
              style({ transform: 'translateY(25%)' })
          ]))),
          // Hidden Below => Hint Center
          transition('* => asc-to-hint, * => asc-to-active', animate(SORT_ANIMATION_TRANSITION, keyframes([
              style({ transform: 'translateY(25%)' }),
              style({ transform: 'translateY(0)' })
          ]))),
          // Hint Center => Hidden Above
          transition('* => hint-to-asc, * => active-to-asc', animate(SORT_ANIMATION_TRANSITION, keyframes([
              style({ transform: 'translateY(0)' }),
              style({ transform: 'translateY(-25%)' })
          ]))),
          state('desc-to-hint, asc-to-hint, hint, desc-to-active, asc-to-active, active', style({ transform: 'translateY(0)' })),
          state('hint-to-desc, active-to-desc, desc', style({ transform: 'translateY(-25%)' })),
          state('hint-to-asc, active-to-asc, asc', style({ transform: 'translateY(25%)' })),
      ]),
      /**
       * Necessary trigger that calls animate on children animations.
       */
      allowChildren: trigger('allowChildren', [
          transition('* <=> *', [
              query('@*', animateChild(), { optional: true })
          ])
      ]),
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * To modify the labels and text displayed, create a new instance of MatSortHeaderIntl and
   * include it in a custom provider.
   */
  var MatSortHeaderIntl = /** @class */ (function () {
      function MatSortHeaderIntl() {
          /**
           * Stream that emits whenever the labels here are changed. Use this to notify
           * components if the labels have changed after initialization.
           */
          this.changes = new rxjs.Subject();
          /**
           * ARIA label for the sorting button.
           */
          this.sortButtonLabel = function (id) {
              return "Change sorting for " + id;
          };
      }
      MatSortHeaderIntl.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */ MatSortHeaderIntl.ngInjectableDef = core.defineInjectable({ factory: function MatSortHeaderIntl_Factory() { return new MatSortHeaderIntl(); }, token: MatSortHeaderIntl, providedIn: "root" });
      return MatSortHeaderIntl;
  }());
  /**
   * \@docs-private
   * @param {?} parentIntl
   * @return {?}
   */
  function MAT_SORT_HEADER_INTL_PROVIDER_FACTORY(parentIntl) {
      return parentIntl || new MatSortHeaderIntl();
  }
  /**
   * \@docs-private
   * @type {?}
   */
  var MAT_SORT_HEADER_INTL_PROVIDER = {
      // If there is already an MatSortHeaderIntl available, use that. Otherwise, provide a new one.
      provide: MatSortHeaderIntl,
      deps: [[new core.Optional(), new core.SkipSelf(), MatSortHeaderIntl]],
      useFactory: MAT_SORT_HEADER_INTL_PROVIDER_FACTORY
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Boilerplate for applying mixins to the sort header.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to the sort header.
  /**
   * \@docs-private
   */
  MatSortHeaderBase = /** @class */ (function () {
      function MatSortHeaderBase() {
      }
      return MatSortHeaderBase;
  }());
  /** @type {?} */
  var _MatSortHeaderMixinBase = mixinDisabled(MatSortHeaderBase);
  /**
   * Applies sorting behavior (click to change sort) and styles to an element, including an
   * arrow to display the current sort direction.
   *
   * Must be provided with an id and contained within a parent MatSort directive.
   *
   * If used on header cells in a CdkTable, it will automatically default its id from its containing
   * column definition.
   */
  var MatSortHeader = /** @class */ (function (_super) {
      tslib_1.__extends(MatSortHeader, _super);
      function MatSortHeader(_intl, changeDetectorRef, _sort, _columnDef) {
          var _this = 
          // Note that we use a string token for the `_columnDef`, because the value is provided both by
          // `material/table` and `cdk/table` and we can't have the CDK depending on Material,
          // and we want to avoid having the sort header depending on the CDK table because
          // of this single reference.
          _super.call(this) || this;
          _this._intl = _intl;
          _this._sort = _sort;
          _this._columnDef = _columnDef;
          /**
           * Flag set to true when the indicator should be displayed while the sort is not active. Used to
           * provide an affordance that the header is sortable by showing on focus and hover.
           */
          _this._showIndicatorHint = false;
          /**
           * The direction the arrow should be facing according to the current state.
           */
          _this._arrowDirection = '';
          /**
           * Whether the view state animation should show the transition between the `from` and `to` states.
           */
          _this._disableViewStateAnimation = false;
          /**
           * Sets the position of the arrow that displays when sorted.
           */
          _this.arrowPosition = 'after';
          if (!_sort) {
              throw getSortHeaderNotContainedWithinSortError();
          }
          _this._rerenderSubscription = rxjs.merge(_sort.sortChange, _sort._stateChanges, _intl.changes)
              .subscribe(function () {
              if (_this._isSorted()) {
                  _this._updateArrowDirection();
              }
              // If this header was recently active and now no longer sorted, animate away the arrow.
              if (!_this._isSorted() && _this._viewState && _this._viewState.toState === 'active') {
                  _this._disableViewStateAnimation = false;
                  _this._setAnimationTransitionState({ fromState: 'active', toState: _this._arrowDirection });
              }
              changeDetectorRef.markForCheck();
          });
          return _this;
      }
      Object.defineProperty(MatSortHeader.prototype, "disableClear", {
          /** Overrides the disable clear value of the containing MatSort for this MatSortable. */
          get: /**
           * Overrides the disable clear value of the containing MatSort for this MatSortable.
           * @return {?}
           */ function () { return this._disableClear; },
          set: /**
           * @param {?} v
           * @return {?}
           */ function (v) { this._disableClear = coerceBooleanProperty(v); },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatSortHeader.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              if (!this.id && this._columnDef) {
                  this.id = this._columnDef.name;
              }
              // Initialize the direction of the arrow and set the view state to be immediately that state.
              this._updateArrowDirection();
              this._setAnimationTransitionState({ toState: this._isSorted() ? 'active' : this._arrowDirection });
              this._sort.register(this);
          };
      /**
       * @return {?}
       */
      MatSortHeader.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._sort.deregister(this);
              this._rerenderSubscription.unsubscribe();
          };
      /**
       * Sets the "hint" state such that the arrow will be semi-transparently displayed as a hint to the
       * user showing what the active sort will become. If set to false, the arrow will fade away.
       */
      /**
       * Sets the "hint" state such that the arrow will be semi-transparently displayed as a hint to the
       * user showing what the active sort will become. If set to false, the arrow will fade away.
       * @param {?} visible
       * @return {?}
       */
      MatSortHeader.prototype._setIndicatorHintVisible = /**
       * Sets the "hint" state such that the arrow will be semi-transparently displayed as a hint to the
       * user showing what the active sort will become. If set to false, the arrow will fade away.
       * @param {?} visible
       * @return {?}
       */
          function (visible) {
              // No-op if the sort header is disabled - should not make the hint visible.
              if (this._isDisabled() && visible) {
                  return;
              }
              this._showIndicatorHint = visible;
              if (!this._isSorted()) {
                  this._updateArrowDirection();
                  if (this._showIndicatorHint) {
                      this._setAnimationTransitionState({ fromState: this._arrowDirection, toState: 'hint' });
                  }
                  else {
                      this._setAnimationTransitionState({ fromState: 'hint', toState: this._arrowDirection });
                  }
              }
          };
      /**
       * Sets the animation transition view state for the arrow's position and opacity. If the
       * `disableViewStateAnimation` flag is set to true, the `fromState` will be ignored so that
       * no animation appears.
       */
      /**
       * Sets the animation transition view state for the arrow's position and opacity. If the
       * `disableViewStateAnimation` flag is set to true, the `fromState` will be ignored so that
       * no animation appears.
       * @param {?} viewState
       * @return {?}
       */
      MatSortHeader.prototype._setAnimationTransitionState = /**
       * Sets the animation transition view state for the arrow's position and opacity. If the
       * `disableViewStateAnimation` flag is set to true, the `fromState` will be ignored so that
       * no animation appears.
       * @param {?} viewState
       * @return {?}
       */
          function (viewState) {
              this._viewState = viewState;
              // If the animation for arrow position state (opacity/translation) should be disabled,
              // remove the fromState so that it jumps right to the toState.
              if (this._disableViewStateAnimation) {
                  this._viewState = { toState: viewState.toState };
              }
          };
      /** Triggers the sort on this sort header and removes the indicator hint. */
      /**
       * Triggers the sort on this sort header and removes the indicator hint.
       * @return {?}
       */
      MatSortHeader.prototype._handleClick = /**
       * Triggers the sort on this sort header and removes the indicator hint.
       * @return {?}
       */
          function () {
              if (this._isDisabled()) {
                  return;
              }
              this._sort.sort(this);
              // Do not show the animation if the header was already shown in the right position.
              if (this._viewState.toState === 'hint' || this._viewState.toState === 'active') {
                  this._disableViewStateAnimation = true;
              }
              // If the arrow is now sorted, animate the arrow into place. Otherwise, animate it away into
              // the direction it is facing.
              /** @type {?} */
              var viewState = this._isSorted() ?
                  { fromState: this._arrowDirection, toState: 'active' } :
                  { fromState: 'active', toState: this._arrowDirection };
              this._setAnimationTransitionState(viewState);
              this._showIndicatorHint = false;
          };
      /** Whether this MatSortHeader is currently sorted in either ascending or descending order. */
      /**
       * Whether this MatSortHeader is currently sorted in either ascending or descending order.
       * @return {?}
       */
      MatSortHeader.prototype._isSorted = /**
       * Whether this MatSortHeader is currently sorted in either ascending or descending order.
       * @return {?}
       */
          function () {
              return this._sort.active == this.id &&
                  (this._sort.direction === 'asc' || this._sort.direction === 'desc');
          };
      /** Returns the animation state for the arrow direction (indicator and pointers). */
      /**
       * Returns the animation state for the arrow direction (indicator and pointers).
       * @return {?}
       */
      MatSortHeader.prototype._getArrowDirectionState = /**
       * Returns the animation state for the arrow direction (indicator and pointers).
       * @return {?}
       */
          function () {
              return "" + (this._isSorted() ? 'active-' : '') + this._arrowDirection;
          };
      /** Returns the arrow position state (opacity, translation). */
      /**
       * Returns the arrow position state (opacity, translation).
       * @return {?}
       */
      MatSortHeader.prototype._getArrowViewState = /**
       * Returns the arrow position state (opacity, translation).
       * @return {?}
       */
          function () {
              /** @type {?} */
              var fromState = this._viewState.fromState;
              return (fromState ? fromState + "-to-" : '') + this._viewState.toState;
          };
      /**
       * Updates the direction the arrow should be pointing. If it is not sorted, the arrow should be
       * facing the start direction. Otherwise if it is sorted, the arrow should point in the currently
       * active sorted direction. The reason this is updated through a function is because the direction
       * should only be changed at specific times - when deactivated but the hint is displayed and when
       * the sort is active and the direction changes. Otherwise the arrow's direction should linger
       * in cases such as the sort becoming deactivated but we want to animate the arrow away while
       * preserving its direction, even though the next sort direction is actually different and should
       * only be changed once the arrow displays again (hint or activation).
       */
      /**
       * Updates the direction the arrow should be pointing. If it is not sorted, the arrow should be
       * facing the start direction. Otherwise if it is sorted, the arrow should point in the currently
       * active sorted direction. The reason this is updated through a function is because the direction
       * should only be changed at specific times - when deactivated but the hint is displayed and when
       * the sort is active and the direction changes. Otherwise the arrow's direction should linger
       * in cases such as the sort becoming deactivated but we want to animate the arrow away while
       * preserving its direction, even though the next sort direction is actually different and should
       * only be changed once the arrow displays again (hint or activation).
       * @return {?}
       */
      MatSortHeader.prototype._updateArrowDirection = /**
       * Updates the direction the arrow should be pointing. If it is not sorted, the arrow should be
       * facing the start direction. Otherwise if it is sorted, the arrow should point in the currently
       * active sorted direction. The reason this is updated through a function is because the direction
       * should only be changed at specific times - when deactivated but the hint is displayed and when
       * the sort is active and the direction changes. Otherwise the arrow's direction should linger
       * in cases such as the sort becoming deactivated but we want to animate the arrow away while
       * preserving its direction, even though the next sort direction is actually different and should
       * only be changed once the arrow displays again (hint or activation).
       * @return {?}
       */
          function () {
              this._arrowDirection = this._isSorted() ?
                  this._sort.direction :
                  (this.start || this._sort.start);
          };
      /**
       * @return {?}
       */
      MatSortHeader.prototype._isDisabled = /**
       * @return {?}
       */
          function () {
              return this._sort.disabled || this.disabled;
          };
      /**
       * Gets the aria-sort attribute that should be applied to this sort header. If this header
       * is not sorted, returns null so that the attribute is removed from the host element. Aria spec
       * says that the aria-sort property should only be present on one header at a time, so removing
       * ensures this is true.
       */
      /**
       * Gets the aria-sort attribute that should be applied to this sort header. If this header
       * is not sorted, returns null so that the attribute is removed from the host element. Aria spec
       * says that the aria-sort property should only be present on one header at a time, so removing
       * ensures this is true.
       * @return {?}
       */
      MatSortHeader.prototype._getAriaSortAttribute = /**
       * Gets the aria-sort attribute that should be applied to this sort header. If this header
       * is not sorted, returns null so that the attribute is removed from the host element. Aria spec
       * says that the aria-sort property should only be present on one header at a time, so removing
       * ensures this is true.
       * @return {?}
       */
          function () {
              if (!this._isSorted()) {
                  return null;
              }
              return this._sort.direction == 'asc' ? 'ascending' : 'descending';
          };
      MatSortHeader.decorators = [
          { type: core.Component, args: [{ selector: '[mat-sort-header]',
                      exportAs: 'matSortHeader',
                      template: "<div class=\"mat-sort-header-container\" [class.mat-sort-header-sorted]=\"_isSorted()\" [class.mat-sort-header-position-before]=\"arrowPosition == 'before'\"><button class=\"mat-sort-header-button\" type=\"button\" [attr.disabled]=\"_isDisabled() || null\" [attr.aria-label]=\"_intl.sortButtonLabel(id)\" (focus)=\"_setIndicatorHintVisible(true)\" (blur)=\"_setIndicatorHintVisible(false)\"><ng-content></ng-content></button><div class=\"mat-sort-header-arrow\" [@arrowOpacity]=\"_getArrowViewState()\" [@arrowPosition]=\"_getArrowViewState()\" [@allowChildren]=\"_getArrowDirectionState()\" (@arrowPosition.start)=\"_disableViewStateAnimation = true\" (@arrowPosition.done)=\"_disableViewStateAnimation = false\"><div class=\"mat-sort-header-stem\"></div><div class=\"mat-sort-header-indicator\" [@indicator]=\"_getArrowDirectionState()\"><div class=\"mat-sort-header-pointer-left\" [@leftPointer]=\"_getArrowDirectionState()\"></div><div class=\"mat-sort-header-pointer-right\" [@rightPointer]=\"_getArrowDirectionState()\"></div><div class=\"mat-sort-header-pointer-middle\"></div></div></div></div>",
                      styles: [".mat-sort-header-container{display:flex;cursor:pointer;align-items:center}.mat-sort-header-disabled .mat-sort-header-container{cursor:default}.mat-sort-header-position-before{flex-direction:row-reverse}.mat-sort-header-button{border:none;background:0 0;display:flex;align-items:center;padding:0;cursor:inherit;outline:0;font:inherit;color:currentColor}.mat-sort-header-button::-moz-focus-inner{border:0}.mat-sort-header-arrow{height:12px;width:12px;min-width:12px;position:relative;display:flex;opacity:0}.mat-sort-header-arrow,[dir=rtl] .mat-sort-header-position-before .mat-sort-header-arrow{margin:0 0 0 6px}.mat-sort-header-position-before .mat-sort-header-arrow,[dir=rtl] .mat-sort-header-arrow{margin:0 6px 0 0}.mat-sort-header-stem{background:currentColor;height:10px;width:2px;margin:auto;display:flex;align-items:center}@media (-ms-high-contrast:active){.mat-sort-header-stem{width:0;border-left:solid 2px}}.mat-sort-header-indicator{width:100%;height:2px;display:flex;align-items:center;position:absolute;top:0;left:0}.mat-sort-header-pointer-middle{margin:auto;height:2px;width:2px;background:currentColor;transform:rotate(45deg)}@media (-ms-high-contrast:active){.mat-sort-header-pointer-middle{width:0;height:0;border-top:solid 2px;border-left:solid 2px}}.mat-sort-header-pointer-left,.mat-sort-header-pointer-right{background:currentColor;width:6px;height:2px;position:absolute;top:0}@media (-ms-high-contrast:active){.mat-sort-header-pointer-left,.mat-sort-header-pointer-right{width:0;height:0;border-left:solid 6px;border-top:solid 2px}}.mat-sort-header-pointer-left{transform-origin:right;left:0}.mat-sort-header-pointer-right{transform-origin:left;right:0}"],
                      host: {
                          '(click)': '_handleClick()',
                          '(mouseenter)': '_setIndicatorHintVisible(true)',
                          '(longpress)': '_setIndicatorHintVisible(true)',
                          '(mouseleave)': '_setIndicatorHintVisible(false)',
                          '[attr.aria-sort]': '_getAriaSortAttribute()',
                          '[class.mat-sort-header-disabled]': '_isDisabled()',
                      },
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      inputs: ['disabled'],
                      animations: [
                          matSortAnimations.indicator,
                          matSortAnimations.leftPointer,
                          matSortAnimations.rightPointer,
                          matSortAnimations.arrowOpacity,
                          matSortAnimations.arrowPosition,
                          matSortAnimations.allowChildren,
                      ]
                  },] },
      ];
      /** @nocollapse */
      MatSortHeader.ctorParameters = function () {
          return [
              { type: MatSortHeaderIntl },
              { type: core.ChangeDetectorRef },
              { type: MatSort, decorators: [{ type: core.Optional }] },
              { type: undefined, decorators: [{ type: core.Inject, args: ['MAT_SORT_HEADER_COLUMN_DEF',] }, { type: core.Optional }] }
          ];
      };
      MatSortHeader.propDecorators = {
          id: [{ type: core.Input, args: ['mat-sort-header',] }],
          arrowPosition: [{ type: core.Input }],
          start: [{ type: core.Input }],
          disableClear: [{ type: core.Input }]
      };
      return MatSortHeader;
  }(_MatSortHeaderMixinBase));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var CdkStepLabel = /** @class */ (function () {
      function CdkStepLabel(/** @docs-private */ template) {
          this.template = template;
      }
      CdkStepLabel.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkStepLabel]',
                  },] },
      ];
      /** @nocollapse */
      CdkStepLabel.ctorParameters = function () {
          return [
              { type: core.TemplateRef }
          ];
      };
      return CdkStepLabel;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var CdkStepHeader = /** @class */ (function () {
      function CdkStepHeader(_elementRef) {
          this._elementRef = _elementRef;
      }
      /** Focuses the step header. */
      /**
       * Focuses the step header.
       * @return {?}
       */
      CdkStepHeader.prototype.focus = /**
       * Focuses the step header.
       * @return {?}
       */
          function () {
              this._elementRef.nativeElement.focus();
          };
      CdkStepHeader.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkStepHeader]',
                      host: {
                          'role': 'tab',
                      },
                  },] },
      ];
      /** @nocollapse */
      CdkStepHeader.ctorParameters = function () {
          return [
              { type: core.ElementRef }
          ];
      };
      return CdkStepHeader;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Used to generate unique ID for each stepper component.
   * @type {?}
   */
  var nextId$3 = 0;
  /**
   * Enum to represent the different states of the steps.
   * @type {?}
   */
  var STEP_STATE = {
      NUMBER: 'number',
      EDIT: 'edit',
      DONE: 'done',
      ERROR: 'error'
  };
  /**
   * InjectionToken that can be used to specify the global stepper options.
   * @type {?}
   */
  var STEPPER_GLOBAL_OPTIONS = new core.InjectionToken('STEPPER_GLOBAL_OPTIONS');
  var CdkStep = /** @class */ (function () {
      /** @breaking-change 8.0.0 remove the `?` after `stepperOptions` */
      function CdkStep(_stepper, stepperOptions) {
          this._stepper = _stepper;
          /**
           * Whether user has seen the expanded step content or not.
           */
          this.interacted = false;
          this._editable = true;
          this._optional = false;
          this._customCompleted = null;
          this._customError = null;
          this._stepperOptions = stepperOptions ? stepperOptions : {};
          this._displayDefaultIndicatorType = this._stepperOptions.displayDefaultIndicatorType !== false;
          this._showError = !!this._stepperOptions.showError;
      }
      Object.defineProperty(CdkStep.prototype, "editable", {
          /** Whether the user can return to this step once it has been marked as completed. */
          get: /**
           * Whether the user can return to this step once it has been marked as completed.
           * @return {?}
           */ function () { return this._editable; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._editable = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkStep.prototype, "optional", {
          /** Whether the completion of step is optional. */
          get: /**
           * Whether the completion of step is optional.
           * @return {?}
           */ function () { return this._optional; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._optional = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkStep.prototype, "completed", {
          /** Whether step is marked as completed. */
          get: /**
           * Whether step is marked as completed.
           * @return {?}
           */ function () {
              return this._customCompleted == null ? this._getDefaultCompleted() : this._customCompleted;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._customCompleted = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @private
       * @return {?}
       */
      CdkStep.prototype._getDefaultCompleted = /**
       * @private
       * @return {?}
       */
          function () {
              return this.stepControl ? this.stepControl.valid && this.interacted : this.interacted;
          };
      Object.defineProperty(CdkStep.prototype, "hasError", {
          /** Whether step has an error. */
          get: /**
           * Whether step has an error.
           * @return {?}
           */ function () {
              return this._customError == null ? this._getDefaultError() : this._customError;
          },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._customError = coerceBooleanProperty(value);
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @private
       * @return {?}
       */
      CdkStep.prototype._getDefaultError = /**
       * @private
       * @return {?}
       */
          function () {
              return this.stepControl && this.stepControl.invalid && this.interacted;
          };
      /** Selects this step component. */
      /**
       * Selects this step component.
       * @return {?}
       */
      CdkStep.prototype.select = /**
       * Selects this step component.
       * @return {?}
       */
          function () {
              this._stepper.selected = this;
          };
      /** Resets the step to its initial state. Note that this includes resetting form data. */
      /**
       * Resets the step to its initial state. Note that this includes resetting form data.
       * @return {?}
       */
      CdkStep.prototype.reset = /**
       * Resets the step to its initial state. Note that this includes resetting form data.
       * @return {?}
       */
          function () {
              this.interacted = false;
              if (this._customCompleted != null) {
                  this._customCompleted = false;
              }
              if (this._customError != null) {
                  this._customError = false;
              }
              if (this.stepControl) {
                  this.stepControl.reset();
              }
          };
      /**
       * @return {?}
       */
      CdkStep.prototype.ngOnChanges = /**
       * @return {?}
       */
          function () {
              // Since basically all inputs of the MatStep get proxied through the view down to the
              // underlying MatStepHeader, we have to make sure that change detection runs correctly.
              this._stepper._stateChanged();
          };
      CdkStep.decorators = [
          { type: core.Component, args: [{ selector: 'cdk-step',
                      exportAs: 'cdkStep',
                      template: '<ng-template><ng-content></ng-content></ng-template>',
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      CdkStep.ctorParameters = function () {
          return [
              { type: CdkStepper, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return CdkStepper; }),] }] },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [STEPPER_GLOBAL_OPTIONS,] }] }
          ];
      };
      CdkStep.propDecorators = {
          stepLabel: [{ type: core.ContentChild, args: [CdkStepLabel,] }],
          content: [{ type: core.ViewChild, args: [core.TemplateRef,] }],
          stepControl: [{ type: core.Input }],
          label: [{ type: core.Input }],
          errorMessage: [{ type: core.Input }],
          ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
          ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],
          state: [{ type: core.Input }],
          editable: [{ type: core.Input }],
          optional: [{ type: core.Input }],
          completed: [{ type: core.Input }],
          hasError: [{ type: core.Input }]
      };
      return CdkStep;
  }());
  var CdkStepper = /** @class */ (function () {
      function CdkStepper(_dir, _changeDetectorRef, _elementRef, _document) {
          this._dir = _dir;
          this._changeDetectorRef = _changeDetectorRef;
          this._elementRef = _elementRef;
          /**
           * Emits when the component is destroyed.
           */
          this._destroyed = new rxjs.Subject();
          this._linear = false;
          this._selectedIndex = 0;
          /**
           * Event emitted when the selected step has changed.
           */
          this.selectionChange = new core.EventEmitter();
          this._orientation = 'horizontal';
          this._groupId = nextId$3++;
          this._document = _document;
      }
      Object.defineProperty(CdkStepper.prototype, "steps", {
          /** The list of step components that the stepper is holding. */
          get: /**
           * The list of step components that the stepper is holding.
           * @return {?}
           */ function () {
              return this._steps;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkStepper.prototype, "linear", {
          /** Whether the validity of previous steps should be checked or not. */
          get: /**
           * Whether the validity of previous steps should be checked or not.
           * @return {?}
           */ function () { return this._linear; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._linear = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkStepper.prototype, "selectedIndex", {
          /** The index of the selected step. */
          get: /**
           * The index of the selected step.
           * @return {?}
           */ function () { return this._selectedIndex; },
          set: /**
           * @param {?} index
           * @return {?}
           */ function (index) {
              /** @type {?} */
              var newIndex = coerceNumberProperty(index);
              if (this.steps) {
                  // Ensure that the index can't be out of bounds.
                  if (newIndex < 0 || newIndex > this.steps.length - 1) {
                      throw Error('cdkStepper: Cannot assign out-of-bounds value to `selectedIndex`.');
                  }
                  if (this._selectedIndex != newIndex &&
                      !this._anyControlsInvalidOrPending(newIndex) &&
                      (newIndex >= this._selectedIndex || this.steps.toArray()[newIndex].editable)) {
                      this._updateSelectedItemIndex(index);
                  }
              }
              else {
                  this._selectedIndex = newIndex;
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkStepper.prototype, "selected", {
          /** The step that is selected. */
          get: /**
           * The step that is selected.
           * @return {?}
           */ function () {
              // @breaking-change 8.0.0 Change return type to `CdkStep | undefined`.
              return this.steps ? this.steps.toArray()[this.selectedIndex] : ( /** @type {?} */(undefined));
          },
          set: /**
           * @param {?} step
           * @return {?}
           */ function (step) {
              this.selectedIndex = this.steps ? this.steps.toArray().indexOf(step) : -1;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      CdkStepper.prototype.ngAfterViewInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              // Note that while the step headers are content children by default, any components that
              // extend this one might have them as view chidren. We initialize the keyboard handling in
              // AfterViewInit so we're guaranteed for both view and content children to be defined.
              this._keyManager = new FocusKeyManager(this._stepHeader)
                  .withWrap()
                  .withVerticalOrientation(this._orientation === 'vertical');
              (this._dir ? ( /** @type {?} */(this._dir.change)) : rxjs.of())
                  .pipe(operators.startWith(this._layoutDirection()), operators.takeUntil(this._destroyed))
                  .subscribe(function (direction) { return _this._keyManager.withHorizontalOrientation(direction); });
              this._keyManager.updateActiveItemIndex(this._selectedIndex);
              this.steps.changes.pipe(operators.takeUntil(this._destroyed)).subscribe(function () {
                  if (!_this.selected) {
                      _this._selectedIndex = Math.max(_this._selectedIndex - 1, 0);
                  }
              });
          };
      /**
       * @return {?}
       */
      CdkStepper.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._destroyed.next();
              this._destroyed.complete();
          };
      /** Selects and focuses the next step in list. */
      /**
       * Selects and focuses the next step in list.
       * @return {?}
       */
      CdkStepper.prototype.next = /**
       * Selects and focuses the next step in list.
       * @return {?}
       */
          function () {
              this.selectedIndex = Math.min(this._selectedIndex + 1, this.steps.length - 1);
          };
      /** Selects and focuses the previous step in list. */
      /**
       * Selects and focuses the previous step in list.
       * @return {?}
       */
      CdkStepper.prototype.previous = /**
       * Selects and focuses the previous step in list.
       * @return {?}
       */
          function () {
              this.selectedIndex = Math.max(this._selectedIndex - 1, 0);
          };
      /** Resets the stepper to its initial state. Note that this includes clearing form data. */
      /**
       * Resets the stepper to its initial state. Note that this includes clearing form data.
       * @return {?}
       */
      CdkStepper.prototype.reset = /**
       * Resets the stepper to its initial state. Note that this includes clearing form data.
       * @return {?}
       */
          function () {
              this._updateSelectedItemIndex(0);
              this.steps.forEach(function (step) { return step.reset(); });
              this._stateChanged();
          };
      /** Returns a unique id for each step label element. */
      /**
       * Returns a unique id for each step label element.
       * @param {?} i
       * @return {?}
       */
      CdkStepper.prototype._getStepLabelId = /**
       * Returns a unique id for each step label element.
       * @param {?} i
       * @return {?}
       */
          function (i) {
              return "cdk-step-label-" + this._groupId + "-" + i;
          };
      /** Returns unique id for each step content element. */
      /**
       * Returns unique id for each step content element.
       * @param {?} i
       * @return {?}
       */
      CdkStepper.prototype._getStepContentId = /**
       * Returns unique id for each step content element.
       * @param {?} i
       * @return {?}
       */
          function (i) {
              return "cdk-step-content-" + this._groupId + "-" + i;
          };
      /** Marks the component to be change detected. */
      /**
       * Marks the component to be change detected.
       * @return {?}
       */
      CdkStepper.prototype._stateChanged = /**
       * Marks the component to be change detected.
       * @return {?}
       */
          function () {
              this._changeDetectorRef.markForCheck();
          };
      /** Returns position state of the step with the given index. */
      /**
       * Returns position state of the step with the given index.
       * @param {?} index
       * @return {?}
       */
      CdkStepper.prototype._getAnimationDirection = /**
       * Returns position state of the step with the given index.
       * @param {?} index
       * @return {?}
       */
          function (index) {
              /** @type {?} */
              var position = index - this._selectedIndex;
              if (position < 0) {
                  return this._layoutDirection() === 'rtl' ? 'next' : 'previous';
              }
              else if (position > 0) {
                  return this._layoutDirection() === 'rtl' ? 'previous' : 'next';
              }
              return 'current';
          };
      /** Returns the type of icon to be displayed. */
      /**
       * Returns the type of icon to be displayed.
       * @param {?} index
       * @param {?=} state
       * @return {?}
       */
      CdkStepper.prototype._getIndicatorType = /**
       * Returns the type of icon to be displayed.
       * @param {?} index
       * @param {?=} state
       * @return {?}
       */
          function (index, state) {
              if (state === void 0) {
                  state = STEP_STATE.NUMBER;
              }
              /** @type {?} */
              var step = this.steps.toArray()[index];
              /** @type {?} */
              var isCurrentStep = this._isCurrentStep(index);
              return step._displayDefaultIndicatorType
                  ? this._getDefaultIndicatorLogic(step, isCurrentStep)
                  : this._getGuidelineLogic(step, isCurrentStep, state);
          };
      /**
       * @private
       * @param {?} step
       * @param {?} isCurrentStep
       * @return {?}
       */
      CdkStepper.prototype._getDefaultIndicatorLogic = /**
       * @private
       * @param {?} step
       * @param {?} isCurrentStep
       * @return {?}
       */
          function (step, isCurrentStep) {
              if (step._showError && step.hasError && !isCurrentStep) {
                  return STEP_STATE.ERROR;
              }
              else if (!step.completed || isCurrentStep) {
                  return STEP_STATE.NUMBER;
              }
              else {
                  return step.editable ? STEP_STATE.EDIT : STEP_STATE.DONE;
              }
          };
      /**
       * @private
       * @param {?} step
       * @param {?} isCurrentStep
       * @param {?=} state
       * @return {?}
       */
      CdkStepper.prototype._getGuidelineLogic = /**
       * @private
       * @param {?} step
       * @param {?} isCurrentStep
       * @param {?=} state
       * @return {?}
       */
          function (step, isCurrentStep, state) {
              if (state === void 0) {
                  state = STEP_STATE.NUMBER;
              }
              if (step._showError && step.hasError && !isCurrentStep) {
                  return STEP_STATE.ERROR;
              }
              else if (step.completed && !isCurrentStep) {
                  return STEP_STATE.DONE;
              }
              else if (step.completed && isCurrentStep) {
                  return state;
              }
              else if (step.editable && isCurrentStep) {
                  return STEP_STATE.EDIT;
              }
              else {
                  return state;
              }
          };
      /**
       * @private
       * @param {?} index
       * @return {?}
       */
      CdkStepper.prototype._isCurrentStep = /**
       * @private
       * @param {?} index
       * @return {?}
       */
          function (index) {
              return this._selectedIndex === index;
          };
      /** Returns the index of the currently-focused step header. */
      /**
       * Returns the index of the currently-focused step header.
       * @return {?}
       */
      CdkStepper.prototype._getFocusIndex = /**
       * Returns the index of the currently-focused step header.
       * @return {?}
       */
          function () {
              return this._keyManager ? this._keyManager.activeItemIndex : this._selectedIndex;
          };
      /**
       * @private
       * @param {?} newIndex
       * @return {?}
       */
      CdkStepper.prototype._updateSelectedItemIndex = /**
       * @private
       * @param {?} newIndex
       * @return {?}
       */
          function (newIndex) {
              /** @type {?} */
              var stepsArray = this.steps.toArray();
              this.selectionChange.emit({
                  selectedIndex: newIndex,
                  previouslySelectedIndex: this._selectedIndex,
                  selectedStep: stepsArray[newIndex],
                  previouslySelectedStep: stepsArray[this._selectedIndex],
              });
              // If focus is inside the stepper, move it to the next header, otherwise it may become
              // lost when the active step content is hidden. We can't be more granular with the check
              // (e.g. checking whether focus is inside the active step), because we don't have a
              // reference to the elements that are rendering out the content.
              this._containsFocus() ? this._keyManager.setActiveItem(newIndex) :
                  this._keyManager.updateActiveItemIndex(newIndex);
              this._selectedIndex = newIndex;
              this._stateChanged();
          };
      /**
       * @param {?} event
       * @return {?}
       */
      CdkStepper.prototype._onKeydown = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var hasModifier = hasModifierKey(event);
              /** @type {?} */
              var keyCode = event.keyCode;
              /** @type {?} */
              var manager = this._keyManager;
              if (manager.activeItemIndex != null && !hasModifier &&
                  (keyCode === SPACE || keyCode === ENTER)) {
                  this.selectedIndex = manager.activeItemIndex;
                  event.preventDefault();
              }
              else if (keyCode === HOME) {
                  manager.setFirstItemActive();
                  event.preventDefault();
              }
              else if (keyCode === END) {
                  manager.setLastItemActive();
                  event.preventDefault();
              }
              else {
                  manager.onKeydown(event);
              }
          };
      /**
       * @private
       * @param {?} index
       * @return {?}
       */
      CdkStepper.prototype._anyControlsInvalidOrPending = /**
       * @private
       * @param {?} index
       * @return {?}
       */
          function (index) {
              /** @type {?} */
              var steps = this.steps.toArray();
              steps[this._selectedIndex].interacted = true;
              if (this._linear && index >= 0) {
                  return steps.slice(0, index).some(function (step) {
                      /** @type {?} */
                      var control = step.stepControl;
                      /** @type {?} */
                      var isIncomplete = control ?
                          (control.invalid || control.pending || !step.interacted) :
                          !step.completed;
                      return isIncomplete && !step.optional;
                  });
              }
              return false;
          };
      /**
       * @private
       * @return {?}
       */
      CdkStepper.prototype._layoutDirection = /**
       * @private
       * @return {?}
       */
          function () {
              return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
          };
      /** Checks whether the stepper contains the focused element. */
      /**
       * Checks whether the stepper contains the focused element.
       * @private
       * @return {?}
       */
      CdkStepper.prototype._containsFocus = /**
       * Checks whether the stepper contains the focused element.
       * @private
       * @return {?}
       */
          function () {
              if (!this._document || !this._elementRef) {
                  return false;
              }
              /** @type {?} */
              var stepperElement = this._elementRef.nativeElement;
              /** @type {?} */
              var focusedElement = this._document.activeElement;
              return stepperElement === focusedElement || stepperElement.contains(focusedElement);
          };
      CdkStepper.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkStepper]',
                      exportAs: 'cdkStepper',
                  },] },
      ];
      /** @nocollapse */
      CdkStepper.ctorParameters = function () {
          return [
              { type: Directionality, decorators: [{ type: core.Optional }] },
              { type: core.ChangeDetectorRef },
              { type: core.ElementRef },
              { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
          ];
      };
      CdkStepper.propDecorators = {
          _steps: [{ type: core.ContentChildren, args: [CdkStep,] }],
          _stepHeader: [{ type: core.ContentChildren, args: [CdkStepHeader,] }],
          linear: [{ type: core.Input }],
          selectedIndex: [{ type: core.Input }],
          selected: [{ type: core.Input }],
          selectionChange: [{ type: core.Output }]
      };
      return CdkStepper;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Button that moves to the next step in a stepper workflow.
   */
  var CdkStepperNext = /** @class */ (function () {
      function CdkStepperNext(_stepper) {
          this._stepper = _stepper;
          /**
           * Type of the next button. Defaults to "submit" if not specified.
           */
          this.type = 'submit';
      }
      CdkStepperNext.decorators = [
          { type: core.Directive, args: [{
                      selector: 'button[cdkStepperNext]',
                      host: {
                          '(click)': '_stepper.next()',
                          '[type]': 'type',
                      }
                  },] },
      ];
      /** @nocollapse */
      CdkStepperNext.ctorParameters = function () {
          return [
              { type: CdkStepper }
          ];
      };
      CdkStepperNext.propDecorators = {
          type: [{ type: core.Input }]
      };
      return CdkStepperNext;
  }());
  /**
   * Button that moves to the previous step in a stepper workflow.
   */
  var CdkStepperPrevious = /** @class */ (function () {
      function CdkStepperPrevious(_stepper) {
          this._stepper = _stepper;
          /**
           * Type of the previous button. Defaults to "button" if not specified.
           */
          this.type = 'button';
      }
      CdkStepperPrevious.decorators = [
          { type: core.Directive, args: [{
                      selector: 'button[cdkStepperPrevious]',
                      host: {
                          '(click)': '_stepper.previous()',
                          '[type]': 'type',
                      }
                  },] },
      ];
      /** @nocollapse */
      CdkStepperPrevious.ctorParameters = function () {
          return [
              { type: CdkStepper }
          ];
      };
      CdkStepperPrevious.propDecorators = {
          type: [{ type: core.Input }]
      };
      return CdkStepperPrevious;
  }());

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var MatStepLabel = /** @class */ (function (_super) {
      tslib_1.__extends(MatStepLabel, _super);
      function MatStepLabel() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MatStepLabel.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matStepLabel]',
                  },] },
      ];
      return MatStepLabel;
  }(CdkStepLabel));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Stepper data that is required for internationalization.
   */
  var MatStepperIntl = /** @class */ (function () {
      function MatStepperIntl() {
          /**
           * Stream that emits whenever the labels here are changed. Use this to notify
           * components if the labels have changed after initialization.
           */
          this.changes = new rxjs.Subject();
          /**
           * Label that is rendered below optional steps.
           */
          this.optionalLabel = 'Optional';
      }
      MatStepperIntl.decorators = [
          { type: core.Injectable, args: [{ providedIn: 'root' },] },
      ];
      /** @nocollapse */ MatStepperIntl.ngInjectableDef = core.defineInjectable({ factory: function MatStepperIntl_Factory() { return new MatStepperIntl(); }, token: MatStepperIntl, providedIn: "root" });
      return MatStepperIntl;
  }());
  /**
   * \@docs-private
   * @param {?} parentIntl
   * @return {?}
   */
  function MAT_STEPPER_INTL_PROVIDER_FACTORY(parentIntl) {
      return parentIntl || new MatStepperIntl();
  }
  /**
   * \@docs-private
   * @type {?}
   */
  var MAT_STEPPER_INTL_PROVIDER = {
      provide: MatStepperIntl,
      deps: [[new core.Optional(), new core.SkipSelf(), MatStepperIntl]],
      useFactory: MAT_STEPPER_INTL_PROVIDER_FACTORY
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var MatStepHeader = /** @class */ (function (_super) {
      tslib_1.__extends(MatStepHeader, _super);
      function MatStepHeader(_intl, _focusMonitor, _elementRef, changeDetectorRef) {
          var _this = _super.call(this, _elementRef) || this;
          _this._intl = _intl;
          _this._focusMonitor = _focusMonitor;
          _focusMonitor.monitor(_elementRef, true);
          _this._intlSubscription = _intl.changes.subscribe(function () { return changeDetectorRef.markForCheck(); });
          return _this;
      }
      /**
       * @return {?}
       */
      MatStepHeader.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._intlSubscription.unsubscribe();
              this._focusMonitor.stopMonitoring(this._elementRef);
          };
      /** Returns string label of given step if it is a text label. */
      /**
       * Returns string label of given step if it is a text label.
       * @return {?}
       */
      MatStepHeader.prototype._stringLabel = /**
       * Returns string label of given step if it is a text label.
       * @return {?}
       */
          function () {
              return this.label instanceof MatStepLabel ? null : this.label;
          };
      /** Returns MatStepLabel if the label of given step is a template label. */
      /**
       * Returns MatStepLabel if the label of given step is a template label.
       * @return {?}
       */
      MatStepHeader.prototype._templateLabel = /**
       * Returns MatStepLabel if the label of given step is a template label.
       * @return {?}
       */
          function () {
              return this.label instanceof MatStepLabel ? this.label : null;
          };
      /** Returns the host HTML element. */
      /**
       * Returns the host HTML element.
       * @return {?}
       */
      MatStepHeader.prototype._getHostElement = /**
       * Returns the host HTML element.
       * @return {?}
       */
          function () {
              return this._elementRef.nativeElement;
          };
      /** Template context variables that are exposed to the `matStepperIcon` instances. */
      /**
       * Template context variables that are exposed to the `matStepperIcon` instances.
       * @return {?}
       */
      MatStepHeader.prototype._getIconContext = /**
       * Template context variables that are exposed to the `matStepperIcon` instances.
       * @return {?}
       */
          function () {
              return {
                  index: this.index,
                  active: this.active,
                  optional: this.optional
              };
          };
      /**
       * @param {?} state
       * @return {?}
       */
      MatStepHeader.prototype._getDefaultTextForState = /**
       * @param {?} state
       * @return {?}
       */
          function (state$$1) {
              if (state$$1 == 'number') {
                  return "" + (this.index + 1);
              }
              if (state$$1 == 'edit') {
                  return 'create';
              }
              if (state$$1 == 'error') {
                  return 'warning';
              }
              return state$$1;
          };
      MatStepHeader.decorators = [
          { type: core.Component, args: [{ selector: 'mat-step-header',
                      template: "<div class=\"mat-step-header-ripple\" mat-ripple [matRippleTrigger]=\"_getHostElement()\"></div><div class=\"mat-step-icon-state-{{state}} mat-step-icon\" [class.mat-step-icon-selected]=\"selected\"><div class=\"mat-step-icon-content\" [ngSwitch]=\"!!(iconOverrides && iconOverrides[state])\"><ng-container *ngSwitchCase=\"true\" [ngTemplateOutlet]=\"iconOverrides[state]\" [ngTemplateOutletContext]=\"_getIconContext()\"></ng-container><ng-container *ngSwitchDefault [ngSwitch]=\"state\"><span *ngSwitchCase=\"'number'\">{{_getDefaultTextForState(state)}}</span><mat-icon *ngSwitchDefault>{{_getDefaultTextForState(state)}}</mat-icon></ng-container></div></div><div class=\"mat-step-label\" [class.mat-step-label-active]=\"active\" [class.mat-step-label-selected]=\"selected\" [class.mat-step-label-error]=\"state == 'error'\"><ng-container *ngIf=\"_templateLabel()\" [ngTemplateOutlet]=\"_templateLabel()!.template\"></ng-container><div class=\"mat-step-text-label\" *ngIf=\"_stringLabel()\">{{label}}</div><div class=\"mat-step-optional\" *ngIf=\"optional && state != 'error'\">{{_intl.optionalLabel}}</div><div class=\"mat-step-sub-label-error\" *ngIf=\"state == 'error'\">{{errorMessage}}</div></div>",
                      styles: [".mat-step-header{overflow:hidden;outline:0;cursor:pointer;position:relative;box-sizing:content-box;-webkit-tap-highlight-color:transparent}.mat-step-optional,.mat-step-sub-label-error{font-size:12px}.mat-step-icon{border-radius:50%;height:24px;width:24px;flex-shrink:0;position:relative}.mat-step-icon .mat-icon,.mat-step-icon-content{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}.mat-step-icon .mat-icon{font-size:16px;height:16px;width:16px}.mat-step-icon-state-error .mat-icon{font-size:24px;height:24px;width:24px}.mat-step-label{display:inline-block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;min-width:50px;vertical-align:middle}.mat-step-text-label{text-overflow:ellipsis;overflow:hidden}.mat-step-header .mat-step-header-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}"],
                      host: {
                          'class': 'mat-step-header',
                          'role': 'tab',
                      },
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatStepHeader.ctorParameters = function () {
          return [
              { type: MatStepperIntl },
              { type: FocusMonitor },
              { type: core.ElementRef },
              { type: core.ChangeDetectorRef }
          ];
      };
      MatStepHeader.propDecorators = {
          state: [{ type: core.Input }],
          label: [{ type: core.Input }],
          errorMessage: [{ type: core.Input }],
          iconOverrides: [{ type: core.Input }],
          index: [{ type: core.Input }],
          selected: [{ type: core.Input }],
          active: [{ type: core.Input }],
          optional: [{ type: core.Input }]
      };
      return MatStepHeader;
  }(CdkStepHeader));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Animations used by the Material steppers.
   * \@docs-private
   * @type {?}
   */
  var matStepperAnimations = {
      /**
       * Animation that transitions the step along the X axis in a horizontal stepper.
       */
      horizontalStepTransition: trigger('stepTransition', [
          state('previous', style({ transform: 'translate3d(-100%, 0, 0)', visibility: 'hidden' })),
          state('current', style({ transform: 'none', visibility: 'visible' })),
          state('next', style({ transform: 'translate3d(100%, 0, 0)', visibility: 'hidden' })),
          transition('* => *', animate('500ms cubic-bezier(0.35, 0, 0.25, 1)'))
      ]),
      /**
       * Animation that transitions the step along the Y axis in a vertical stepper.
       */
      verticalStepTransition: trigger('stepTransition', [
          state('previous', style({ height: '0px', visibility: 'hidden' })),
          state('next', style({ height: '0px', visibility: 'hidden' })),
          state('current', style({ height: '*', visibility: 'visible' })),
          transition('* <=> current', animate('225ms cubic-bezier(0.4, 0.0, 0.2, 1)'))
      ])
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Template to be used to override the icons inside the step header.
   */
  var MatStepperIcon = /** @class */ (function () {
      function MatStepperIcon(templateRef) {
          this.templateRef = templateRef;
      }
      MatStepperIcon.decorators = [
          { type: core.Directive, args: [{
                      selector: 'ng-template[matStepperIcon]',
                  },] },
      ];
      /** @nocollapse */
      MatStepperIcon.ctorParameters = function () {
          return [
              { type: core.TemplateRef }
          ];
      };
      MatStepperIcon.propDecorators = {
          name: [{ type: core.Input, args: ['matStepperIcon',] }]
      };
      return MatStepperIcon;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var MatStep = /** @class */ (function (_super) {
      tslib_1.__extends(MatStep, _super);
      /** @breaking-change 8.0.0 remove the `?` after `stepperOptions` */
      function MatStep(stepper, _errorStateMatcher, stepperOptions) {
          var _this = _super.call(this, stepper, stepperOptions) || this;
          _this._errorStateMatcher = _errorStateMatcher;
          return _this;
      }
      /** Custom error state matcher that additionally checks for validity of interacted form. */
      /**
       * Custom error state matcher that additionally checks for validity of interacted form.
       * @param {?} control
       * @param {?} form
       * @return {?}
       */
      MatStep.prototype.isErrorState = /**
       * Custom error state matcher that additionally checks for validity of interacted form.
       * @param {?} control
       * @param {?} form
       * @return {?}
       */
          function (control, form) {
              /** @type {?} */
              var originalErrorState = this._errorStateMatcher.isErrorState(control, form);
              // Custom error state checks for the validity of form that is not submitted or touched
              // since user can trigger a form change by calling for another step without directly
              // interacting with the current form.
              /** @type {?} */
              var customErrorState = !!(control && control.invalid && this.interacted);
              return originalErrorState || customErrorState;
          };
      MatStep.decorators = [
          { type: core.Component, args: [{ selector: 'mat-step',
                      template: "<ng-template><ng-content></ng-content></ng-template>",
                      providers: [{ provide: ErrorStateMatcher, useExisting: MatStep }],
                      encapsulation: core.ViewEncapsulation.None,
                      exportAs: 'matStep',
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatStep.ctorParameters = function () {
          return [
              { type: MatStepper, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return MatStepper; }),] }] },
              { type: ErrorStateMatcher, decorators: [{ type: core.SkipSelf }] },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [STEPPER_GLOBAL_OPTIONS,] }] }
          ];
      };
      MatStep.propDecorators = {
          stepLabel: [{ type: core.ContentChild, args: [MatStepLabel,] }]
      };
      return MatStep;
  }(CdkStep));
  var MatStepper = /** @class */ (function (_super) {
      tslib_1.__extends(MatStepper, _super);
      function MatStepper() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          /**
           * Event emitted when the current step is done transitioning in.
           */
          _this.animationDone = new core.EventEmitter();
          /**
           * Consumer-specified template-refs to be used to override the header icons.
           */
          _this._iconOverrides = {};
          /**
           * Stream of animation `done` events when the body expands/collapses.
           */
          _this._animationDone = new rxjs.Subject();
          return _this;
      }
      /**
       * @return {?}
       */
      MatStepper.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._icons.forEach(function (_a) {
                  var name = _a.name, templateRef = _a.templateRef;
                  return _this._iconOverrides[name] = templateRef;
              });
              // Mark the component for change detection whenever the content children query changes
              this._steps.changes.pipe(operators.takeUntil(this._destroyed)).subscribe(function () { return _this._stateChanged(); });
              this._animationDone.pipe(
              // This needs a `distinctUntilChanged` in order to avoid emitting the same event twice due
              // to a bug in animations where the `.done` callback gets invoked twice on some browsers.
              // See https://github.com/angular/angular/issues/24084
              operators.distinctUntilChanged(function (x, y) { return x.fromState === y.fromState && x.toState === y.toState; }), operators.takeUntil(this._destroyed)).subscribe(function (event) {
                  if ((( /** @type {?} */(event.toState))) === 'current') {
                      _this.animationDone.emit();
                  }
              });
          };
      MatStepper.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matStepper]'
                  },] },
      ];
      MatStepper.propDecorators = {
          _stepHeader: [{ type: core.ViewChildren, args: [MatStepHeader,] }],
          _steps: [{ type: core.ContentChildren, args: [MatStep,] }],
          _icons: [{ type: core.ContentChildren, args: [MatStepperIcon,] }],
          animationDone: [{ type: core.Output }]
      };
      return MatStepper;
  }(CdkStepper));
  var MatHorizontalStepper = /** @class */ (function (_super) {
      tslib_1.__extends(MatHorizontalStepper, _super);
      function MatHorizontalStepper() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          /**
           * Whether the label should display in bottom or end position.
           */
          _this.labelPosition = 'end';
          return _this;
      }
      MatHorizontalStepper.decorators = [
          { type: core.Component, args: [{ selector: 'mat-horizontal-stepper',
                      exportAs: 'matHorizontalStepper',
                      template: "<div class=\"mat-horizontal-stepper-header-container\"><ng-container *ngFor=\"let step of steps; let i = index; let isLast = last\"><mat-step-header class=\"mat-horizontal-stepper-header\" (click)=\"step.select()\" (keydown)=\"_onKeydown($event)\" [tabIndex]=\"_getFocusIndex() === i ? 0 : -1\" [id]=\"_getStepLabelId(i)\" [attr.aria-posinset]=\"i + 1\" [attr.aria-setsize]=\"steps.length\" [attr.aria-controls]=\"_getStepContentId(i)\" [attr.aria-selected]=\"selectedIndex == i\" [attr.aria-label]=\"step.ariaLabel || null\" [attr.aria-labelledby]=\"(!step.ariaLabel && step.ariaLabelledby) ? step.ariaLabelledby : null\" [index]=\"i\" [state]=\"_getIndicatorType(i, step.state)\" [label]=\"step.stepLabel || step.label\" [selected]=\"selectedIndex === i\" [active]=\"step.completed || selectedIndex === i || !linear\" [optional]=\"step.optional\" [errorMessage]=\"step.errorMessage\" [iconOverrides]=\"_iconOverrides\"></mat-step-header><div *ngIf=\"!isLast\" class=\"mat-stepper-horizontal-line\"></div></ng-container></div><div class=\"mat-horizontal-content-container\"><div *ngFor=\"let step of steps; let i = index\" class=\"mat-horizontal-stepper-content\" role=\"tabpanel\" [@stepTransition]=\"_getAnimationDirection(i)\" (@stepTransition.done)=\"_animationDone.next($event)\" [id]=\"_getStepContentId(i)\" [attr.aria-labelledby]=\"_getStepLabelId(i)\" [attr.aria-expanded]=\"selectedIndex === i\"><ng-container [ngTemplateOutlet]=\"step.content\"></ng-container></div></div>",
                      styles: [".mat-stepper-horizontal,.mat-stepper-vertical{display:block}.mat-horizontal-stepper-header-container{white-space:nowrap;display:flex;align-items:center}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header-container{align-items:flex-start}.mat-stepper-horizontal-line{border-top-width:1px;border-top-style:solid;flex:auto;height:0;margin:0 -16px;min-width:32px}.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{margin:0;min-width:0;position:relative;top:36px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{border-top-width:1px;border-top-style:solid;content:'';display:inline-block;height:0;position:absolute;top:36px;width:calc(50% - 20px)}.mat-horizontal-stepper-header{display:flex;height:72px;overflow:hidden;align-items:center;padding:0 24px}.mat-horizontal-stepper-header .mat-step-icon{margin-right:8px;flex:none}[dir=rtl] .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:8px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header{box-sizing:border-box;flex-direction:column;height:auto;padding:24px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{right:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{left:0}[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:first-child::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:last-child::before{display:none}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-label{padding:16px 0 0 0;text-align:center;width:100%}.mat-vertical-stepper-header{display:flex;align-items:center;padding:24px;height:24px}.mat-vertical-stepper-header .mat-step-icon{margin-right:12px}[dir=rtl] .mat-vertical-stepper-header .mat-step-icon{margin-right:0;margin-left:12px}.mat-horizontal-stepper-content[aria-expanded=false]{height:0;overflow:hidden}.mat-horizontal-content-container{overflow:hidden;padding:0 24px 24px 24px}.mat-vertical-content-container{margin-left:36px;border:0;position:relative}[dir=rtl] .mat-vertical-content-container{margin-left:0;margin-right:36px}.mat-stepper-vertical-line::before{content:'';position:absolute;top:-16px;bottom:-16px;left:0;border-left-width:1px;border-left-style:solid}[dir=rtl] .mat-stepper-vertical-line::before{left:auto;right:0}.mat-vertical-stepper-content{overflow:hidden}.mat-vertical-content{padding:0 24px 24px 24px}.mat-step:last-child .mat-vertical-content-container{border:none}"],
                      inputs: ['selectedIndex'],
                      host: {
                          'class': 'mat-stepper-horizontal',
                          '[class.mat-stepper-label-position-end]': 'labelPosition == "end"',
                          '[class.mat-stepper-label-position-bottom]': 'labelPosition == "bottom"',
                          'aria-orientation': 'horizontal',
                          'role': 'tablist',
                      },
                      animations: [matStepperAnimations.horizontalStepTransition],
                      providers: [{ provide: MatStepper, useExisting: MatHorizontalStepper }],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      MatHorizontalStepper.propDecorators = {
          labelPosition: [{ type: core.Input }]
      };
      return MatHorizontalStepper;
  }(MatStepper));
  var MatVerticalStepper = /** @class */ (function (_super) {
      tslib_1.__extends(MatVerticalStepper, _super);
      function MatVerticalStepper(dir, changeDetectorRef, 
      // @breaking-change 8.0.0 `elementRef` and `_document` parameters to become required.
      elementRef, _document) {
          var _this = _super.call(this, dir, changeDetectorRef, elementRef, _document) || this;
          _this._orientation = 'vertical';
          return _this;
      }
      MatVerticalStepper.decorators = [
          { type: core.Component, args: [{ selector: 'mat-vertical-stepper',
                      exportAs: 'matVerticalStepper',
                      template: "<div class=\"mat-step\" *ngFor=\"let step of steps; let i = index; let isLast = last\"><mat-step-header class=\"mat-vertical-stepper-header\" (click)=\"step.select()\" (keydown)=\"_onKeydown($event)\" [tabIndex]=\"_getFocusIndex() == i ? 0 : -1\" [id]=\"_getStepLabelId(i)\" [attr.aria-posinset]=\"i + 1\" [attr.aria-setsize]=\"steps.length\" [attr.aria-controls]=\"_getStepContentId(i)\" [attr.aria-selected]=\"selectedIndex === i\" [attr.aria-label]=\"step.ariaLabel || null\" [attr.aria-labelledby]=\"(!step.ariaLabel && step.ariaLabelledby) ? step.ariaLabelledby : null\" [index]=\"i\" [state]=\"_getIndicatorType(i, step.state)\" [label]=\"step.stepLabel || step.label\" [selected]=\"selectedIndex === i\" [active]=\"step.completed || selectedIndex === i || !linear\" [optional]=\"step.optional\" [errorMessage]=\"step.errorMessage\" [iconOverrides]=\"_iconOverrides\"></mat-step-header><div class=\"mat-vertical-content-container\" [class.mat-stepper-vertical-line]=\"!isLast\"><div class=\"mat-vertical-stepper-content\" role=\"tabpanel\" [@stepTransition]=\"_getAnimationDirection(i)\" (@stepTransition.done)=\"_animationDone.next($event)\" [id]=\"_getStepContentId(i)\" [attr.aria-labelledby]=\"_getStepLabelId(i)\" [attr.aria-expanded]=\"selectedIndex === i\"><div class=\"mat-vertical-content\"><ng-container [ngTemplateOutlet]=\"step.content\"></ng-container></div></div></div></div>",
                      styles: [".mat-stepper-horizontal,.mat-stepper-vertical{display:block}.mat-horizontal-stepper-header-container{white-space:nowrap;display:flex;align-items:center}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header-container{align-items:flex-start}.mat-stepper-horizontal-line{border-top-width:1px;border-top-style:solid;flex:auto;height:0;margin:0 -16px;min-width:32px}.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{margin:0;min-width:0;position:relative;top:36px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{border-top-width:1px;border-top-style:solid;content:'';display:inline-block;height:0;position:absolute;top:36px;width:calc(50% - 20px)}.mat-horizontal-stepper-header{display:flex;height:72px;overflow:hidden;align-items:center;padding:0 24px}.mat-horizontal-stepper-header .mat-step-icon{margin-right:8px;flex:none}[dir=rtl] .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:8px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header{box-sizing:border-box;flex-direction:column;height:auto;padding:24px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{right:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{left:0}[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:first-child::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:last-child::before{display:none}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-label{padding:16px 0 0 0;text-align:center;width:100%}.mat-vertical-stepper-header{display:flex;align-items:center;padding:24px;height:24px}.mat-vertical-stepper-header .mat-step-icon{margin-right:12px}[dir=rtl] .mat-vertical-stepper-header .mat-step-icon{margin-right:0;margin-left:12px}.mat-horizontal-stepper-content[aria-expanded=false]{height:0;overflow:hidden}.mat-horizontal-content-container{overflow:hidden;padding:0 24px 24px 24px}.mat-vertical-content-container{margin-left:36px;border:0;position:relative}[dir=rtl] .mat-vertical-content-container{margin-left:0;margin-right:36px}.mat-stepper-vertical-line::before{content:'';position:absolute;top:-16px;bottom:-16px;left:0;border-left-width:1px;border-left-style:solid}[dir=rtl] .mat-stepper-vertical-line::before{left:auto;right:0}.mat-vertical-stepper-content{overflow:hidden}.mat-vertical-content{padding:0 24px 24px 24px}.mat-step:last-child .mat-vertical-content-container{border:none}"],
                      inputs: ['selectedIndex'],
                      host: {
                          'class': 'mat-stepper-vertical',
                          'aria-orientation': 'vertical',
                          'role': 'tablist',
                      },
                      animations: [matStepperAnimations.verticalStepTransition],
                      providers: [{ provide: MatStepper, useExisting: MatVerticalStepper }],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatVerticalStepper.ctorParameters = function () {
          return [
              { type: Directionality, decorators: [{ type: core.Optional }] },
              { type: core.ChangeDetectorRef },
              { type: core.ElementRef },
              { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
          ];
      };
      return MatVerticalStepper;
  }(MatStepper));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Button that moves to the next step in a stepper workflow.
   */
  var MatStepperNext = /** @class */ (function (_super) {
      tslib_1.__extends(MatStepperNext, _super);
      function MatStepperNext() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MatStepperNext.decorators = [
          { type: core.Directive, args: [{
                      selector: 'button[matStepperNext]',
                      host: {
                          '(click)': '_stepper.next()',
                          '[type]': 'type',
                      },
                      inputs: ['type'],
                      providers: [{ provide: CdkStepper, useExisting: MatStepper }]
                  },] },
      ];
      return MatStepperNext;
  }(CdkStepperNext));
  /**
   * Button that moves to the previous step in a stepper workflow.
   */
  var MatStepperPrevious = /** @class */ (function (_super) {
      tslib_1.__extends(MatStepperPrevious, _super);
      function MatStepperPrevious() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MatStepperPrevious.decorators = [
          { type: core.Directive, args: [{
                      selector: 'button[matStepperPrevious]',
                      host: {
                          '(click)': '_stepper.previous()',
                          '[type]': 'type',
                      },
                      inputs: ['type'],
                      providers: [{ provide: CdkStepper, useExisting: MatStepper }]
                  },] },
      ];
      return MatStepperPrevious;
  }(CdkStepperPrevious));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Mixin to provide a directive with a function that checks if the sticky input has been
   * changed since the last time the function was called. Essentially adds a dirty-check to the
   * sticky value.
   * \@docs-private
   * @template T
   * @param {?} base
   * @return {?}
   */
  function mixinHasStickyInput(base) {
      return /** @class */ (function (_super) {
          tslib_1.__extends(class_1, _super);
          function class_1() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
              }
              var _this = _super.apply(this, args) || this;
              _this._sticky = false;
              /**
               * Whether the sticky input has changed since it was last checked.
               */
              _this._hasStickyChanged = false;
              return _this;
          }
          Object.defineProperty(class_1.prototype, "sticky", {
              /** Whether sticky positioning should be applied. */
              get: /**
               * Whether sticky positioning should be applied.
               * @return {?}
               */ function () { return this._sticky; },
              set: /**
               * @param {?} v
               * @return {?}
               */ function (v) {
                  /** @type {?} */
                  var prevValue = this._sticky;
                  this._sticky = coerceBooleanProperty(v);
                  this._hasStickyChanged = prevValue !== this._sticky;
              },
              enumerable: true,
              configurable: true
          });
          /** Whether the sticky value has changed since this was last called. */
          /**
           * Whether the sticky value has changed since this was last called.
           * @return {?}
           */
          class_1.prototype.hasStickyChanged = /**
           * Whether the sticky value has changed since this was last called.
           * @return {?}
           */
              function () {
                  /** @type {?} */
                  var hasStickyChanged = this._hasStickyChanged;
                  this._hasStickyChanged = false;
                  return hasStickyChanged;
              };
          /** Resets the dirty check for cases where the sticky state has been used without checking. */
          /**
           * Resets the dirty check for cases where the sticky state has been used without checking.
           * @return {?}
           */
          class_1.prototype.resetStickyChanged = /**
           * Resets the dirty check for cases where the sticky state has been used without checking.
           * @return {?}
           */
              function () {
                  this._hasStickyChanged = false;
              };
          return class_1;
      }(base));
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Cell definition for a CDK table.
   * Captures the template of a column's data row cell as well as cell-specific properties.
   */
  var CdkCellDef = /** @class */ (function () {
      function CdkCellDef(/** @docs-private */ template) {
          this.template = template;
      }
      CdkCellDef.decorators = [
          { type: core.Directive, args: [{ selector: '[cdkCellDef]' },] },
      ];
      /** @nocollapse */
      CdkCellDef.ctorParameters = function () {
          return [
              { type: core.TemplateRef }
          ];
      };
      return CdkCellDef;
  }());
  /**
   * Header cell definition for a CDK table.
   * Captures the template of a column's header cell and as well as cell-specific properties.
   */
  var CdkHeaderCellDef = /** @class */ (function () {
      function CdkHeaderCellDef(/** @docs-private */ template) {
          this.template = template;
      }
      CdkHeaderCellDef.decorators = [
          { type: core.Directive, args: [{ selector: '[cdkHeaderCellDef]' },] },
      ];
      /** @nocollapse */
      CdkHeaderCellDef.ctorParameters = function () {
          return [
              { type: core.TemplateRef }
          ];
      };
      return CdkHeaderCellDef;
  }());
  /**
   * Footer cell definition for a CDK table.
   * Captures the template of a column's footer cell and as well as cell-specific properties.
   */
  var CdkFooterCellDef = /** @class */ (function () {
      function CdkFooterCellDef(/** @docs-private */ template) {
          this.template = template;
      }
      CdkFooterCellDef.decorators = [
          { type: core.Directive, args: [{ selector: '[cdkFooterCellDef]' },] },
      ];
      /** @nocollapse */
      CdkFooterCellDef.ctorParameters = function () {
          return [
              { type: core.TemplateRef }
          ];
      };
      return CdkFooterCellDef;
  }());
  // Boilerplate for applying mixins to CdkColumnDef.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to CdkColumnDef.
  /**
   * \@docs-private
   */
  CdkColumnDefBase = /** @class */ (function () {
      function CdkColumnDefBase() {
      }
      return CdkColumnDefBase;
  }());
  /** @type {?} */
  var _CdkColumnDefBase = mixinHasStickyInput(CdkColumnDefBase);
  /**
   * Column definition for the CDK table.
   * Defines a set of cells available for a table column.
   */
  var CdkColumnDef = /** @class */ (function (_super) {
      tslib_1.__extends(CdkColumnDef, _super);
      function CdkColumnDef() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this._stickyEnd = false;
          return _this;
      }
      Object.defineProperty(CdkColumnDef.prototype, "name", {
          /** Unique name for this column. */
          get: /**
           * Unique name for this column.
           * @return {?}
           */ function () { return this._name; },
          set: /**
           * @param {?} name
           * @return {?}
           */ function (name) {
              // If the directive is set without a name (updated programatically), then this setter will
              // trigger with an empty string and should not overwrite the programatically set value.
              if (!name) {
                  return;
              }
              this._name = name;
              this.cssClassFriendlyName = name.replace(/[^a-z0-9_-]/ig, '-');
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkColumnDef.prototype, "stickyEnd", {
          /**
           * Whether this column should be sticky positioned on the end of the row. Should make sure
           * that it mimics the `CanStick` mixin such that `_hasStickyChanged` is set to true if the value
           * has been changed.
           */
          get: /**
           * Whether this column should be sticky positioned on the end of the row. Should make sure
           * that it mimics the `CanStick` mixin such that `_hasStickyChanged` is set to true if the value
           * has been changed.
           * @return {?}
           */ function () { return this._stickyEnd; },
          set: /**
           * @param {?} v
           * @return {?}
           */ function (v) {
              /** @type {?} */
              var prevValue = this._stickyEnd;
              this._stickyEnd = coerceBooleanProperty(v);
              this._hasStickyChanged = prevValue !== this._stickyEnd;
          },
          enumerable: true,
          configurable: true
      });
      CdkColumnDef.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkColumnDef]',
                      inputs: ['sticky'],
                      providers: [{
                              provide: 'MAT_SORT_HEADER_COLUMN_DEF',
                              useExisting: CdkColumnDef
                          }],
                  },] },
      ];
      CdkColumnDef.propDecorators = {
          name: [{ type: core.Input, args: ['cdkColumnDef',] }],
          stickyEnd: [{ type: core.Input, args: ['stickyEnd',] }],
          cell: [{ type: core.ContentChild, args: [CdkCellDef,] }],
          headerCell: [{ type: core.ContentChild, args: [CdkHeaderCellDef,] }],
          footerCell: [{ type: core.ContentChild, args: [CdkFooterCellDef,] }]
      };
      return CdkColumnDef;
  }(_CdkColumnDefBase));
  /**
   * Base class for the cells. Adds a CSS classname that identifies the column it renders in.
   */
  var /**
   * Base class for the cells. Adds a CSS classname that identifies the column it renders in.
   */ BaseCdkCell = /** @class */ (function () {
      function BaseCdkCell(columnDef, elementRef) {
          /** @type {?} */
          var columnClassName = "cdk-column-" + columnDef.cssClassFriendlyName;
          elementRef.nativeElement.classList.add(columnClassName);
      }
      return BaseCdkCell;
  }());
  /**
   * Header cell template container that adds the right classes and role.
   */
  var CdkHeaderCell = /** @class */ (function (_super) {
      tslib_1.__extends(CdkHeaderCell, _super);
      function CdkHeaderCell(columnDef, elementRef) {
          return _super.call(this, columnDef, elementRef) || this;
      }
      CdkHeaderCell.decorators = [
          { type: core.Directive, args: [{
                      selector: 'cdk-header-cell, th[cdk-header-cell]',
                      host: {
                          'class': 'cdk-header-cell',
                          'role': 'columnheader',
                      },
                  },] },
      ];
      /** @nocollapse */
      CdkHeaderCell.ctorParameters = function () {
          return [
              { type: CdkColumnDef },
              { type: core.ElementRef }
          ];
      };
      return CdkHeaderCell;
  }(BaseCdkCell));
  /**
   * Footer cell template container that adds the right classes and role.
   */
  var CdkFooterCell = /** @class */ (function (_super) {
      tslib_1.__extends(CdkFooterCell, _super);
      function CdkFooterCell(columnDef, elementRef) {
          return _super.call(this, columnDef, elementRef) || this;
      }
      CdkFooterCell.decorators = [
          { type: core.Directive, args: [{
                      selector: 'cdk-footer-cell, td[cdk-footer-cell]',
                      host: {
                          'class': 'cdk-footer-cell',
                          'role': 'gridcell',
                      },
                  },] },
      ];
      /** @nocollapse */
      CdkFooterCell.ctorParameters = function () {
          return [
              { type: CdkColumnDef },
              { type: core.ElementRef }
          ];
      };
      return CdkFooterCell;
  }(BaseCdkCell));
  /**
   * Cell template container that adds the right classes and role.
   */
  var CdkCell = /** @class */ (function (_super) {
      tslib_1.__extends(CdkCell, _super);
      function CdkCell(columnDef, elementRef) {
          return _super.call(this, columnDef, elementRef) || this;
      }
      CdkCell.decorators = [
          { type: core.Directive, args: [{
                      selector: 'cdk-cell, td[cdk-cell]',
                      host: {
                          'class': 'cdk-cell',
                          'role': 'gridcell',
                      },
                  },] },
      ];
      /** @nocollapse */
      CdkCell.ctorParameters = function () {
          return [
              { type: CdkColumnDef },
              { type: core.ElementRef }
          ];
      };
      return CdkCell;
  }(BaseCdkCell));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * The row template that can be used by the mat-table. Should not be used outside of the
   * material library.
   * @type {?}
   */
  var CDK_ROW_TEMPLATE = "<ng-container cdkCellOutlet></ng-container>";
  /**
   * Base class for the CdkHeaderRowDef and CdkRowDef that handles checking their columns inputs
   * for changes and notifying the table.
   * @abstract
   */
  var /**
   * Base class for the CdkHeaderRowDef and CdkRowDef that handles checking their columns inputs
   * for changes and notifying the table.
   * @abstract
   */ BaseRowDef = /** @class */ (function () {
      function BaseRowDef(/** @docs-private */ template, _differs) {
          this.template = template;
          this._differs = _differs;
      }
      /**
       * @param {?} changes
       * @return {?}
       */
      BaseRowDef.prototype.ngOnChanges = /**
       * @param {?} changes
       * @return {?}
       */
          function (changes) {
              // Create a new columns differ if one does not yet exist. Initialize it based on initial value
              // of the columns property or an empty array if none is provided.
              if (!this._columnsDiffer) {
                  /** @type {?} */
                  var columns = (changes['columns'] && changes['columns'].currentValue) || [];
                  this._columnsDiffer = this._differs.find(columns).create();
                  this._columnsDiffer.diff(columns);
              }
          };
      /**
       * Returns the difference between the current columns and the columns from the last diff, or null
       * if there is no difference.
       */
      /**
       * Returns the difference between the current columns and the columns from the last diff, or null
       * if there is no difference.
       * @return {?}
       */
      BaseRowDef.prototype.getColumnsDiff = /**
       * Returns the difference between the current columns and the columns from the last diff, or null
       * if there is no difference.
       * @return {?}
       */
          function () {
              return this._columnsDiffer.diff(this.columns);
          };
      /** Gets this row def's relevant cell template from the provided column def. */
      /**
       * Gets this row def's relevant cell template from the provided column def.
       * @param {?} column
       * @return {?}
       */
      BaseRowDef.prototype.extractCellTemplate = /**
       * Gets this row def's relevant cell template from the provided column def.
       * @param {?} column
       * @return {?}
       */
          function (column) {
              if (this instanceof CdkHeaderRowDef) {
                  return column.headerCell.template;
              }
              if (this instanceof CdkFooterRowDef) {
                  return column.footerCell.template;
              }
              else {
                  return column.cell.template;
              }
          };
      return BaseRowDef;
  }());
  // Boilerplate for applying mixins to CdkHeaderRowDef.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to CdkHeaderRowDef.
  /**
   * \@docs-private
   */
  CdkHeaderRowDefBase = /** @class */ (function (_super) {
      tslib_1.__extends(CdkHeaderRowDefBase, _super);
      function CdkHeaderRowDefBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      return CdkHeaderRowDefBase;
  }(BaseRowDef));
  /** @type {?} */
  var _CdkHeaderRowDefBase = mixinHasStickyInput(CdkHeaderRowDefBase);
  /**
   * Header row definition for the CDK table.
   * Captures the header row's template and other header properties such as the columns to display.
   */
  var CdkHeaderRowDef = /** @class */ (function (_super) {
      tslib_1.__extends(CdkHeaderRowDef, _super);
      function CdkHeaderRowDef(template, _differs) {
          return _super.call(this, template, _differs) || this;
      }
      // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
      // Explicitly define it so that the method is called as part of the Angular lifecycle.
      // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
      // Explicitly define it so that the method is called as part of the Angular lifecycle.
      /**
       * @param {?} changes
       * @return {?}
       */
      CdkHeaderRowDef.prototype.ngOnChanges =
          // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
          // Explicitly define it so that the method is called as part of the Angular lifecycle.
          /**
           * @param {?} changes
           * @return {?}
           */
          function (changes) {
              _super.prototype.ngOnChanges.call(this, changes);
          };
      CdkHeaderRowDef.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkHeaderRowDef]',
                      inputs: ['columns: cdkHeaderRowDef', 'sticky: cdkHeaderRowDefSticky'],
                  },] },
      ];
      /** @nocollapse */
      CdkHeaderRowDef.ctorParameters = function () {
          return [
              { type: core.TemplateRef },
              { type: core.IterableDiffers }
          ];
      };
      return CdkHeaderRowDef;
  }(_CdkHeaderRowDefBase));
  // Boilerplate for applying mixins to CdkFooterRowDef.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to CdkFooterRowDef.
  /**
   * \@docs-private
   */
  CdkFooterRowDefBase = /** @class */ (function (_super) {
      tslib_1.__extends(CdkFooterRowDefBase, _super);
      function CdkFooterRowDefBase() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      return CdkFooterRowDefBase;
  }(BaseRowDef));
  /** @type {?} */
  var _CdkFooterRowDefBase = mixinHasStickyInput(CdkFooterRowDefBase);
  /**
   * Footer row definition for the CDK table.
   * Captures the footer row's template and other footer properties such as the columns to display.
   */
  var CdkFooterRowDef = /** @class */ (function (_super) {
      tslib_1.__extends(CdkFooterRowDef, _super);
      function CdkFooterRowDef(template, _differs) {
          return _super.call(this, template, _differs) || this;
      }
      // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
      // Explicitly define it so that the method is called as part of the Angular lifecycle.
      // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
      // Explicitly define it so that the method is called as part of the Angular lifecycle.
      /**
       * @param {?} changes
       * @return {?}
       */
      CdkFooterRowDef.prototype.ngOnChanges =
          // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
          // Explicitly define it so that the method is called as part of the Angular lifecycle.
          /**
           * @param {?} changes
           * @return {?}
           */
          function (changes) {
              _super.prototype.ngOnChanges.call(this, changes);
          };
      CdkFooterRowDef.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkFooterRowDef]',
                      inputs: ['columns: cdkFooterRowDef', 'sticky: cdkFooterRowDefSticky'],
                  },] },
      ];
      /** @nocollapse */
      CdkFooterRowDef.ctorParameters = function () {
          return [
              { type: core.TemplateRef },
              { type: core.IterableDiffers }
          ];
      };
      return CdkFooterRowDef;
  }(_CdkFooterRowDefBase));
  /**
   * Data row definition for the CDK table.
   * Captures the header row's template and other row properties such as the columns to display and
   * a when predicate that describes when this row should be used.
   * @template T
   */
  var CdkRowDef = /** @class */ (function (_super) {
      tslib_1.__extends(CdkRowDef, _super);
      // TODO(andrewseguin): Add an input for providing a switch function to determine
      //   if this template should be used.
      function CdkRowDef(template, _differs) {
          return _super.call(this, template, _differs) || this;
      }
      CdkRowDef.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkRowDef]',
                      inputs: ['columns: cdkRowDefColumns', 'when: cdkRowDefWhen'],
                  },] },
      ];
      /** @nocollapse */
      CdkRowDef.ctorParameters = function () {
          return [
              { type: core.TemplateRef },
              { type: core.IterableDiffers }
          ];
      };
      return CdkRowDef;
  }(BaseRowDef));
  /**
   * Outlet for rendering cells inside of a row or header row.
   * \@docs-private
   */
  var CdkCellOutlet = /** @class */ (function () {
      function CdkCellOutlet(_viewContainer) {
          this._viewContainer = _viewContainer;
          CdkCellOutlet.mostRecentCellOutlet = this;
      }
      /**
       * @return {?}
       */
      CdkCellOutlet.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              // If this was the last outlet being rendered in the view, remove the reference
              // from the static property after it has been destroyed to avoid leaking memory.
              if (CdkCellOutlet.mostRecentCellOutlet === this) {
                  CdkCellOutlet.mostRecentCellOutlet = null;
              }
          };
      /**
       * Static property containing the latest constructed instance of this class.
       * Used by the CDK table when each CdkHeaderRow and CdkRow component is created using
       * createEmbeddedView. After one of these components are created, this property will provide
       * a handle to provide that component's cells and context. After init, the CdkCellOutlet will
       * construct the cells with the provided context.
       */
      CdkCellOutlet.mostRecentCellOutlet = null;
      CdkCellOutlet.decorators = [
          { type: core.Directive, args: [{ selector: '[cdkCellOutlet]' },] },
      ];
      /** @nocollapse */
      CdkCellOutlet.ctorParameters = function () {
          return [
              { type: core.ViewContainerRef }
          ];
      };
      return CdkCellOutlet;
  }());
  /**
   * Header template container that contains the cell outlet. Adds the right class and role.
   */
  var CdkHeaderRow = /** @class */ (function () {
      function CdkHeaderRow() {
      }
      CdkHeaderRow.decorators = [
          { type: core.Component, args: [{ selector: 'cdk-header-row, tr[cdk-header-row]',
                      template: CDK_ROW_TEMPLATE,
                      host: {
                          'class': 'cdk-header-row',
                          'role': 'row',
                      },
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                  },] },
      ];
      return CdkHeaderRow;
  }());
  /**
   * Footer template container that contains the cell outlet. Adds the right class and role.
   */
  var CdkFooterRow = /** @class */ (function () {
      function CdkFooterRow() {
      }
      CdkFooterRow.decorators = [
          { type: core.Component, args: [{ selector: 'cdk-footer-row, tr[cdk-footer-row]',
                      template: CDK_ROW_TEMPLATE,
                      host: {
                          'class': 'cdk-footer-row',
                          'role': 'row',
                      },
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                  },] },
      ];
      return CdkFooterRow;
  }());
  /**
   * Data row template container that contains the cell outlet. Adds the right class and role.
   */
  var CdkRow = /** @class */ (function () {
      function CdkRow() {
      }
      CdkRow.decorators = [
          { type: core.Component, args: [{ selector: 'cdk-row, tr[cdk-row]',
                      template: CDK_ROW_TEMPLATE,
                      host: {
                          'class': 'cdk-row',
                          'role': 'row',
                      },
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                  },] },
      ];
      return CdkRow;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Returns an error to be thrown when attempting to find an unexisting column.
   * \@docs-private
   * @param {?} id Id whose lookup failed.
   * @return {?}
   */
  function getTableUnknownColumnError(id) {
      return Error("Could not find column with id \"" + id + "\".");
  }
  /**
   * Returns an error to be thrown when two column definitions have the same name.
   * \@docs-private
   * @param {?} name
   * @return {?}
   */
  function getTableDuplicateColumnNameError(name) {
      return Error("Duplicate column definition name provided: \"" + name + "\".");
  }
  /**
   * Returns an error to be thrown when there are multiple rows that are missing a when function.
   * \@docs-private
   * @return {?}
   */
  function getTableMultipleDefaultRowDefsError() {
      return Error("There can only be one default row without a when predicate function.");
  }
  /**
   * Returns an error to be thrown when there are no matching row defs for a particular set of data.
   * \@docs-private
   * @param {?} data
   * @return {?}
   */
  function getTableMissingMatchingRowDefError(data) {
      return Error("Could not find a matching row definition for the" +
          ("provided row data: " + JSON.stringify(data)));
  }
  /**
   * Returns an error to be thrown when there is no row definitions present in the content.
   * \@docs-private
   * @return {?}
   */
  function getTableMissingRowDefsError() {
      return Error('Missing definitions for header, footer, and row; ' +
          'cannot determine which columns should be rendered.');
  }
  /**
   * Returns an error to be thrown when the data source does not match the compatible types.
   * \@docs-private
   * @return {?}
   */
  function getTableUnknownDataSourceError() {
      return Error("Provided data source did not match an array, Observable, or DataSource");
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * List of all possible directions that can be used for sticky positioning.
   * \@docs-private
   * @type {?}
   */
  var STICKY_DIRECTIONS = ['top', 'bottom', 'left', 'right'];
  /**
   * Applies and removes sticky positioning styles to the `CdkTable` rows and columns cells.
   * \@docs-private
   */
  var /**
   * Applies and removes sticky positioning styles to the `CdkTable` rows and columns cells.
   * \@docs-private
   */ StickyStyler = /** @class */ (function () {
      /**
       * @param isNativeHtmlTable Whether the sticky logic should be based on a table
       *     that uses the native `<table>` element.
       * @param stickCellCss The CSS class that will be applied to every row/cell that has
       *     sticky positioning applied.
       * @param direction The directionality context of the table (ltr/rtl); affects column positioning
       *     by reversing left/right positions.
       * @param _isBrowser Whether the table is currently being rendered on the server or the client.
       */
      function StickyStyler(isNativeHtmlTable, stickCellCss, direction, _isBrowser) {
          if (_isBrowser === void 0) {
              _isBrowser = true;
          }
          this.isNativeHtmlTable = isNativeHtmlTable;
          this.stickCellCss = stickCellCss;
          this.direction = direction;
          this._isBrowser = _isBrowser;
      }
      /**
       * Clears the sticky positioning styles from the row and its cells by resetting the `position`
       * style, setting the zIndex to 0, and unsetting each provided sticky direction.
       * @param rows The list of rows that should be cleared from sticking in the provided directions
       * @param stickyDirections The directions that should no longer be set as sticky on the rows.
       */
      /**
       * Clears the sticky positioning styles from the row and its cells by resetting the `position`
       * style, setting the zIndex to 0, and unsetting each provided sticky direction.
       * @param {?} rows The list of rows that should be cleared from sticking in the provided directions
       * @param {?} stickyDirections The directions that should no longer be set as sticky on the rows.
       * @return {?}
       */
      StickyStyler.prototype.clearStickyPositioning = /**
       * Clears the sticky positioning styles from the row and its cells by resetting the `position`
       * style, setting the zIndex to 0, and unsetting each provided sticky direction.
       * @param {?} rows The list of rows that should be cleared from sticking in the provided directions
       * @param {?} stickyDirections The directions that should no longer be set as sticky on the rows.
       * @return {?}
       */
          function (rows, stickyDirections) {
              for (var _i = 0, rows_1 = rows; _i < rows_1.length; _i++) {
                  var row = rows_1[_i];
                  // If the row isn't an element (e.g. if it's an `ng-container`),
                  // it won't have inline styles or `children` so we skip it.
                  if (row.nodeType !== row.ELEMENT_NODE) {
                      continue;
                  }
                  this._removeStickyStyle(row, stickyDirections);
                  for (var i = 0; i < row.children.length; i++) {
                      /** @type {?} */
                      var cell = ( /** @type {?} */(row.children[i]));
                      this._removeStickyStyle(cell, stickyDirections);
                  }
              }
          };
      /**
       * Applies sticky left and right positions to the cells of each row according to the sticky
       * states of the rendered column definitions.
       * @param rows The rows that should have its set of cells stuck according to the sticky states.
       * @param stickyStartStates A list of boolean states where each state represents whether the cell
       *     in this index position should be stuck to the start of the row.
       * @param stickyEndStates A list of boolean states where each state represents whether the cell
       *     in this index position should be stuck to the end of the row.
       */
      /**
       * Applies sticky left and right positions to the cells of each row according to the sticky
       * states of the rendered column definitions.
       * @param {?} rows The rows that should have its set of cells stuck according to the sticky states.
       * @param {?} stickyStartStates A list of boolean states where each state represents whether the cell
       *     in this index position should be stuck to the start of the row.
       * @param {?} stickyEndStates A list of boolean states where each state represents whether the cell
       *     in this index position should be stuck to the end of the row.
       * @return {?}
       */
      StickyStyler.prototype.updateStickyColumns = /**
       * Applies sticky left and right positions to the cells of each row according to the sticky
       * states of the rendered column definitions.
       * @param {?} rows The rows that should have its set of cells stuck according to the sticky states.
       * @param {?} stickyStartStates A list of boolean states where each state represents whether the cell
       *     in this index position should be stuck to the start of the row.
       * @param {?} stickyEndStates A list of boolean states where each state represents whether the cell
       *     in this index position should be stuck to the end of the row.
       * @return {?}
       */
          function (rows, stickyStartStates, stickyEndStates) {
              /** @type {?} */
              var hasStickyColumns = stickyStartStates.some(function (state) { return state; }) || stickyEndStates.some(function (state) { return state; });
              if (!rows.length || !hasStickyColumns || !this._isBrowser) {
                  return;
              }
              /** @type {?} */
              var firstRow = rows[0];
              /** @type {?} */
              var numCells = firstRow.children.length;
              /** @type {?} */
              var cellWidths = this._getCellWidths(firstRow);
              /** @type {?} */
              var startPositions = this._getStickyStartColumnPositions(cellWidths, stickyStartStates);
              /** @type {?} */
              var endPositions = this._getStickyEndColumnPositions(cellWidths, stickyEndStates);
              /** @type {?} */
              var isRtl = this.direction === 'rtl';
              for (var _i = 0, rows_2 = rows; _i < rows_2.length; _i++) {
                  var row = rows_2[_i];
                  for (var i = 0; i < numCells; i++) {
                      /** @type {?} */
                      var cell = ( /** @type {?} */(row.children[i]));
                      if (stickyStartStates[i]) {
                          this._addStickyStyle(cell, isRtl ? 'right' : 'left', startPositions[i]);
                      }
                      if (stickyEndStates[i]) {
                          this._addStickyStyle(cell, isRtl ? 'left' : 'right', endPositions[i]);
                      }
                  }
              }
          };
      /**
       * Applies sticky positioning to the row's cells if using the native table layout, and to the
       * row itself otherwise.
       * @param rowsToStick The list of rows that should be stuck according to their corresponding
       *     sticky state and to the provided top or bottom position.
       * @param stickyStates A list of boolean states where each state represents whether the row
       *     should be stuck in the particular top or bottom position.
       * @param position The position direction in which the row should be stuck if that row should be
       *     sticky.
       *
       */
      /**
       * Applies sticky positioning to the row's cells if using the native table layout, and to the
       * row itself otherwise.
       * @param {?} rowsToStick The list of rows that should be stuck according to their corresponding
       *     sticky state and to the provided top or bottom position.
       * @param {?} stickyStates A list of boolean states where each state represents whether the row
       *     should be stuck in the particular top or bottom position.
       * @param {?} position The position direction in which the row should be stuck if that row should be
       *     sticky.
       *
       * @return {?}
       */
      StickyStyler.prototype.stickRows = /**
       * Applies sticky positioning to the row's cells if using the native table layout, and to the
       * row itself otherwise.
       * @param {?} rowsToStick The list of rows that should be stuck according to their corresponding
       *     sticky state and to the provided top or bottom position.
       * @param {?} stickyStates A list of boolean states where each state represents whether the row
       *     should be stuck in the particular top or bottom position.
       * @param {?} position The position direction in which the row should be stuck if that row should be
       *     sticky.
       *
       * @return {?}
       */
          function (rowsToStick, stickyStates, position) {
              // Since we can't measure the rows on the server, we can't stick the rows properly.
              if (!this._isBrowser) {
                  return;
              }
              // If positioning the rows to the bottom, reverse their order when evaluating the sticky
              // position such that the last row stuck will be "bottom: 0px" and so on.
              /** @type {?} */
              var rows = position === 'bottom' ? rowsToStick.reverse() : rowsToStick;
              /** @type {?} */
              var stickyHeight = 0;
              for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
                  if (!stickyStates[rowIndex]) {
                      continue;
                  }
                  /** @type {?} */
                  var row = rows[rowIndex];
                  if (this.isNativeHtmlTable) {
                      for (var j = 0; j < row.children.length; j++) {
                          /** @type {?} */
                          var cell = ( /** @type {?} */(row.children[j]));
                          this._addStickyStyle(cell, position, stickyHeight);
                      }
                  }
                  else {
                      // Flex does not respect the stick positioning on the cells, needs to be applied to the row.
                      // If this is applied on a native table, Safari causes the header to fly in wrong direction.
                      this._addStickyStyle(row, position, stickyHeight);
                  }
                  if (rowIndex === rows.length - 1) {
                      // prevent unnecessary reflow from getBoundingClientRect()
                      return;
                  }
                  stickyHeight += row.getBoundingClientRect().height;
              }
          };
      /**
       * When using the native table in Safari, sticky footer cells do not stick. The only way to stick
       * footer rows is to apply sticky styling to the tfoot container. This should only be done if
       * all footer rows are sticky. If not all footer rows are sticky, remove sticky positioning from
       * the tfoot element.
       */
      /**
       * When using the native table in Safari, sticky footer cells do not stick. The only way to stick
       * footer rows is to apply sticky styling to the tfoot container. This should only be done if
       * all footer rows are sticky. If not all footer rows are sticky, remove sticky positioning from
       * the tfoot element.
       * @param {?} tableElement
       * @param {?} stickyStates
       * @return {?}
       */
      StickyStyler.prototype.updateStickyFooterContainer = /**
       * When using the native table in Safari, sticky footer cells do not stick. The only way to stick
       * footer rows is to apply sticky styling to the tfoot container. This should only be done if
       * all footer rows are sticky. If not all footer rows are sticky, remove sticky positioning from
       * the tfoot element.
       * @param {?} tableElement
       * @param {?} stickyStates
       * @return {?}
       */
          function (tableElement, stickyStates) {
              if (!this.isNativeHtmlTable) {
                  return;
              }
              /** @type {?} */
              var tfoot = ( /** @type {?} */(tableElement.querySelector('tfoot')));
              if (stickyStates.some(function (state) { return !state; })) {
                  this._removeStickyStyle(tfoot, ['bottom']);
              }
              else {
                  this._addStickyStyle(tfoot, 'bottom', 0);
              }
          };
      /**
       * Removes the sticky style on the element by removing the sticky cell CSS class, re-evaluating
       * the zIndex, removing each of the provided sticky directions, and removing the
       * sticky position if there are no more directions.
       */
      /**
       * Removes the sticky style on the element by removing the sticky cell CSS class, re-evaluating
       * the zIndex, removing each of the provided sticky directions, and removing the
       * sticky position if there are no more directions.
       * @param {?} element
       * @param {?} stickyDirections
       * @return {?}
       */
      StickyStyler.prototype._removeStickyStyle = /**
       * Removes the sticky style on the element by removing the sticky cell CSS class, re-evaluating
       * the zIndex, removing each of the provided sticky directions, and removing the
       * sticky position if there are no more directions.
       * @param {?} element
       * @param {?} stickyDirections
       * @return {?}
       */
          function (element, stickyDirections) {
              for (var _i = 0, stickyDirections_1 = stickyDirections; _i < stickyDirections_1.length; _i++) {
                  var dir = stickyDirections_1[_i];
                  element.style[dir] = '';
              }
              element.style.zIndex = this._getCalculatedZIndex(element);
              // If the element no longer has any more sticky directions, remove sticky positioning and
              // the sticky CSS class.
              /** @type {?} */
              var hasDirection = STICKY_DIRECTIONS.some(function (dir) { return !!element.style[dir]; });
              if (!hasDirection) {
                  element.style.position = '';
                  element.classList.remove(this.stickCellCss);
              }
          };
      /**
       * Adds the sticky styling to the element by adding the sticky style class, changing position
       * to be sticky (and -webkit-sticky), setting the appropriate zIndex, and adding a sticky
       * direction and value.
       */
      /**
       * Adds the sticky styling to the element by adding the sticky style class, changing position
       * to be sticky (and -webkit-sticky), setting the appropriate zIndex, and adding a sticky
       * direction and value.
       * @param {?} element
       * @param {?} dir
       * @param {?} dirValue
       * @return {?}
       */
      StickyStyler.prototype._addStickyStyle = /**
       * Adds the sticky styling to the element by adding the sticky style class, changing position
       * to be sticky (and -webkit-sticky), setting the appropriate zIndex, and adding a sticky
       * direction and value.
       * @param {?} element
       * @param {?} dir
       * @param {?} dirValue
       * @return {?}
       */
          function (element, dir, dirValue) {
              element.classList.add(this.stickCellCss);
              element.style[dir] = dirValue + "px";
              element.style.cssText += 'position: -webkit-sticky; position: sticky; ';
              element.style.zIndex = this._getCalculatedZIndex(element);
          };
      /**
       * Calculate what the z-index should be for the element, depending on what directions (top,
       * bottom, left, right) have been set. It should be true that elements with a top direction
       * should have the highest index since these are elements like a table header. If any of those
       * elements are also sticky in another direction, then they should appear above other elements
       * that are only sticky top (e.g. a sticky column on a sticky header). Bottom-sticky elements
       * (e.g. footer rows) should then be next in the ordering such that they are below the header
       * but above any non-sticky elements. Finally, left/right sticky elements (e.g. sticky columns)
       * should minimally increment so that they are above non-sticky elements but below top and bottom
       * elements.
       */
      /**
       * Calculate what the z-index should be for the element, depending on what directions (top,
       * bottom, left, right) have been set. It should be true that elements with a top direction
       * should have the highest index since these are elements like a table header. If any of those
       * elements are also sticky in another direction, then they should appear above other elements
       * that are only sticky top (e.g. a sticky column on a sticky header). Bottom-sticky elements
       * (e.g. footer rows) should then be next in the ordering such that they are below the header
       * but above any non-sticky elements. Finally, left/right sticky elements (e.g. sticky columns)
       * should minimally increment so that they are above non-sticky elements but below top and bottom
       * elements.
       * @param {?} element
       * @return {?}
       */
      StickyStyler.prototype._getCalculatedZIndex = /**
       * Calculate what the z-index should be for the element, depending on what directions (top,
       * bottom, left, right) have been set. It should be true that elements with a top direction
       * should have the highest index since these are elements like a table header. If any of those
       * elements are also sticky in another direction, then they should appear above other elements
       * that are only sticky top (e.g. a sticky column on a sticky header). Bottom-sticky elements
       * (e.g. footer rows) should then be next in the ordering such that they are below the header
       * but above any non-sticky elements. Finally, left/right sticky elements (e.g. sticky columns)
       * should minimally increment so that they are above non-sticky elements but below top and bottom
       * elements.
       * @param {?} element
       * @return {?}
       */
          function (element) {
              /** @type {?} */
              var zIndexIncrements = {
                  top: 100,
                  bottom: 10,
                  left: 1,
                  right: 1,
              };
              /** @type {?} */
              var zIndex = 0;
              for (var _i = 0, STICKY_DIRECTIONS_1 = STICKY_DIRECTIONS; _i < STICKY_DIRECTIONS_1.length; _i++) {
                  var dir = STICKY_DIRECTIONS_1[_i];
                  if (element.style[dir]) {
                      zIndex += zIndexIncrements[dir];
                  }
              }
              return zIndex ? "" + zIndex : '';
          };
      /** Gets the widths for each cell in the provided row. */
      /**
       * Gets the widths for each cell in the provided row.
       * @param {?} row
       * @return {?}
       */
      StickyStyler.prototype._getCellWidths = /**
       * Gets the widths for each cell in the provided row.
       * @param {?} row
       * @return {?}
       */
          function (row) {
              /** @type {?} */
              var cellWidths = [];
              /** @type {?} */
              var firstRowCells = row.children;
              for (var i = 0; i < firstRowCells.length; i++) {
                  /** @type {?} */
                  var cell = ( /** @type {?} */(firstRowCells[i]));
                  cellWidths.push(cell.getBoundingClientRect().width);
              }
              return cellWidths;
          };
      /**
       * Determines the left and right positions of each sticky column cell, which will be the
       * accumulation of all sticky column cell widths to the left and right, respectively.
       * Non-sticky cells do not need to have a value set since their positions will not be applied.
       */
      /**
       * Determines the left and right positions of each sticky column cell, which will be the
       * accumulation of all sticky column cell widths to the left and right, respectively.
       * Non-sticky cells do not need to have a value set since their positions will not be applied.
       * @param {?} widths
       * @param {?} stickyStates
       * @return {?}
       */
      StickyStyler.prototype._getStickyStartColumnPositions = /**
       * Determines the left and right positions of each sticky column cell, which will be the
       * accumulation of all sticky column cell widths to the left and right, respectively.
       * Non-sticky cells do not need to have a value set since their positions will not be applied.
       * @param {?} widths
       * @param {?} stickyStates
       * @return {?}
       */
          function (widths, stickyStates) {
              /** @type {?} */
              var positions = [];
              /** @type {?} */
              var nextPosition = 0;
              for (var i = 0; i < widths.length; i++) {
                  if (stickyStates[i]) {
                      positions[i] = nextPosition;
                      nextPosition += widths[i];
                  }
              }
              return positions;
          };
      /**
       * Determines the left and right positions of each sticky column cell, which will be the
       * accumulation of all sticky column cell widths to the left and right, respectively.
       * Non-sticky cells do not need to have a value set since their positions will not be applied.
       */
      /**
       * Determines the left and right positions of each sticky column cell, which will be the
       * accumulation of all sticky column cell widths to the left and right, respectively.
       * Non-sticky cells do not need to have a value set since their positions will not be applied.
       * @param {?} widths
       * @param {?} stickyStates
       * @return {?}
       */
      StickyStyler.prototype._getStickyEndColumnPositions = /**
       * Determines the left and right positions of each sticky column cell, which will be the
       * accumulation of all sticky column cell widths to the left and right, respectively.
       * Non-sticky cells do not need to have a value set since their positions will not be applied.
       * @param {?} widths
       * @param {?} stickyStates
       * @return {?}
       */
          function (widths, stickyStates) {
              /** @type {?} */
              var positions = [];
              /** @type {?} */
              var nextPosition = 0;
              for (var i = widths.length; i > 0; i--) {
                  if (stickyStates[i]) {
                      positions[i] = nextPosition;
                      nextPosition += widths[i];
                  }
              }
              return positions;
          };
      return StickyStyler;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Provides a handle for the table to grab the view container's ng-container to insert data rows.
   * \@docs-private
   */
  var DataRowOutlet = /** @class */ (function () {
      function DataRowOutlet(viewContainer, elementRef) {
          this.viewContainer = viewContainer;
          this.elementRef = elementRef;
      }
      DataRowOutlet.decorators = [
          { type: core.Directive, args: [{ selector: '[rowOutlet]' },] },
      ];
      /** @nocollapse */
      DataRowOutlet.ctorParameters = function () {
          return [
              { type: core.ViewContainerRef },
              { type: core.ElementRef }
          ];
      };
      return DataRowOutlet;
  }());
  /**
   * Provides a handle for the table to grab the view container's ng-container to insert the header.
   * \@docs-private
   */
  var HeaderRowOutlet = /** @class */ (function () {
      function HeaderRowOutlet(viewContainer, elementRef) {
          this.viewContainer = viewContainer;
          this.elementRef = elementRef;
      }
      HeaderRowOutlet.decorators = [
          { type: core.Directive, args: [{ selector: '[headerRowOutlet]' },] },
      ];
      /** @nocollapse */
      HeaderRowOutlet.ctorParameters = function () {
          return [
              { type: core.ViewContainerRef },
              { type: core.ElementRef }
          ];
      };
      return HeaderRowOutlet;
  }());
  /**
   * Provides a handle for the table to grab the view container's ng-container to insert the footer.
   * \@docs-private
   */
  var FooterRowOutlet = /** @class */ (function () {
      function FooterRowOutlet(viewContainer, elementRef) {
          this.viewContainer = viewContainer;
          this.elementRef = elementRef;
      }
      FooterRowOutlet.decorators = [
          { type: core.Directive, args: [{ selector: '[footerRowOutlet]' },] },
      ];
      /** @nocollapse */
      FooterRowOutlet.ctorParameters = function () {
          return [
              { type: core.ViewContainerRef },
              { type: core.ElementRef }
          ];
      };
      return FooterRowOutlet;
  }());
  /**
   * The table template that can be used by the mat-table. Should not be used outside of the
   * material library.
   * \@docs-private
   * @type {?}
   */
  var CDK_TABLE_TEMPLATE = 
  // Note that according to MDN, the `caption` element has to be projected as the **first** element
  // in the table. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption
  "\n  <ng-content select=\"caption\"></ng-content>\n  <ng-container headerRowOutlet></ng-container>\n  <ng-container rowOutlet></ng-container>\n  <ng-container footerRowOutlet></ng-container>\n";
  /**
   * Class used to conveniently type the embedded view ref for rows with a context.
   * \@docs-private
   * @abstract
   * @template T
   */
  var /**
   * Class used to conveniently type the embedded view ref for rows with a context.
   * \@docs-private
   * @abstract
   * @template T
   */ RowViewRef = /** @class */ (function (_super) {
      tslib_1.__extends(RowViewRef, _super);
      function RowViewRef() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      return RowViewRef;
  }(core.EmbeddedViewRef));
  /**
   * A data table that can render a header row, data rows, and a footer row.
   * Uses the dataSource input to determine the data to be rendered. The data can be provided either
   * as a data array, an Observable stream that emits the data array to render, or a DataSource with a
   * connect function that will return an Observable stream that emits the data array to render.
   * @template T
   */
  var CdkTable = /** @class */ (function () {
      function CdkTable(_differs, _changeDetectorRef, _elementRef, role, _dir, 
      /**
       * @deprecated
       * @breaking-change 8.0.0 `_document` and `_platform` to
       *    be made into a required parameters.
       */
      _document, _platform) {
          this._differs = _differs;
          this._changeDetectorRef = _changeDetectorRef;
          this._elementRef = _elementRef;
          this._dir = _dir;
          this._platform = _platform;
          /**
           * Subject that emits when the component has been destroyed.
           */
          this._onDestroy = new rxjs.Subject();
          /**
           * Map of all the user's defined columns (header, data, and footer cell template) identified by
           * name. Collection populated by the column definitions gathered by `ContentChildren` as well as
           * any custom column definitions added to `_customColumnDefs`.
           */
          this._columnDefsByName = new Map();
          /**
           * Column definitions that were defined outside of the direct content children of the table.
           * These will be defined when, e.g., creating a wrapper around the cdkTable that has
           * column definitions as *it's* content child.
           */
          this._customColumnDefs = new Set();
          /**
           * Data row definitions that were defined outside of the direct content children of the table.
           * These will be defined when, e.g., creating a wrapper around the cdkTable that has
           * built-in data rows as *it's* content child.
           */
          this._customRowDefs = new Set();
          /**
           * Header row definitions that were defined outside of the direct content children of the table.
           * These will be defined when, e.g., creating a wrapper around the cdkTable that has
           * built-in header rows as *it's* content child.
           */
          this._customHeaderRowDefs = new Set();
          /**
           * Footer row definitions that were defined outside of the direct content children of the table.
           * These will be defined when, e.g., creating a wrapper around the cdkTable that has a
           * built-in footer row as *it's* content child.
           */
          this._customFooterRowDefs = new Set();
          /**
           * Whether the header row definition has been changed. Triggers an update to the header row after
           * content is checked. Initialized as true so that the table renders the initial set of rows.
           */
          this._headerRowDefChanged = true;
          /**
           * Whether the footer row definition has been changed. Triggers an update to the footer row after
           * content is checked. Initialized as true so that the table renders the initial set of rows.
           */
          this._footerRowDefChanged = true;
          /**
           * Cache of the latest rendered `RenderRow` objects as a map for easy retrieval when constructing
           * a new list of `RenderRow` objects for rendering rows. Since the new list is constructed with
           * the cached `RenderRow` objects when possible, the row identity is preserved when the data
           * and row template matches, which allows the `IterableDiffer` to check rows by reference
           * and understand which rows are added/moved/removed.
           *
           * Implemented as a map of maps where the first key is the `data: T` object and the second is the
           * `CdkRowDef<T>` object. With the two keys, the cache points to a `RenderRow<T>` object that
           * contains an array of created pairs. The array is necessary to handle cases where the data
           * array contains multiple duplicate data objects and each instantiated `RenderRow` must be
           * stored.
           */
          this._cachedRenderRowsMap = new Map();
          /**
           * CSS class added to any row or cell that has sticky positioning applied. May be overriden by
           * table subclasses.
           */
          this.stickyCssClass = 'cdk-table-sticky';
          this._multiTemplateDataRows = false;
          // TODO(andrewseguin): Remove max value as the end index
          //   and instead calculate the view on init and scroll.
          /**
           * Stream containing the latest information on what rows are being displayed on screen.
           * Can be used by the data source to as a heuristic of what data should be provided.
           */
          this.viewChange = new rxjs.BehaviorSubject({ start: 0, end: Number.MAX_VALUE });
          if (!role) {
              this._elementRef.nativeElement.setAttribute('role', 'grid');
          }
          this._document = _document;
          this._isNativeHtmlTable = this._elementRef.nativeElement.nodeName === 'TABLE';
      }
      Object.defineProperty(CdkTable.prototype, "trackBy", {
          /**
           * Tracking function that will be used to check the differences in data changes. Used similarly
           * to `ngFor` `trackBy` function. Optimize row operations by identifying a row based on its data
           * relative to the function to know if a row should be added/removed/moved.
           * Accepts a function that takes two parameters, `index` and `item`.
           */
          get: /**
           * Tracking function that will be used to check the differences in data changes. Used similarly
           * to `ngFor` `trackBy` function. Optimize row operations by identifying a row based on its data
           * relative to the function to know if a row should be added/removed/moved.
           * Accepts a function that takes two parameters, `index` and `item`.
           * @return {?}
           */ function () { return this._trackByFn; },
          set: /**
           * @param {?} fn
           * @return {?}
           */ function (fn) {
              if (core.isDevMode() &&
                  fn != null && typeof fn !== 'function' &&
                  ( /** @type {?} */(console)) && ( /** @type {?} */(console.warn))) {
                  console.warn("trackBy must be a function, but received " + JSON.stringify(fn) + ".");
              }
              this._trackByFn = fn;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkTable.prototype, "dataSource", {
          /**
           * The table's source of data, which can be provided in three ways (in order of complexity):
           *   - Simple data array (each object represents one table row)
           *   - Stream that emits a data array each time the array changes
           *   - `DataSource` object that implements the connect/disconnect interface.
           *
           * If a data array is provided, the table must be notified when the array's objects are
           * added, removed, or moved. This can be done by calling the `renderRows()` function which will
           * render the diff since the last table render. If the data array reference is changed, the table
           * will automatically trigger an update to the rows.
           *
           * When providing an Observable stream, the table will trigger an update automatically when the
           * stream emits a new array of data.
           *
           * Finally, when providing a `DataSource` object, the table will use the Observable stream
           * provided by the connect function and trigger updates when that stream emits new data array
           * values. During the table's ngOnDestroy or when the data source is removed from the table, the
           * table will call the DataSource's `disconnect` function (may be useful for cleaning up any
           * subscriptions registered during the connect process).
           */
          get: /**
           * The table's source of data, which can be provided in three ways (in order of complexity):
           *   - Simple data array (each object represents one table row)
           *   - Stream that emits a data array each time the array changes
           *   - `DataSource` object that implements the connect/disconnect interface.
           *
           * If a data array is provided, the table must be notified when the array's objects are
           * added, removed, or moved. This can be done by calling the `renderRows()` function which will
           * render the diff since the last table render. If the data array reference is changed, the table
           * will automatically trigger an update to the rows.
           *
           * When providing an Observable stream, the table will trigger an update automatically when the
           * stream emits a new array of data.
           *
           * Finally, when providing a `DataSource` object, the table will use the Observable stream
           * provided by the connect function and trigger updates when that stream emits new data array
           * values. During the table's ngOnDestroy or when the data source is removed from the table, the
           * table will call the DataSource's `disconnect` function (may be useful for cleaning up any
           * subscriptions registered during the connect process).
           * @return {?}
           */ function () { return this._dataSource; },
          set: /**
           * @param {?} dataSource
           * @return {?}
           */ function (dataSource) {
              if (this._dataSource !== dataSource) {
                  this._switchDataSource(dataSource);
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkTable.prototype, "multiTemplateDataRows", {
          /**
           * Whether to allow multiple rows per data object by evaluating which rows evaluate their 'when'
           * predicate to true. If `multiTemplateDataRows` is false, which is the default value, then each
           * dataobject will render the first row that evaluates its when predicate to true, in the order
           * defined in the table, or otherwise the default row which does not have a when predicate.
           */
          get: /**
           * Whether to allow multiple rows per data object by evaluating which rows evaluate their 'when'
           * predicate to true. If `multiTemplateDataRows` is false, which is the default value, then each
           * dataobject will render the first row that evaluates its when predicate to true, in the order
           * defined in the table, or otherwise the default row which does not have a when predicate.
           * @return {?}
           */ function () { return this._multiTemplateDataRows; },
          set: /**
           * @param {?} v
           * @return {?}
           */ function (v) {
              this._multiTemplateDataRows = coerceBooleanProperty(v);
              if (this._rowOutlet.viewContainer.length) {
                  this._forceRenderDataRows();
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      CdkTable.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._setupStickyStyler();
              if (this._isNativeHtmlTable) {
                  this._applyNativeTableSections();
              }
              // Set up the trackBy function so that it uses the `RenderRow` as its identity by default. If
              // the user has provided a custom trackBy, return the result of that function as evaluated
              // with the values of the `RenderRow`'s data and index.
              this._dataDiffer = this._differs.find([]).create(function (_i, dataRow) {
                  return _this.trackBy ? _this.trackBy(dataRow.dataIndex, dataRow.data) : dataRow;
              });
          };
      /**
       * @return {?}
       */
      CdkTable.prototype.ngAfterContentChecked = /**
       * @return {?}
       */
          function () {
              // Cache the row and column definitions gathered by ContentChildren and programmatic injection.
              this._cacheRowDefs();
              this._cacheColumnDefs();
              // Make sure that the user has at least added header, footer, or data row def.
              if (!this._headerRowDefs.length && !this._footerRowDefs.length && !this._rowDefs.length) {
                  throw getTableMissingRowDefsError();
              }
              // Render updates if the list of columns have been changed for the header, row, or footer defs.
              this._renderUpdatedColumns();
              // If the header row definition has been changed, trigger a render to the header row.
              if (this._headerRowDefChanged) {
                  this._forceRenderHeaderRows();
                  this._headerRowDefChanged = false;
              }
              // If the footer row definition has been changed, trigger a render to the footer row.
              if (this._footerRowDefChanged) {
                  this._forceRenderFooterRows();
                  this._footerRowDefChanged = false;
              }
              // If there is a data source and row definitions, connect to the data source unless a
              // connection has already been made.
              if (this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription) {
                  this._observeRenderChanges();
              }
              this._checkStickyStates();
          };
      /**
       * @return {?}
       */
      CdkTable.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._rowOutlet.viewContainer.clear();
              this._headerRowOutlet.viewContainer.clear();
              this._footerRowOutlet.viewContainer.clear();
              this._cachedRenderRowsMap.clear();
              this._onDestroy.next();
              this._onDestroy.complete();
              if (isDataSource(this.dataSource)) {
                  this.dataSource.disconnect(this);
              }
          };
      /**
       * Renders rows based on the table's latest set of data, which was either provided directly as an
       * input or retrieved through an Observable stream (directly or from a DataSource).
       * Checks for differences in the data since the last diff to perform only the necessary
       * changes (add/remove/move rows).
       *
       * If the table's data source is a DataSource or Observable, this will be invoked automatically
       * each time the provided Observable stream emits a new data array. Otherwise if your data is
       * an array, this function will need to be called to render any changes.
       */
      /**
       * Renders rows based on the table's latest set of data, which was either provided directly as an
       * input or retrieved through an Observable stream (directly or from a DataSource).
       * Checks for differences in the data since the last diff to perform only the necessary
       * changes (add/remove/move rows).
       *
       * If the table's data source is a DataSource or Observable, this will be invoked automatically
       * each time the provided Observable stream emits a new data array. Otherwise if your data is
       * an array, this function will need to be called to render any changes.
       * @return {?}
       */
      CdkTable.prototype.renderRows = /**
       * Renders rows based on the table's latest set of data, which was either provided directly as an
       * input or retrieved through an Observable stream (directly or from a DataSource).
       * Checks for differences in the data since the last diff to perform only the necessary
       * changes (add/remove/move rows).
       *
       * If the table's data source is a DataSource or Observable, this will be invoked automatically
       * each time the provided Observable stream emits a new data array. Otherwise if your data is
       * an array, this function will need to be called to render any changes.
       * @return {?}
       */
          function () {
              var _this = this;
              this._renderRows = this._getAllRenderRows();
              /** @type {?} */
              var changes = this._dataDiffer.diff(this._renderRows);
              if (!changes) {
                  return;
              }
              /** @type {?} */
              var viewContainer = this._rowOutlet.viewContainer;
              changes.forEachOperation(function (record, prevIndex, currentIndex) {
                  if (record.previousIndex == null) {
                      _this._insertRow(record.item, ( /** @type {?} */(currentIndex)));
                  }
                  else if (currentIndex == null) {
                      viewContainer.remove(( /** @type {?} */(prevIndex)));
                  }
                  else {
                      /** @type {?} */
                      var view = ( /** @type {?} */(viewContainer.get(( /** @type {?} */(prevIndex)))));
                      viewContainer.move(( /** @type {?} */(view)), currentIndex);
                  }
              });
              // Update the meta context of a row's context data (index, count, first, last, ...)
              this._updateRowIndexContext();
              // Update rows that did not get added/removed/moved but may have had their identity changed,
              // e.g. if trackBy matched data on some property but the actual data reference changed.
              changes.forEachIdentityChange(function (record) {
                  /** @type {?} */
                  var rowView = ( /** @type {?} */(viewContainer.get(( /** @type {?} */(record.currentIndex)))));
                  rowView.context.$implicit = record.item.data;
              });
              this.updateStickyColumnStyles();
          };
      /**
       * Sets the header row definition to be used. Overrides the header row definition gathered by
       * using `ContentChild`, if one exists. Sets a flag that will re-render the header row after the
       * table's content is checked.
       * @docs-private
       * @deprecated Use `addHeaderRowDef` and `removeHeaderRowDef` instead
       * @breaking-change 8.0.0
       */
      /**
       * Sets the header row definition to be used. Overrides the header row definition gathered by
       * using `ContentChild`, if one exists. Sets a flag that will re-render the header row after the
       * table's content is checked.
       * \@docs-private
       * @deprecated Use `addHeaderRowDef` and `removeHeaderRowDef` instead
       * \@breaking-change 8.0.0
       * @param {?} headerRowDef
       * @return {?}
       */
      CdkTable.prototype.setHeaderRowDef = /**
       * Sets the header row definition to be used. Overrides the header row definition gathered by
       * using `ContentChild`, if one exists. Sets a flag that will re-render the header row after the
       * table's content is checked.
       * \@docs-private
       * @deprecated Use `addHeaderRowDef` and `removeHeaderRowDef` instead
       * \@breaking-change 8.0.0
       * @param {?} headerRowDef
       * @return {?}
       */
          function (headerRowDef) {
              this._customHeaderRowDefs = new Set([headerRowDef]);
              this._headerRowDefChanged = true;
          };
      /**
       * Sets the footer row definition to be used. Overrides the footer row definition gathered by
       * using `ContentChild`, if one exists. Sets a flag that will re-render the footer row after the
       * table's content is checked.
       * @docs-private
       * @deprecated Use `addFooterRowDef` and `removeFooterRowDef` instead
       * @breaking-change 8.0.0
       */
      /**
       * Sets the footer row definition to be used. Overrides the footer row definition gathered by
       * using `ContentChild`, if one exists. Sets a flag that will re-render the footer row after the
       * table's content is checked.
       * \@docs-private
       * @deprecated Use `addFooterRowDef` and `removeFooterRowDef` instead
       * \@breaking-change 8.0.0
       * @param {?} footerRowDef
       * @return {?}
       */
      CdkTable.prototype.setFooterRowDef = /**
       * Sets the footer row definition to be used. Overrides the footer row definition gathered by
       * using `ContentChild`, if one exists. Sets a flag that will re-render the footer row after the
       * table's content is checked.
       * \@docs-private
       * @deprecated Use `addFooterRowDef` and `removeFooterRowDef` instead
       * \@breaking-change 8.0.0
       * @param {?} footerRowDef
       * @return {?}
       */
          function (footerRowDef) {
              this._customFooterRowDefs = new Set([footerRowDef]);
              this._footerRowDefChanged = true;
          };
      /** Adds a column definition that was not included as part of the content children. */
      /**
       * Adds a column definition that was not included as part of the content children.
       * @param {?} columnDef
       * @return {?}
       */
      CdkTable.prototype.addColumnDef = /**
       * Adds a column definition that was not included as part of the content children.
       * @param {?} columnDef
       * @return {?}
       */
          function (columnDef) {
              this._customColumnDefs.add(columnDef);
          };
      /** Removes a column definition that was not included as part of the content children. */
      /**
       * Removes a column definition that was not included as part of the content children.
       * @param {?} columnDef
       * @return {?}
       */
      CdkTable.prototype.removeColumnDef = /**
       * Removes a column definition that was not included as part of the content children.
       * @param {?} columnDef
       * @return {?}
       */
          function (columnDef) {
              this._customColumnDefs.delete(columnDef);
          };
      /** Adds a row definition that was not included as part of the content children. */
      /**
       * Adds a row definition that was not included as part of the content children.
       * @param {?} rowDef
       * @return {?}
       */
      CdkTable.prototype.addRowDef = /**
       * Adds a row definition that was not included as part of the content children.
       * @param {?} rowDef
       * @return {?}
       */
          function (rowDef) {
              this._customRowDefs.add(rowDef);
          };
      /** Removes a row definition that was not included as part of the content children. */
      /**
       * Removes a row definition that was not included as part of the content children.
       * @param {?} rowDef
       * @return {?}
       */
      CdkTable.prototype.removeRowDef = /**
       * Removes a row definition that was not included as part of the content children.
       * @param {?} rowDef
       * @return {?}
       */
          function (rowDef) {
              this._customRowDefs.delete(rowDef);
          };
      /** Adds a header row definition that was not included as part of the content children. */
      /**
       * Adds a header row definition that was not included as part of the content children.
       * @param {?} headerRowDef
       * @return {?}
       */
      CdkTable.prototype.addHeaderRowDef = /**
       * Adds a header row definition that was not included as part of the content children.
       * @param {?} headerRowDef
       * @return {?}
       */
          function (headerRowDef) {
              this._customHeaderRowDefs.add(headerRowDef);
              this._headerRowDefChanged = true;
          };
      /** Removes a header row definition that was not included as part of the content children. */
      /**
       * Removes a header row definition that was not included as part of the content children.
       * @param {?} headerRowDef
       * @return {?}
       */
      CdkTable.prototype.removeHeaderRowDef = /**
       * Removes a header row definition that was not included as part of the content children.
       * @param {?} headerRowDef
       * @return {?}
       */
          function (headerRowDef) {
              this._customHeaderRowDefs.delete(headerRowDef);
              this._headerRowDefChanged = true;
          };
      /** Adds a footer row definition that was not included as part of the content children. */
      /**
       * Adds a footer row definition that was not included as part of the content children.
       * @param {?} footerRowDef
       * @return {?}
       */
      CdkTable.prototype.addFooterRowDef = /**
       * Adds a footer row definition that was not included as part of the content children.
       * @param {?} footerRowDef
       * @return {?}
       */
          function (footerRowDef) {
              this._customFooterRowDefs.add(footerRowDef);
              this._footerRowDefChanged = true;
          };
      /** Removes a footer row definition that was not included as part of the content children. */
      /**
       * Removes a footer row definition that was not included as part of the content children.
       * @param {?} footerRowDef
       * @return {?}
       */
      CdkTable.prototype.removeFooterRowDef = /**
       * Removes a footer row definition that was not included as part of the content children.
       * @param {?} footerRowDef
       * @return {?}
       */
          function (footerRowDef) {
              this._customFooterRowDefs.delete(footerRowDef);
              this._footerRowDefChanged = true;
          };
      /**
       * Updates the header sticky styles. First resets all applied styles with respect to the cells
       * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is
       * automatically called when the header row changes its displayed set of columns, or if its
       * sticky input changes. May be called manually for cases where the cell content changes outside
       * of these events.
       */
      /**
       * Updates the header sticky styles. First resets all applied styles with respect to the cells
       * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is
       * automatically called when the header row changes its displayed set of columns, or if its
       * sticky input changes. May be called manually for cases where the cell content changes outside
       * of these events.
       * @return {?}
       */
      CdkTable.prototype.updateStickyHeaderRowStyles = /**
       * Updates the header sticky styles. First resets all applied styles with respect to the cells
       * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is
       * automatically called when the header row changes its displayed set of columns, or if its
       * sticky input changes. May be called manually for cases where the cell content changes outside
       * of these events.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var headerRows = this._getRenderedRows(this._headerRowOutlet);
              this._stickyStyler.clearStickyPositioning(headerRows, ['top']);
              /** @type {?} */
              var stickyStates = this._headerRowDefs.map(function (def) { return def.sticky; });
              this._stickyStyler.stickRows(headerRows, stickyStates, 'top');
              // Reset the dirty state of the sticky input change since it has been used.
              this._headerRowDefs.forEach(function (def) { return def.resetStickyChanged(); });
          };
      /**
       * Updates the footer sticky styles. First resets all applied styles with respect to the cells
       * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is
       * automatically called when the footer row changes its displayed set of columns, or if its
       * sticky input changes. May be called manually for cases where the cell content changes outside
       * of these events.
       */
      /**
       * Updates the footer sticky styles. First resets all applied styles with respect to the cells
       * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is
       * automatically called when the footer row changes its displayed set of columns, or if its
       * sticky input changes. May be called manually for cases where the cell content changes outside
       * of these events.
       * @return {?}
       */
      CdkTable.prototype.updateStickyFooterRowStyles = /**
       * Updates the footer sticky styles. First resets all applied styles with respect to the cells
       * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is
       * automatically called when the footer row changes its displayed set of columns, or if its
       * sticky input changes. May be called manually for cases where the cell content changes outside
       * of these events.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var footerRows = this._getRenderedRows(this._footerRowOutlet);
              this._stickyStyler.clearStickyPositioning(footerRows, ['bottom']);
              /** @type {?} */
              var stickyStates = this._footerRowDefs.map(function (def) { return def.sticky; });
              this._stickyStyler.stickRows(footerRows, stickyStates, 'bottom');
              this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement, stickyStates);
              // Reset the dirty state of the sticky input change since it has been used.
              this._footerRowDefs.forEach(function (def) { return def.resetStickyChanged(); });
          };
      /**
       * Updates the column sticky styles. First resets all applied styles with respect to the cells
       * sticking to the left and right. Then sticky styles are added for the left and right according
       * to the column definitions for each cell in each row. This is automatically called when
       * the data source provides a new set of data or when a column definition changes its sticky
       * input. May be called manually for cases where the cell content changes outside of these events.
       */
      /**
       * Updates the column sticky styles. First resets all applied styles with respect to the cells
       * sticking to the left and right. Then sticky styles are added for the left and right according
       * to the column definitions for each cell in each row. This is automatically called when
       * the data source provides a new set of data or when a column definition changes its sticky
       * input. May be called manually for cases where the cell content changes outside of these events.
       * @return {?}
       */
      CdkTable.prototype.updateStickyColumnStyles = /**
       * Updates the column sticky styles. First resets all applied styles with respect to the cells
       * sticking to the left and right. Then sticky styles are added for the left and right according
       * to the column definitions for each cell in each row. This is automatically called when
       * the data source provides a new set of data or when a column definition changes its sticky
       * input. May be called manually for cases where the cell content changes outside of these events.
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var headerRows = this._getRenderedRows(this._headerRowOutlet);
              /** @type {?} */
              var dataRows = this._getRenderedRows(this._rowOutlet);
              /** @type {?} */
              var footerRows = this._getRenderedRows(this._footerRowOutlet);
              // Clear the left and right positioning from all columns in the table across all rows since
              // sticky columns span across all table sections (header, data, footer)
              this._stickyStyler.clearStickyPositioning(headerRows.concat(dataRows, footerRows), ['left', 'right']);
              // Update the sticky styles for each header row depending on the def's sticky state
              headerRows.forEach(function (headerRow, i) {
                  _this._addStickyColumnStyles([headerRow], _this._headerRowDefs[i]);
              });
              // Update the sticky styles for each data row depending on its def's sticky state
              this._rowDefs.forEach(function (rowDef) {
                  // Collect all the rows rendered with this row definition.
                  /** @type {?} */
                  var rows = [];
                  for (var i = 0; i < dataRows.length; i++) {
                      if (_this._renderRows[i].rowDef === rowDef) {
                          rows.push(dataRows[i]);
                      }
                  }
                  _this._addStickyColumnStyles(rows, rowDef);
              });
              // Update the sticky styles for each footer row depending on the def's sticky state
              footerRows.forEach(function (footerRow, i) {
                  _this._addStickyColumnStyles([footerRow], _this._footerRowDefs[i]);
              });
              // Reset the dirty state of the sticky input change since it has been used.
              Array.from(this._columnDefsByName.values()).forEach(function (def) { return def.resetStickyChanged(); });
          };
      /**
       * Get the list of RenderRow objects to render according to the current list of data and defined
       * row definitions. If the previous list already contained a particular pair, it should be reused
       * so that the differ equates their references.
       */
      /**
       * Get the list of RenderRow objects to render according to the current list of data and defined
       * row definitions. If the previous list already contained a particular pair, it should be reused
       * so that the differ equates their references.
       * @private
       * @return {?}
       */
      CdkTable.prototype._getAllRenderRows = /**
       * Get the list of RenderRow objects to render according to the current list of data and defined
       * row definitions. If the previous list already contained a particular pair, it should be reused
       * so that the differ equates their references.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var renderRows = [];
              // Store the cache and create a new one. Any re-used RenderRow objects will be moved into the
              // new cache while unused ones can be picked up by garbage collection.
              /** @type {?} */
              var prevCachedRenderRows = this._cachedRenderRowsMap;
              this._cachedRenderRowsMap = new Map();
              // For each data object, get the list of rows that should be rendered, represented by the
              // respective `RenderRow` object which is the pair of `data` and `CdkRowDef`.
              for (var i = 0; i < this._data.length; i++) {
                  /** @type {?} */
                  var data = this._data[i];
                  /** @type {?} */
                  var renderRowsForData = this._getRenderRowsForData(data, i, prevCachedRenderRows.get(data));
                  if (!this._cachedRenderRowsMap.has(data)) {
                      this._cachedRenderRowsMap.set(data, new WeakMap());
                  }
                  for (var j = 0; j < renderRowsForData.length; j++) {
                      /** @type {?} */
                      var renderRow = renderRowsForData[j];
                      /** @type {?} */
                      var cache = ( /** @type {?} */(this._cachedRenderRowsMap.get(renderRow.data)));
                      if (cache.has(renderRow.rowDef)) {
                          ( /** @type {?} */(cache.get(renderRow.rowDef))).push(renderRow);
                      }
                      else {
                          cache.set(renderRow.rowDef, [renderRow]);
                      }
                      renderRows.push(renderRow);
                  }
              }
              return renderRows;
          };
      /**
       * Gets a list of `RenderRow<T>` for the provided data object and any `CdkRowDef` objects that
       * should be rendered for this data. Reuses the cached RenderRow objects if they match the same
       * `(T, CdkRowDef)` pair.
       */
      /**
       * Gets a list of `RenderRow<T>` for the provided data object and any `CdkRowDef` objects that
       * should be rendered for this data. Reuses the cached RenderRow objects if they match the same
       * `(T, CdkRowDef)` pair.
       * @private
       * @param {?} data
       * @param {?} dataIndex
       * @param {?=} cache
       * @return {?}
       */
      CdkTable.prototype._getRenderRowsForData = /**
       * Gets a list of `RenderRow<T>` for the provided data object and any `CdkRowDef` objects that
       * should be rendered for this data. Reuses the cached RenderRow objects if they match the same
       * `(T, CdkRowDef)` pair.
       * @private
       * @param {?} data
       * @param {?} dataIndex
       * @param {?=} cache
       * @return {?}
       */
          function (data, dataIndex, cache) {
              /** @type {?} */
              var rowDefs = this._getRowDefs(data, dataIndex);
              return rowDefs.map(function (rowDef) {
                  /** @type {?} */
                  var cachedRenderRows = (cache && cache.has(rowDef)) ? ( /** @type {?} */(cache.get(rowDef))) : [];
                  if (cachedRenderRows.length) {
                      /** @type {?} */
                      var dataRow = ( /** @type {?} */(cachedRenderRows.shift()));
                      dataRow.dataIndex = dataIndex;
                      return dataRow;
                  }
                  else {
                      return { data: data, rowDef: rowDef, dataIndex: dataIndex };
                  }
              });
          };
      /** Update the map containing the content's column definitions. */
      /**
       * Update the map containing the content's column definitions.
       * @private
       * @return {?}
       */
      CdkTable.prototype._cacheColumnDefs = /**
       * Update the map containing the content's column definitions.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              this._columnDefsByName.clear();
              /** @type {?} */
              var columnDefs = mergeQueryListAndSet(this._contentColumnDefs, this._customColumnDefs);
              columnDefs.forEach(function (columnDef) {
                  if (_this._columnDefsByName.has(columnDef.name)) {
                      throw getTableDuplicateColumnNameError(columnDef.name);
                  }
                  _this._columnDefsByName.set(columnDef.name, columnDef);
              });
          };
      /** Update the list of all available row definitions that can be used. */
      /**
       * Update the list of all available row definitions that can be used.
       * @private
       * @return {?}
       */
      CdkTable.prototype._cacheRowDefs = /**
       * Update the list of all available row definitions that can be used.
       * @private
       * @return {?}
       */
          function () {
              this._headerRowDefs =
                  mergeQueryListAndSet(this._contentHeaderRowDefs, this._customHeaderRowDefs);
              this._footerRowDefs =
                  mergeQueryListAndSet(this._contentFooterRowDefs, this._customFooterRowDefs);
              this._rowDefs =
                  mergeQueryListAndSet(this._contentRowDefs, this._customRowDefs);
              // After all row definitions are determined, find the row definition to be considered default.
              /** @type {?} */
              var defaultRowDefs = this._rowDefs.filter(function (def) { return !def.when; });
              if (!this.multiTemplateDataRows && defaultRowDefs.length > 1) {
                  throw getTableMultipleDefaultRowDefsError();
              }
              this._defaultRowDef = defaultRowDefs[0];
          };
      /**
       * Check if the header, data, or footer rows have changed what columns they want to display or
       * whether the sticky states have changed for the header or footer. If there is a diff, then
       * re-render that section.
       */
      /**
       * Check if the header, data, or footer rows have changed what columns they want to display or
       * whether the sticky states have changed for the header or footer. If there is a diff, then
       * re-render that section.
       * @private
       * @return {?}
       */
      CdkTable.prototype._renderUpdatedColumns = /**
       * Check if the header, data, or footer rows have changed what columns they want to display or
       * whether the sticky states have changed for the header or footer. If there is a diff, then
       * re-render that section.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var columnsDiffReducer = function (acc, def) { return acc || !!def.getColumnsDiff(); };
              // Force re-render data rows if the list of column definitions have changed.
              if (this._rowDefs.reduce(columnsDiffReducer, false)) {
                  this._forceRenderDataRows();
              }
              // Force re-render header/footer rows if the list of column definitions have changed..
              if (this._headerRowDefs.reduce(columnsDiffReducer, false)) {
                  this._forceRenderHeaderRows();
              }
              if (this._footerRowDefs.reduce(columnsDiffReducer, false)) {
                  this._forceRenderFooterRows();
              }
          };
      /**
       * Switch to the provided data source by resetting the data and unsubscribing from the current
       * render change subscription if one exists. If the data source is null, interpret this by
       * clearing the row outlet. Otherwise start listening for new data.
       */
      /**
       * Switch to the provided data source by resetting the data and unsubscribing from the current
       * render change subscription if one exists. If the data source is null, interpret this by
       * clearing the row outlet. Otherwise start listening for new data.
       * @private
       * @param {?} dataSource
       * @return {?}
       */
      CdkTable.prototype._switchDataSource = /**
       * Switch to the provided data source by resetting the data and unsubscribing from the current
       * render change subscription if one exists. If the data source is null, interpret this by
       * clearing the row outlet. Otherwise start listening for new data.
       * @private
       * @param {?} dataSource
       * @return {?}
       */
          function (dataSource) {
              this._data = [];
              if (isDataSource(this.dataSource)) {
                  this.dataSource.disconnect(this);
              }
              // Stop listening for data from the previous data source.
              if (this._renderChangeSubscription) {
                  this._renderChangeSubscription.unsubscribe();
                  this._renderChangeSubscription = null;
              }
              if (!dataSource) {
                  if (this._dataDiffer) {
                      this._dataDiffer.diff([]);
                  }
                  this._rowOutlet.viewContainer.clear();
              }
              this._dataSource = dataSource;
          };
      /** Set up a subscription for the data provided by the data source. */
      /**
       * Set up a subscription for the data provided by the data source.
       * @private
       * @return {?}
       */
      CdkTable.prototype._observeRenderChanges = /**
       * Set up a subscription for the data provided by the data source.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              // If no data source has been set, there is nothing to observe for changes.
              if (!this.dataSource) {
                  return;
              }
              /** @type {?} */
              var dataStream;
              if (isDataSource(this.dataSource)) {
                  dataStream = this.dataSource.connect(this);
              }
              else if (this.dataSource instanceof rxjs.Observable) {
                  dataStream = this.dataSource;
              }
              else if (Array.isArray(this.dataSource)) {
                  dataStream = rxjs.of(this.dataSource);
              }
              if (dataStream === undefined) {
                  throw getTableUnknownDataSourceError();
              }
              this._renderChangeSubscription = dataStream
                  .pipe(operators.takeUntil(this._onDestroy))
                  .subscribe(function (data) {
                  _this._data = data || [];
                  _this.renderRows();
              });
          };
      /**
       * Clears any existing content in the header row outlet and creates a new embedded view
       * in the outlet using the header row definition.
       */
      /**
       * Clears any existing content in the header row outlet and creates a new embedded view
       * in the outlet using the header row definition.
       * @private
       * @return {?}
       */
      CdkTable.prototype._forceRenderHeaderRows = /**
       * Clears any existing content in the header row outlet and creates a new embedded view
       * in the outlet using the header row definition.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              // Clear the header row outlet if any content exists.
              if (this._headerRowOutlet.viewContainer.length > 0) {
                  this._headerRowOutlet.viewContainer.clear();
              }
              this._headerRowDefs.forEach(function (def, i) { return _this._renderRow(_this._headerRowOutlet, def, i); });
              this.updateStickyHeaderRowStyles();
              this.updateStickyColumnStyles();
          };
      /**
       * Clears any existing content in the footer row outlet and creates a new embedded view
       * in the outlet using the footer row definition.
       */
      /**
       * Clears any existing content in the footer row outlet and creates a new embedded view
       * in the outlet using the footer row definition.
       * @private
       * @return {?}
       */
      CdkTable.prototype._forceRenderFooterRows = /**
       * Clears any existing content in the footer row outlet and creates a new embedded view
       * in the outlet using the footer row definition.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              // Clear the footer row outlet if any content exists.
              if (this._footerRowOutlet.viewContainer.length > 0) {
                  this._footerRowOutlet.viewContainer.clear();
              }
              this._footerRowDefs.forEach(function (def, i) { return _this._renderRow(_this._footerRowOutlet, def, i); });
              this.updateStickyFooterRowStyles();
              this.updateStickyColumnStyles();
          };
      /** Adds the sticky column styles for the rows according to the columns' stick states. */
      /**
       * Adds the sticky column styles for the rows according to the columns' stick states.
       * @private
       * @param {?} rows
       * @param {?} rowDef
       * @return {?}
       */
      CdkTable.prototype._addStickyColumnStyles = /**
       * Adds the sticky column styles for the rows according to the columns' stick states.
       * @private
       * @param {?} rows
       * @param {?} rowDef
       * @return {?}
       */
          function (rows, rowDef) {
              var _this = this;
              /** @type {?} */
              var columnDefs = Array.from(rowDef.columns || []).map(function (columnName) {
                  /** @type {?} */
                  var columnDef = _this._columnDefsByName.get(columnName);
                  if (!columnDef) {
                      throw getTableUnknownColumnError(columnName);
                  }
                  return ( /** @type {?} */(columnDef));
              });
              /** @type {?} */
              var stickyStartStates = columnDefs.map(function (columnDef) { return columnDef.sticky; });
              /** @type {?} */
              var stickyEndStates = columnDefs.map(function (columnDef) { return columnDef.stickyEnd; });
              this._stickyStyler.updateStickyColumns(rows, stickyStartStates, stickyEndStates);
          };
      /** Gets the list of rows that have been rendered in the row outlet. */
      /**
       * Gets the list of rows that have been rendered in the row outlet.
       * @param {?} rowOutlet
       * @return {?}
       */
      CdkTable.prototype._getRenderedRows = /**
       * Gets the list of rows that have been rendered in the row outlet.
       * @param {?} rowOutlet
       * @return {?}
       */
          function (rowOutlet) {
              /** @type {?} */
              var renderedRows = [];
              for (var i = 0; i < rowOutlet.viewContainer.length; i++) {
                  /** @type {?} */
                  var viewRef = (( /** @type {?} */(( /** @type {?} */(rowOutlet.viewContainer.get(i))))));
                  renderedRows.push(viewRef.rootNodes[0]);
              }
              return renderedRows;
          };
      /**
       * Get the matching row definitions that should be used for this row data. If there is only
       * one row definition, it is returned. Otherwise, find the row definitions that has a when
       * predicate that returns true with the data. If none return true, return the default row
       * definition.
       */
      /**
       * Get the matching row definitions that should be used for this row data. If there is only
       * one row definition, it is returned. Otherwise, find the row definitions that has a when
       * predicate that returns true with the data. If none return true, return the default row
       * definition.
       * @param {?} data
       * @param {?} dataIndex
       * @return {?}
       */
      CdkTable.prototype._getRowDefs = /**
       * Get the matching row definitions that should be used for this row data. If there is only
       * one row definition, it is returned. Otherwise, find the row definitions that has a when
       * predicate that returns true with the data. If none return true, return the default row
       * definition.
       * @param {?} data
       * @param {?} dataIndex
       * @return {?}
       */
          function (data, dataIndex) {
              if (this._rowDefs.length == 1) {
                  return [this._rowDefs[0]];
              }
              /** @type {?} */
              var rowDefs = [];
              if (this.multiTemplateDataRows) {
                  rowDefs = this._rowDefs.filter(function (def) { return !def.when || def.when(dataIndex, data); });
              }
              else {
                  /** @type {?} */
                  var rowDef = this._rowDefs.find(function (def) { return def.when && def.when(dataIndex, data); }) || this._defaultRowDef;
                  if (rowDef) {
                      rowDefs.push(rowDef);
                  }
              }
              if (!rowDefs.length) {
                  throw getTableMissingMatchingRowDefError(data);
              }
              return rowDefs;
          };
      /**
       * Create the embedded view for the data row template and place it in the correct index location
       * within the data row view container.
       */
      /**
       * Create the embedded view for the data row template and place it in the correct index location
       * within the data row view container.
       * @private
       * @param {?} renderRow
       * @param {?} renderIndex
       * @return {?}
       */
      CdkTable.prototype._insertRow = /**
       * Create the embedded view for the data row template and place it in the correct index location
       * within the data row view container.
       * @private
       * @param {?} renderRow
       * @param {?} renderIndex
       * @return {?}
       */
          function (renderRow, renderIndex) {
              /** @type {?} */
              var rowDef = renderRow.rowDef;
              /** @type {?} */
              var context = { $implicit: renderRow.data };
              this._renderRow(this._rowOutlet, rowDef, renderIndex, context);
          };
      /**
       * Creates a new row template in the outlet and fills it with the set of cell templates.
       * Optionally takes a context to provide to the row and cells, as well as an optional index
       * of where to place the new row template in the outlet.
       */
      /**
       * Creates a new row template in the outlet and fills it with the set of cell templates.
       * Optionally takes a context to provide to the row and cells, as well as an optional index
       * of where to place the new row template in the outlet.
       * @private
       * @param {?} outlet
       * @param {?} rowDef
       * @param {?} index
       * @param {?=} context
       * @return {?}
       */
      CdkTable.prototype._renderRow = /**
       * Creates a new row template in the outlet and fills it with the set of cell templates.
       * Optionally takes a context to provide to the row and cells, as well as an optional index
       * of where to place the new row template in the outlet.
       * @private
       * @param {?} outlet
       * @param {?} rowDef
       * @param {?} index
       * @param {?=} context
       * @return {?}
       */
          function (outlet, rowDef, index, context) {
              if (context === void 0) {
                  context = {};
              }
              // TODO(andrewseguin): enforce that one outlet was instantiated from createEmbeddedView
              outlet.viewContainer.createEmbeddedView(rowDef.template, context, index);
              for (var _a = 0, _b = this._getCellTemplates(rowDef); _a < _b.length; _a++) {
                  var cellTemplate = _b[_a];
                  if (CdkCellOutlet.mostRecentCellOutlet) {
                      CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cellTemplate, context);
                  }
              }
              this._changeDetectorRef.markForCheck();
          };
      /**
       * Updates the index-related context for each row to reflect any changes in the index of the rows,
       * e.g. first/last/even/odd.
       */
      /**
       * Updates the index-related context for each row to reflect any changes in the index of the rows,
       * e.g. first/last/even/odd.
       * @private
       * @return {?}
       */
      CdkTable.prototype._updateRowIndexContext = /**
       * Updates the index-related context for each row to reflect any changes in the index of the rows,
       * e.g. first/last/even/odd.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var viewContainer = this._rowOutlet.viewContainer;
              for (var renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {
                  /** @type {?} */
                  var viewRef = ( /** @type {?} */(viewContainer.get(renderIndex)));
                  /** @type {?} */
                  var context = ( /** @type {?} */(viewRef.context));
                  context.count = count;
                  context.first = renderIndex === 0;
                  context.last = renderIndex === count - 1;
                  context.even = renderIndex % 2 === 0;
                  context.odd = !context.even;
                  if (this.multiTemplateDataRows) {
                      context.dataIndex = this._renderRows[renderIndex].dataIndex;
                      context.renderIndex = renderIndex;
                  }
                  else {
                      context.index = this._renderRows[renderIndex].dataIndex;
                  }
              }
          };
      /** Gets the column definitions for the provided row def. */
      /**
       * Gets the column definitions for the provided row def.
       * @private
       * @param {?} rowDef
       * @return {?}
       */
      CdkTable.prototype._getCellTemplates = /**
       * Gets the column definitions for the provided row def.
       * @private
       * @param {?} rowDef
       * @return {?}
       */
          function (rowDef) {
              var _this = this;
              if (!rowDef || !rowDef.columns) {
                  return [];
              }
              return Array.from(rowDef.columns, function (columnId) {
                  /** @type {?} */
                  var column = _this._columnDefsByName.get(columnId);
                  if (!column) {
                      throw getTableUnknownColumnError(columnId);
                  }
                  return rowDef.extractCellTemplate(column);
              });
          };
      /** Adds native table sections (e.g. tbody) and moves the row outlets into them. */
      /**
       * Adds native table sections (e.g. tbody) and moves the row outlets into them.
       * @private
       * @return {?}
       */
      CdkTable.prototype._applyNativeTableSections = /**
       * Adds native table sections (e.g. tbody) and moves the row outlets into them.
       * @private
       * @return {?}
       */
          function () {
              // @breaking-change 8.0.0 remove the `|| document` once the `_document` is a required param.
              /** @type {?} */
              var documentRef = this._document || document;
              /** @type {?} */
              var documentFragment = documentRef.createDocumentFragment();
              /** @type {?} */
              var sections = [
                  { tag: 'thead', outlet: this._headerRowOutlet },
                  { tag: 'tbody', outlet: this._rowOutlet },
                  { tag: 'tfoot', outlet: this._footerRowOutlet },
              ];
              for (var _a = 0, sections_1 = sections; _a < sections_1.length; _a++) {
                  var section = sections_1[_a];
                  /** @type {?} */
                  var element = documentRef.createElement(section.tag);
                  element.appendChild(section.outlet.elementRef.nativeElement);
                  documentFragment.appendChild(element);
              }
              // Use a DocumentFragment so we don't hit the DOM on each iteration.
              this._elementRef.nativeElement.appendChild(documentFragment);
          };
      /**
       * Forces a re-render of the data rows. Should be called in cases where there has been an input
       * change that affects the evaluation of which rows should be rendered, e.g. toggling
       * `multiTemplateDataRows` or adding/removing row definitions.
       */
      /**
       * Forces a re-render of the data rows. Should be called in cases where there has been an input
       * change that affects the evaluation of which rows should be rendered, e.g. toggling
       * `multiTemplateDataRows` or adding/removing row definitions.
       * @private
       * @return {?}
       */
      CdkTable.prototype._forceRenderDataRows = /**
       * Forces a re-render of the data rows. Should be called in cases where there has been an input
       * change that affects the evaluation of which rows should be rendered, e.g. toggling
       * `multiTemplateDataRows` or adding/removing row definitions.
       * @private
       * @return {?}
       */
          function () {
              this._dataDiffer.diff([]);
              this._rowOutlet.viewContainer.clear();
              this.renderRows();
              this.updateStickyColumnStyles();
          };
      /**
       * Checks if there has been a change in sticky states since last check and applies the correct
       * sticky styles. Since checking resets the "dirty" state, this should only be performed once
       * during a change detection and after the inputs are settled (after content check).
       */
      /**
       * Checks if there has been a change in sticky states since last check and applies the correct
       * sticky styles. Since checking resets the "dirty" state, this should only be performed once
       * during a change detection and after the inputs are settled (after content check).
       * @private
       * @return {?}
       */
      CdkTable.prototype._checkStickyStates = /**
       * Checks if there has been a change in sticky states since last check and applies the correct
       * sticky styles. Since checking resets the "dirty" state, this should only be performed once
       * during a change detection and after the inputs are settled (after content check).
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var stickyCheckReducer = function (acc, d) {
                  return acc || d.hasStickyChanged();
              };
              // Note that the check needs to occur for every definition since it notifies the definition
              // that it can reset its dirty state. Using another operator like `some` may short-circuit
              // remaining definitions and leave them in an unchecked state.
              if (this._headerRowDefs.reduce(stickyCheckReducer, false)) {
                  this.updateStickyHeaderRowStyles();
              }
              if (this._footerRowDefs.reduce(stickyCheckReducer, false)) {
                  this.updateStickyFooterRowStyles();
              }
              if (Array.from(this._columnDefsByName.values()).reduce(stickyCheckReducer, false)) {
                  this.updateStickyColumnStyles();
              }
          };
      /**
       * Creates the sticky styler that will be used for sticky rows and columns. Listens
       * for directionality changes and provides the latest direction to the styler. Re-applies column
       * stickiness when directionality changes.
       */
      /**
       * Creates the sticky styler that will be used for sticky rows and columns. Listens
       * for directionality changes and provides the latest direction to the styler. Re-applies column
       * stickiness when directionality changes.
       * @private
       * @return {?}
       */
      CdkTable.prototype._setupStickyStyler = /**
       * Creates the sticky styler that will be used for sticky rows and columns. Listens
       * for directionality changes and provides the latest direction to the styler. Re-applies column
       * stickiness when directionality changes.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var direction = this._dir ? this._dir.value : 'ltr';
              this._stickyStyler = new StickyStyler(this._isNativeHtmlTable, 
              // @breaking-change 8.0.0 remove the null check for `this._platform`.
              this.stickyCssClass, direction, this._platform ? this._platform.isBrowser : true);
              (this._dir ? this._dir.change : rxjs.of())
                  .pipe(operators.takeUntil(this._onDestroy))
                  .subscribe(function (value) {
                  _this._stickyStyler.direction = value;
                  _this.updateStickyColumnStyles();
              });
          };
      CdkTable.decorators = [
          { type: core.Component, args: [{ selector: 'cdk-table, table[cdk-table]',
                      exportAs: 'cdkTable',
                      template: CDK_TABLE_TEMPLATE,
                      host: {
                          'class': 'cdk-table',
                      },
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      CdkTable.ctorParameters = function () {
          return [
              { type: core.IterableDiffers },
              { type: core.ChangeDetectorRef },
              { type: core.ElementRef },
              { type: String, decorators: [{ type: core.Attribute, args: ['role',] }] },
              { type: Directionality, decorators: [{ type: core.Optional }] },
              { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
              { type: Platform }
          ];
      };
      CdkTable.propDecorators = {
          trackBy: [{ type: core.Input }],
          dataSource: [{ type: core.Input }],
          multiTemplateDataRows: [{ type: core.Input }],
          _rowOutlet: [{ type: core.ViewChild, args: [DataRowOutlet,] }],
          _headerRowOutlet: [{ type: core.ViewChild, args: [HeaderRowOutlet,] }],
          _footerRowOutlet: [{ type: core.ViewChild, args: [FooterRowOutlet,] }],
          _contentColumnDefs: [{ type: core.ContentChildren, args: [CdkColumnDef,] }],
          _contentRowDefs: [{ type: core.ContentChildren, args: [CdkRowDef,] }],
          _contentHeaderRowDefs: [{ type: core.ContentChildren, args: [CdkHeaderRowDef,] }],
          _contentFooterRowDefs: [{ type: core.ContentChildren, args: [CdkFooterRowDef,] }]
      };
      return CdkTable;
  }());
  /**
   * Utility function that gets a merged list of the entries in a QueryList and values of a Set.
   * @template T
   * @param {?} queryList
   * @param {?} set
   * @return {?}
   */
  function mergeQueryListAndSet(queryList, set) {
      return queryList.toArray().concat(Array.from(set));
  }

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Wrapper for the CdkTable with Material design styles.
   * @template T
   */
  var MatTable = /** @class */ (function (_super) {
      tslib_1.__extends(MatTable, _super);
      function MatTable() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          /**
           * Overrides the sticky CSS class set by the `CdkTable`.
           */
          _this.stickyCssClass = 'mat-table-sticky';
          return _this;
      }
      MatTable.decorators = [
          { type: core.Component, args: [{ selector: 'mat-table, table[mat-table]',
                      exportAs: 'matTable',
                      template: CDK_TABLE_TEMPLATE,
                      styles: ["mat-table{display:block}mat-header-row{min-height:56px}mat-footer-row,mat-row{min-height:48px}mat-footer-row,mat-header-row,mat-row{display:flex;border-width:0;border-bottom-width:1px;border-style:solid;align-items:center;box-sizing:border-box}mat-footer-row::after,mat-header-row::after,mat-row::after{display:inline-block;min-height:inherit;content:''}mat-cell:first-of-type,mat-footer-cell:first-of-type,mat-header-cell:first-of-type{padding-left:24px}[dir=rtl] mat-cell:first-of-type,[dir=rtl] mat-footer-cell:first-of-type,[dir=rtl] mat-header-cell:first-of-type{padding-left:0;padding-right:24px}mat-cell:last-of-type,mat-footer-cell:last-of-type,mat-header-cell:last-of-type{padding-right:24px}[dir=rtl] mat-cell:last-of-type,[dir=rtl] mat-footer-cell:last-of-type,[dir=rtl] mat-header-cell:last-of-type{padding-right:0;padding-left:24px}mat-cell,mat-footer-cell,mat-header-cell{flex:1;display:flex;align-items:center;overflow:hidden;word-wrap:break-word;min-height:inherit}table.mat-table{border-spacing:0}tr.mat-header-row{height:56px}tr.mat-footer-row,tr.mat-row{height:48px}th.mat-header-cell{text-align:left}[dir=rtl] th.mat-header-cell{text-align:right}td.mat-cell,td.mat-footer-cell,th.mat-header-cell{padding:0;border-bottom-width:1px;border-bottom-style:solid}td.mat-cell:first-of-type,td.mat-footer-cell:first-of-type,th.mat-header-cell:first-of-type{padding-left:24px}[dir=rtl] td.mat-cell:first-of-type,[dir=rtl] td.mat-footer-cell:first-of-type,[dir=rtl] th.mat-header-cell:first-of-type{padding-left:0;padding-right:24px}td.mat-cell:last-of-type,td.mat-footer-cell:last-of-type,th.mat-header-cell:last-of-type{padding-right:24px}[dir=rtl] td.mat-cell:last-of-type,[dir=rtl] td.mat-footer-cell:last-of-type,[dir=rtl] th.mat-header-cell:last-of-type{padding-right:0;padding-left:24px}"],
                      host: {
                          'class': 'mat-table',
                      },
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      return MatTable;
  }(CdkTable));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Cell definition for the mat-table.
   * Captures the template of a column's data row cell as well as cell-specific properties.
   */
  var MatCellDef = /** @class */ (function (_super) {
      tslib_1.__extends(MatCellDef, _super);
      function MatCellDef() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MatCellDef.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matCellDef]',
                      providers: [{ provide: CdkCellDef, useExisting: MatCellDef }]
                  },] },
      ];
      return MatCellDef;
  }(CdkCellDef));
  /**
   * Header cell definition for the mat-table.
   * Captures the template of a column's header cell and as well as cell-specific properties.
   */
  var MatHeaderCellDef = /** @class */ (function (_super) {
      tslib_1.__extends(MatHeaderCellDef, _super);
      function MatHeaderCellDef() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MatHeaderCellDef.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matHeaderCellDef]',
                      providers: [{ provide: CdkHeaderCellDef, useExisting: MatHeaderCellDef }]
                  },] },
      ];
      return MatHeaderCellDef;
  }(CdkHeaderCellDef));
  /**
   * Footer cell definition for the mat-table.
   * Captures the template of a column's footer cell and as well as cell-specific properties.
   */
  var MatFooterCellDef = /** @class */ (function (_super) {
      tslib_1.__extends(MatFooterCellDef, _super);
      function MatFooterCellDef() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MatFooterCellDef.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matFooterCellDef]',
                      providers: [{ provide: CdkFooterCellDef, useExisting: MatFooterCellDef }]
                  },] },
      ];
      return MatFooterCellDef;
  }(CdkFooterCellDef));
  /**
   * Column definition for the mat-table.
   * Defines a set of cells available for a table column.
   */
  var MatColumnDef = /** @class */ (function (_super) {
      tslib_1.__extends(MatColumnDef, _super);
      function MatColumnDef() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MatColumnDef.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matColumnDef]',
                      providers: [
                          { provide: CdkColumnDef, useExisting: MatColumnDef },
                          { provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: MatColumnDef }
                      ],
                  },] },
      ];
      MatColumnDef.propDecorators = {
          name: [{ type: core.Input, args: ['matColumnDef',] }],
          sticky: [{ type: core.Input }],
          stickyEnd: [{ type: core.Input }]
      };
      return MatColumnDef;
  }(CdkColumnDef));
  /**
   * Header cell template container that adds the right classes and role.
   */
  var MatHeaderCell = /** @class */ (function (_super) {
      tslib_1.__extends(MatHeaderCell, _super);
      function MatHeaderCell(columnDef, elementRef) {
          var _this = _super.call(this, columnDef, elementRef) || this;
          elementRef.nativeElement.classList.add("mat-column-" + columnDef.cssClassFriendlyName);
          return _this;
      }
      MatHeaderCell.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-header-cell, th[mat-header-cell]',
                      host: {
                          'class': 'mat-header-cell',
                          'role': 'columnheader',
                      },
                  },] },
      ];
      /** @nocollapse */
      MatHeaderCell.ctorParameters = function () {
          return [
              { type: CdkColumnDef },
              { type: core.ElementRef }
          ];
      };
      return MatHeaderCell;
  }(CdkHeaderCell));
  /**
   * Footer cell template container that adds the right classes and role.
   */
  var MatFooterCell = /** @class */ (function (_super) {
      tslib_1.__extends(MatFooterCell, _super);
      function MatFooterCell(columnDef, elementRef) {
          var _this = _super.call(this, columnDef, elementRef) || this;
          elementRef.nativeElement.classList.add("mat-column-" + columnDef.cssClassFriendlyName);
          return _this;
      }
      MatFooterCell.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-footer-cell, td[mat-footer-cell]',
                      host: {
                          'class': 'mat-footer-cell',
                          'role': 'gridcell',
                      },
                  },] },
      ];
      /** @nocollapse */
      MatFooterCell.ctorParameters = function () {
          return [
              { type: CdkColumnDef },
              { type: core.ElementRef }
          ];
      };
      return MatFooterCell;
  }(CdkFooterCell));
  /**
   * Cell template container that adds the right classes and role.
   */
  var MatCell = /** @class */ (function (_super) {
      tslib_1.__extends(MatCell, _super);
      function MatCell(columnDef, elementRef) {
          var _this = _super.call(this, columnDef, elementRef) || this;
          elementRef.nativeElement.classList.add("mat-column-" + columnDef.cssClassFriendlyName);
          return _this;
      }
      MatCell.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-cell, td[mat-cell]',
                      host: {
                          'class': 'mat-cell',
                          'role': 'gridcell',
                      },
                  },] },
      ];
      /** @nocollapse */
      MatCell.ctorParameters = function () {
          return [
              { type: CdkColumnDef },
              { type: core.ElementRef }
          ];
      };
      return MatCell;
  }(CdkCell));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Header row definition for the mat-table.
   * Captures the header row's template and other header properties such as the columns to display.
   */
  var MatHeaderRowDef = /** @class */ (function (_super) {
      tslib_1.__extends(MatHeaderRowDef, _super);
      function MatHeaderRowDef() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MatHeaderRowDef.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matHeaderRowDef]',
                      providers: [{ provide: CdkHeaderRowDef, useExisting: MatHeaderRowDef }],
                      inputs: ['columns: matHeaderRowDef', 'sticky: matHeaderRowDefSticky'],
                  },] },
      ];
      return MatHeaderRowDef;
  }(CdkHeaderRowDef));
  /**
   * Footer row definition for the mat-table.
   * Captures the footer row's template and other footer properties such as the columns to display.
   */
  var MatFooterRowDef = /** @class */ (function (_super) {
      tslib_1.__extends(MatFooterRowDef, _super);
      function MatFooterRowDef() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MatFooterRowDef.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matFooterRowDef]',
                      providers: [{ provide: CdkFooterRowDef, useExisting: MatFooterRowDef }],
                      inputs: ['columns: matFooterRowDef', 'sticky: matFooterRowDefSticky'],
                  },] },
      ];
      return MatFooterRowDef;
  }(CdkFooterRowDef));
  /**
   * Data row definition for the mat-table.
   * Captures the data row's template and other properties such as the columns to display and
   * a when predicate that describes when this row should be used.
   * @template T
   */
  var MatRowDef = /** @class */ (function (_super) {
      tslib_1.__extends(MatRowDef, _super);
      function MatRowDef() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MatRowDef.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matRowDef]',
                      providers: [{ provide: CdkRowDef, useExisting: MatRowDef }],
                      inputs: ['columns: matRowDefColumns', 'when: matRowDefWhen'],
                  },] },
      ];
      return MatRowDef;
  }(CdkRowDef));
  /**
   * Footer template container that contains the cell outlet. Adds the right class and role.
   */
  var MatHeaderRow = /** @class */ (function (_super) {
      tslib_1.__extends(MatHeaderRow, _super);
      function MatHeaderRow() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MatHeaderRow.decorators = [
          { type: core.Component, args: [{ selector: 'mat-header-row, tr[mat-header-row]',
                      template: CDK_ROW_TEMPLATE,
                      host: {
                          'class': 'mat-header-row',
                          'role': 'row',
                      },
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                      exportAs: 'matHeaderRow',
                      providers: [{ provide: CdkHeaderRow, useExisting: MatHeaderRow }],
                  },] },
      ];
      return MatHeaderRow;
  }(CdkHeaderRow));
  /**
   * Footer template container that contains the cell outlet. Adds the right class and role.
   */
  var MatFooterRow = /** @class */ (function (_super) {
      tslib_1.__extends(MatFooterRow, _super);
      function MatFooterRow() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MatFooterRow.decorators = [
          { type: core.Component, args: [{ selector: 'mat-footer-row, tr[mat-footer-row]',
                      template: CDK_ROW_TEMPLATE,
                      host: {
                          'class': 'mat-footer-row',
                          'role': 'row',
                      },
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                      exportAs: 'matFooterRow',
                      providers: [{ provide: CdkFooterRow, useExisting: MatFooterRow }],
                  },] },
      ];
      return MatFooterRow;
  }(CdkFooterRow));
  /**
   * Data row template container that contains the cell outlet. Adds the right class and role.
   */
  var MatRow = /** @class */ (function (_super) {
      tslib_1.__extends(MatRow, _super);
      function MatRow() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MatRow.decorators = [
          { type: core.Component, args: [{ selector: 'mat-row, tr[mat-row]',
                      template: CDK_ROW_TEMPLATE,
                      host: {
                          'class': 'mat-row',
                          'role': 'row',
                      },
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                      exportAs: 'matRow',
                      providers: [{ provide: CdkRow, useExisting: MatRow }],
                  },] },
      ];
      return MatRow;
  }(CdkRow));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Corresponds to `Number.MAX_SAFE_INTEGER`. Moved out into a variable here due to
   * flaky browser support and the value not being defined in Closure's typings.
   * @type {?}
   */
  var MAX_SAFE_INTEGER = 9007199254740991;
  /**
   * Data source that accepts a client-side data array and includes native support of filtering,
   * sorting (using MatSort), and pagination (using MatPaginator).
   *
   * Allows for sort customization by overriding sortingDataAccessor, which defines how data
   * properties are accessed. Also allows for filter customization by overriding filterTermAccessor,
   * which defines how row data is converted to a string for filter matching.
   * @template T
   */
  var /**
   * Data source that accepts a client-side data array and includes native support of filtering,
   * sorting (using MatSort), and pagination (using MatPaginator).
   *
   * Allows for sort customization by overriding sortingDataAccessor, which defines how data
   * properties are accessed. Also allows for filter customization by overriding filterTermAccessor,
   * which defines how row data is converted to a string for filter matching.
   * @template T
   */ MatTableDataSource = /** @class */ (function (_super) {
      tslib_1.__extends(MatTableDataSource, _super);
      function MatTableDataSource(initialData) {
          if (initialData === void 0) {
              initialData = [];
          }
          var _this = _super.call(this) || this;
          /**
           * Stream emitting render data to the table (depends on ordered data changes).
           */
          _this._renderData = new rxjs.BehaviorSubject([]);
          /**
           * Stream that emits when a new filter string is set on the data source.
           */
          _this._filter = new rxjs.BehaviorSubject('');
          /**
           * Used to react to internal changes of the paginator that are made by the data source itself.
           */
          _this._internalPageChanges = new rxjs.Subject();
          /**
           * Subscription to the changes that should trigger an update to the table's rendered rows, such
           * as filtering, sorting, pagination, or base data changes.
           */
          _this._renderChangesSubscription = rxjs.Subscription.EMPTY;
          /**
           * Data accessor function that is used for accessing data properties for sorting through
           * the default sortData function.
           * This default function assumes that the sort header IDs (which defaults to the column name)
           * matches the data's properties (e.g. column Xyz represents data['Xyz']).
           * May be set to a custom function for different behavior.
           * @param data Data object that is being accessed.
           * @param sortHeaderId The name of the column that represents the data.
           */
          _this.sortingDataAccessor = function (data, sortHeaderId) {
              /** @type {?} */
              var value = (( /** @type {?} */(data)))[sortHeaderId];
              if (_isNumberValue(value)) {
                  /** @type {?} */
                  var numberValue = Number(value);
                  // Numbers beyond `MAX_SAFE_INTEGER` can't be compared reliably so we
                  // leave them as strings. For more info: https://goo.gl/y5vbSg
                  return numberValue < MAX_SAFE_INTEGER ? numberValue : value;
              }
              return value;
          };
          /**
           * Gets a sorted copy of the data array based on the state of the MatSort. Called
           * after changes are made to the filtered data or when sort changes are emitted from MatSort.
           * By default, the function retrieves the active sort and its direction and compares data
           * by retrieving data using the sortingDataAccessor. May be overridden for a custom implementation
           * of data ordering.
           * @param data The array of data that should be sorted.
           * @param sort The connected MatSort that holds the current sort state.
           */
          _this.sortData = function (data, sort) {
              /** @type {?} */
              var active = sort.active;
              /** @type {?} */
              var direction = sort.direction;
              if (!active || direction == '') {
                  return data;
              }
              return data.sort(function (a, b) {
                  /** @type {?} */
                  var valueA = _this.sortingDataAccessor(a, active);
                  /** @type {?} */
                  var valueB = _this.sortingDataAccessor(b, active);
                  // If both valueA and valueB exist (truthy), then compare the two. Otherwise, check if
                  // one value exists while the other doesn't. In this case, existing value should come first.
                  // This avoids inconsistent results when comparing values to undefined/null.
                  // If neither value exists, return 0 (equal).
                  /** @type {?} */
                  var comparatorResult = 0;
                  if (valueA != null && valueB != null) {
                      // Check if one value is greater than the other; if equal, comparatorResult should remain 0.
                      if (valueA > valueB) {
                          comparatorResult = 1;
                      }
                      else if (valueA < valueB) {
                          comparatorResult = -1;
                      }
                  }
                  else if (valueA != null) {
                      comparatorResult = 1;
                  }
                  else if (valueB != null) {
                      comparatorResult = -1;
                  }
                  return comparatorResult * (direction == 'asc' ? 1 : -1);
              });
          };
          /**
           * Checks if a data object matches the data source's filter string. By default, each data object
           * is converted to a string of its properties and returns true if the filter has
           * at least one occurrence in that string. By default, the filter string has its whitespace
           * trimmed and the match is case-insensitive. May be overridden for a custom implementation of
           * filter matching.
           * @param data Data object used to check against the filter.
           * @param filter Filter string that has been set on the data source.
           * @return Whether the filter matches against the data
           */
          _this.filterPredicate = function (data, filter) {
              // Transform the data into a lowercase string of all property values.
              /** @type {?} */
              var dataStr = Object.keys(data).reduce(function (currentTerm, key) {
                  // Use an obscure Unicode character to delimit the words in the concatenated string.
                  // This avoids matches where the values of two columns combined will match the user's query
                  // (e.g. `Flute` and `Stop` will match `Test`). The character is intended to be something
                  // that has a very low chance of being typed in by somebody in a text field. This one in
                  // particular is "White up-pointing triangle with dot" from
                  // https://en.wikipedia.org/wiki/List_of_Unicode_characters
                  return currentTerm + (( /** @type {?} */(data)))[key] + '◬';
              }, '').toLowerCase();
              // Transform the filter by converting it to lowercase and removing whitespace.
              /** @type {?} */
              var transformedFilter = filter.trim().toLowerCase();
              return dataStr.indexOf(transformedFilter) != -1;
          };
          _this._data = new rxjs.BehaviorSubject(initialData);
          _this._updateChangeSubscription();
          return _this;
      }
      Object.defineProperty(MatTableDataSource.prototype, "data", {
          /** Array of data that should be rendered by the table, where each object represents one row. */
          get: /**
           * Array of data that should be rendered by the table, where each object represents one row.
           * @return {?}
           */ function () { return this._data.value; },
          set: /**
           * @param {?} data
           * @return {?}
           */ function (data) { this._data.next(data); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatTableDataSource.prototype, "filter", {
          /**
           * Filter term that should be used to filter out objects from the data array. To override how
           * data objects match to this filter string, provide a custom function for filterPredicate.
           */
          get: /**
           * Filter term that should be used to filter out objects from the data array. To override how
           * data objects match to this filter string, provide a custom function for filterPredicate.
           * @return {?}
           */ function () { return this._filter.value; },
          set: /**
           * @param {?} filter
           * @return {?}
           */ function (filter) { this._filter.next(filter); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatTableDataSource.prototype, "sort", {
          /**
           * Instance of the MatSort directive used by the table to control its sorting. Sort changes
           * emitted by the MatSort will trigger an update to the table's rendered data.
           */
          get: /**
           * Instance of the MatSort directive used by the table to control its sorting. Sort changes
           * emitted by the MatSort will trigger an update to the table's rendered data.
           * @return {?}
           */ function () { return this._sort; },
          set: /**
           * @param {?} sort
           * @return {?}
           */ function (sort) {
              this._sort = sort;
              this._updateChangeSubscription();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatTableDataSource.prototype, "paginator", {
          /**
           * Instance of the MatPaginator component used by the table to control what page of the data is
           * displayed. Page changes emitted by the MatPaginator will trigger an update to the
           * table's rendered data.
           *
           * Note that the data source uses the paginator's properties to calculate which page of data
           * should be displayed. If the paginator receives its properties as template inputs,
           * e.g. `[pageLength]=100` or `[pageIndex]=1`, then be sure that the paginator's view has been
           * initialized before assigning it to this data source.
           */
          get: /**
           * Instance of the MatPaginator component used by the table to control what page of the data is
           * displayed. Page changes emitted by the MatPaginator will trigger an update to the
           * table's rendered data.
           *
           * Note that the data source uses the paginator's properties to calculate which page of data
           * should be displayed. If the paginator receives its properties as template inputs,
           * e.g. `[pageLength]=100` or `[pageIndex]=1`, then be sure that the paginator's view has been
           * initialized before assigning it to this data source.
           * @return {?}
           */ function () { return this._paginator; },
          set: /**
           * @param {?} paginator
           * @return {?}
           */ function (paginator) {
              this._paginator = paginator;
              this._updateChangeSubscription();
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Subscribe to changes that should trigger an update to the table's rendered rows. When the
       * changes occur, process the current state of the filter, sort, and pagination along with
       * the provided base data and send it to the table for rendering.
       */
      /**
       * Subscribe to changes that should trigger an update to the table's rendered rows. When the
       * changes occur, process the current state of the filter, sort, and pagination along with
       * the provided base data and send it to the table for rendering.
       * @return {?}
       */
      MatTableDataSource.prototype._updateChangeSubscription = /**
       * Subscribe to changes that should trigger an update to the table's rendered rows. When the
       * changes occur, process the current state of the filter, sort, and pagination along with
       * the provided base data and send it to the table for rendering.
       * @return {?}
       */
          function () {
              var _this = this;
              // Sorting and/or pagination should be watched if MatSort and/or MatPaginator are provided.
              // The events should emit whenever the component emits a change or initializes, or if no
              // component is provided, a stream with just a null event should be provided.
              // The `sortChange` and `pageChange` acts as a signal to the combineLatests below so that the
              // pipeline can progress to the next step. Note that the value from these streams are not used,
              // they purely act as a signal to progress in the pipeline.
              /** @type {?} */
              var sortChange = this._sort ?
                  rxjs.merge(this._sort.sortChange, this._sort.initialized) :
                  rxjs.of(null);
              /** @type {?} */
              var pageChange = this._paginator ?
                  rxjs.merge(this._paginator.page, this._internalPageChanges, this._paginator.initialized) :
                  rxjs.of(null);
              /** @type {?} */
              var dataStream = this._data;
              // Watch for base data or filter changes to provide a filtered set of data.
              /** @type {?} */
              var filteredData = rxjs.combineLatest(dataStream, this._filter)
                  .pipe(operators.map(function (_a) {
                  var data = _a[0];
                  return _this._filterData(data);
              }));
              // Watch for filtered data or sort changes to provide an ordered set of data.
              /** @type {?} */
              var orderedData = rxjs.combineLatest(filteredData, sortChange)
                  .pipe(operators.map(function (_a) {
                  var data = _a[0];
                  return _this._orderData(data);
              }));
              // Watch for ordered data or page changes to provide a paged set of data.
              /** @type {?} */
              var paginatedData = rxjs.combineLatest(orderedData, pageChange)
                  .pipe(operators.map(function (_a) {
                  var data = _a[0];
                  return _this._pageData(data);
              }));
              // Watched for paged data changes and send the result to the table to render.
              this._renderChangesSubscription.unsubscribe();
              this._renderChangesSubscription = paginatedData.subscribe(function (data) { return _this._renderData.next(data); });
          };
      /**
       * Returns a filtered data array where each filter object contains the filter string within
       * the result of the filterTermAccessor function. If no filter is set, returns the data array
       * as provided.
       */
      /**
       * Returns a filtered data array where each filter object contains the filter string within
       * the result of the filterTermAccessor function. If no filter is set, returns the data array
       * as provided.
       * @param {?} data
       * @return {?}
       */
      MatTableDataSource.prototype._filterData = /**
       * Returns a filtered data array where each filter object contains the filter string within
       * the result of the filterTermAccessor function. If no filter is set, returns the data array
       * as provided.
       * @param {?} data
       * @return {?}
       */
          function (data) {
              var _this = this;
              // If there is a filter string, filter out data that does not contain it.
              // Each data object is converted to a string using the function defined by filterTermAccessor.
              // May be overridden for customization.
              this.filteredData =
                  !this.filter ? data : data.filter(function (obj) { return _this.filterPredicate(obj, _this.filter); });
              if (this.paginator) {
                  this._updatePaginator(this.filteredData.length);
              }
              return this.filteredData;
          };
      /**
       * Returns a sorted copy of the data if MatSort has a sort applied, otherwise just returns the
       * data array as provided. Uses the default data accessor for data lookup, unless a
       * sortDataAccessor function is defined.
       */
      /**
       * Returns a sorted copy of the data if MatSort has a sort applied, otherwise just returns the
       * data array as provided. Uses the default data accessor for data lookup, unless a
       * sortDataAccessor function is defined.
       * @param {?} data
       * @return {?}
       */
      MatTableDataSource.prototype._orderData = /**
       * Returns a sorted copy of the data if MatSort has a sort applied, otherwise just returns the
       * data array as provided. Uses the default data accessor for data lookup, unless a
       * sortDataAccessor function is defined.
       * @param {?} data
       * @return {?}
       */
          function (data) {
              // If there is no active sort or direction, return the data without trying to sort.
              if (!this.sort) {
                  return data;
              }
              return this.sortData(data.slice(), this.sort);
          };
      /**
       * Returns a paged splice of the provided data array according to the provided MatPaginator's page
       * index and length. If there is no paginator provided, returns the data array as provided.
       */
      /**
       * Returns a paged splice of the provided data array according to the provided MatPaginator's page
       * index and length. If there is no paginator provided, returns the data array as provided.
       * @param {?} data
       * @return {?}
       */
      MatTableDataSource.prototype._pageData = /**
       * Returns a paged splice of the provided data array according to the provided MatPaginator's page
       * index and length. If there is no paginator provided, returns the data array as provided.
       * @param {?} data
       * @return {?}
       */
          function (data) {
              if (!this.paginator) {
                  return data;
              }
              /** @type {?} */
              var startIndex = this.paginator.pageIndex * this.paginator.pageSize;
              return data.slice().splice(startIndex, this.paginator.pageSize);
          };
      /**
       * Updates the paginator to reflect the length of the filtered data, and makes sure that the page
       * index does not exceed the paginator's last page. Values are changed in a resolved promise to
       * guard against making property changes within a round of change detection.
       */
      /**
       * Updates the paginator to reflect the length of the filtered data, and makes sure that the page
       * index does not exceed the paginator's last page. Values are changed in a resolved promise to
       * guard against making property changes within a round of change detection.
       * @param {?} filteredDataLength
       * @return {?}
       */
      MatTableDataSource.prototype._updatePaginator = /**
       * Updates the paginator to reflect the length of the filtered data, and makes sure that the page
       * index does not exceed the paginator's last page. Values are changed in a resolved promise to
       * guard against making property changes within a round of change detection.
       * @param {?} filteredDataLength
       * @return {?}
       */
          function (filteredDataLength) {
              var _this = this;
              Promise.resolve().then(function () {
                  /** @type {?} */
                  var paginator = _this.paginator;
                  if (!paginator) {
                      return;
                  }
                  paginator.length = filteredDataLength;
                  // If the page index is set beyond the page, reduce it to the last page.
                  if (paginator.pageIndex > 0) {
                      /** @type {?} */
                      var lastPageIndex = Math.ceil(paginator.length / paginator.pageSize) - 1 || 0;
                      /** @type {?} */
                      var newPageIndex = Math.min(paginator.pageIndex, lastPageIndex);
                      if (newPageIndex !== paginator.pageIndex) {
                          paginator.pageIndex = newPageIndex;
                          // Since the paginator only emits after user-generated changes,
                          // we need our own stream so we know to should re-render the data.
                          _this._internalPageChanges.next();
                      }
                  }
              });
          };
      /**
       * Used by the MatTable. Called when it connects to the data source.
       * @docs-private
       */
      /**
       * Used by the MatTable. Called when it connects to the data source.
       * \@docs-private
       * @return {?}
       */
      MatTableDataSource.prototype.connect = /**
       * Used by the MatTable. Called when it connects to the data source.
       * \@docs-private
       * @return {?}
       */
          function () { return this._renderData; };
      /**
       * Used by the MatTable. Called when it is destroyed. No-op.
       * @docs-private
       */
      /**
       * Used by the MatTable. Called when it is destroyed. No-op.
       * \@docs-private
       * @return {?}
       */
      MatTableDataSource.prototype.disconnect = /**
       * Used by the MatTable. Called when it is destroyed. No-op.
       * \@docs-private
       * @return {?}
       */
          function () { };
      return MatTableDataSource;
  }(DataSource));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Injection token for the MatInkBar's Positioner.
   * @type {?}
   */
  var _MAT_INK_BAR_POSITIONER = new core.InjectionToken('MatInkBarPositioner', {
      providedIn: 'root',
      factory: _MAT_INK_BAR_POSITIONER_FACTORY
  });
  /**
   * The default positioner function for the MatInkBar.
   * \@docs-private
   * @return {?}
   */
  function _MAT_INK_BAR_POSITIONER_FACTORY() {
      /** @type {?} */
      var method = function (element) {
          return ({
              left: element ? (element.offsetLeft || 0) + 'px' : '0',
              width: element ? (element.offsetWidth || 0) + 'px' : '0',
          });
      };
      return method;
  }
  /**
   * The ink-bar is used to display and animate the line underneath the current active tab label.
   * \@docs-private
   */
  var MatInkBar = /** @class */ (function () {
      function MatInkBar(_elementRef, _ngZone, _inkBarPositioner) {
          this._elementRef = _elementRef;
          this._ngZone = _ngZone;
          this._inkBarPositioner = _inkBarPositioner;
      }
      /**
       * Calculates the styles from the provided element in order to align the ink-bar to that element.
       * Shows the ink bar if previously set as hidden.
       * @param element
       */
      /**
       * Calculates the styles from the provided element in order to align the ink-bar to that element.
       * Shows the ink bar if previously set as hidden.
       * @param {?} element
       * @return {?}
       */
      MatInkBar.prototype.alignToElement = /**
       * Calculates the styles from the provided element in order to align the ink-bar to that element.
       * Shows the ink bar if previously set as hidden.
       * @param {?} element
       * @return {?}
       */
          function (element) {
              var _this = this;
              this.show();
              if (typeof requestAnimationFrame !== 'undefined') {
                  this._ngZone.runOutsideAngular(function () {
                      requestAnimationFrame(function () { return _this._setStyles(element); });
                  });
              }
              else {
                  this._setStyles(element);
              }
          };
      /** Shows the ink bar. */
      /**
       * Shows the ink bar.
       * @return {?}
       */
      MatInkBar.prototype.show = /**
       * Shows the ink bar.
       * @return {?}
       */
          function () {
              this._elementRef.nativeElement.style.visibility = 'visible';
          };
      /** Hides the ink bar. */
      /**
       * Hides the ink bar.
       * @return {?}
       */
      MatInkBar.prototype.hide = /**
       * Hides the ink bar.
       * @return {?}
       */
          function () {
              this._elementRef.nativeElement.style.visibility = 'hidden';
          };
      /**
       * Sets the proper styles to the ink bar element.
       * @param element
       */
      /**
       * Sets the proper styles to the ink bar element.
       * @private
       * @param {?} element
       * @return {?}
       */
      MatInkBar.prototype._setStyles = /**
       * Sets the proper styles to the ink bar element.
       * @private
       * @param {?} element
       * @return {?}
       */
          function (element) {
              /** @type {?} */
              var positions = this._inkBarPositioner(element);
              /** @type {?} */
              var inkBar = this._elementRef.nativeElement;
              inkBar.style.left = positions.left;
              inkBar.style.width = positions.width;
          };
      MatInkBar.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-ink-bar',
                      host: {
                          'class': 'mat-ink-bar',
                      },
                  },] },
      ];
      /** @nocollapse */
      MatInkBar.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.NgZone },
              { type: undefined, decorators: [{ type: core.Inject, args: [_MAT_INK_BAR_POSITIONER,] }] }
          ];
      };
      return MatInkBar;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Decorates the `ng-template` tags and reads out the template from it.
   */
  var MatTabContent = /** @class */ (function () {
      function MatTabContent(template) {
          this.template = template;
      }
      MatTabContent.decorators = [
          { type: core.Directive, args: [{ selector: '[matTabContent]' },] },
      ];
      /** @nocollapse */
      MatTabContent.ctorParameters = function () {
          return [
              { type: core.TemplateRef }
          ];
      };
      return MatTabContent;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Used to flag tab labels for use with the portal directive
   */
  var MatTabLabel = /** @class */ (function (_super) {
      tslib_1.__extends(MatTabLabel, _super);
      function MatTabLabel() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MatTabLabel.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mat-tab-label], [matTabLabel]',
                  },] },
      ];
      return MatTabLabel;
  }(CdkPortal));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Boilerplate for applying mixins to MatTab.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatTab.
  /**
   * \@docs-private
   */
  MatTabBase = /** @class */ (function () {
      function MatTabBase() {
      }
      return MatTabBase;
  }());
  /** @type {?} */
  var _MatTabMixinBase = mixinDisabled(MatTabBase);
  var MatTab = /** @class */ (function (_super) {
      tslib_1.__extends(MatTab, _super);
      function MatTab(_viewContainerRef) {
          var _this = _super.call(this) || this;
          _this._viewContainerRef = _viewContainerRef;
          /**
           * Plain text label for the tab, used when there is no template label.
           */
          _this.textLabel = '';
          /**
           * Portal that will be the hosted content of the tab
           */
          _this._contentPortal = null;
          /**
           * Emits whenever the internal state of the tab changes.
           */
          _this._stateChanges = new rxjs.Subject();
          /**
           * The relatively indexed position where 0 represents the center, negative is left, and positive
           * represents the right.
           */
          _this.position = null;
          /**
           * The initial relatively index origin of the tab if it was created and selected after there
           * was already a selected tab. Provides context of what position the tab should originate from.
           */
          _this.origin = null;
          /**
           * Whether the tab is currently active.
           */
          _this.isActive = false;
          return _this;
      }
      Object.defineProperty(MatTab.prototype, "content", {
          /** @docs-private */
          get: /**
           * \@docs-private
           * @return {?}
           */ function () {
              return this._contentPortal;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @param {?} changes
       * @return {?}
       */
      MatTab.prototype.ngOnChanges = /**
       * @param {?} changes
       * @return {?}
       */
          function (changes) {
              if (changes.hasOwnProperty('textLabel') || changes.hasOwnProperty('disabled')) {
                  this._stateChanges.next();
              }
          };
      /**
       * @return {?}
       */
      MatTab.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._stateChanges.complete();
          };
      /**
       * @return {?}
       */
      MatTab.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              this._contentPortal = new TemplatePortal(this._explicitContent || this._implicitContent, this._viewContainerRef);
          };
      MatTab.decorators = [
          { type: core.Component, args: [{ selector: 'mat-tab',
                      template: "<ng-template><ng-content></ng-content></ng-template>",
                      inputs: ['disabled'],
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                      exportAs: 'matTab',
                  },] },
      ];
      /** @nocollapse */
      MatTab.ctorParameters = function () {
          return [
              { type: core.ViewContainerRef }
          ];
      };
      MatTab.propDecorators = {
          templateLabel: [{ type: core.ContentChild, args: [MatTabLabel,] }],
          _explicitContent: [{ type: core.ContentChild, args: [MatTabContent, { read: core.TemplateRef },] }],
          _implicitContent: [{ type: core.ViewChild, args: [core.TemplateRef,] }],
          textLabel: [{ type: core.Input, args: ['label',] }],
          ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
          ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }]
      };
      return MatTab;
  }(_MatTabMixinBase));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Animations used by the Material tabs.
   * \@docs-private
   * @type {?}
   */
  var matTabsAnimations = {
      /**
       * Animation translates a tab along the X axis.
       */
      translateTab: trigger('translateTab', [
          // Note: transitions to `none` instead of 0, because some browsers might blur the content.
          state('center, void, left-origin-center, right-origin-center', style({ transform: 'none' })),
          // If the tab is either on the left or right, we additionally add a `min-height` of 1px
          // in order to ensure that the element has a height before its state changes. This is
          // necessary because Chrome does seem to skip the transition in RTL mode if the element does
          // not have a static height and is not rendered. See related issue: #9465
          state('left', style({ transform: 'translate3d(-100%, 0, 0)', minHeight: '1px' })),
          state('right', style({ transform: 'translate3d(100%, 0, 0)', minHeight: '1px' })),
          transition('* => left, * => right, left => center, right => center', animate('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')),
          transition('void => left-origin-center', [
              style({ transform: 'translate3d(-100%, 0, 0)' }),
              animate('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')
          ]),
          transition('void => right-origin-center', [
              style({ transform: 'translate3d(100%, 0, 0)' }),
              animate('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')
          ])
      ])
  };
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * The portal host directive for the contents of the tab.
   * \@docs-private
   */
  var MatTabBodyPortal = /** @class */ (function (_super) {
      tslib_1.__extends(MatTabBodyPortal, _super);
      function MatTabBodyPortal(componentFactoryResolver, viewContainerRef, _host) {
          var _this = _super.call(this, componentFactoryResolver, viewContainerRef) || this;
          _this._host = _host;
          /**
           * Subscription to events for when the tab body begins centering.
           */
          _this._centeringSub = rxjs.Subscription.EMPTY;
          /**
           * Subscription to events for when the tab body finishes leaving from center position.
           */
          _this._leavingSub = rxjs.Subscription.EMPTY;
          return _this;
      }
      /** Set initial visibility or set up subscription for changing visibility. */
      /**
       * Set initial visibility or set up subscription for changing visibility.
       * @return {?}
       */
      MatTabBodyPortal.prototype.ngOnInit = /**
       * Set initial visibility or set up subscription for changing visibility.
       * @return {?}
       */
          function () {
              var _this = this;
              _super.prototype.ngOnInit.call(this);
              this._centeringSub = this._host._beforeCentering
                  .pipe(operators.startWith(this._host._isCenterPosition(this._host._position)))
                  .subscribe(function (isCentering) {
                  if (isCentering && !_this.hasAttached()) {
                      _this.attach(_this._host._content);
                  }
              });
              this._leavingSub = this._host._afterLeavingCenter.subscribe(function () {
                  _this.detach();
              });
          };
      /** Clean up centering subscription. */
      /**
       * Clean up centering subscription.
       * @return {?}
       */
      MatTabBodyPortal.prototype.ngOnDestroy = /**
       * Clean up centering subscription.
       * @return {?}
       */
          function () {
              _super.prototype.ngOnDestroy.call(this);
              this._centeringSub.unsubscribe();
              this._leavingSub.unsubscribe();
          };
      MatTabBodyPortal.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matTabBodyHost]'
                  },] },
      ];
      /** @nocollapse */
      MatTabBodyPortal.ctorParameters = function () {
          return [
              { type: core.ComponentFactoryResolver },
              { type: core.ViewContainerRef },
              { type: MatTabBody, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return MatTabBody; }),] }] }
          ];
      };
      return MatTabBodyPortal;
  }(CdkPortalOutlet));
  /**
   * Wrapper for the contents of a tab.
   * \@docs-private
   */
  var MatTabBody = /** @class */ (function () {
      function MatTabBody(_elementRef, _dir, 
      /**
       * @breaking-change 8.0.0 changeDetectorRef to be made required.
       */
      changeDetectorRef) {
          var _this = this;
          this._elementRef = _elementRef;
          this._dir = _dir;
          /**
           * Subscription to the directionality change observable.
           */
          this._dirChangeSubscription = rxjs.Subscription.EMPTY;
          /**
           * Emits when an animation on the tab is complete.
           */
          this._translateTabComplete = new rxjs.Subject();
          /**
           * Event emitted when the tab begins to animate towards the center as the active tab.
           */
          this._onCentering = new core.EventEmitter();
          /**
           * Event emitted before the centering of the tab begins.
           */
          this._beforeCentering = new core.EventEmitter();
          /**
           * Event emitted before the centering of the tab begins.
           */
          this._afterLeavingCenter = new core.EventEmitter();
          /**
           * Event emitted when the tab completes its animation towards the center.
           */
          this._onCentered = new core.EventEmitter(true);
          // Note that the default value will always be overwritten by `MatTabBody`, but we need one
          // anyway to prevent the animations module from throwing an error if the body is used on its own.
          /**
           * Duration for the tab's animation.
           */
          this.animationDuration = '500ms';
          if (this._dir && changeDetectorRef) {
              this._dirChangeSubscription = this._dir.change.subscribe(function (dir) {
                  _this._computePositionAnimationState(dir);
                  changeDetectorRef.markForCheck();
              });
          }
          // Ensure that we get unique animation events, because the `.done` callback can get
          // invoked twice in some browsers. See https://github.com/angular/angular/issues/24084.
          this._translateTabComplete.pipe(operators.distinctUntilChanged(function (x, y) {
              return x.fromState === y.fromState && x.toState === y.toState;
          })).subscribe(function (event) {
              // If the transition to the center is complete, emit an event.
              if (_this._isCenterPosition(event.toState) && _this._isCenterPosition(_this._position)) {
                  _this._onCentered.emit();
              }
              if (_this._isCenterPosition(event.fromState) && !_this._isCenterPosition(_this._position)) {
                  _this._afterLeavingCenter.emit();
              }
          });
      }
      Object.defineProperty(MatTabBody.prototype, "position", {
          /** The shifted index position of the tab body, where zero represents the active center tab. */
          set: /**
           * The shifted index position of the tab body, where zero represents the active center tab.
           * @param {?} position
           * @return {?}
           */ function (position) {
              this._positionIndex = position;
              this._computePositionAnimationState();
          },
          enumerable: true,
          configurable: true
      });
      /**
       * After initialized, check if the content is centered and has an origin. If so, set the
       * special position states that transition the tab from the left or right before centering.
       */
      /**
       * After initialized, check if the content is centered and has an origin. If so, set the
       * special position states that transition the tab from the left or right before centering.
       * @return {?}
       */
      MatTabBody.prototype.ngOnInit = /**
       * After initialized, check if the content is centered and has an origin. If so, set the
       * special position states that transition the tab from the left or right before centering.
       * @return {?}
       */
          function () {
              if (this._position == 'center' && this.origin != null) {
                  this._position = this._computePositionFromOrigin();
              }
          };
      /**
       * @return {?}
       */
      MatTabBody.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._dirChangeSubscription.unsubscribe();
              this._translateTabComplete.complete();
          };
      /**
       * @param {?} event
       * @return {?}
       */
      MatTabBody.prototype._onTranslateTabStarted = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              /** @type {?} */
              var isCentering = this._isCenterPosition(event.toState);
              this._beforeCentering.emit(isCentering);
              if (isCentering) {
                  this._onCentering.emit(this._elementRef.nativeElement.clientHeight);
              }
          };
      /** The text direction of the containing app. */
      /**
       * The text direction of the containing app.
       * @return {?}
       */
      MatTabBody.prototype._getLayoutDirection = /**
       * The text direction of the containing app.
       * @return {?}
       */
          function () {
              return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
          };
      /** Whether the provided position state is considered center, regardless of origin. */
      /**
       * Whether the provided position state is considered center, regardless of origin.
       * @param {?} position
       * @return {?}
       */
      MatTabBody.prototype._isCenterPosition = /**
       * Whether the provided position state is considered center, regardless of origin.
       * @param {?} position
       * @return {?}
       */
          function (position) {
              return position == 'center' ||
                  position == 'left-origin-center' ||
                  position == 'right-origin-center';
          };
      /** Computes the position state that will be used for the tab-body animation trigger. */
      /**
       * Computes the position state that will be used for the tab-body animation trigger.
       * @private
       * @param {?=} dir
       * @return {?}
       */
      MatTabBody.prototype._computePositionAnimationState = /**
       * Computes the position state that will be used for the tab-body animation trigger.
       * @private
       * @param {?=} dir
       * @return {?}
       */
          function (dir) {
              if (dir === void 0) {
                  dir = this._getLayoutDirection();
              }
              if (this._positionIndex < 0) {
                  this._position = dir == 'ltr' ? 'left' : 'right';
              }
              else if (this._positionIndex > 0) {
                  this._position = dir == 'ltr' ? 'right' : 'left';
              }
              else {
                  this._position = 'center';
              }
          };
      /**
       * Computes the position state based on the specified origin position. This is used if the
       * tab is becoming visible immediately after creation.
       */
      /**
       * Computes the position state based on the specified origin position. This is used if the
       * tab is becoming visible immediately after creation.
       * @private
       * @return {?}
       */
      MatTabBody.prototype._computePositionFromOrigin = /**
       * Computes the position state based on the specified origin position. This is used if the
       * tab is becoming visible immediately after creation.
       * @private
       * @return {?}
       */
          function () {
              /** @type {?} */
              var dir = this._getLayoutDirection();
              if ((dir == 'ltr' && this.origin <= 0) || (dir == 'rtl' && this.origin > 0)) {
                  return 'left-origin-center';
              }
              return 'right-origin-center';
          };
      MatTabBody.decorators = [
          { type: core.Component, args: [{ selector: 'mat-tab-body',
                      template: "<div class=\"mat-tab-body-content\" #content [@translateTab]=\"{ value: _position, params: {animationDuration: animationDuration} }\" (@translateTab.start)=\"_onTranslateTabStarted($event)\" (@translateTab.done)=\"_translateTabComplete.next($event)\"><ng-template matTabBodyHost></ng-template></div>",
                      styles: [".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}"],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      animations: [matTabsAnimations.translateTab],
                      host: {
                          'class': 'mat-tab-body',
                      },
                  },] },
      ];
      /** @nocollapse */
      MatTabBody.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: Directionality, decorators: [{ type: core.Optional }] },
              { type: core.ChangeDetectorRef }
          ];
      };
      MatTabBody.propDecorators = {
          _onCentering: [{ type: core.Output }],
          _beforeCentering: [{ type: core.Output }],
          _afterLeavingCenter: [{ type: core.Output }],
          _onCentered: [{ type: core.Output }],
          _portalHost: [{ type: core.ViewChild, args: [CdkPortalOutlet,] }],
          _content: [{ type: core.Input, args: ['content',] }],
          origin: [{ type: core.Input }],
          animationDuration: [{ type: core.Input }],
          position: [{ type: core.Input }]
      };
      return MatTabBody;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Boilerplate for applying mixins to MatTabLabelWrapper.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatTabLabelWrapper.
  /**
   * \@docs-private
   */
  MatTabLabelWrapperBase = /** @class */ (function () {
      function MatTabLabelWrapperBase() {
      }
      return MatTabLabelWrapperBase;
  }());
  /** @type {?} */
  var _MatTabLabelWrapperMixinBase = mixinDisabled(MatTabLabelWrapperBase);
  /**
   * Used in the `mat-tab-group` view to display tab labels.
   * \@docs-private
   */
  var MatTabLabelWrapper = /** @class */ (function (_super) {
      tslib_1.__extends(MatTabLabelWrapper, _super);
      function MatTabLabelWrapper(elementRef) {
          var _this = _super.call(this) || this;
          _this.elementRef = elementRef;
          return _this;
      }
      /** Sets focus on the wrapper element */
      /**
       * Sets focus on the wrapper element
       * @return {?}
       */
      MatTabLabelWrapper.prototype.focus = /**
       * Sets focus on the wrapper element
       * @return {?}
       */
          function () {
              this.elementRef.nativeElement.focus();
          };
      /**
       * @return {?}
       */
      MatTabLabelWrapper.prototype.getOffsetLeft = /**
       * @return {?}
       */
          function () {
              return this.elementRef.nativeElement.offsetLeft;
          };
      /**
       * @return {?}
       */
      MatTabLabelWrapper.prototype.getOffsetWidth = /**
       * @return {?}
       */
          function () {
              return this.elementRef.nativeElement.offsetWidth;
          };
      MatTabLabelWrapper.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matTabLabelWrapper]',
                      inputs: ['disabled'],
                      host: {
                          '[class.mat-tab-disabled]': 'disabled',
                          '[attr.aria-disabled]': '!!disabled',
                      }
                  },] },
      ];
      /** @nocollapse */
      MatTabLabelWrapper.ctorParameters = function () {
          return [
              { type: core.ElementRef }
          ];
      };
      return MatTabLabelWrapper;
  }(_MatTabLabelWrapperMixinBase));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Config used to bind passive event listeners
   * @type {?}
   */
  var passiveEventListenerOptions$1 = ( /** @type {?} */(normalizePassiveListenerOptions({ passive: true })));
  /**
   * The distance in pixels that will be overshot when scrolling a tab label into view. This helps
   * provide a small affordance to the label next to it.
   * @type {?}
   */
  var EXAGGERATED_OVERSCROLL = 60;
  /**
   * Amount of milliseconds to wait before starting to scroll the header automatically.
   * Set a little conservatively in order to handle fake events dispatched on touch devices.
   * @type {?}
   */
  var HEADER_SCROLL_DELAY = 650;
  /**
   * Interval in milliseconds at which to scroll the header
   * while the user is holding their pointer.
   * @type {?}
   */
  var HEADER_SCROLL_INTERVAL = 100;
  // Boilerplate for applying mixins to MatTabHeader.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatTabHeader.
  /**
   * \@docs-private
   */
  MatTabHeaderBase = /** @class */ (function () {
      function MatTabHeaderBase() {
      }
      return MatTabHeaderBase;
  }());
  /** @type {?} */
  var _MatTabHeaderMixinBase = mixinDisableRipple(MatTabHeaderBase);
  /**
   * The header of the tab group which displays a list of all the tabs in the tab group. Includes
   * an ink bar that follows the currently selected tab. When the tabs list's width exceeds the
   * width of the header container, then arrows will be displayed to allow the user to scroll
   * left and right across the header.
   * \@docs-private
   */
  var MatTabHeader = /** @class */ (function (_super) {
      tslib_1.__extends(MatTabHeader, _super);
      function MatTabHeader(_elementRef, _changeDetectorRef, _viewportRuler, _dir, _ngZone, _platform) {
          var _this = _super.call(this) || this;
          _this._elementRef = _elementRef;
          _this._changeDetectorRef = _changeDetectorRef;
          _this._viewportRuler = _viewportRuler;
          _this._dir = _dir;
          _this._ngZone = _ngZone;
          _this._platform = _platform;
          /**
           * The distance in pixels that the tab labels should be translated to the left.
           */
          _this._scrollDistance = 0;
          /**
           * Whether the header should scroll to the selected index after the view has been checked.
           */
          _this._selectedIndexChanged = false;
          /**
           * Emits when the component is destroyed.
           */
          _this._destroyed = new rxjs.Subject();
          /**
           * Whether the controls for pagination should be displayed
           */
          _this._showPaginationControls = false;
          /**
           * Whether the tab list can be scrolled more towards the end of the tab label list.
           */
          _this._disableScrollAfter = true;
          /**
           * Whether the tab list can be scrolled more towards the beginning of the tab label list.
           */
          _this._disableScrollBefore = true;
          /**
           * Stream that will stop the automated scrolling.
           */
          _this._stopScrolling = new rxjs.Subject();
          _this._selectedIndex = 0;
          /**
           * Event emitted when the option is selected.
           */
          _this.selectFocusedIndex = new core.EventEmitter();
          /**
           * Event emitted when a label is focused.
           */
          _this.indexFocused = new core.EventEmitter();
          /** @type {?} */
          var element = _elementRef.nativeElement;
          /** @type {?} */
          var bindEvent = function () {
              rxjs.fromEvent(element, 'mouseleave')
                  .pipe(operators.takeUntil(_this._destroyed))
                  .subscribe(function () {
                  _this._stopInterval();
              });
          };
          // @breaking-change 8.0.0 remove null check once _ngZone is made into a required parameter.
          if (_ngZone) {
              // Bind the `mouseleave` event on the outside since it doesn't change anything in the view.
              _ngZone.runOutsideAngular(bindEvent);
          }
          else {
              bindEvent();
          }
          return _this;
      }
      Object.defineProperty(MatTabHeader.prototype, "selectedIndex", {
          /** The index of the active tab. */
          get: /**
           * The index of the active tab.
           * @return {?}
           */ function () { return this._selectedIndex; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              value = coerceNumberProperty(value);
              this._selectedIndexChanged = this._selectedIndex != value;
              this._selectedIndex = value;
              if (this._keyManager) {
                  this._keyManager.updateActiveItemIndex(value);
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatTabHeader.prototype.ngAfterContentChecked = /**
       * @return {?}
       */
          function () {
              // If the number of tab labels have changed, check if scrolling should be enabled
              if (this._tabLabelCount != this._labelWrappers.length) {
                  this.updatePagination();
                  this._tabLabelCount = this._labelWrappers.length;
                  this._changeDetectorRef.markForCheck();
              }
              // If the selected index has changed, scroll to the label and check if the scrolling controls
              // should be disabled.
              if (this._selectedIndexChanged) {
                  this._scrollToLabel(this._selectedIndex);
                  this._checkScrollingControls();
                  this._alignInkBarToSelectedTab();
                  this._selectedIndexChanged = false;
                  this._changeDetectorRef.markForCheck();
              }
              // If the scroll distance has been changed (tab selected, focused, scroll controls activated),
              // then translate the header to reflect this.
              if (this._scrollDistanceChanged) {
                  this._updateTabScrollPosition();
                  this._scrollDistanceChanged = false;
                  this._changeDetectorRef.markForCheck();
              }
          };
      /** Handles keyboard events on the header. */
      /**
       * Handles keyboard events on the header.
       * @param {?} event
       * @return {?}
       */
      MatTabHeader.prototype._handleKeydown = /**
       * Handles keyboard events on the header.
       * @param {?} event
       * @return {?}
       */
          function (event) {
              // We don't handle any key bindings with a modifier key.
              if (hasModifierKey(event)) {
                  return;
              }
              switch (event.keyCode) {
                  case HOME:
                      this._keyManager.setFirstItemActive();
                      event.preventDefault();
                      break;
                  case END:
                      this._keyManager.setLastItemActive();
                      event.preventDefault();
                      break;
                  case ENTER:
                  case SPACE:
                      this.selectFocusedIndex.emit(this.focusIndex);
                      event.preventDefault();
                      break;
                  default:
                      this._keyManager.onKeydown(event);
              }
          };
      /**
       * Aligns the ink bar to the selected tab on load.
       */
      /**
       * Aligns the ink bar to the selected tab on load.
       * @return {?}
       */
      MatTabHeader.prototype.ngAfterContentInit = /**
       * Aligns the ink bar to the selected tab on load.
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var dirChange = this._dir ? this._dir.change : rxjs.of(null);
              /** @type {?} */
              var resize = this._viewportRuler.change(150);
              /** @type {?} */
              var realign = function () {
                  _this.updatePagination();
                  _this._alignInkBarToSelectedTab();
              };
              this._keyManager = new FocusKeyManager(this._labelWrappers)
                  .withHorizontalOrientation(this._getLayoutDirection())
                  .withWrap();
              this._keyManager.updateActiveItem(0);
              // Defer the first call in order to allow for slower browsers to lay out the elements.
              // This helps in cases where the user lands directly on a page with paginated tabs.
              typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame(realign) : realign();
              // On dir change or window resize, realign the ink bar and update the orientation of
              // the key manager if the direction has changed.
              rxjs.merge(dirChange, resize).pipe(operators.takeUntil(this._destroyed)).subscribe(function () {
                  realign();
                  _this._keyManager.withHorizontalOrientation(_this._getLayoutDirection());
              });
              // If there is a change in the focus key manager we need to emit the `indexFocused`
              // event in order to provide a public event that notifies about focus changes. Also we realign
              // the tabs container by scrolling the new focused tab into the visible section.
              this._keyManager.change.pipe(operators.takeUntil(this._destroyed)).subscribe(function (newFocusIndex) {
                  _this.indexFocused.emit(newFocusIndex);
                  _this._setTabFocus(newFocusIndex);
              });
          };
      /**
       * @return {?}
       */
      MatTabHeader.prototype.ngAfterViewInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              // We need to handle these events manually, because we want to bind passive event listeners.
              rxjs.fromEvent(this._previousPaginator.nativeElement, 'touchstart', passiveEventListenerOptions$1)
                  .pipe(operators.takeUntil(this._destroyed))
                  .subscribe(function () {
                  _this._handlePaginatorPress('before');
              });
              rxjs.fromEvent(this._nextPaginator.nativeElement, 'touchstart', passiveEventListenerOptions$1)
                  .pipe(operators.takeUntil(this._destroyed))
                  .subscribe(function () {
                  _this._handlePaginatorPress('after');
              });
          };
      /**
       * @return {?}
       */
      MatTabHeader.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._destroyed.next();
              this._destroyed.complete();
              this._stopScrolling.complete();
          };
      /**
       * Callback for when the MutationObserver detects that the content has changed.
       */
      /**
       * Callback for when the MutationObserver detects that the content has changed.
       * @return {?}
       */
      MatTabHeader.prototype._onContentChanges = /**
       * Callback for when the MutationObserver detects that the content has changed.
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var textContent = this._elementRef.nativeElement.textContent;
              // We need to diff the text content of the header, because the MutationObserver callback
              // will fire even if the text content didn't change which is inefficient and is prone
              // to infinite loops if a poorly constructed expression is passed in (see #14249).
              if (textContent !== this._currentTextContent) {
                  this._currentTextContent = textContent;
                  /** @type {?} */
                  var zoneCallback = function () {
                      _this.updatePagination();
                      _this._alignInkBarToSelectedTab();
                      _this._changeDetectorRef.markForCheck();
                  };
                  // The content observer runs outside the `NgZone` by default, which
                  // means that we need to bring the callback back in ourselves.
                  // @breaking-change 8.0.0 Remove null check for `_ngZone` once it's a required parameter.
                  this._ngZone ? this._ngZone.run(zoneCallback) : zoneCallback();
              }
          };
      /**
       * Updates the view whether pagination should be enabled or not.
       *
       * WARNING: Calling this method can be very costly in terms of performance.  It should be called
       * as infrequently as possible from outside of the Tabs component as it causes a reflow of the
       * page.
       */
      /**
       * Updates the view whether pagination should be enabled or not.
       *
       * WARNING: Calling this method can be very costly in terms of performance.  It should be called
       * as infrequently as possible from outside of the Tabs component as it causes a reflow of the
       * page.
       * @return {?}
       */
      MatTabHeader.prototype.updatePagination = /**
       * Updates the view whether pagination should be enabled or not.
       *
       * WARNING: Calling this method can be very costly in terms of performance.  It should be called
       * as infrequently as possible from outside of the Tabs component as it causes a reflow of the
       * page.
       * @return {?}
       */
          function () {
              this._checkPaginationEnabled();
              this._checkScrollingControls();
              this._updateTabScrollPosition();
          };
      Object.defineProperty(MatTabHeader.prototype, "focusIndex", {
          /** Tracks which element has focus; used for keyboard navigation */
          get: /**
           * Tracks which element has focus; used for keyboard navigation
           * @return {?}
           */ function () {
              return this._keyManager ? ( /** @type {?} */(this._keyManager.activeItemIndex)) : 0;
          },
          /** When the focus index is set, we must manually send focus to the correct label */
          set: /**
           * When the focus index is set, we must manually send focus to the correct label
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {
                  return;
              }
              this._keyManager.setActiveItem(value);
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is
       * providing a valid index and return true.
       */
      /**
       * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is
       * providing a valid index and return true.
       * @param {?} index
       * @return {?}
       */
      MatTabHeader.prototype._isValidIndex = /**
       * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is
       * providing a valid index and return true.
       * @param {?} index
       * @return {?}
       */
          function (index) {
              if (!this._labelWrappers) {
                  return true;
              }
              /** @type {?} */
              var tab = this._labelWrappers ? this._labelWrappers.toArray()[index] : null;
              return !!tab && !tab.disabled;
          };
      /**
       * Sets focus on the HTML element for the label wrapper and scrolls it into the view if
       * scrolling is enabled.
       */
      /**
       * Sets focus on the HTML element for the label wrapper and scrolls it into the view if
       * scrolling is enabled.
       * @param {?} tabIndex
       * @return {?}
       */
      MatTabHeader.prototype._setTabFocus = /**
       * Sets focus on the HTML element for the label wrapper and scrolls it into the view if
       * scrolling is enabled.
       * @param {?} tabIndex
       * @return {?}
       */
          function (tabIndex) {
              if (this._showPaginationControls) {
                  this._scrollToLabel(tabIndex);
              }
              if (this._labelWrappers && this._labelWrappers.length) {
                  this._labelWrappers.toArray()[tabIndex].focus();
                  // Do not let the browser manage scrolling to focus the element, this will be handled
                  // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width
                  // should be the full width minus the offset width.
                  /** @type {?} */
                  var containerEl = this._tabListContainer.nativeElement;
                  /** @type {?} */
                  var dir = this._getLayoutDirection();
                  if (dir == 'ltr') {
                      containerEl.scrollLeft = 0;
                  }
                  else {
                      containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;
                  }
              }
          };
      /** The layout direction of the containing app. */
      /**
       * The layout direction of the containing app.
       * @return {?}
       */
      MatTabHeader.prototype._getLayoutDirection = /**
       * The layout direction of the containing app.
       * @return {?}
       */
          function () {
              return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
          };
      /** Performs the CSS transformation on the tab list that will cause the list to scroll. */
      /**
       * Performs the CSS transformation on the tab list that will cause the list to scroll.
       * @return {?}
       */
      MatTabHeader.prototype._updateTabScrollPosition = /**
       * Performs the CSS transformation on the tab list that will cause the list to scroll.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var scrollDistance = this.scrollDistance;
              /** @type {?} */
              var platform = this._platform;
              /** @type {?} */
              var translateX = this._getLayoutDirection() === 'ltr' ? -scrollDistance : scrollDistance;
              // Don't use `translate3d` here because we don't want to create a new layer. A new layer
              // seems to cause flickering and overflow in Internet Explorer. For example, the ink bar
              // and ripples will exceed the boundaries of the visible tab bar.
              // See: https://github.com/angular/material2/issues/10276
              // We round the `transform` here, because transforms with sub-pixel precision cause some
              // browsers to blur the content of the element.
              this._tabList.nativeElement.style.transform = "translateX(" + Math.round(translateX) + "px)";
              // Setting the `transform` on IE will change the scroll offset of the parent, causing the
              // position to be thrown off in some cases. We have to reset it ourselves to ensure that
              // it doesn't get thrown off. Note that we scope it only to IE and Edge, because messing
              // with the scroll position throws off Chrome 71+ in RTL mode (see #14689).
              // @breaking-change 8.0.0 Remove null check for `platform`.
              if (platform && (platform.TRIDENT || platform.EDGE)) {
                  this._tabListContainer.nativeElement.scrollLeft = 0;
              }
          };
      Object.defineProperty(MatTabHeader.prototype, "scrollDistance", {
          /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */
          get: /**
           * Sets the distance in pixels that the tab header should be transformed in the X-axis.
           * @return {?}
           */ function () { return this._scrollDistance; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._scrollTo(value);
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or
       * the end of the list, respectively). The distance to scroll is computed to be a third of the
       * length of the tab list view window.
       *
       * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
       * should be called sparingly.
       */
      /**
       * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or
       * the end of the list, respectively). The distance to scroll is computed to be a third of the
       * length of the tab list view window.
       *
       * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
       * should be called sparingly.
       * @param {?} direction
       * @return {?}
       */
      MatTabHeader.prototype._scrollHeader = /**
       * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or
       * the end of the list, respectively). The distance to scroll is computed to be a third of the
       * length of the tab list view window.
       *
       * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
       * should be called sparingly.
       * @param {?} direction
       * @return {?}
       */
          function (direction) {
              /** @type {?} */
              var viewLength = this._tabListContainer.nativeElement.offsetWidth;
              // Move the scroll distance one-third the length of the tab list's viewport.
              /** @type {?} */
              var scrollAmount = (direction == 'before' ? -1 : 1) * viewLength / 3;
              return this._scrollTo(this._scrollDistance + scrollAmount);
          };
      /** Handles click events on the pagination arrows. */
      /**
       * Handles click events on the pagination arrows.
       * @param {?} direction
       * @return {?}
       */
      MatTabHeader.prototype._handlePaginatorClick = /**
       * Handles click events on the pagination arrows.
       * @param {?} direction
       * @return {?}
       */
          function (direction) {
              this._stopInterval();
              this._scrollHeader(direction);
          };
      /**
       * Moves the tab list such that the desired tab label (marked by index) is moved into view.
       *
       * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
       * should be called sparingly.
       */
      /**
       * Moves the tab list such that the desired tab label (marked by index) is moved into view.
       *
       * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
       * should be called sparingly.
       * @param {?} labelIndex
       * @return {?}
       */
      MatTabHeader.prototype._scrollToLabel = /**
       * Moves the tab list such that the desired tab label (marked by index) is moved into view.
       *
       * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
       * should be called sparingly.
       * @param {?} labelIndex
       * @return {?}
       */
          function (labelIndex) {
              /** @type {?} */
              var selectedLabel = this._labelWrappers ? this._labelWrappers.toArray()[labelIndex] : null;
              if (!selectedLabel) {
                  return;
              }
              // The view length is the visible width of the tab labels.
              /** @type {?} */
              var viewLength = this._tabListContainer.nativeElement.offsetWidth;
              /** @type {?} */
              var labelBeforePos;
              /** @type {?} */
              var labelAfterPos;
              if (this._getLayoutDirection() == 'ltr') {
                  labelBeforePos = selectedLabel.getOffsetLeft();
                  labelAfterPos = labelBeforePos + selectedLabel.getOffsetWidth();
              }
              else {
                  labelAfterPos = this._tabList.nativeElement.offsetWidth - selectedLabel.getOffsetLeft();
                  labelBeforePos = labelAfterPos - selectedLabel.getOffsetWidth();
              }
              /** @type {?} */
              var beforeVisiblePos = this.scrollDistance;
              /** @type {?} */
              var afterVisiblePos = this.scrollDistance + viewLength;
              if (labelBeforePos < beforeVisiblePos) {
                  // Scroll header to move label to the before direction
                  this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;
              }
              else if (labelAfterPos > afterVisiblePos) {
                  // Scroll header to move label to the after direction
                  this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;
              }
          };
      /**
       * Evaluate whether the pagination controls should be displayed. If the scroll width of the
       * tab list is wider than the size of the header container, then the pagination controls should
       * be shown.
       *
       * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
       * should be called sparingly.
       */
      /**
       * Evaluate whether the pagination controls should be displayed. If the scroll width of the
       * tab list is wider than the size of the header container, then the pagination controls should
       * be shown.
       *
       * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
       * should be called sparingly.
       * @return {?}
       */
      MatTabHeader.prototype._checkPaginationEnabled = /**
       * Evaluate whether the pagination controls should be displayed. If the scroll width of the
       * tab list is wider than the size of the header container, then the pagination controls should
       * be shown.
       *
       * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
       * should be called sparingly.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var isEnabled = this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;
              if (!isEnabled) {
                  this.scrollDistance = 0;
              }
              if (isEnabled !== this._showPaginationControls) {
                  this._changeDetectorRef.markForCheck();
              }
              this._showPaginationControls = isEnabled;
          };
      /**
       * Evaluate whether the before and after controls should be enabled or disabled.
       * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the
       * before button. If the header is at the end of the list (scroll distance is equal to the
       * maximum distance we can scroll), then disable the after button.
       *
       * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
       * should be called sparingly.
       */
      /**
       * Evaluate whether the before and after controls should be enabled or disabled.
       * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the
       * before button. If the header is at the end of the list (scroll distance is equal to the
       * maximum distance we can scroll), then disable the after button.
       *
       * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
       * should be called sparingly.
       * @return {?}
       */
      MatTabHeader.prototype._checkScrollingControls = /**
       * Evaluate whether the before and after controls should be enabled or disabled.
       * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the
       * before button. If the header is at the end of the list (scroll distance is equal to the
       * maximum distance we can scroll), then disable the after button.
       *
       * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
       * should be called sparingly.
       * @return {?}
       */
          function () {
              // Check if the pagination arrows should be activated.
              this._disableScrollBefore = this.scrollDistance == 0;
              this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();
              this._changeDetectorRef.markForCheck();
          };
      /**
       * Determines what is the maximum length in pixels that can be set for the scroll distance. This
       * is equal to the difference in width between the tab list container and tab header container.
       *
       * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
       * should be called sparingly.
       */
      /**
       * Determines what is the maximum length in pixels that can be set for the scroll distance. This
       * is equal to the difference in width between the tab list container and tab header container.
       *
       * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
       * should be called sparingly.
       * @return {?}
       */
      MatTabHeader.prototype._getMaxScrollDistance = /**
       * Determines what is the maximum length in pixels that can be set for the scroll distance. This
       * is equal to the difference in width between the tab list container and tab header container.
       *
       * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
       * should be called sparingly.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var lengthOfTabList = this._tabList.nativeElement.scrollWidth;
              /** @type {?} */
              var viewLength = this._tabListContainer.nativeElement.offsetWidth;
              return (lengthOfTabList - viewLength) || 0;
          };
      /** Tells the ink-bar to align itself to the current label wrapper */
      /**
       * Tells the ink-bar to align itself to the current label wrapper
       * @return {?}
       */
      MatTabHeader.prototype._alignInkBarToSelectedTab = /**
       * Tells the ink-bar to align itself to the current label wrapper
       * @return {?}
       */
          function () {
              /** @type {?} */
              var selectedLabelWrapper = this._labelWrappers && this._labelWrappers.length ?
                  this._labelWrappers.toArray()[this.selectedIndex].elementRef.nativeElement :
                  null;
              this._inkBar.alignToElement(( /** @type {?} */(selectedLabelWrapper)));
          };
      /** Stops the currently-running paginator interval.  */
      /**
       * Stops the currently-running paginator interval.
       * @return {?}
       */
      MatTabHeader.prototype._stopInterval = /**
       * Stops the currently-running paginator interval.
       * @return {?}
       */
          function () {
              this._stopScrolling.next();
          };
      /**
       * Handles the user pressing down on one of the paginators.
       * Starts scrolling the header after a certain amount of time.
       * @param direction In which direction the paginator should be scrolled.
       */
      /**
       * Handles the user pressing down on one of the paginators.
       * Starts scrolling the header after a certain amount of time.
       * @param {?} direction In which direction the paginator should be scrolled.
       * @return {?}
       */
      MatTabHeader.prototype._handlePaginatorPress = /**
       * Handles the user pressing down on one of the paginators.
       * Starts scrolling the header after a certain amount of time.
       * @param {?} direction In which direction the paginator should be scrolled.
       * @return {?}
       */
          function (direction) {
              var _this = this;
              // Avoid overlapping timers.
              this._stopInterval();
              // Start a timer after the delay and keep firing based on the interval.
              rxjs.timer(HEADER_SCROLL_DELAY, HEADER_SCROLL_INTERVAL)
                  // Keep the timer going until something tells it to stop or the component is destroyed.
                  .pipe(operators.takeUntil(rxjs.merge(this._stopScrolling, this._destroyed)))
                  .subscribe(function () {
                  var _a = _this._scrollHeader(direction), maxScrollDistance = _a.maxScrollDistance, distance = _a.distance;
                  // Stop the timer if we've reached the start or the end.
                  if (distance === 0 || distance >= maxScrollDistance) {
                      _this._stopInterval();
                  }
              });
          };
      /**
       * Scrolls the header to a given position.
       * @param position Position to which to scroll.
       * @returns Information on the current scroll distance and the maximum.
       */
      /**
       * Scrolls the header to a given position.
       * @private
       * @param {?} position Position to which to scroll.
       * @return {?} Information on the current scroll distance and the maximum.
       */
      MatTabHeader.prototype._scrollTo = /**
       * Scrolls the header to a given position.
       * @private
       * @param {?} position Position to which to scroll.
       * @return {?} Information on the current scroll distance and the maximum.
       */
          function (position) {
              /** @type {?} */
              var maxScrollDistance = this._getMaxScrollDistance();
              this._scrollDistance = Math.max(0, Math.min(maxScrollDistance, position));
              // Mark that the scroll distance has changed so that after the view is checked, the CSS
              // transformation can move the header.
              this._scrollDistanceChanged = true;
              this._checkScrollingControls();
              return { maxScrollDistance: maxScrollDistance, distance: this._scrollDistance };
          };
      MatTabHeader.decorators = [
          { type: core.Component, args: [{ selector: 'mat-tab-header',
                      template: "<div class=\"mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4\" #previousPaginator aria-hidden=\"true\" mat-ripple [matRippleDisabled]=\"_disableScrollBefore || disableRipple\" [class.mat-tab-header-pagination-disabled]=\"_disableScrollBefore\" (click)=\"_handlePaginatorClick('before')\" (mousedown)=\"_handlePaginatorPress('before')\" (touchend)=\"_stopInterval()\"><div class=\"mat-tab-header-pagination-chevron\"></div></div><div class=\"mat-tab-label-container\" #tabListContainer (keydown)=\"_handleKeydown($event)\"><div class=\"mat-tab-list\" #tabList role=\"tablist\" (cdkObserveContent)=\"_onContentChanges()\"><div class=\"mat-tab-labels\"><ng-content></ng-content></div><mat-ink-bar></mat-ink-bar></div></div><div class=\"mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4\" #nextPaginator aria-hidden=\"true\" mat-ripple [matRippleDisabled]=\"_disableScrollAfter || disableRipple\" [class.mat-tab-header-pagination-disabled]=\"_disableScrollAfter\" (mousedown)=\"_handlePaginatorPress('after')\" (click)=\"_handlePaginatorClick('after')\" (touchend)=\"_stopInterval()\"><div class=\"mat-tab-header-pagination-chevron\"></div></div>",
                      styles: [".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-pagination-after,.mat-tab-header-rtl .mat-tab-header-pagination-before{padding-right:4px}.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:'';height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-list{flex-grow:1;position:relative;transition:transform .5s cubic-bezier(.35,0,.25,1)}.mat-tab-labels{display:flex}[mat-align-tabs=center] .mat-tab-labels{justify-content:center}[mat-align-tabs=end] .mat-tab-labels{justify-content:flex-end}"],
                      inputs: ['disableRipple'],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      host: {
                          'class': 'mat-tab-header',
                          '[class.mat-tab-header-pagination-controls-enabled]': '_showPaginationControls',
                          '[class.mat-tab-header-rtl]': "_getLayoutDirection() == 'rtl'",
                      },
                  },] },
      ];
      /** @nocollapse */
      MatTabHeader.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.ChangeDetectorRef },
              { type: ViewportRuler },
              { type: Directionality, decorators: [{ type: core.Optional }] },
              { type: core.NgZone },
              { type: Platform }
          ];
      };
      MatTabHeader.propDecorators = {
          _labelWrappers: [{ type: core.ContentChildren, args: [MatTabLabelWrapper,] }],
          _inkBar: [{ type: core.ViewChild, args: [MatInkBar,] }],
          _tabListContainer: [{ type: core.ViewChild, args: ['tabListContainer',] }],
          _tabList: [{ type: core.ViewChild, args: ['tabList',] }],
          _nextPaginator: [{ type: core.ViewChild, args: ['nextPaginator',] }],
          _previousPaginator: [{ type: core.ViewChild, args: ['previousPaginator',] }],
          selectedIndex: [{ type: core.Input }],
          selectFocusedIndex: [{ type: core.Output }],
          indexFocused: [{ type: core.Output }]
      };
      return MatTabHeader;
  }(_MatTabHeaderMixinBase));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Used to generate unique ID's for each tab component
   * @type {?}
   */
  var nextId$4 = 0;
  /**
   * A simple change event emitted on focus or selection changes.
   */
  var /**
   * A simple change event emitted on focus or selection changes.
   */ MatTabChangeEvent = /** @class */ (function () {
      function MatTabChangeEvent() {
      }
      return MatTabChangeEvent;
  }());
  /**
   * Injection token that can be used to provide the default options the tabs module.
   * @type {?}
   */
  var MAT_TABS_CONFIG = new core.InjectionToken('MAT_TABS_CONFIG');
  // Boilerplate for applying mixins to MatTabGroup.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatTabGroup.
  /**
   * \@docs-private
   */
  MatTabGroupBase = /** @class */ (function () {
      function MatTabGroupBase(_elementRef) {
          this._elementRef = _elementRef;
      }
      return MatTabGroupBase;
  }());
  /** @type {?} */
  var _MatTabGroupMixinBase = mixinColor(mixinDisableRipple(MatTabGroupBase), 'primary');
  /**
   * Material design tab-group component.  Supports basic tab pairs (label + content) and includes
   * animated ink-bar, keyboard navigation, and screen reader.
   * See: https://material.io/design/components/tabs.html
   */
  var MatTabGroup = /** @class */ (function (_super) {
      tslib_1.__extends(MatTabGroup, _super);
      function MatTabGroup(elementRef, _changeDetectorRef, defaultConfig) {
          var _this = _super.call(this, elementRef) || this;
          _this._changeDetectorRef = _changeDetectorRef;
          /**
           * The tab index that should be selected after the content has been checked.
           */
          _this._indexToSelect = 0;
          /**
           * Snapshot of the height of the tab body wrapper before another tab is activated.
           */
          _this._tabBodyWrapperHeight = 0;
          /**
           * Subscription to tabs being added/removed.
           */
          _this._tabsSubscription = rxjs.Subscription.EMPTY;
          /**
           * Subscription to changes in the tab labels.
           */
          _this._tabLabelSubscription = rxjs.Subscription.EMPTY;
          _this._dynamicHeight = false;
          _this._selectedIndex = null;
          /**
           * Position of the tab header.
           */
          _this.headerPosition = 'above';
          /**
           * Output to enable support for two-way binding on `[(selectedIndex)]`
           */
          _this.selectedIndexChange = new core.EventEmitter();
          /**
           * Event emitted when focus has changed within a tab group.
           */
          _this.focusChange = new core.EventEmitter();
          /**
           * Event emitted when the body animation has completed
           */
          _this.animationDone = new core.EventEmitter();
          /**
           * Event emitted when the tab selection has changed.
           */
          _this.selectedTabChange = new core.EventEmitter(true);
          _this._groupId = nextId$4++;
          _this.animationDuration = defaultConfig && defaultConfig.animationDuration ?
              defaultConfig.animationDuration : '500ms';
          return _this;
      }
      Object.defineProperty(MatTabGroup.prototype, "dynamicHeight", {
          /** Whether the tab group should grow to the size of the active tab. */
          get: /**
           * Whether the tab group should grow to the size of the active tab.
           * @return {?}
           */ function () { return this._dynamicHeight; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._dynamicHeight = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatTabGroup.prototype, "selectedIndex", {
          /** The index of the active tab. */
          get: /**
           * The index of the active tab.
           * @return {?}
           */ function () { return this._selectedIndex; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._indexToSelect = coerceNumberProperty(value, null);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatTabGroup.prototype, "animationDuration", {
          /** Duration for the tab animation. Will be normalized to milliseconds if no units are set. */
          get: /**
           * Duration for the tab animation. Will be normalized to milliseconds if no units are set.
           * @return {?}
           */ function () { return this._animationDuration; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._animationDuration = /^\d+$/.test(value) ? value + 'ms' : value;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatTabGroup.prototype, "backgroundColor", {
          /** Background color of the tab group. */
          get: /**
           * Background color of the tab group.
           * @return {?}
           */ function () { return this._backgroundColor; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var nativeElement = this._elementRef.nativeElement;
              nativeElement.classList.remove("mat-background-" + this.backgroundColor);
              if (value) {
                  nativeElement.classList.add("mat-background-" + value);
              }
              this._backgroundColor = value;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * After the content is checked, this component knows what tabs have been defined
       * and what the selected index should be. This is where we can know exactly what position
       * each tab should be in according to the new selected index, and additionally we know how
       * a new selected tab should transition in (from the left or right).
       */
      /**
       * After the content is checked, this component knows what tabs have been defined
       * and what the selected index should be. This is where we can know exactly what position
       * each tab should be in according to the new selected index, and additionally we know how
       * a new selected tab should transition in (from the left or right).
       * @return {?}
       */
      MatTabGroup.prototype.ngAfterContentChecked = /**
       * After the content is checked, this component knows what tabs have been defined
       * and what the selected index should be. This is where we can know exactly what position
       * each tab should be in according to the new selected index, and additionally we know how
       * a new selected tab should transition in (from the left or right).
       * @return {?}
       */
          function () {
              var _this = this;
              // Don't clamp the `indexToSelect` immediately in the setter because it can happen that
              // the amount of tabs changes before the actual change detection runs.
              /** @type {?} */
              var indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);
              // If there is a change in selected index, emit a change event. Should not trigger if
              // the selected index has not yet been initialized.
              if (this._selectedIndex != indexToSelect) {
                  /** @type {?} */
                  var isFirstRun_1 = this._selectedIndex == null;
                  if (!isFirstRun_1) {
                      this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));
                  }
                  // Changing these values after change detection has run
                  // since the checked content may contain references to them.
                  Promise.resolve().then(function () {
                      _this._tabs.forEach(function (tab, index) { return tab.isActive = index === indexToSelect; });
                      if (!isFirstRun_1) {
                          _this.selectedIndexChange.emit(indexToSelect);
                      }
                  });
              }
              // Setup the position for each tab and optionally setup an origin on the next selected tab.
              this._tabs.forEach(function (tab, index) {
                  tab.position = index - indexToSelect;
                  // If there is already a selected tab, then set up an origin for the next selected tab
                  // if it doesn't have one already.
                  if (_this._selectedIndex != null && tab.position == 0 && !tab.origin) {
                      tab.origin = indexToSelect - _this._selectedIndex;
                  }
              });
              if (this._selectedIndex !== indexToSelect) {
                  this._selectedIndex = indexToSelect;
                  this._changeDetectorRef.markForCheck();
              }
          };
      /**
       * @return {?}
       */
      MatTabGroup.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._subscribeToTabLabels();
              // Subscribe to changes in the amount of tabs, in order to be
              // able to re-render the content as new tabs are added or removed.
              this._tabsSubscription = this._tabs.changes.subscribe(function () {
                  /** @type {?} */
                  var indexToSelect = _this._clampTabIndex(_this._indexToSelect);
                  // Maintain the previously-selected tab if a new tab is added or removed and there is no
                  // explicit change that selects a different tab.
                  if (indexToSelect === _this._selectedIndex) {
                      /** @type {?} */
                      var tabs = _this._tabs.toArray();
                      for (var i = 0; i < tabs.length; i++) {
                          if (tabs[i].isActive) {
                              // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed
                              // event, otherwise the consumer may end up in an infinite loop in some edge cases like
                              // adding a tab within the `selectedIndexChange` event.
                              _this._indexToSelect = _this._selectedIndex = i;
                              break;
                          }
                      }
                  }
                  _this._subscribeToTabLabels();
                  _this._changeDetectorRef.markForCheck();
              });
          };
      /**
       * @return {?}
       */
      MatTabGroup.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._tabsSubscription.unsubscribe();
              this._tabLabelSubscription.unsubscribe();
          };
      /** Re-aligns the ink bar to the selected tab element. */
      /**
       * Re-aligns the ink bar to the selected tab element.
       * @return {?}
       */
      MatTabGroup.prototype.realignInkBar = /**
       * Re-aligns the ink bar to the selected tab element.
       * @return {?}
       */
          function () {
              if (this._tabHeader) {
                  this._tabHeader._alignInkBarToSelectedTab();
              }
          };
      /**
       * @param {?} index
       * @return {?}
       */
      MatTabGroup.prototype._focusChanged = /**
       * @param {?} index
       * @return {?}
       */
          function (index) {
              this.focusChange.emit(this._createChangeEvent(index));
          };
      /**
       * @private
       * @param {?} index
       * @return {?}
       */
      MatTabGroup.prototype._createChangeEvent = /**
       * @private
       * @param {?} index
       * @return {?}
       */
          function (index) {
              /** @type {?} */
              var event = new MatTabChangeEvent;
              event.index = index;
              if (this._tabs && this._tabs.length) {
                  event.tab = this._tabs.toArray()[index];
              }
              return event;
          };
      /**
       * Subscribes to changes in the tab labels. This is needed, because the @Input for the label is
       * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the
       * binding to be updated, we need to subscribe to changes in it and trigger change detection
       * manually.
       */
      /**
       * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
       * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the
       * binding to be updated, we need to subscribe to changes in it and trigger change detection
       * manually.
       * @private
       * @return {?}
       */
      MatTabGroup.prototype._subscribeToTabLabels = /**
       * Subscribes to changes in the tab labels. This is needed, because the \@Input for the label is
       * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the
       * binding to be updated, we need to subscribe to changes in it and trigger change detection
       * manually.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._tabLabelSubscription) {
                  this._tabLabelSubscription.unsubscribe();
              }
              this._tabLabelSubscription = rxjs.merge.apply(void 0, this._tabs.map(function (tab) { return tab._stateChanges; })).subscribe(function () { return _this._changeDetectorRef.markForCheck(); });
          };
      /** Clamps the given index to the bounds of 0 and the tabs length. */
      /**
       * Clamps the given index to the bounds of 0 and the tabs length.
       * @private
       * @param {?} index
       * @return {?}
       */
      MatTabGroup.prototype._clampTabIndex = /**
       * Clamps the given index to the bounds of 0 and the tabs length.
       * @private
       * @param {?} index
       * @return {?}
       */
          function (index) {
              // Note the `|| 0`, which ensures that values like NaN can't get through
              // and which would otherwise throw the component into an infinite loop
              // (since Math.max(NaN, 0) === NaN).
              return Math.min(this._tabs.length - 1, Math.max(index || 0, 0));
          };
      /** Returns a unique id for each tab label element */
      /**
       * Returns a unique id for each tab label element
       * @param {?} i
       * @return {?}
       */
      MatTabGroup.prototype._getTabLabelId = /**
       * Returns a unique id for each tab label element
       * @param {?} i
       * @return {?}
       */
          function (i) {
              return "mat-tab-label-" + this._groupId + "-" + i;
          };
      /** Returns a unique id for each tab content element */
      /**
       * Returns a unique id for each tab content element
       * @param {?} i
       * @return {?}
       */
      MatTabGroup.prototype._getTabContentId = /**
       * Returns a unique id for each tab content element
       * @param {?} i
       * @return {?}
       */
          function (i) {
              return "mat-tab-content-" + this._groupId + "-" + i;
          };
      /**
       * Sets the height of the body wrapper to the height of the activating tab if dynamic
       * height property is true.
       */
      /**
       * Sets the height of the body wrapper to the height of the activating tab if dynamic
       * height property is true.
       * @param {?} tabHeight
       * @return {?}
       */
      MatTabGroup.prototype._setTabBodyWrapperHeight = /**
       * Sets the height of the body wrapper to the height of the activating tab if dynamic
       * height property is true.
       * @param {?} tabHeight
       * @return {?}
       */
          function (tabHeight) {
              if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {
                  return;
              }
              /** @type {?} */
              var wrapper = this._tabBodyWrapper.nativeElement;
              wrapper.style.height = this._tabBodyWrapperHeight + 'px';
              // This conditional forces the browser to paint the height so that
              // the animation to the new height can have an origin.
              if (this._tabBodyWrapper.nativeElement.offsetHeight) {
                  wrapper.style.height = tabHeight + 'px';
              }
          };
      /** Removes the height of the tab body wrapper. */
      /**
       * Removes the height of the tab body wrapper.
       * @return {?}
       */
      MatTabGroup.prototype._removeTabBodyWrapperHeight = /**
       * Removes the height of the tab body wrapper.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var wrapper = this._tabBodyWrapper.nativeElement;
              this._tabBodyWrapperHeight = wrapper.clientHeight;
              wrapper.style.height = '';
              this.animationDone.emit();
          };
      /** Handle click events, setting new selected index if appropriate. */
      /**
       * Handle click events, setting new selected index if appropriate.
       * @param {?} tab
       * @param {?} tabHeader
       * @param {?} index
       * @return {?}
       */
      MatTabGroup.prototype._handleClick = /**
       * Handle click events, setting new selected index if appropriate.
       * @param {?} tab
       * @param {?} tabHeader
       * @param {?} index
       * @return {?}
       */
          function (tab, tabHeader, index) {
              if (!tab.disabled) {
                  this.selectedIndex = tabHeader.focusIndex = index;
              }
          };
      /** Retrieves the tabindex for the tab. */
      /**
       * Retrieves the tabindex for the tab.
       * @param {?} tab
       * @param {?} idx
       * @return {?}
       */
      MatTabGroup.prototype._getTabIndex = /**
       * Retrieves the tabindex for the tab.
       * @param {?} tab
       * @param {?} idx
       * @return {?}
       */
          function (tab, idx) {
              if (tab.disabled) {
                  return null;
              }
              return this.selectedIndex === idx ? 0 : -1;
          };
      MatTabGroup.decorators = [
          { type: core.Component, args: [{ selector: 'mat-tab-group',
                      exportAs: 'matTabGroup',
                      template: "<mat-tab-header #tabHeader [selectedIndex]=\"selectedIndex\" [disableRipple]=\"disableRipple\" (indexFocused)=\"_focusChanged($event)\" (selectFocusedIndex)=\"selectedIndex = $event\"><div class=\"mat-tab-label\" role=\"tab\" matTabLabelWrapper mat-ripple cdkMonitorElementFocus *ngFor=\"let tab of _tabs; let i = index\" [id]=\"_getTabLabelId(i)\" [attr.tabIndex]=\"_getTabIndex(tab, i)\" [attr.aria-posinset]=\"i + 1\" [attr.aria-setsize]=\"_tabs.length\" [attr.aria-controls]=\"_getTabContentId(i)\" [attr.aria-selected]=\"selectedIndex == i\" [attr.aria-label]=\"tab.ariaLabel || null\" [attr.aria-labelledby]=\"(!tab.ariaLabel && tab.ariaLabelledby) ? tab.ariaLabelledby : null\" [class.mat-tab-label-active]=\"selectedIndex == i\" [disabled]=\"tab.disabled\" [matRippleDisabled]=\"tab.disabled || disableRipple\" (click)=\"_handleClick(tab, tabHeader, i)\"><div class=\"mat-tab-label-content\"><ng-template [ngIf]=\"tab.templateLabel\"><ng-template [cdkPortalOutlet]=\"tab.templateLabel\"></ng-template></ng-template><ng-template [ngIf]=\"!tab.templateLabel\">{{tab.textLabel}}</ng-template></div></div></mat-tab-header><div class=\"mat-tab-body-wrapper\" #tabBodyWrapper><mat-tab-body role=\"tabpanel\" *ngFor=\"let tab of _tabs; let i = index\" [id]=\"_getTabContentId(i)\" [attr.aria-labelledby]=\"_getTabLabelId(i)\" [class.mat-tab-body-active]=\"selectedIndex == i\" [content]=\"tab.content\" [position]=\"tab.position\" [origin]=\"tab.origin\" [animationDuration]=\"animationDuration\" (_onCentered)=\"_removeTabBodyWrapperHeight()\" (_onCentering)=\"_setTabBodyWrapperHeight($event)\"></mat-tab-body></div>",
                      styles: [".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:0}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}@media (-ms-high-contrast:active){.mat-tab-label:focus{outline:dotted 2px}}.mat-tab-label.mat-tab-disabled{cursor:default}@media (-ms-high-contrast:active){.mat-tab-label.mat-tab-disabled{opacity:.5}}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media (-ms-high-contrast:active){.mat-tab-label{opacity:1}}@media (max-width:599px){.mat-tab-label{padding:0 12px}}@media (max-width:959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height .5s cubic-bezier(.35,0,.25,1)}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}"],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      inputs: ['color', 'disableRipple'],
                      host: {
                          'class': 'mat-tab-group',
                          '[class.mat-tab-group-dynamic-height]': 'dynamicHeight',
                          '[class.mat-tab-group-inverted-header]': 'headerPosition === "below"',
                      },
                  },] },
      ];
      /** @nocollapse */
      MatTabGroup.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: core.ChangeDetectorRef },
              { type: undefined, decorators: [{ type: core.Inject, args: [MAT_TABS_CONFIG,] }, { type: core.Optional }] }
          ];
      };
      MatTabGroup.propDecorators = {
          _tabs: [{ type: core.ContentChildren, args: [MatTab,] }],
          _tabBodyWrapper: [{ type: core.ViewChild, args: ['tabBodyWrapper',] }],
          _tabHeader: [{ type: core.ViewChild, args: ['tabHeader',] }],
          dynamicHeight: [{ type: core.Input }],
          selectedIndex: [{ type: core.Input }],
          headerPosition: [{ type: core.Input }],
          animationDuration: [{ type: core.Input }],
          backgroundColor: [{ type: core.Input }],
          selectedIndexChange: [{ type: core.Output }],
          focusChange: [{ type: core.Output }],
          animationDone: [{ type: core.Output }],
          selectedTabChange: [{ type: core.Output }]
      };
      return MatTabGroup;
  }(_MatTabGroupMixinBase));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Boilerplate for applying mixins to MatTabNav.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatTabNav.
  /**
   * \@docs-private
   */
  MatTabNavBase = /** @class */ (function () {
      function MatTabNavBase(_elementRef) {
          this._elementRef = _elementRef;
      }
      return MatTabNavBase;
  }());
  /** @type {?} */
  var _MatTabNavMixinBase = mixinDisableRipple(mixinColor(MatTabNavBase, 'primary'));
  /**
   * Navigation component matching the styles of the tab group header.
   * Provides anchored navigation with animated ink bar.
   */
  var MatTabNav = /** @class */ (function (_super) {
      tslib_1.__extends(MatTabNav, _super);
      function MatTabNav(elementRef, _dir, _ngZone, _changeDetectorRef, _viewportRuler) {
          var _this = _super.call(this, elementRef) || this;
          _this._dir = _dir;
          _this._ngZone = _ngZone;
          _this._changeDetectorRef = _changeDetectorRef;
          _this._viewportRuler = _viewportRuler;
          /**
           * Subject that emits when the component has been destroyed.
           */
          _this._onDestroy = new rxjs.Subject();
          return _this;
      }
      Object.defineProperty(MatTabNav.prototype, "backgroundColor", {
          /** Background color of the tab nav. */
          get: /**
           * Background color of the tab nav.
           * @return {?}
           */ function () { return this._backgroundColor; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              /** @type {?} */
              var nativeElement = this._elementRef.nativeElement;
              nativeElement.classList.remove("mat-background-" + this.backgroundColor);
              if (value) {
                  nativeElement.classList.add("mat-background-" + value);
              }
              this._backgroundColor = value;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Notifies the component that the active link has been changed.
       * @breaking-change 8.0.0 `element` parameter to be removed.
       */
      /**
       * Notifies the component that the active link has been changed.
       * \@breaking-change 8.0.0 `element` parameter to be removed.
       * @param {?} element
       * @return {?}
       */
      MatTabNav.prototype.updateActiveLink = /**
       * Notifies the component that the active link has been changed.
       * \@breaking-change 8.0.0 `element` parameter to be removed.
       * @param {?} element
       * @return {?}
       */
          function (element) {
              // Note: keeping the `element` for backwards-compat, but isn't being used for anything.
              // @breaking-change 8.0.0
              this._activeLinkChanged = !!element;
              this._changeDetectorRef.markForCheck();
          };
      /**
       * @return {?}
       */
      MatTabNav.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._ngZone.runOutsideAngular(function () {
                  /** @type {?} */
                  var dirChange = _this._dir ? _this._dir.change : rxjs.of(null);
                  return rxjs.merge(dirChange, _this._viewportRuler.change(10))
                      .pipe(operators.takeUntil(_this._onDestroy))
                      .subscribe(function () { return _this._alignInkBar(); });
              });
          };
      /** Checks if the active link has been changed and, if so, will update the ink bar. */
      /**
       * Checks if the active link has been changed and, if so, will update the ink bar.
       * @return {?}
       */
      MatTabNav.prototype.ngAfterContentChecked = /**
       * Checks if the active link has been changed and, if so, will update the ink bar.
       * @return {?}
       */
          function () {
              if (this._activeLinkChanged) {
                  /** @type {?} */
                  var activeTab = this._tabLinks.find(function (tab) { return tab.active; });
                  this._activeLinkElement = activeTab ? activeTab._elementRef : null;
                  this._alignInkBar();
                  this._activeLinkChanged = false;
              }
          };
      /**
       * @return {?}
       */
      MatTabNav.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._onDestroy.next();
              this._onDestroy.complete();
          };
      /** Aligns the ink bar to the active link. */
      /**
       * Aligns the ink bar to the active link.
       * @return {?}
       */
      MatTabNav.prototype._alignInkBar = /**
       * Aligns the ink bar to the active link.
       * @return {?}
       */
          function () {
              if (this._activeLinkElement) {
                  this._inkBar.show();
                  this._inkBar.alignToElement(this._activeLinkElement.nativeElement);
              }
              else {
                  this._inkBar.hide();
              }
          };
      MatTabNav.decorators = [
          { type: core.Component, args: [{ selector: '[mat-tab-nav-bar]',
                      exportAs: 'matTabNavBar, matTabNav',
                      inputs: ['color', 'disableRipple'],
                      template: "<div class=\"mat-tab-links\" (cdkObserveContent)=\"_alignInkBar()\"><ng-content></ng-content><mat-ink-bar></mat-ink-bar></div>",
                      styles: [".mat-tab-nav-bar{overflow:hidden;position:relative;flex-shrink:0}.mat-tab-links{position:relative;display:flex}[mat-align-tabs=center] .mat-tab-links{justify-content:center}[mat-align-tabs=end] .mat-tab-links{justify-content:flex-end}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:0}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}@media (-ms-high-contrast:active){.mat-tab-link:focus{outline:dotted 2px}}.mat-tab-link.mat-tab-disabled{cursor:default}@media (-ms-high-contrast:active){.mat-tab-link.mat-tab-disabled{opacity:.5}}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}@media (-ms-high-contrast:active){.mat-tab-link{opacity:1}}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media (max-width:599px){.mat-tab-link{min-width:72px}}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:.5s cubic-bezier(.35,0,.25,1)}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}@media (-ms-high-contrast:active){.mat-ink-bar{outline:solid 2px;height:0}}"],
                      host: { 'class': 'mat-tab-nav-bar' },
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                  },] },
      ];
      /** @nocollapse */
      MatTabNav.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: Directionality, decorators: [{ type: core.Optional }] },
              { type: core.NgZone },
              { type: core.ChangeDetectorRef },
              { type: ViewportRuler }
          ];
      };
      MatTabNav.propDecorators = {
          _inkBar: [{ type: core.ViewChild, args: [MatInkBar,] }],
          _tabLinks: [{ type: core.ContentChildren, args: [core.forwardRef(function () { return MatTabLink; }), { descendants: true },] }],
          backgroundColor: [{ type: core.Input }]
      };
      return MatTabNav;
  }(_MatTabNavMixinBase));
  // Boilerplate for applying mixins to MatTabLink.
  var 
  // Boilerplate for applying mixins to MatTabLink.
  MatTabLinkBase = /** @class */ (function () {
      function MatTabLinkBase() {
      }
      return MatTabLinkBase;
  }());
  /** @type {?} */
  var _MatTabLinkMixinBase = mixinTabIndex(mixinDisableRipple(mixinDisabled(MatTabLinkBase)));
  /**
   * Link inside of a `mat-tab-nav-bar`.
   */
  var MatTabLink = /** @class */ (function (_super) {
      tslib_1.__extends(MatTabLink, _super);
      function MatTabLink(_tabNavBar, _elementRef, ngZone, platform, globalRippleOptions, tabIndex, _focusMonitor) {
          var _this = _super.call(this) || this;
          _this._tabNavBar = _tabNavBar;
          _this._elementRef = _elementRef;
          _this._focusMonitor = _focusMonitor;
          /**
           * Whether the tab link is active or not.
           */
          _this._isActive = false;
          _this._tabLinkRipple = new RippleRenderer(_this, ngZone, _elementRef, platform);
          _this._tabLinkRipple.setupTriggerEvents(_elementRef.nativeElement);
          _this.rippleConfig = globalRippleOptions || {};
          _this.tabIndex = parseInt(tabIndex) || 0;
          if (_focusMonitor) {
              _focusMonitor.monitor(_elementRef);
          }
          return _this;
      }
      Object.defineProperty(MatTabLink.prototype, "active", {
          /** Whether the link is active. */
          get: /**
           * Whether the link is active.
           * @return {?}
           */ function () { return this._isActive; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              if (value !== this._isActive) {
                  this._isActive = value;
                  this._tabNavBar.updateActiveLink(this._elementRef);
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MatTabLink.prototype, "rippleDisabled", {
          /**
           * Whether ripples are disabled on interaction.
           * @docs-private
           */
          get: /**
           * Whether ripples are disabled on interaction.
           * \@docs-private
           * @return {?}
           */ function () {
              return this.disabled || this.disableRipple || this._tabNavBar.disableRipple ||
                  !!this.rippleConfig.disabled;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MatTabLink.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._tabLinkRipple._removeTriggerEvents();
              if (this._focusMonitor) {
                  this._focusMonitor.stopMonitoring(this._elementRef);
              }
          };
      MatTabLink.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mat-tab-link], [matTabLink]',
                      exportAs: 'matTabLink',
                      inputs: ['disabled', 'disableRipple', 'tabIndex'],
                      host: {
                          'class': 'mat-tab-link',
                          '[attr.aria-current]': 'active',
                          '[attr.aria-disabled]': 'disabled.toString()',
                          '[attr.tabIndex]': 'tabIndex',
                          '[class.mat-tab-disabled]': 'disabled',
                          '[class.mat-tab-label-active]': 'active',
                      }
                  },] },
      ];
      /** @nocollapse */
      MatTabLink.ctorParameters = function () {
          return [
              { type: MatTabNav },
              { type: core.ElementRef },
              { type: core.NgZone },
              { type: Platform },
              { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [MAT_RIPPLE_GLOBAL_OPTIONS,] }] },
              { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] },
              { type: FocusMonitor }
          ];
      };
      MatTabLink.propDecorators = {
          active: [{ type: core.Input }]
      };
      return MatTabLink;
  }(_MatTabLinkMixinBase));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Boilerplate for applying mixins to MatToolbar.
  /**
   * \@docs-private
   */
  var 
  // Boilerplate for applying mixins to MatToolbar.
  /**
   * \@docs-private
   */
  MatToolbarBase = /** @class */ (function () {
      function MatToolbarBase(_elementRef) {
          this._elementRef = _elementRef;
      }
      return MatToolbarBase;
  }());
  /** @type {?} */
  var _MatToolbarMixinBase = mixinColor(MatToolbarBase);
  var MatToolbarRow = /** @class */ (function () {
      function MatToolbarRow() {
      }
      MatToolbarRow.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-toolbar-row',
                      exportAs: 'matToolbarRow',
                      host: { 'class': 'mat-toolbar-row' },
                  },] },
      ];
      return MatToolbarRow;
  }());
  var MatToolbar = /** @class */ (function (_super) {
      tslib_1.__extends(MatToolbar, _super);
      function MatToolbar(elementRef, _platform, document) {
          var _this = _super.call(this, elementRef) || this;
          _this._platform = _platform;
          // TODO: make the document a required param when doing breaking changes.
          _this._document = document;
          return _this;
      }
      /**
       * @return {?}
       */
      MatToolbar.prototype.ngAfterViewInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              if (!core.isDevMode() || !this._platform.isBrowser) {
                  return;
              }
              this._checkToolbarMixedModes();
              this._toolbarRows.changes.subscribe(function () { return _this._checkToolbarMixedModes(); });
          };
      /**
       * Throws an exception when developers are attempting to combine the different toolbar row modes.
       */
      /**
       * Throws an exception when developers are attempting to combine the different toolbar row modes.
       * @private
       * @return {?}
       */
      MatToolbar.prototype._checkToolbarMixedModes = /**
       * Throws an exception when developers are attempting to combine the different toolbar row modes.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              if (!this._toolbarRows.length) {
                  return;
              }
              // Check if there are any other DOM nodes that can display content but aren't inside of
              // a <mat-toolbar-row> element.
              /** @type {?} */
              var isCombinedUsage = Array.from(this._elementRef.nativeElement.childNodes)
                  .filter(function (node) { return !(node.classList && node.classList.contains('mat-toolbar-row')); })
                  .filter(function (node) { return node.nodeType !== (_this._document ? _this._document.COMMENT_NODE : 8); })
                  .some(function (node) { return !!(node.textContent && node.textContent.trim()); });
              if (isCombinedUsage) {
                  throwToolbarMixedModesError();
              }
          };
      MatToolbar.decorators = [
          { type: core.Component, args: [{ selector: 'mat-toolbar',
                      exportAs: 'matToolbar',
                      template: "<ng-content></ng-content><ng-content select=\"mat-toolbar-row\"></ng-content>",
                      styles: ["@media (-ms-high-contrast:active){.mat-toolbar{outline:solid 1px}}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}.mat-toolbar-multiple-rows{min-height:64px}.mat-toolbar-row,.mat-toolbar-single-row{height:64px}@media (max-width:599px){.mat-toolbar-multiple-rows{min-height:56px}.mat-toolbar-row,.mat-toolbar-single-row{height:56px}}"],
                      inputs: ['color'],
                      host: {
                          'class': 'mat-toolbar',
                          '[class.mat-toolbar-multiple-rows]': '_toolbarRows.length > 0',
                          '[class.mat-toolbar-single-row]': '_toolbarRows.length === 0',
                      },
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      encapsulation: core.ViewEncapsulation.None,
                  },] },
      ];
      /** @nocollapse */
      MatToolbar.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: Platform },
              { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
          ];
      };
      MatToolbar.propDecorators = {
          _toolbarRows: [{ type: core.ContentChildren, args: [MatToolbarRow,] }]
      };
      return MatToolbar;
  }(_MatToolbarMixinBase));
  /**
   * Throws an exception when attempting to combine the different toolbar row modes.
   * \@docs-private
   * @return {?}
   */
  function throwToolbarMixedModesError() {
      throw Error('MatToolbar: Attempting to combine different toolbar modes. ' +
          'Either specify multiple `<mat-toolbar-row>` elements explicitly or just place content ' +
          'inside of a `<mat-toolbar>` for a single row.');
  }

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Base tree control. It has basic toggle/expand/collapse operations on a single data node.
   * @abstract
   * @template T
   */
  var /**
   * Base tree control. It has basic toggle/expand/collapse operations on a single data node.
   * @abstract
   * @template T
   */ BaseTreeControl = /** @class */ (function () {
      function BaseTreeControl() {
          /**
           * A selection model with multi-selection to track expansion status.
           */
          this.expansionModel = new SelectionModel(true);
      }
      /** Toggles one single data node's expanded/collapsed state. */
      /**
       * Toggles one single data node's expanded/collapsed state.
       * @param {?} dataNode
       * @return {?}
       */
      BaseTreeControl.prototype.toggle = /**
       * Toggles one single data node's expanded/collapsed state.
       * @param {?} dataNode
       * @return {?}
       */
          function (dataNode) {
              this.expansionModel.toggle(dataNode);
          };
      /** Expands one single data node. */
      /**
       * Expands one single data node.
       * @param {?} dataNode
       * @return {?}
       */
      BaseTreeControl.prototype.expand = /**
       * Expands one single data node.
       * @param {?} dataNode
       * @return {?}
       */
          function (dataNode) {
              this.expansionModel.select(dataNode);
          };
      /** Collapses one single data node. */
      /**
       * Collapses one single data node.
       * @param {?} dataNode
       * @return {?}
       */
      BaseTreeControl.prototype.collapse = /**
       * Collapses one single data node.
       * @param {?} dataNode
       * @return {?}
       */
          function (dataNode) {
              this.expansionModel.deselect(dataNode);
          };
      /** Whether a given data node is expanded or not. Returns true if the data node is expanded. */
      /**
       * Whether a given data node is expanded or not. Returns true if the data node is expanded.
       * @param {?} dataNode
       * @return {?}
       */
      BaseTreeControl.prototype.isExpanded = /**
       * Whether a given data node is expanded or not. Returns true if the data node is expanded.
       * @param {?} dataNode
       * @return {?}
       */
          function (dataNode) {
              return this.expansionModel.isSelected(dataNode);
          };
      /** Toggles a subtree rooted at `node` recursively. */
      /**
       * Toggles a subtree rooted at `node` recursively.
       * @param {?} dataNode
       * @return {?}
       */
      BaseTreeControl.prototype.toggleDescendants = /**
       * Toggles a subtree rooted at `node` recursively.
       * @param {?} dataNode
       * @return {?}
       */
          function (dataNode) {
              this.expansionModel.isSelected(dataNode)
                  ? this.collapseDescendants(dataNode)
                  : this.expandDescendants(dataNode);
          };
      /** Collapse all dataNodes in the tree. */
      /**
       * Collapse all dataNodes in the tree.
       * @return {?}
       */
      BaseTreeControl.prototype.collapseAll = /**
       * Collapse all dataNodes in the tree.
       * @return {?}
       */
          function () {
              this.expansionModel.clear();
          };
      /** Expands a subtree rooted at given data node recursively. */
      /**
       * Expands a subtree rooted at given data node recursively.
       * @param {?} dataNode
       * @return {?}
       */
      BaseTreeControl.prototype.expandDescendants = /**
       * Expands a subtree rooted at given data node recursively.
       * @param {?} dataNode
       * @return {?}
       */
          function (dataNode) {
              var _a;
              /** @type {?} */
              var toBeProcessed = [dataNode];
              toBeProcessed.push.apply(toBeProcessed, this.getDescendants(dataNode));
              (_a = this.expansionModel).select.apply(_a, toBeProcessed);
          };
      /** Collapses a subtree rooted at given data node recursively. */
      /**
       * Collapses a subtree rooted at given data node recursively.
       * @param {?} dataNode
       * @return {?}
       */
      BaseTreeControl.prototype.collapseDescendants = /**
       * Collapses a subtree rooted at given data node recursively.
       * @param {?} dataNode
       * @return {?}
       */
          function (dataNode) {
              var _a;
              /** @type {?} */
              var toBeProcessed = [dataNode];
              toBeProcessed.push.apply(toBeProcessed, this.getDescendants(dataNode));
              (_a = this.expansionModel).deselect.apply(_a, toBeProcessed);
          };
      return BaseTreeControl;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Flat tree control. Able to expand/collapse a subtree recursively for flattened tree.
   * @template T
   */
  var /**
   * Flat tree control. Able to expand/collapse a subtree recursively for flattened tree.
   * @template T
   */ FlatTreeControl = /** @class */ (function (_super) {
      tslib_1.__extends(FlatTreeControl, _super);
      /** Construct with flat tree data node functions getLevel and isExpandable. */
      function FlatTreeControl(getLevel, isExpandable) {
          var _this = _super.call(this) || this;
          _this.getLevel = getLevel;
          _this.isExpandable = isExpandable;
          return _this;
      }
      /**
       * Gets a list of the data node's subtree of descendent data nodes.
       *
       * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes
       * with correct levels.
       */
      /**
       * Gets a list of the data node's subtree of descendent data nodes.
       *
       * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes
       * with correct levels.
       * @param {?} dataNode
       * @return {?}
       */
      FlatTreeControl.prototype.getDescendants = /**
       * Gets a list of the data node's subtree of descendent data nodes.
       *
       * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes
       * with correct levels.
       * @param {?} dataNode
       * @return {?}
       */
          function (dataNode) {
              /** @type {?} */
              var startIndex = this.dataNodes.indexOf(dataNode);
              /** @type {?} */
              var results = [];
              // Goes through flattened tree nodes in the `dataNodes` array, and get all descendants.
              // The level of descendants of a tree node must be greater than the level of the given
              // tree node.
              // If we reach a node whose level is equal to the level of the tree node, we hit a sibling.
              // If we reach a node whose level is greater than the level of the tree node, we hit a
              // sibling of an ancestor.
              for (var i = startIndex + 1; i < this.dataNodes.length && this.getLevel(dataNode) < this.getLevel(this.dataNodes[i]); i++) {
                  results.push(this.dataNodes[i]);
              }
              return results;
          };
      /**
       * Expands all data nodes in the tree.
       *
       * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened
       * data nodes of the tree.
       */
      /**
       * Expands all data nodes in the tree.
       *
       * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened
       * data nodes of the tree.
       * @return {?}
       */
      FlatTreeControl.prototype.expandAll = /**
       * Expands all data nodes in the tree.
       *
       * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened
       * data nodes of the tree.
       * @return {?}
       */
          function () {
              var _a;
              (_a = this.expansionModel).select.apply(_a, this.dataNodes);
          };
      return FlatTreeControl;
  }(BaseTreeControl));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Nested tree control. Able to expand/collapse a subtree recursively for NestedNode type.
   * @template T
   */
  var /**
   * Nested tree control. Able to expand/collapse a subtree recursively for NestedNode type.
   * @template T
   */ NestedTreeControl = /** @class */ (function (_super) {
      tslib_1.__extends(NestedTreeControl, _super);
      /** Construct with nested tree function getChildren. */
      function NestedTreeControl(getChildren) {
          var _this = _super.call(this) || this;
          _this.getChildren = getChildren;
          return _this;
      }
      /**
       * Expands all dataNodes in the tree.
       *
       * To make this working, the `dataNodes` variable of the TreeControl must be set to all root level
       * data nodes of the tree.
       */
      /**
       * Expands all dataNodes in the tree.
       *
       * To make this working, the `dataNodes` variable of the TreeControl must be set to all root level
       * data nodes of the tree.
       * @return {?}
       */
      NestedTreeControl.prototype.expandAll = /**
       * Expands all dataNodes in the tree.
       *
       * To make this working, the `dataNodes` variable of the TreeControl must be set to all root level
       * data nodes of the tree.
       * @return {?}
       */
          function () {
              var _this = this;
              var _a;
              this.expansionModel.clear();
              /** @type {?} */
              var allNodes = this.dataNodes.reduce(function (accumulator, dataNode) {
                  return accumulator.concat(_this.getDescendants(dataNode), [dataNode]);
              }, []);
              (_a = this.expansionModel).select.apply(_a, allNodes);
          };
      /** Gets a list of descendant dataNodes of a subtree rooted at given data node recursively. */
      /**
       * Gets a list of descendant dataNodes of a subtree rooted at given data node recursively.
       * @param {?} dataNode
       * @return {?}
       */
      NestedTreeControl.prototype.getDescendants = /**
       * Gets a list of descendant dataNodes of a subtree rooted at given data node recursively.
       * @param {?} dataNode
       * @return {?}
       */
          function (dataNode) {
              /** @type {?} */
              var descendants = [];
              this._getDescendants(descendants, dataNode);
              // Remove the node itself
              return descendants.splice(1);
          };
      /** A helper function to get descendants recursively. */
      /**
       * A helper function to get descendants recursively.
       * @protected
       * @param {?} descendants
       * @param {?} dataNode
       * @return {?}
       */
      NestedTreeControl.prototype._getDescendants = /**
       * A helper function to get descendants recursively.
       * @protected
       * @param {?} descendants
       * @param {?} dataNode
       * @return {?}
       */
          function (descendants, dataNode) {
              var _this = this;
              descendants.push(dataNode);
              /** @type {?} */
              var childrenNodes = this.getChildren(dataNode);
              if (Array.isArray(childrenNodes)) {
                  childrenNodes.forEach(function (child) { return _this._getDescendants(descendants, child); });
              }
              else if (childrenNodes instanceof rxjs.Observable) {
                  childrenNodes.pipe(operators.take(1), operators.filter(Boolean)).subscribe(function (children) {
                      children.forEach(function (child) { return _this._getDescendants(descendants, child); });
                  });
              }
          };
      return NestedTreeControl;
  }(BaseTreeControl));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Context provided to the tree node component.
   * @template T
   */
  var /**
   * Context provided to the tree node component.
   * @template T
   */ CdkTreeNodeOutletContext = /** @class */ (function () {
      function CdkTreeNodeOutletContext(data) {
          this.$implicit = data;
      }
      return CdkTreeNodeOutletContext;
  }());
  /**
   * Data node definition for the CdkTree.
   * Captures the node's template and a when predicate that describes when this node should be used.
   * @template T
   */
  var CdkTreeNodeDef = /** @class */ (function () {
      /** @docs-private */
      function CdkTreeNodeDef(template) {
          this.template = template;
      }
      CdkTreeNodeDef.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkTreeNodeDef]',
                      inputs: [
                          'when: cdkTreeNodeDefWhen'
                      ],
                  },] },
      ];
      /** @nocollapse */
      CdkTreeNodeDef.ctorParameters = function () {
          return [
              { type: core.TemplateRef }
          ];
      };
      return CdkTreeNodeDef;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Outlet for nested CdkNode. Put `[cdkTreeNodeOutlet]` on a tag to place children dataNodes
   * inside the outlet.
   */
  var CdkTreeNodeOutlet = /** @class */ (function () {
      function CdkTreeNodeOutlet(viewContainer) {
          this.viewContainer = viewContainer;
      }
      CdkTreeNodeOutlet.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkTreeNodeOutlet]'
                  },] },
      ];
      /** @nocollapse */
      CdkTreeNodeOutlet.ctorParameters = function () {
          return [
              { type: core.ViewContainerRef }
          ];
      };
      return CdkTreeNodeOutlet;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Returns an error to be thrown when there is no usable data.
   * \@docs-private
   * @return {?}
   */
  function getTreeNoValidDataSourceError() {
      return Error("A valid data source must be provided.");
  }
  /**
   * Returns an error to be thrown when there are multiple nodes that are missing a when function.
   * \@docs-private
   * @return {?}
   */
  function getTreeMultipleDefaultNodeDefsError() {
      return Error("There can only be one default row without a when predicate function.");
  }
  /**
   * Returns an error to be thrown when there are no matching node defs for a particular set of data.
   * \@docs-private
   * @return {?}
   */
  function getTreeMissingMatchingNodeDefError() {
      return Error("Could not find a matching node definition for the provided node data.");
  }
  /**
   * Returns an error to be thrown when there are tree control.
   * \@docs-private
   * @return {?}
   */
  function getTreeControlMissingError() {
      return Error("Could not find a tree control for the tree.");
  }
  /**
   * Returns an error to be thrown when tree control did not implement functions for flat/nested node.
   * \@docs-private
   * @return {?}
   */
  function getTreeControlFunctionsMissingError() {
      return Error("Could not find functions for nested/flat tree in tree control.");
  }
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * CDK tree component that connects with a data source to retrieve data of type `T` and renders
   * dataNodes with hierarchy. Updates the dataNodes when new data is provided by the data source.
   * @template T
   */
  var CdkTree = /** @class */ (function () {
      function CdkTree(_differs, _changeDetectorRef) {
          this._differs = _differs;
          this._changeDetectorRef = _changeDetectorRef;
          /**
           * Subject that emits when the component has been destroyed.
           */
          this._onDestroy = new rxjs.Subject();
          /**
           * Level of nodes
           */
          this._levels = new Map();
          // TODO(tinayuangao): Setup a listener for scrolling, emit the calculated view to viewChange.
          //     Remove the MAX_VALUE in viewChange
          /**
           * Stream containing the latest information on what rows are being displayed on screen.
           * Can be used by the data source to as a heuristic of what data should be provided.
           */
          this.viewChange = new rxjs.BehaviorSubject({ start: 0, end: Number.MAX_VALUE });
      }
      Object.defineProperty(CdkTree.prototype, "dataSource", {
          /**
           * Provides a stream containing the latest data array to render. Influenced by the tree's
           * stream of view window (what dataNodes are currently on screen).
           * Data source can be an observable of data array, or a data array to render.
           */
          get: /**
           * Provides a stream containing the latest data array to render. Influenced by the tree's
           * stream of view window (what dataNodes are currently on screen).
           * Data source can be an observable of data array, or a data array to render.
           * @return {?}
           */ function () { return this._dataSource; },
          set: /**
           * @param {?} dataSource
           * @return {?}
           */ function (dataSource) {
              if (this._dataSource !== dataSource) {
                  this._switchDataSource(dataSource);
              }
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      CdkTree.prototype.ngOnInit = /**
       * @return {?}
       */
          function () {
              this._dataDiffer = this._differs.find([]).create(this.trackBy);
              if (!this.treeControl) {
                  throw getTreeControlMissingError();
              }
          };
      /**
       * @return {?}
       */
      CdkTree.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._nodeOutlet.viewContainer.clear();
              this._onDestroy.next();
              this._onDestroy.complete();
              if (this._dataSource && typeof (( /** @type {?} */(this._dataSource))).disconnect === 'function') {
                  (( /** @type {?} */(this.dataSource))).disconnect(this);
              }
              if (this._dataSubscription) {
                  this._dataSubscription.unsubscribe();
                  this._dataSubscription = null;
              }
          };
      /**
       * @return {?}
       */
      CdkTree.prototype.ngAfterContentChecked = /**
       * @return {?}
       */
          function () {
              /** @type {?} */
              var defaultNodeDefs = this._nodeDefs.filter(function (def) { return !def.when; });
              if (defaultNodeDefs.length > 1) {
                  throw getTreeMultipleDefaultNodeDefsError();
              }
              this._defaultNodeDef = defaultNodeDefs[0];
              if (this.dataSource && this._nodeDefs && !this._dataSubscription) {
                  this._observeRenderChanges();
              }
          };
      // TODO(tinayuangao): Work on keyboard traversal and actions, make sure it's working for RTL
      //     and nested trees.
      /**
       * Switch to the provided data source by resetting the data and unsubscribing from the current
       * render change subscription if one exists. If the data source is null, interpret this by
       * clearing the node outlet. Otherwise start listening for new data.
       */
      // TODO(tinayuangao): Work on keyboard traversal and actions, make sure it's working for RTL
      //     and nested trees.
      /**
       * Switch to the provided data source by resetting the data and unsubscribing from the current
       * render change subscription if one exists. If the data source is null, interpret this by
       * clearing the node outlet. Otherwise start listening for new data.
       * @private
       * @param {?} dataSource
       * @return {?}
       */
      CdkTree.prototype._switchDataSource =
          // TODO(tinayuangao): Work on keyboard traversal and actions, make sure it's working for RTL
          //     and nested trees.
          /**
           * Switch to the provided data source by resetting the data and unsubscribing from the current
           * render change subscription if one exists. If the data source is null, interpret this by
           * clearing the node outlet. Otherwise start listening for new data.
           * @private
           * @param {?} dataSource
           * @return {?}
           */
          function (dataSource) {
              if (this._dataSource && typeof (( /** @type {?} */(this._dataSource))).disconnect === 'function') {
                  (( /** @type {?} */(this.dataSource))).disconnect(this);
              }
              if (this._dataSubscription) {
                  this._dataSubscription.unsubscribe();
                  this._dataSubscription = null;
              }
              // Remove the all dataNodes if there is now no data source
              if (!dataSource) {
                  this._nodeOutlet.viewContainer.clear();
              }
              this._dataSource = dataSource;
              if (this._nodeDefs) {
                  this._observeRenderChanges();
              }
          };
      /** Set up a subscription for the data provided by the data source. */
      /**
       * Set up a subscription for the data provided by the data source.
       * @private
       * @return {?}
       */
      CdkTree.prototype._observeRenderChanges = /**
       * Set up a subscription for the data provided by the data source.
       * @private
       * @return {?}
       */
          function () {
              var _this = this;
              /** @type {?} */
              var dataStream;
              if (isDataSource(this._dataSource)) {
                  dataStream = this._dataSource.connect(this);
              }
              else if (this._dataSource instanceof rxjs.Observable) {
                  dataStream = this._dataSource;
              }
              else if (Array.isArray(this._dataSource)) {
                  dataStream = rxjs.of(this._dataSource);
              }
              if (dataStream) {
                  this._dataSubscription = dataStream.pipe(operators.takeUntil(this._onDestroy))
                      .subscribe(function (data) { return _this.renderNodeChanges(data); });
              }
              else {
                  throw getTreeNoValidDataSourceError();
              }
          };
      /** Check for changes made in the data and render each change (node added/removed/moved). */
      /**
       * Check for changes made in the data and render each change (node added/removed/moved).
       * @param {?} data
       * @param {?=} dataDiffer
       * @param {?=} viewContainer
       * @param {?=} parentData
       * @return {?}
       */
      CdkTree.prototype.renderNodeChanges = /**
       * Check for changes made in the data and render each change (node added/removed/moved).
       * @param {?} data
       * @param {?=} dataDiffer
       * @param {?=} viewContainer
       * @param {?=} parentData
       * @return {?}
       */
          function (data, dataDiffer, viewContainer, parentData) {
              var _this = this;
              if (dataDiffer === void 0) {
                  dataDiffer = this._dataDiffer;
              }
              if (viewContainer === void 0) {
                  viewContainer = this._nodeOutlet.viewContainer;
              }
              /** @type {?} */
              var changes = dataDiffer.diff(data);
              if (!changes) {
                  return;
              }
              changes.forEachOperation(function (item, adjustedPreviousIndex, currentIndex) {
                  if (item.previousIndex == null) {
                      _this.insertNode(data[( /** @type {?} */(currentIndex))], ( /** @type {?} */(currentIndex)), viewContainer, parentData);
                  }
                  else if (currentIndex == null) {
                      viewContainer.remove(( /** @type {?} */(adjustedPreviousIndex)));
                      _this._levels.delete(item.item);
                  }
                  else {
                      /** @type {?} */
                      var view = viewContainer.get(( /** @type {?} */(adjustedPreviousIndex)));
                      viewContainer.move(( /** @type {?} */(view)), currentIndex);
                  }
              });
              this._changeDetectorRef.detectChanges();
          };
      /**
       * Finds the matching node definition that should be used for this node data. If there is only
       * one node definition, it is returned. Otherwise, find the node definition that has a when
       * predicate that returns true with the data. If none return true, return the default node
       * definition.
       */
      /**
       * Finds the matching node definition that should be used for this node data. If there is only
       * one node definition, it is returned. Otherwise, find the node definition that has a when
       * predicate that returns true with the data. If none return true, return the default node
       * definition.
       * @param {?} data
       * @param {?} i
       * @return {?}
       */
      CdkTree.prototype._getNodeDef = /**
       * Finds the matching node definition that should be used for this node data. If there is only
       * one node definition, it is returned. Otherwise, find the node definition that has a when
       * predicate that returns true with the data. If none return true, return the default node
       * definition.
       * @param {?} data
       * @param {?} i
       * @return {?}
       */
          function (data, i) {
              if (this._nodeDefs.length === 1) {
                  return this._nodeDefs.first;
              }
              /** @type {?} */
              var nodeDef = this._nodeDefs.find(function (def) { return def.when && def.when(i, data); }) || this._defaultNodeDef;
              if (!nodeDef) {
                  throw getTreeMissingMatchingNodeDefError();
              }
              return nodeDef;
          };
      /**
       * Create the embedded view for the data node template and place it in the correct index location
       * within the data node view container.
       */
      /**
       * Create the embedded view for the data node template and place it in the correct index location
       * within the data node view container.
       * @param {?} nodeData
       * @param {?} index
       * @param {?=} viewContainer
       * @param {?=} parentData
       * @return {?}
       */
      CdkTree.prototype.insertNode = /**
       * Create the embedded view for the data node template and place it in the correct index location
       * within the data node view container.
       * @param {?} nodeData
       * @param {?} index
       * @param {?=} viewContainer
       * @param {?=} parentData
       * @return {?}
       */
          function (nodeData, index, viewContainer, parentData) {
              /** @type {?} */
              var node = this._getNodeDef(nodeData, index);
              // Node context that will be provided to created embedded view
              /** @type {?} */
              var context = new CdkTreeNodeOutletContext(nodeData);
              // If the tree is flat tree, then use the `getLevel` function in flat tree control
              // Otherwise, use the level of parent node.
              if (this.treeControl.getLevel) {
                  context.level = this.treeControl.getLevel(nodeData);
              }
              else if (typeof parentData !== 'undefined' && this._levels.has(parentData)) {
                  context.level = ( /** @type {?} */(this._levels.get(parentData))) + 1;
              }
              else {
                  context.level = 0;
              }
              this._levels.set(nodeData, context.level);
              // Use default tree nodeOutlet, or nested node's nodeOutlet
              /** @type {?} */
              var container = viewContainer ? viewContainer : this._nodeOutlet.viewContainer;
              container.createEmbeddedView(node.template, context, index);
              // Set the data to just created `CdkTreeNode`.
              // The `CdkTreeNode` created from `createEmbeddedView` will be saved in static variable
              //     `mostRecentTreeNode`. We get it from static variable and pass the node data to it.
              if (CdkTreeNode.mostRecentTreeNode) {
                  CdkTreeNode.mostRecentTreeNode.data = nodeData;
              }
          };
      CdkTree.decorators = [
          { type: core.Component, args: [{ selector: 'cdk-tree',
                      exportAs: 'cdkTree',
                      template: "<ng-container cdkTreeNodeOutlet></ng-container>",
                      host: {
                          'class': 'cdk-tree',
                          'role': 'tree',
                      },
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      /** @nocollapse */
      CdkTree.ctorParameters = function () {
          return [
              { type: core.IterableDiffers },
              { type: core.ChangeDetectorRef }
          ];
      };
      CdkTree.propDecorators = {
          dataSource: [{ type: core.Input }],
          treeControl: [{ type: core.Input }],
          trackBy: [{ type: core.Input }],
          _nodeOutlet: [{ type: core.ViewChild, args: [CdkTreeNodeOutlet,] }],
          _nodeDefs: [{ type: core.ContentChildren, args: [CdkTreeNodeDef,] }]
      };
      return CdkTree;
  }());
  /**
   * Tree node for CdkTree. It contains the data in the tree node.
   * @template T
   */
  var CdkTreeNode = /** @class */ (function () {
      function CdkTreeNode(_elementRef, _tree) {
          this._elementRef = _elementRef;
          this._tree = _tree;
          /**
           * Subject that emits when the component has been destroyed.
           */
          this._destroyed = new rxjs.Subject();
          /**
           * The role of the node should be 'group' if it's an internal node,
           * and 'treeitem' if it's a leaf node.
           */
          this.role = 'treeitem';
          CdkTreeNode.mostRecentTreeNode = ( /** @type {?} */(this));
      }
      Object.defineProperty(CdkTreeNode.prototype, "data", {
          /** The tree node's data. */
          get: /**
           * The tree node's data.
           * @return {?}
           */ function () { return this._data; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._data = value;
              this._setRoleFromData();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkTreeNode.prototype, "isExpanded", {
          get: /**
           * @return {?}
           */ function () {
              return this._tree.treeControl.isExpanded(this._data);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkTreeNode.prototype, "level", {
          get: /**
           * @return {?}
           */ function () {
              return this._tree.treeControl.getLevel ? this._tree.treeControl.getLevel(this._data) : 0;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      CdkTreeNode.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              // If this is the last tree node being destroyed,
              // clear out the reference to avoid leaking memory.
              if (CdkTreeNode.mostRecentTreeNode === this) {
                  CdkTreeNode.mostRecentTreeNode = null;
              }
              this._destroyed.next();
              this._destroyed.complete();
          };
      /** Focuses the menu item. Implements for FocusableOption. */
      /**
       * Focuses the menu item. Implements for FocusableOption.
       * @return {?}
       */
      CdkTreeNode.prototype.focus = /**
       * Focuses the menu item. Implements for FocusableOption.
       * @return {?}
       */
          function () {
              this._elementRef.nativeElement.focus();
          };
      /**
       * @protected
       * @return {?}
       */
      CdkTreeNode.prototype._setRoleFromData = /**
       * @protected
       * @return {?}
       */
          function () {
              var _this = this;
              if (this._tree.treeControl.isExpandable) {
                  this.role = this._tree.treeControl.isExpandable(this._data) ? 'group' : 'treeitem';
              }
              else {
                  if (!this._tree.treeControl.getChildren) {
                      throw getTreeControlFunctionsMissingError();
                  }
                  /** @type {?} */
                  var childrenNodes = this._tree.treeControl.getChildren(this._data);
                  if (Array.isArray(childrenNodes)) {
                      this._setRoleFromChildren(( /** @type {?} */(childrenNodes)));
                  }
                  else if (childrenNodes instanceof rxjs.Observable) {
                      childrenNodes.pipe(operators.takeUntil(this._destroyed))
                          .subscribe(function (children) { return _this._setRoleFromChildren(children); });
                  }
              }
          };
      /**
       * @protected
       * @param {?} children
       * @return {?}
       */
      CdkTreeNode.prototype._setRoleFromChildren = /**
       * @protected
       * @param {?} children
       * @return {?}
       */
          function (children) {
              this.role = children && children.length ? 'group' : 'treeitem';
          };
      /**
       * The most recently created `CdkTreeNode`. We save it in static variable so we can retrieve it
       * in `CdkTree` and set the data to it.
       */
      CdkTreeNode.mostRecentTreeNode = null;
      CdkTreeNode.decorators = [
          { type: core.Directive, args: [{
                      selector: 'cdk-tree-node',
                      exportAs: 'cdkTreeNode',
                      host: {
                          '[attr.aria-expanded]': 'isExpanded',
                          '[attr.aria-level]': 'role === "treeitem" ? level : null',
                          '[attr.role]': 'role',
                          'class': 'cdk-tree-node',
                      },
                  },] },
      ];
      /** @nocollapse */
      CdkTreeNode.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: CdkTree }
          ];
      };
      CdkTreeNode.propDecorators = {
          role: [{ type: core.Input }]
      };
      return CdkTreeNode;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Nested node is a child of `<cdk-tree>`. It works with nested tree.
   * By using `cdk-nested-tree-node` component in tree node template, children of the parent node will
   * be added in the `cdkTreeNodeOutlet` in tree node template.
   * For example:
   *   ```html
   *   <cdk-nested-tree-node>
   *     {{node.name}}
   *     <ng-template cdkTreeNodeOutlet></ng-template>
   *   </cdk-nested-tree-node>
   *   ```
   * The children of node will be automatically added to `cdkTreeNodeOutlet`, the result dom will be
   * like this:
   *   ```html
   *   <cdk-nested-tree-node>
   *     {{node.name}}
   *      <cdk-nested-tree-node>{{child1.name}}</cdk-nested-tree-node>
   *      <cdk-nested-tree-node>{{child2.name}}</cdk-nested-tree-node>
   *   </cdk-nested-tree-node>
   *   ```
   * @template T
   */
  var CdkNestedTreeNode = /** @class */ (function (_super) {
      tslib_1.__extends(CdkNestedTreeNode, _super);
      function CdkNestedTreeNode(_elementRef, _tree, _differs) {
          var _this = _super.call(this, _elementRef, _tree) || this;
          _this._elementRef = _elementRef;
          _this._tree = _tree;
          _this._differs = _differs;
          return _this;
      }
      /**
       * @return {?}
       */
      CdkNestedTreeNode.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              var _this = this;
              this._dataDiffer = this._differs.find([]).create(this._tree.trackBy);
              if (!this._tree.treeControl.getChildren) {
                  throw getTreeControlFunctionsMissingError();
              }
              /** @type {?} */
              var childrenNodes = this._tree.treeControl.getChildren(this.data);
              if (Array.isArray(childrenNodes)) {
                  this.updateChildrenNodes(( /** @type {?} */(childrenNodes)));
              }
              else if (childrenNodes instanceof rxjs.Observable) {
                  childrenNodes.pipe(operators.takeUntil(this._destroyed))
                      .subscribe(function (result) { return _this.updateChildrenNodes(result); });
              }
              this.nodeOutlet.changes.pipe(operators.takeUntil(this._destroyed))
                  .subscribe(function () { return _this.updateChildrenNodes(); });
          };
      /**
       * @return {?}
       */
      CdkNestedTreeNode.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._clear();
              _super.prototype.ngOnDestroy.call(this);
          };
      /** Add children dataNodes to the NodeOutlet */
      /**
       * Add children dataNodes to the NodeOutlet
       * @protected
       * @param {?=} children
       * @return {?}
       */
      CdkNestedTreeNode.prototype.updateChildrenNodes = /**
       * Add children dataNodes to the NodeOutlet
       * @protected
       * @param {?=} children
       * @return {?}
       */
          function (children) {
              if (children) {
                  this._children = children;
              }
              if (this.nodeOutlet.length && this._children) {
                  /** @type {?} */
                  var viewContainer = this.nodeOutlet.first.viewContainer;
                  this._tree.renderNodeChanges(this._children, this._dataDiffer, viewContainer, this._data);
              }
              else {
                  // Reset the data differ if there's no children nodes displayed
                  this._dataDiffer.diff([]);
              }
          };
      /** Clear the children dataNodes. */
      /**
       * Clear the children dataNodes.
       * @protected
       * @return {?}
       */
      CdkNestedTreeNode.prototype._clear = /**
       * Clear the children dataNodes.
       * @protected
       * @return {?}
       */
          function () {
              if (this.nodeOutlet && this.nodeOutlet.first) {
                  this.nodeOutlet.first.viewContainer.clear();
                  this._dataDiffer.diff([]);
              }
          };
      CdkNestedTreeNode.decorators = [
          { type: core.Directive, args: [{
                      selector: 'cdk-nested-tree-node',
                      exportAs: 'cdkNestedTreeNode',
                      host: {
                          '[attr.aria-expanded]': 'isExpanded',
                          '[attr.role]': 'role',
                          'class': 'cdk-tree-node cdk-nested-tree-node',
                      },
                      providers: [{ provide: CdkTreeNode, useExisting: CdkNestedTreeNode }]
                  },] },
      ];
      /** @nocollapse */
      CdkNestedTreeNode.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: CdkTree },
              { type: core.IterableDiffers }
          ];
      };
      CdkNestedTreeNode.propDecorators = {
          nodeOutlet: [{ type: core.ContentChildren, args: [CdkTreeNodeOutlet,] }]
      };
      return CdkNestedTreeNode;
  }(CdkTreeNode));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Regex used to split a string on its CSS units.
   * @type {?}
   */
  var cssUnitPattern = /([A-Za-z%]+)$/;
  /**
   * Indent for the children tree dataNodes.
   * This directive will add left-padding to the node to show hierarchy.
   * @template T
   */
  var CdkTreeNodePadding = /** @class */ (function () {
      function CdkTreeNodePadding(_treeNode, _tree, _renderer, _element, _dir) {
          var _this = this;
          this._treeNode = _treeNode;
          this._tree = _tree;
          this._renderer = _renderer;
          this._element = _element;
          this._dir = _dir;
          /**
           * Subject that emits when the component has been destroyed.
           */
          this._destroyed = new rxjs.Subject();
          /**
           * CSS units used for the indentation value.
           */
          this.indentUnits = 'px';
          this._indent = 40;
          this._setPadding();
          if (_dir) {
              _dir.change.pipe(operators.takeUntil(this._destroyed)).subscribe(function () { return _this._setPadding(); });
          }
      }
      Object.defineProperty(CdkTreeNodePadding.prototype, "level", {
          /** The level of depth of the tree node. The padding will be `level * indent` pixels. */
          get: /**
           * The level of depth of the tree node. The padding will be `level * indent` pixels.
           * @return {?}
           */ function () { return this._level; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._level = coerceNumberProperty(value);
              this._setPadding();
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CdkTreeNodePadding.prototype, "indent", {
          /**
           * The indent for each level. Can be a number or a CSS string.
           * Default number 40px from material design menu sub-menu spec.
           */
          get: /**
           * The indent for each level. Can be a number or a CSS string.
           * Default number 40px from material design menu sub-menu spec.
           * @return {?}
           */ function () { return this._indent; },
          set: /**
           * @param {?} indent
           * @return {?}
           */ function (indent) {
              /** @type {?} */
              var value = indent;
              /** @type {?} */
              var units = 'px';
              if (typeof indent === 'string') {
                  /** @type {?} */
                  var parts = indent.split(cssUnitPattern);
                  value = parts[0];
                  units = parts[1] || units;
              }
              this.indentUnits = units;
              this._indent = coerceNumberProperty(value);
              this._setPadding();
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      CdkTreeNodePadding.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              this._destroyed.next();
              this._destroyed.complete();
          };
      /** The padding indent value for the tree node. Returns a string with px numbers if not null. */
      /**
       * The padding indent value for the tree node. Returns a string with px numbers if not null.
       * @return {?}
       */
      CdkTreeNodePadding.prototype._paddingIndent = /**
       * The padding indent value for the tree node. Returns a string with px numbers if not null.
       * @return {?}
       */
          function () {
              /** @type {?} */
              var nodeLevel = (this._treeNode.data && this._tree.treeControl.getLevel)
                  ? this._tree.treeControl.getLevel(this._treeNode.data)
                  : null;
              /** @type {?} */
              var level = this._level || nodeLevel;
              return level ? "" + level * this._indent + this.indentUnits : null;
          };
      /**
       * @return {?}
       */
      CdkTreeNodePadding.prototype._setPadding = /**
       * @return {?}
       */
          function () {
              /** @type {?} */
              var element = this._element.nativeElement;
              /** @type {?} */
              var padding = this._paddingIndent();
              /** @type {?} */
              var paddingProp = this._dir && this._dir.value === 'rtl' ? 'paddingRight' : 'paddingLeft';
              /** @type {?} */
              var resetProp = paddingProp === 'paddingLeft' ? 'paddingRight' : 'paddingLeft';
              this._renderer.setStyle(element, paddingProp, padding);
              this._renderer.setStyle(element, resetProp, '');
          };
      CdkTreeNodePadding.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkTreeNodePadding]',
                  },] },
      ];
      /** @nocollapse */
      CdkTreeNodePadding.ctorParameters = function () {
          return [
              { type: CdkTreeNode },
              { type: CdkTree },
              { type: core.Renderer2 },
              { type: core.ElementRef },
              { type: Directionality, decorators: [{ type: core.Optional }] }
          ];
      };
      CdkTreeNodePadding.propDecorators = {
          level: [{ type: core.Input, args: ['cdkTreeNodePadding',] }],
          indent: [{ type: core.Input, args: ['cdkTreeNodePaddingIndent',] }]
      };
      return CdkTreeNodePadding;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Node toggle to expand/collapse the node.
   * @template T
   */
  var CdkTreeNodeToggle = /** @class */ (function () {
      function CdkTreeNodeToggle(_tree, _treeNode) {
          this._tree = _tree;
          this._treeNode = _treeNode;
          this._recursive = false;
      }
      Object.defineProperty(CdkTreeNodeToggle.prototype, "recursive", {
          /** Whether expand/collapse the node recursively. */
          get: /**
           * Whether expand/collapse the node recursively.
           * @return {?}
           */ function () { return this._recursive; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._recursive = coerceBooleanProperty(value); },
          enumerable: true,
          configurable: true
      });
      /**
       * @param {?} event
       * @return {?}
       */
      CdkTreeNodeToggle.prototype._toggle = /**
       * @param {?} event
       * @return {?}
       */
          function (event) {
              this.recursive
                  ? this._tree.treeControl.toggleDescendants(this._treeNode.data)
                  : this._tree.treeControl.toggle(this._treeNode.data);
              event.stopPropagation();
          };
      CdkTreeNodeToggle.decorators = [
          { type: core.Directive, args: [{
                      selector: '[cdkTreeNodeToggle]',
                      host: {
                          '(click)': '_toggle($event)',
                      }
                  },] },
      ];
      /** @nocollapse */
      CdkTreeNodeToggle.ctorParameters = function () {
          return [
              { type: CdkTree },
              { type: CdkTreeNode }
          ];
      };
      CdkTreeNodeToggle.propDecorators = {
          recursive: [{ type: core.Input, args: ['cdkTreeNodeToggleRecursive',] }]
      };
      return CdkTreeNodeToggle;
  }());

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Outlet for nested CdkNode. Put `[matTreeNodeOutlet]` on a tag to place children dataNodes
   * inside the outlet.
   */
  var MatTreeNodeOutlet = /** @class */ (function () {
      function MatTreeNodeOutlet(viewContainer) {
          this.viewContainer = viewContainer;
      }
      MatTreeNodeOutlet.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matTreeNodeOutlet]'
                  },] },
      ];
      /** @nocollapse */
      MatTreeNodeOutlet.ctorParameters = function () {
          return [
              { type: core.ViewContainerRef }
          ];
      };
      return MatTreeNodeOutlet;
  }());
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var _MatTreeNodeMixinBase = mixinTabIndex(mixinDisabled(CdkTreeNode));
  /** @type {?} */
  var _MatNestedTreeNodeMixinBase = mixinTabIndex(mixinDisabled(CdkNestedTreeNode));
  /**
   * Wrapper for the CdkTree node with Material design styles.
   * @template T
   */
  var MatTreeNode = /** @class */ (function (_super) {
      tslib_1.__extends(MatTreeNode, _super);
      function MatTreeNode(_elementRef, _tree, tabIndex) {
          var _this = _super.call(this, _elementRef, _tree) || this;
          _this._elementRef = _elementRef;
          _this._tree = _tree;
          _this.role = 'treeitem';
          _this.tabIndex = Number(tabIndex) || 0;
          return _this;
      }
      MatTreeNode.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-tree-node',
                      exportAs: 'matTreeNode',
                      inputs: ['disabled', 'tabIndex'],
                      host: {
                          '[attr.aria-expanded]': 'isExpanded',
                          '[attr.aria-level]': 'role === "treeitem" ? level : null',
                          '[attr.role]': 'role',
                          'class': 'mat-tree-node'
                      },
                      providers: [{ provide: CdkTreeNode, useExisting: MatTreeNode }]
                  },] },
      ];
      /** @nocollapse */
      MatTreeNode.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: CdkTree },
              { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] }
          ];
      };
      MatTreeNode.propDecorators = {
          role: [{ type: core.Input }]
      };
      return MatTreeNode;
  }(_MatTreeNodeMixinBase));
  /**
   * Wrapper for the CdkTree node definition with Material design styles.
   * @template T
   */
  var MatTreeNodeDef = /** @class */ (function (_super) {
      tslib_1.__extends(MatTreeNodeDef, _super);
      function MatTreeNodeDef() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MatTreeNodeDef.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matTreeNodeDef]',
                      inputs: [
                          'when: matTreeNodeDefWhen'
                      ],
                      providers: [{ provide: CdkTreeNodeDef, useExisting: MatTreeNodeDef }]
                  },] },
      ];
      MatTreeNodeDef.propDecorators = {
          data: [{ type: core.Input, args: ['matTreeNode',] }]
      };
      return MatTreeNodeDef;
  }(CdkTreeNodeDef));
  /**
   * Wrapper for the CdkTree nested node with Material design styles.
   * @template T
   */
  var MatNestedTreeNode = /** @class */ (function (_super) {
      tslib_1.__extends(MatNestedTreeNode, _super);
      function MatNestedTreeNode(_elementRef, _tree, _differs, tabIndex) {
          var _this = _super.call(this, _elementRef, _tree, _differs) || this;
          _this._elementRef = _elementRef;
          _this._tree = _tree;
          _this._differs = _differs;
          _this.tabIndex = Number(tabIndex) || 0;
          return _this;
      }
      // This is a workaround for https://github.com/angular/angular/issues/23091
      // In aot mode, the lifecycle hooks from parent class are not called.
      // TODO(tinayuangao): Remove when the angular issue #23091 is fixed
      // This is a workaround for https://github.com/angular/angular/issues/23091
      // In aot mode, the lifecycle hooks from parent class are not called.
      // TODO(tinayuangao): Remove when the angular issue #23091 is fixed
      /**
       * @return {?}
       */
      MatNestedTreeNode.prototype.ngAfterContentInit =
          // This is a workaround for https://github.com/angular/angular/issues/23091
          // In aot mode, the lifecycle hooks from parent class are not called.
          // TODO(tinayuangao): Remove when the angular issue #23091 is fixed
          /**
           * @return {?}
           */
          function () {
              _super.prototype.ngAfterContentInit.call(this);
          };
      /**
       * @return {?}
       */
      MatNestedTreeNode.prototype.ngOnDestroy = /**
       * @return {?}
       */
          function () {
              _super.prototype.ngOnDestroy.call(this);
          };
      MatNestedTreeNode.decorators = [
          { type: core.Directive, args: [{
                      selector: 'mat-nested-tree-node',
                      exportAs: 'matNestedTreeNode',
                      host: {
                          '[attr.aria-expanded]': 'isExpanded',
                          '[attr.role]': 'role',
                          'class': 'mat-nested-tree-node',
                      },
                      inputs: ['disabled', 'tabIndex'],
                      providers: [
                          { provide: CdkNestedTreeNode, useExisting: MatNestedTreeNode },
                          { provide: CdkTreeNode, useExisting: MatNestedTreeNode }
                      ]
                  },] },
      ];
      /** @nocollapse */
      MatNestedTreeNode.ctorParameters = function () {
          return [
              { type: core.ElementRef },
              { type: CdkTree },
              { type: core.IterableDiffers },
              { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] }
          ];
      };
      MatNestedTreeNode.propDecorators = {
          node: [{ type: core.Input, args: ['matNestedTreeNode',] }],
          nodeOutlet: [{ type: core.ContentChildren, args: [MatTreeNodeOutlet,] }]
      };
      return MatNestedTreeNode;
  }(_MatNestedTreeNodeMixinBase));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Wrapper for the CdkTree padding with Material design styles.
   * @template T
   */
  var MatTreeNodePadding = /** @class */ (function (_super) {
      tslib_1.__extends(MatTreeNodePadding, _super);
      function MatTreeNodePadding() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MatTreeNodePadding.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matTreeNodePadding]',
                      providers: [{ provide: CdkTreeNodePadding, useExisting: MatTreeNodePadding }]
                  },] },
      ];
      MatTreeNodePadding.propDecorators = {
          level: [{ type: core.Input, args: ['matTreeNodePadding',] }],
          indent: [{ type: core.Input, args: ['matTreeNodePaddingIndent',] }]
      };
      return MatTreeNodePadding;
  }(CdkTreeNodePadding));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Wrapper for the CdkTable with Material design styles.
   * @template T
   */
  var MatTree = /** @class */ (function (_super) {
      tslib_1.__extends(MatTree, _super);
      function MatTree() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      MatTree.decorators = [
          { type: core.Component, args: [{ selector: 'mat-tree',
                      exportAs: 'matTree',
                      template: "<ng-container matTreeNodeOutlet></ng-container>",
                      host: {
                          'class': 'mat-tree',
                          'role': 'tree',
                      },
                      styles: [".mat-tree{display:block}.mat-tree-node{display:flex;align-items:center;min-height:48px;flex:1;overflow:hidden;word-wrap:break-word}.mat-nested-tree-ndoe{border-bottom-width:0}"],
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      providers: [{ provide: CdkTree, useExisting: MatTree }]
                  },] },
      ];
      MatTree.propDecorators = {
          _nodeOutlet: [{ type: core.ViewChild, args: [MatTreeNodeOutlet,] }]
      };
      return MatTree;
  }(CdkTree));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Wrapper for the CdkTree's toggle with Material design styles.
   * @template T
   */
  var MatTreeNodeToggle = /** @class */ (function (_super) {
      tslib_1.__extends(MatTreeNodeToggle, _super);
      function MatTreeNodeToggle() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.recursive = false;
          return _this;
      }
      MatTreeNodeToggle.decorators = [
          { type: core.Directive, args: [{
                      selector: '[matTreeNodeToggle]',
                      host: {
                          '(click)': '_toggle($event)',
                      },
                      providers: [{ provide: CdkTreeNodeToggle, useExisting: MatTreeNodeToggle }]
                  },] },
      ];
      MatTreeNodeToggle.propDecorators = {
          recursive: [{ type: core.Input, args: ['matTreeNodeToggleRecursive',] }]
      };
      return MatTreeNodeToggle;
  }(CdkTreeNodeToggle));
  /**
   * Data source for flat tree.
   * The data source need to handle expansion/collapsion of the tree node and change the data feed
   * to `MatTree`.
   * The nested tree nodes of type `T` are flattened through `MatTreeFlattener`, and converted
   * to type `F` for `MatTree` to consume.
   * @template T, F
   */
  var /**
   * Data source for flat tree.
   * The data source need to handle expansion/collapsion of the tree node and change the data feed
   * to `MatTree`.
   * The nested tree nodes of type `T` are flattened through `MatTreeFlattener`, and converted
   * to type `F` for `MatTree` to consume.
   * @template T, F
   */ MatTreeFlatDataSource = /** @class */ (function (_super) {
      tslib_1.__extends(MatTreeFlatDataSource, _super);
      function MatTreeFlatDataSource(treeControl, treeFlattener, initialData) {
          if (initialData === void 0) {
              initialData = [];
          }
          var _this = _super.call(this) || this;
          _this.treeControl = treeControl;
          _this.treeFlattener = treeFlattener;
          _this._flattenedData = new rxjs.BehaviorSubject([]);
          _this._expandedData = new rxjs.BehaviorSubject([]);
          _this._data = new rxjs.BehaviorSubject(initialData);
          return _this;
      }
      Object.defineProperty(MatTreeFlatDataSource.prototype, "data", {
          get: /**
           * @return {?}
           */ function () { return this._data.value; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) {
              this._data.next(value);
              this._flattenedData.next(this.treeFlattener.flattenNodes(this.data));
              this.treeControl.dataNodes = this._flattenedData.value;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @param {?} collectionViewer
       * @return {?}
       */
      MatTreeFlatDataSource.prototype.connect = /**
       * @param {?} collectionViewer
       * @return {?}
       */
          function (collectionViewer) {
              var _this = this;
              /** @type {?} */
              var changes = [
                  collectionViewer.viewChange,
                  this.treeControl.expansionModel.onChange,
                  this._flattenedData
              ];
              return rxjs.merge.apply(void 0, changes).pipe(operators.map(function () {
                  _this._expandedData.next(_this.treeFlattener.expandFlattenedNodes(_this._flattenedData.value, _this.treeControl));
                  return _this._expandedData.value;
              }));
          };
      /**
       * @return {?}
       */
      MatTreeFlatDataSource.prototype.disconnect = /**
       * @return {?}
       */
          function () {
              // no op
          };
      return MatTreeFlatDataSource;
  }(DataSource));
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Data source for nested tree.
   *
   * The data source for nested tree doesn't have to consider node flattener, or the way to expand
   * or collapse. The expansion/collapsion will be handled by TreeControl and each non-leaf node.
   * @template T
   */
  var /**
   * Data source for nested tree.
   *
   * The data source for nested tree doesn't have to consider node flattener, or the way to expand
   * or collapse. The expansion/collapsion will be handled by TreeControl and each non-leaf node.
   * @template T
   */ MatTreeNestedDataSource = /** @class */ (function (_super) {
      tslib_1.__extends(MatTreeNestedDataSource, _super);
      function MatTreeNestedDataSource() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this._data = new rxjs.BehaviorSubject([]);
          return _this;
      }
      Object.defineProperty(MatTreeNestedDataSource.prototype, "data", {
          /**
           * Data for the nested tree
           */
          get: /**
           * Data for the nested tree
           * @return {?}
           */ function () { return this._data.value; },
          set: /**
           * @param {?} value
           * @return {?}
           */ function (value) { this._data.next(value); },
          enumerable: true,
          configurable: true
      });
      /**
       * @param {?} collectionViewer
       * @return {?}
       */
      MatTreeNestedDataSource.prototype.connect = /**
       * @param {?} collectionViewer
       * @return {?}
       */
          function (collectionViewer) {
              var _this = this;
              return rxjs.merge.apply(void 0, [collectionViewer.viewChange, this._data]).pipe(operators.map(function () {
                  return _this.data;
              }));
          };
      /**
       * @return {?}
       */
      MatTreeNestedDataSource.prototype.disconnect = /**
       * @return {?}
       */
          function () {
              // no op
          };
      return MatTreeNestedDataSource;
  }(DataSource));

  /**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Current version of Angular Material.
   * @type {?}
   */
  var VERSION = new core.Version('7.3.2');

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var AlertService = /** @class */ (function () {
      function AlertService() {
      }
      /**
       * @param {?} text
       * @return {?}
       */
      AlertService.prototype.showDialog = /**
       * @param {?} text
       * @return {?}
       */
          function (text) {
              alert("Entered text: " + text);
          };
      AlertService.decorators = [
          { type: core.Injectable }
      ];
      return AlertService;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var VersionService = /** @class */ (function () {
      function VersionService() {
          this.called = 0;
          this.lastService = 'none';
      }
      /**
       * @return {?}
       */
      VersionService.prototype.getVersion = /**
       * @return {?}
       */
          function () {
              return '2.1';
          };
      /**
       * @param {?} serviceName
       * @return {?}
       */
      VersionService.prototype.registerService = /**
       * @param {?} serviceName
       * @return {?}
       */
          function (serviceName) {
              this.lastService = serviceName;
              this.called++;
          };
      VersionService.decorators = [
          { type: core.Injectable }
      ];
      return VersionService;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @return {?}
   */
  function _window() {
      return ( /** @type {?} */(window));
  }
  var GlobalComponentService = /** @class */ (function () {
      function GlobalComponentService() {
          _window().AppGlobalComponent = _window().AppGlobalComponent || {};
          console.log(_window().AppGlobalComponent);
      }
      /**
       * @param {?} name
       * @return {?}
       */
      GlobalComponentService.prototype.getComponent = /**
       * @param {?} name
       * @return {?}
       */
          function (name) {
              if (_window().AppGlobalComponent[name]) {
                  return _window().AppGlobalComponent[name];
              }
              return null;
          };
      GlobalComponentService.decorators = [
          { type: core.Injectable }
      ];
      /** @nocollapse */
      GlobalComponentService.ctorParameters = function () { return []; };
      return GlobalComponentService;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @enum {string} */
  var ActionTypes = {
      Increment: '[Counter] Increment',
      Decrement: '[Counter] Decrement',
      Reset: '[Counter] Reset',
  };

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var initialState = 0;
  /**
   * @param {?=} state
   * @param {?=} action
   * @return {?}
   */
  function counterReducer(state, action) {
      if (state === void 0) {
          state = initialState;
      }
      switch (action.type) {
          case ActionTypes.Increment:
              return state + 1;
          case ActionTypes.Decrement:
              return state - 1;
          case ActionTypes.Reset:
              return 0;
          default:
              return state;
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var AppActionsComponent = /** @class */ (function () {
      function AppActionsComponent() {
          this.saved = new core.EventEmitter();
      }
      AppActionsComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'app-actions',
                      template: "<div>\n  <ng-content></ng-content>\n  <div class=\"\">\n    <input class=\"b ph3 pv2 input-reset ba b--black bg-transparent grow pointer f6 dib\"\n      type=\"submit\" value=\"Save\" (click)=\"saved.emit()\">\n  </div>\n</div>\n",
                      styles: [""]
                  }] }
      ];
      AppActionsComponent.propDecorators = {
          saved: [{ type: core.Output }]
      };
      return AppActionsComponent;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var AppFieldComponent = /** @class */ (function () {
      function AppFieldComponent() {
          this.valueChanged = new core.EventEmitter();
      }
      AppFieldComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'app-field',
                      template: "<div class=\"black-80\">\n  <app-label [text]=\"text\" [subText]=\"subText\"></app-label>\n  <ng-content></ng-content>\n</div>\n",
                      styles: [""]
                  }] }
      ];
      AppFieldComponent.propDecorators = {
          text: [{ type: core.Input }],
          subText: [{ type: core.Input }],
          value: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          required: [{ type: core.Input }],
          valueChanged: [{ type: core.Output }]
      };
      return AppFieldComponent;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var AppInputComponent = /** @class */ (function () {
      function AppInputComponent() {
          this.valueChanged = new core.EventEmitter();
      }
      AppInputComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'app-input',
                      template: "<input class=\"input-reset ba b--black-20 pa2 mb2 db w-100\" type=\"text\">\n",
                      styles: [""]
                  }] }
      ];
      AppInputComponent.propDecorators = {
          value: [{ type: core.Input }],
          disabled: [{ type: core.Input }],
          valueChanged: [{ type: core.Output }]
      };
      return AppInputComponent;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var AppLabelComponent = /** @class */ (function () {
      function AppLabelComponent() {
      }
      AppLabelComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'app-label',
                      template: "<div class=\"container\">\n  <label for=\"name\" class=\"f6 b db mb2\">\n    {{text}}\n    <span *ngIf=\"!!subText\" class=\"normal black-60\">({{subText}})</span>:\n  </label>\n</div>\n\n",
                      styles: [""]
                  }] }
      ];
      AppLabelComponent.propDecorators = {
          text: [{ type: core.Input }],
          subText: [{ type: core.Input }]
      };
      return AppLabelComponent;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var AppTableComponent = /** @class */ (function () {
      function AppTableComponent() {
          this.columnDefs = [
              { headerName: 'Make', field: 'make' },
              { headerName: 'Model', field: 'model' },
              { headerName: 'Price', field: 'price' }
          ];
          this.rowData = [
              { make: 'Toyota', model: 'Celica', price: 35000 },
              { make: 'Ford', model: 'Mondeo', price: 32000 },
              { make: 'Porsche', model: 'Boxter', price: 72000 }
          ];
      }
      AppTableComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'app-table',
                      template: "<div class=\"container\">\n  <ag-grid-angular\n      style=\"height: 200px\"\n      class=\"ag-theme-balham\"\n      [rowData]=\"rowData\"\n      [columnDefs]=\"columnDefs\"\n      >\n  </ag-grid-angular>\n</div>\n",
                      styles: [".container{margin-top:20px}"]
                  }] }
      ];
      return AppTableComponent;
  }());

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
  function commonjsRequire() {
      throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
  }
  function createCommonjsModule(fn, module) {
      return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var moment = createCommonjsModule(function (module, exports) {
      (function (global, factory) {
          module.exports = factory();
      }(commonjsGlobal, (function () {
          var hookCallback;
          function hooks() {
              return hookCallback.apply(null, arguments);
          }
          // This is done to register the method called with moment()
          // without creating circular dependencies.
          function setHookCallback(callback) {
              hookCallback = callback;
          }
          function isArray(input) {
              return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
          }
          function isObject(input) {
              // IE8 will treat undefined and null as object if it wasn't for
              // input != null
              return input != null && Object.prototype.toString.call(input) === '[object Object]';
          }
          function isObjectEmpty(obj) {
              if (Object.getOwnPropertyNames) {
                  return (Object.getOwnPropertyNames(obj).length === 0);
              }
              else {
                  var k;
                  for (k in obj) {
                      if (obj.hasOwnProperty(k)) {
                          return false;
                      }
                  }
                  return true;
              }
          }
          function isUndefined(input) {
              return input === void 0;
          }
          function isNumber(input) {
              return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
          }
          function isDate(input) {
              return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
          }
          function map(arr, fn) {
              var res = [], i;
              for (i = 0; i < arr.length; ++i) {
                  res.push(fn(arr[i], i));
              }
              return res;
          }
          function hasOwnProp(a, b) {
              return Object.prototype.hasOwnProperty.call(a, b);
          }
          function extend(a, b) {
              for (var i in b) {
                  if (hasOwnProp(b, i)) {
                      a[i] = b[i];
                  }
              }
              if (hasOwnProp(b, 'toString')) {
                  a.toString = b.toString;
              }
              if (hasOwnProp(b, 'valueOf')) {
                  a.valueOf = b.valueOf;
              }
              return a;
          }
          function createUTC(input, format, locale, strict) {
              return createLocalOrUTC(input, format, locale, strict, true).utc();
          }
          function defaultParsingFlags() {
              // We need to deep clone this object.
              return {
                  empty: false,
                  unusedTokens: [],
                  unusedInput: [],
                  overflow: -2,
                  charsLeftOver: 0,
                  nullInput: false,
                  invalidMonth: null,
                  invalidFormat: false,
                  userInvalidated: false,
                  iso: false,
                  parsedDateParts: [],
                  meridiem: null,
                  rfc2822: false,
                  weekdayMismatch: false
              };
          }
          function getParsingFlags(m) {
              if (m._pf == null) {
                  m._pf = defaultParsingFlags();
              }
              return m._pf;
          }
          var some;
          if (Array.prototype.some) {
              some = Array.prototype.some;
          }
          else {
              some = function (fun) {
                  var t = Object(this);
                  var len = t.length >>> 0;
                  for (var i = 0; i < len; i++) {
                      if (i in t && fun.call(this, t[i], i, t)) {
                          return true;
                      }
                  }
                  return false;
              };
          }
          function isValid(m) {
              if (m._isValid == null) {
                  var flags = getParsingFlags(m);
                  var parsedParts = some.call(flags.parsedDateParts, function (i) {
                      return i != null;
                  });
                  var isNowValid = !isNaN(m._d.getTime()) &&
                      flags.overflow < 0 &&
                      !flags.empty &&
                      !flags.invalidMonth &&
                      !flags.invalidWeekday &&
                      !flags.weekdayMismatch &&
                      !flags.nullInput &&
                      !flags.invalidFormat &&
                      !flags.userInvalidated &&
                      (!flags.meridiem || (flags.meridiem && parsedParts));
                  if (m._strict) {
                      isNowValid = isNowValid &&
                          flags.charsLeftOver === 0 &&
                          flags.unusedTokens.length === 0 &&
                          flags.bigHour === undefined;
                  }
                  if (Object.isFrozen == null || !Object.isFrozen(m)) {
                      m._isValid = isNowValid;
                  }
                  else {
                      return isNowValid;
                  }
              }
              return m._isValid;
          }
          function createInvalid(flags) {
              var m = createUTC(NaN);
              if (flags != null) {
                  extend(getParsingFlags(m), flags);
              }
              else {
                  getParsingFlags(m).userInvalidated = true;
              }
              return m;
          }
          // Plugins that add properties should also add the key here (null value),
          // so we can properly clone ourselves.
          var momentProperties = hooks.momentProperties = [];
          function copyConfig(to, from) {
              var i, prop, val;
              if (!isUndefined(from._isAMomentObject)) {
                  to._isAMomentObject = from._isAMomentObject;
              }
              if (!isUndefined(from._i)) {
                  to._i = from._i;
              }
              if (!isUndefined(from._f)) {
                  to._f = from._f;
              }
              if (!isUndefined(from._l)) {
                  to._l = from._l;
              }
              if (!isUndefined(from._strict)) {
                  to._strict = from._strict;
              }
              if (!isUndefined(from._tzm)) {
                  to._tzm = from._tzm;
              }
              if (!isUndefined(from._isUTC)) {
                  to._isUTC = from._isUTC;
              }
              if (!isUndefined(from._offset)) {
                  to._offset = from._offset;
              }
              if (!isUndefined(from._pf)) {
                  to._pf = getParsingFlags(from);
              }
              if (!isUndefined(from._locale)) {
                  to._locale = from._locale;
              }
              if (momentProperties.length > 0) {
                  for (i = 0; i < momentProperties.length; i++) {
                      prop = momentProperties[i];
                      val = from[prop];
                      if (!isUndefined(val)) {
                          to[prop] = val;
                      }
                  }
              }
              return to;
          }
          var updateInProgress = false;
          // Moment prototype object
          function Moment(config) {
              copyConfig(this, config);
              this._d = new Date(config._d != null ? config._d.getTime() : NaN);
              if (!this.isValid()) {
                  this._d = new Date(NaN);
              }
              // Prevent infinite loop in case updateOffset creates new moment
              // objects.
              if (updateInProgress === false) {
                  updateInProgress = true;
                  hooks.updateOffset(this);
                  updateInProgress = false;
              }
          }
          function isMoment(obj) {
              return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
          }
          function absFloor(number) {
              if (number < 0) {
                  // -0 -> 0
                  return Math.ceil(number) || 0;
              }
              else {
                  return Math.floor(number);
              }
          }
          function toInt(argumentForCoercion) {
              var coercedNumber = +argumentForCoercion, value = 0;
              if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                  value = absFloor(coercedNumber);
              }
              return value;
          }
          // compare two arrays, return the number of differences
          function compareArrays(array1, array2, dontConvert) {
              var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
              for (i = 0; i < len; i++) {
                  if ((dontConvert && array1[i] !== array2[i]) ||
                      (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                      diffs++;
                  }
              }
              return diffs + lengthDiff;
          }
          function warn(msg) {
              if (hooks.suppressDeprecationWarnings === false &&
                  (typeof console !== 'undefined') && console.warn) {
                  console.warn('Deprecation warning: ' + msg);
              }
          }
          function deprecate(msg, fn) {
              var firstTime = true;
              return extend(function () {
                  if (hooks.deprecationHandler != null) {
                      hooks.deprecationHandler(null, msg);
                  }
                  if (firstTime) {
                      var args = [];
                      var arg;
                      for (var i = 0; i < arguments.length; i++) {
                          arg = '';
                          if (typeof arguments[i] === 'object') {
                              arg += '\n[' + i + '] ';
                              for (var key in arguments[0]) {
                                  arg += key + ': ' + arguments[0][key] + ', ';
                              }
                              arg = arg.slice(0, -2); // Remove trailing comma and space
                          }
                          else {
                              arg = arguments[i];
                          }
                          args.push(arg);
                      }
                      warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                      firstTime = false;
                  }
                  return fn.apply(this, arguments);
              }, fn);
          }
          var deprecations = {};
          function deprecateSimple(name, msg) {
              if (hooks.deprecationHandler != null) {
                  hooks.deprecationHandler(name, msg);
              }
              if (!deprecations[name]) {
                  warn(msg);
                  deprecations[name] = true;
              }
          }
          hooks.suppressDeprecationWarnings = false;
          hooks.deprecationHandler = null;
          function isFunction(input) {
              return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
          }
          function set(config) {
              var prop, i;
              for (i in config) {
                  prop = config[i];
                  if (isFunction(prop)) {
                      this[i] = prop;
                  }
                  else {
                      this['_' + i] = prop;
                  }
              }
              this._config = config;
              // Lenient ordinal parsing accepts just a number in addition to
              // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
              // TODO: Remove "ordinalParse" fallback in next major release.
              this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                  '|' + (/\d{1,2}/).source);
          }
          function mergeConfigs(parentConfig, childConfig) {
              var res = extend({}, parentConfig), prop;
              for (prop in childConfig) {
                  if (hasOwnProp(childConfig, prop)) {
                      if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                          res[prop] = {};
                          extend(res[prop], parentConfig[prop]);
                          extend(res[prop], childConfig[prop]);
                      }
                      else if (childConfig[prop] != null) {
                          res[prop] = childConfig[prop];
                      }
                      else {
                          delete res[prop];
                      }
                  }
              }
              for (prop in parentConfig) {
                  if (hasOwnProp(parentConfig, prop) &&
                      !hasOwnProp(childConfig, prop) &&
                      isObject(parentConfig[prop])) {
                      // make sure changes to properties don't modify parent config
                      res[prop] = extend({}, res[prop]);
                  }
              }
              return res;
          }
          function Locale(config) {
              if (config != null) {
                  this.set(config);
              }
          }
          var keys;
          if (Object.keys) {
              keys = Object.keys;
          }
          else {
              keys = function (obj) {
                  var i, res = [];
                  for (i in obj) {
                      if (hasOwnProp(obj, i)) {
                          res.push(i);
                      }
                  }
                  return res;
              };
          }
          var defaultCalendar = {
              sameDay: '[Today at] LT',
              nextDay: '[Tomorrow at] LT',
              nextWeek: 'dddd [at] LT',
              lastDay: '[Yesterday at] LT',
              lastWeek: '[Last] dddd [at] LT',
              sameElse: 'L'
          };
          function calendar(key, mom, now) {
              var output = this._calendar[key] || this._calendar['sameElse'];
              return isFunction(output) ? output.call(mom, now) : output;
          }
          var defaultLongDateFormat = {
              LTS: 'h:mm:ss A',
              LT: 'h:mm A',
              L: 'MM/DD/YYYY',
              LL: 'MMMM D, YYYY',
              LLL: 'MMMM D, YYYY h:mm A',
              LLLL: 'dddd, MMMM D, YYYY h:mm A'
          };
          function longDateFormat(key) {
              var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
              if (format || !formatUpper) {
                  return format;
              }
              this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
                  return val.slice(1);
              });
              return this._longDateFormat[key];
          }
          var defaultInvalidDate = 'Invalid date';
          function invalidDate() {
              return this._invalidDate;
          }
          var defaultOrdinal = '%d';
          var defaultDayOfMonthOrdinalParse = /\d{1,2}/;
          function ordinal(number) {
              return this._ordinal.replace('%d', number);
          }
          var defaultRelativeTime = {
              future: 'in %s',
              past: '%s ago',
              s: 'a few seconds',
              ss: '%d seconds',
              m: 'a minute',
              mm: '%d minutes',
              h: 'an hour',
              hh: '%d hours',
              d: 'a day',
              dd: '%d days',
              M: 'a month',
              MM: '%d months',
              y: 'a year',
              yy: '%d years'
          };
          function relativeTime(number, withoutSuffix, string, isFuture) {
              var output = this._relativeTime[string];
              return (isFunction(output)) ?
                  output(number, withoutSuffix, string, isFuture) :
                  output.replace(/%d/i, number);
          }
          function pastFuture(diff, output) {
              var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
              return isFunction(format) ? format(output) : format.replace(/%s/i, output);
          }
          var aliases = {};
          function addUnitAlias(unit, shorthand) {
              var lowerCase = unit.toLowerCase();
              aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
          }
          function normalizeUnits(units) {
              return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
          }
          function normalizeObjectUnits(inputObject) {
              var normalizedInput = {}, normalizedProp, prop;
              for (prop in inputObject) {
                  if (hasOwnProp(inputObject, prop)) {
                      normalizedProp = normalizeUnits(prop);
                      if (normalizedProp) {
                          normalizedInput[normalizedProp] = inputObject[prop];
                      }
                  }
              }
              return normalizedInput;
          }
          var priorities = {};
          function addUnitPriority(unit, priority) {
              priorities[unit] = priority;
          }
          function getPrioritizedUnits(unitsObj) {
              var units = [];
              for (var u in unitsObj) {
                  units.push({ unit: u, priority: priorities[u] });
              }
              units.sort(function (a, b) {
                  return a.priority - b.priority;
              });
              return units;
          }
          function zeroFill(number, targetLength, forceSign) {
              var absNumber = '' + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign = number >= 0;
              return (sign ? (forceSign ? '+' : '') : '-') +
                  Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
          }
          var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
          var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
          var formatFunctions = {};
          var formatTokenFunctions = {};
          // token:    'M'
          // padded:   ['MM', 2]
          // ordinal:  'Mo'
          // callback: function () { this.month() + 1 }
          function addFormatToken(token, padded, ordinal, callback) {
              var func = callback;
              if (typeof callback === 'string') {
                  func = function () {
                      return this[callback]();
                  };
              }
              if (token) {
                  formatTokenFunctions[token] = func;
              }
              if (padded) {
                  formatTokenFunctions[padded[0]] = function () {
                      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
                  };
              }
              if (ordinal) {
                  formatTokenFunctions[ordinal] = function () {
                      return this.localeData().ordinal(func.apply(this, arguments), token);
                  };
              }
          }
          function removeFormattingTokens(input) {
              if (input.match(/\[[\s\S]/)) {
                  return input.replace(/^\[|\]$/g, '');
              }
              return input.replace(/\\/g, '');
          }
          function makeFormatFunction(format) {
              var array = format.match(formattingTokens), i, length;
              for (i = 0, length = array.length; i < length; i++) {
                  if (formatTokenFunctions[array[i]]) {
                      array[i] = formatTokenFunctions[array[i]];
                  }
                  else {
                      array[i] = removeFormattingTokens(array[i]);
                  }
              }
              return function (mom) {
                  var output = '', i;
                  for (i = 0; i < length; i++) {
                      output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
                  }
                  return output;
              };
          }
          // format date using native date object
          function formatMoment(m, format) {
              if (!m.isValid()) {
                  return m.localeData().invalidDate();
              }
              format = expandFormat(format, m.localeData());
              formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
              return formatFunctions[format](m);
          }
          function expandFormat(format, locale) {
              var i = 5;
              function replaceLongDateFormatTokens(input) {
                  return locale.longDateFormat(input) || input;
              }
              localFormattingTokens.lastIndex = 0;
              while (i >= 0 && localFormattingTokens.test(format)) {
                  format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
                  localFormattingTokens.lastIndex = 0;
                  i -= 1;
              }
              return format;
          }
          var match1 = /\d/; //       0 - 9
          var match2 = /\d\d/; //      00 - 99
          var match3 = /\d{3}/; //     000 - 999
          var match4 = /\d{4}/; //    0000 - 9999
          var match6 = /[+-]?\d{6}/; // -999999 - 999999
          var match1to2 = /\d\d?/; //       0 - 99
          var match3to4 = /\d\d\d\d?/; //     999 - 9999
          var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999
          var match1to3 = /\d{1,3}/; //       0 - 999
          var match1to4 = /\d{1,4}/; //       0 - 9999
          var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999
          var matchUnsigned = /\d+/; //       0 - inf
          var matchSigned = /[+-]?\d+/; //    -inf - inf
          var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
          var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z
          var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
          // any word (or two) characters or numbers including two/three word month in arabic.
          // includes scottish gaelic two word and hyphenated months
          var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
          var regexes = {};
          function addRegexToken(token, regex, strictRegex) {
              regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
                  return (isStrict && strictRegex) ? strictRegex : regex;
              };
          }
          function getParseRegexForToken(token, config) {
              if (!hasOwnProp(regexes, token)) {
                  return new RegExp(unescapeFormat(token));
              }
              return regexes[token](config._strict, config._locale);
          }
          // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
          function unescapeFormat(s) {
              return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
                  return p1 || p2 || p3 || p4;
              }));
          }
          function regexEscape(s) {
              return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
          }
          var tokens = {};
          function addParseToken(token, callback) {
              var i, func = callback;
              if (typeof token === 'string') {
                  token = [token];
              }
              if (isNumber(callback)) {
                  func = function (input, array) {
                      array[callback] = toInt(input);
                  };
              }
              for (i = 0; i < token.length; i++) {
                  tokens[token[i]] = func;
              }
          }
          function addWeekParseToken(token, callback) {
              addParseToken(token, function (input, array, config, token) {
                  config._w = config._w || {};
                  callback(input, config._w, config, token);
              });
          }
          function addTimeToArrayFromToken(token, input, config) {
              if (input != null && hasOwnProp(tokens, token)) {
                  tokens[token](input, config._a, config, token);
              }
          }
          var YEAR = 0;
          var MONTH = 1;
          var DATE = 2;
          var HOUR = 3;
          var MINUTE = 4;
          var SECOND = 5;
          var MILLISECOND = 6;
          var WEEK = 7;
          var WEEKDAY = 8;
          // FORMATTING
          addFormatToken('Y', 0, 0, function () {
              var y = this.year();
              return y <= 9999 ? '' + y : '+' + y;
          });
          addFormatToken(0, ['YY', 2], 0, function () {
              return this.year() % 100;
          });
          addFormatToken(0, ['YYYY', 4], 0, 'year');
          addFormatToken(0, ['YYYYY', 5], 0, 'year');
          addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
          // ALIASES
          addUnitAlias('year', 'y');
          // PRIORITIES
          addUnitPriority('year', 1);
          // PARSING
          addRegexToken('Y', matchSigned);
          addRegexToken('YY', match1to2, match2);
          addRegexToken('YYYY', match1to4, match4);
          addRegexToken('YYYYY', match1to6, match6);
          addRegexToken('YYYYYY', match1to6, match6);
          addParseToken(['YYYYY', 'YYYYYY'], YEAR);
          addParseToken('YYYY', function (input, array) {
              array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
          });
          addParseToken('YY', function (input, array) {
              array[YEAR] = hooks.parseTwoDigitYear(input);
          });
          addParseToken('Y', function (input, array) {
              array[YEAR] = parseInt(input, 10);
          });
          // HELPERS
          function daysInYear(year) {
              return isLeapYear(year) ? 366 : 365;
          }
          function isLeapYear(year) {
              return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
          }
          // HOOKS
          hooks.parseTwoDigitYear = function (input) {
              return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
          };
          // MOMENTS
          var getSetYear = makeGetSet('FullYear', true);
          function getIsLeapYear() {
              return isLeapYear(this.year());
          }
          function makeGetSet(unit, keepTime) {
              return function (value) {
                  if (value != null) {
                      set$1(this, unit, value);
                      hooks.updateOffset(this, keepTime);
                      return this;
                  }
                  else {
                      return get(this, unit);
                  }
              };
          }
          function get(mom, unit) {
              return mom.isValid() ?
                  mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
          }
          function set$1(mom, unit, value) {
              if (mom.isValid() && !isNaN(value)) {
                  if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                      mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
                  }
                  else {
                      mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
                  }
              }
          }
          // MOMENTS
          function stringGet(units) {
              units = normalizeUnits(units);
              if (isFunction(this[units])) {
                  return this[units]();
              }
              return this;
          }
          function stringSet(units, value) {
              if (typeof units === 'object') {
                  units = normalizeObjectUnits(units);
                  var prioritized = getPrioritizedUnits(units);
                  for (var i = 0; i < prioritized.length; i++) {
                      this[prioritized[i].unit](units[prioritized[i].unit]);
                  }
              }
              else {
                  units = normalizeUnits(units);
                  if (isFunction(this[units])) {
                      return this[units](value);
                  }
              }
              return this;
          }
          function mod(n, x) {
              return ((n % x) + x) % x;
          }
          var indexOf;
          if (Array.prototype.indexOf) {
              indexOf = Array.prototype.indexOf;
          }
          else {
              indexOf = function (o) {
                  // I know
                  var i;
                  for (i = 0; i < this.length; ++i) {
                      if (this[i] === o) {
                          return i;
                      }
                  }
                  return -1;
              };
          }
          function daysInMonth(year, month) {
              if (isNaN(year) || isNaN(month)) {
                  return NaN;
              }
              var modMonth = mod(month, 12);
              year += (month - modMonth) / 12;
              return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
          }
          // FORMATTING
          addFormatToken('M', ['MM', 2], 'Mo', function () {
              return this.month() + 1;
          });
          addFormatToken('MMM', 0, 0, function (format) {
              return this.localeData().monthsShort(this, format);
          });
          addFormatToken('MMMM', 0, 0, function (format) {
              return this.localeData().months(this, format);
          });
          // ALIASES
          addUnitAlias('month', 'M');
          // PRIORITY
          addUnitPriority('month', 8);
          // PARSING
          addRegexToken('M', match1to2);
          addRegexToken('MM', match1to2, match2);
          addRegexToken('MMM', function (isStrict, locale) {
              return locale.monthsShortRegex(isStrict);
          });
          addRegexToken('MMMM', function (isStrict, locale) {
              return locale.monthsRegex(isStrict);
          });
          addParseToken(['M', 'MM'], function (input, array) {
              array[MONTH] = toInt(input) - 1;
          });
          addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
              var month = config._locale.monthsParse(input, token, config._strict);
              // if we didn't find a month name, mark the date as invalid.
              if (month != null) {
                  array[MONTH] = month;
              }
              else {
                  getParsingFlags(config).invalidMonth = input;
              }
          });
          // LOCALES
          var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
          var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
          function localeMonths(m, format) {
              if (!m) {
                  return isArray(this._months) ? this._months :
                      this._months['standalone'];
              }
              return isArray(this._months) ? this._months[m.month()] :
                  this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
          }
          var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
          function localeMonthsShort(m, format) {
              if (!m) {
                  return isArray(this._monthsShort) ? this._monthsShort :
                      this._monthsShort['standalone'];
              }
              return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
                  this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
          }
          function handleStrictParse(monthName, format, strict) {
              var i, ii, mom, llc = monthName.toLocaleLowerCase();
              if (!this._monthsParse) {
                  // this is not used
                  this._monthsParse = [];
                  this._longMonthsParse = [];
                  this._shortMonthsParse = [];
                  for (i = 0; i < 12; ++i) {
                      mom = createUTC([2000, i]);
                      this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                      this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
                  }
              }
              if (strict) {
                  if (format === 'MMM') {
                      ii = indexOf.call(this._shortMonthsParse, llc);
                      return ii !== -1 ? ii : null;
                  }
                  else {
                      ii = indexOf.call(this._longMonthsParse, llc);
                      return ii !== -1 ? ii : null;
                  }
              }
              else {
                  if (format === 'MMM') {
                      ii = indexOf.call(this._shortMonthsParse, llc);
                      if (ii !== -1) {
                          return ii;
                      }
                      ii = indexOf.call(this._longMonthsParse, llc);
                      return ii !== -1 ? ii : null;
                  }
                  else {
                      ii = indexOf.call(this._longMonthsParse, llc);
                      if (ii !== -1) {
                          return ii;
                      }
                      ii = indexOf.call(this._shortMonthsParse, llc);
                      return ii !== -1 ? ii : null;
                  }
              }
          }
          function localeMonthsParse(monthName, format, strict) {
              var i, mom, regex;
              if (this._monthsParseExact) {
                  return handleStrictParse.call(this, monthName, format, strict);
              }
              if (!this._monthsParse) {
                  this._monthsParse = [];
                  this._longMonthsParse = [];
                  this._shortMonthsParse = [];
              }
              // TODO: add sorting
              // Sorting makes sure if one month (or abbr) is a prefix of another
              // see sorting in computeMonthsParse
              for (i = 0; i < 12; i++) {
                  // make the regex if we don't have it already
                  mom = createUTC([2000, i]);
                  if (strict && !this._longMonthsParse[i]) {
                      this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                      this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
                  }
                  if (!strict && !this._monthsParse[i]) {
                      regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                      this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                  }
                  // test the regex
                  if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                      return i;
                  }
                  else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                      return i;
                  }
                  else if (!strict && this._monthsParse[i].test(monthName)) {
                      return i;
                  }
              }
          }
          // MOMENTS
          function setMonth(mom, value) {
              var dayOfMonth;
              if (!mom.isValid()) {
                  // No op
                  return mom;
              }
              if (typeof value === 'string') {
                  if (/^\d+$/.test(value)) {
                      value = toInt(value);
                  }
                  else {
                      value = mom.localeData().monthsParse(value);
                      // TODO: Another silent failure?
                      if (!isNumber(value)) {
                          return mom;
                      }
                  }
              }
              dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
              mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
              return mom;
          }
          function getSetMonth(value) {
              if (value != null) {
                  setMonth(this, value);
                  hooks.updateOffset(this, true);
                  return this;
              }
              else {
                  return get(this, 'Month');
              }
          }
          function getDaysInMonth() {
              return daysInMonth(this.year(), this.month());
          }
          var defaultMonthsShortRegex = matchWord;
          function monthsShortRegex(isStrict) {
              if (this._monthsParseExact) {
                  if (!hasOwnProp(this, '_monthsRegex')) {
                      computeMonthsParse.call(this);
                  }
                  if (isStrict) {
                      return this._monthsShortStrictRegex;
                  }
                  else {
                      return this._monthsShortRegex;
                  }
              }
              else {
                  if (!hasOwnProp(this, '_monthsShortRegex')) {
                      this._monthsShortRegex = defaultMonthsShortRegex;
                  }
                  return this._monthsShortStrictRegex && isStrict ?
                      this._monthsShortStrictRegex : this._monthsShortRegex;
              }
          }
          var defaultMonthsRegex = matchWord;
          function monthsRegex(isStrict) {
              if (this._monthsParseExact) {
                  if (!hasOwnProp(this, '_monthsRegex')) {
                      computeMonthsParse.call(this);
                  }
                  if (isStrict) {
                      return this._monthsStrictRegex;
                  }
                  else {
                      return this._monthsRegex;
                  }
              }
              else {
                  if (!hasOwnProp(this, '_monthsRegex')) {
                      this._monthsRegex = defaultMonthsRegex;
                  }
                  return this._monthsStrictRegex && isStrict ?
                      this._monthsStrictRegex : this._monthsRegex;
              }
          }
          function computeMonthsParse() {
              function cmpLenRev(a, b) {
                  return b.length - a.length;
              }
              var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
              for (i = 0; i < 12; i++) {
                  // make the regex if we don't have it already
                  mom = createUTC([2000, i]);
                  shortPieces.push(this.monthsShort(mom, ''));
                  longPieces.push(this.months(mom, ''));
                  mixedPieces.push(this.months(mom, ''));
                  mixedPieces.push(this.monthsShort(mom, ''));
              }
              // Sorting makes sure if one month (or abbr) is a prefix of another it
              // will match the longer piece.
              shortPieces.sort(cmpLenRev);
              longPieces.sort(cmpLenRev);
              mixedPieces.sort(cmpLenRev);
              for (i = 0; i < 12; i++) {
                  shortPieces[i] = regexEscape(shortPieces[i]);
                  longPieces[i] = regexEscape(longPieces[i]);
              }
              for (i = 0; i < 24; i++) {
                  mixedPieces[i] = regexEscape(mixedPieces[i]);
              }
              this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
              this._monthsShortRegex = this._monthsRegex;
              this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
              this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
          }
          function createDate(y, m, d, h, M, s, ms) {
              // can't just apply() to create a date:
              // https://stackoverflow.com/q/181348
              var date;
              // the date constructor remaps years 0-99 to 1900-1999
              if (y < 100 && y >= 0) {
                  // preserve leap years using a full 400 year cycle, then reset
                  date = new Date(y + 400, m, d, h, M, s, ms);
                  if (isFinite(date.getFullYear())) {
                      date.setFullYear(y);
                  }
              }
              else {
                  date = new Date(y, m, d, h, M, s, ms);
              }
              return date;
          }
          function createUTCDate(y) {
              var date;
              // the Date.UTC function remaps years 0-99 to 1900-1999
              if (y < 100 && y >= 0) {
                  var args = Array.prototype.slice.call(arguments);
                  // preserve leap years using a full 400 year cycle, then reset
                  args[0] = y + 400;
                  date = new Date(Date.UTC.apply(null, args));
                  if (isFinite(date.getUTCFullYear())) {
                      date.setUTCFullYear(y);
                  }
              }
              else {
                  date = new Date(Date.UTC.apply(null, arguments));
              }
              return date;
          }
          // start-of-first-week - start-of-year
          function firstWeekOffset(year, dow, doy) {
              var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
              fwd = 7 + dow - doy, 
              // first-week day local weekday -- which local weekday is fwd
              fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
              return -fwdlw + fwd - 1;
          }
          // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
          function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
              var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
              if (dayOfYear <= 0) {
                  resYear = year - 1;
                  resDayOfYear = daysInYear(resYear) + dayOfYear;
              }
              else if (dayOfYear > daysInYear(year)) {
                  resYear = year + 1;
                  resDayOfYear = dayOfYear - daysInYear(year);
              }
              else {
                  resYear = year;
                  resDayOfYear = dayOfYear;
              }
              return {
                  year: resYear,
                  dayOfYear: resDayOfYear
              };
          }
          function weekOfYear(mom, dow, doy) {
              var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
              if (week < 1) {
                  resYear = mom.year() - 1;
                  resWeek = week + weeksInYear(resYear, dow, doy);
              }
              else if (week > weeksInYear(mom.year(), dow, doy)) {
                  resWeek = week - weeksInYear(mom.year(), dow, doy);
                  resYear = mom.year() + 1;
              }
              else {
                  resYear = mom.year();
                  resWeek = week;
              }
              return {
                  week: resWeek,
                  year: resYear
              };
          }
          function weeksInYear(year, dow, doy) {
              var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
              return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
          }
          // FORMATTING
          addFormatToken('w', ['ww', 2], 'wo', 'week');
          addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
          // ALIASES
          addUnitAlias('week', 'w');
          addUnitAlias('isoWeek', 'W');
          // PRIORITIES
          addUnitPriority('week', 5);
          addUnitPriority('isoWeek', 5);
          // PARSING
          addRegexToken('w', match1to2);
          addRegexToken('ww', match1to2, match2);
          addRegexToken('W', match1to2);
          addRegexToken('WW', match1to2, match2);
          addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
              week[token.substr(0, 1)] = toInt(input);
          });
          // HELPERS
          // LOCALES
          function localeWeek(mom) {
              return weekOfYear(mom, this._week.dow, this._week.doy).week;
          }
          var defaultLocaleWeek = {
              dow: 0,
              doy: 6 // The week that contains Jan 6th is the first week of the year.
          };
          function localeFirstDayOfWeek() {
              return this._week.dow;
          }
          function localeFirstDayOfYear() {
              return this._week.doy;
          }
          // MOMENTS
          function getSetWeek(input) {
              var week = this.localeData().week(this);
              return input == null ? week : this.add((input - week) * 7, 'd');
          }
          function getSetISOWeek(input) {
              var week = weekOfYear(this, 1, 4).week;
              return input == null ? week : this.add((input - week) * 7, 'd');
          }
          // FORMATTING
          addFormatToken('d', 0, 'do', 'day');
          addFormatToken('dd', 0, 0, function (format) {
              return this.localeData().weekdaysMin(this, format);
          });
          addFormatToken('ddd', 0, 0, function (format) {
              return this.localeData().weekdaysShort(this, format);
          });
          addFormatToken('dddd', 0, 0, function (format) {
              return this.localeData().weekdays(this, format);
          });
          addFormatToken('e', 0, 0, 'weekday');
          addFormatToken('E', 0, 0, 'isoWeekday');
          // ALIASES
          addUnitAlias('day', 'd');
          addUnitAlias('weekday', 'e');
          addUnitAlias('isoWeekday', 'E');
          // PRIORITY
          addUnitPriority('day', 11);
          addUnitPriority('weekday', 11);
          addUnitPriority('isoWeekday', 11);
          // PARSING
          addRegexToken('d', match1to2);
          addRegexToken('e', match1to2);
          addRegexToken('E', match1to2);
          addRegexToken('dd', function (isStrict, locale) {
              return locale.weekdaysMinRegex(isStrict);
          });
          addRegexToken('ddd', function (isStrict, locale) {
              return locale.weekdaysShortRegex(isStrict);
          });
          addRegexToken('dddd', function (isStrict, locale) {
              return locale.weekdaysRegex(isStrict);
          });
          addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
              var weekday = config._locale.weekdaysParse(input, token, config._strict);
              // if we didn't get a weekday name, mark the date as invalid
              if (weekday != null) {
                  week.d = weekday;
              }
              else {
                  getParsingFlags(config).invalidWeekday = input;
              }
          });
          addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
              week[token] = toInt(input);
          });
          // HELPERS
          function parseWeekday(input, locale) {
              if (typeof input !== 'string') {
                  return input;
              }
              if (!isNaN(input)) {
                  return parseInt(input, 10);
              }
              input = locale.weekdaysParse(input);
              if (typeof input === 'number') {
                  return input;
              }
              return null;
          }
          function parseIsoWeekday(input, locale) {
              if (typeof input === 'string') {
                  return locale.weekdaysParse(input) % 7 || 7;
              }
              return isNaN(input) ? null : input;
          }
          // LOCALES
          function shiftWeekdays(ws, n) {
              return ws.slice(n, 7).concat(ws.slice(0, n));
          }
          var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
          function localeWeekdays(m, format) {
              var weekdays = isArray(this._weekdays) ? this._weekdays :
                  this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
              return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
                  : (m) ? weekdays[m.day()] : weekdays;
          }
          var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
          function localeWeekdaysShort(m) {
              return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
                  : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
          }
          var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
          function localeWeekdaysMin(m) {
              return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
                  : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
          }
          function handleStrictParse$1(weekdayName, format, strict) {
              var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
              if (!this._weekdaysParse) {
                  this._weekdaysParse = [];
                  this._shortWeekdaysParse = [];
                  this._minWeekdaysParse = [];
                  for (i = 0; i < 7; ++i) {
                      mom = createUTC([2000, 1]).day(i);
                      this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                      this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                      this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
                  }
              }
              if (strict) {
                  if (format === 'dddd') {
                      ii = indexOf.call(this._weekdaysParse, llc);
                      return ii !== -1 ? ii : null;
                  }
                  else if (format === 'ddd') {
                      ii = indexOf.call(this._shortWeekdaysParse, llc);
                      return ii !== -1 ? ii : null;
                  }
                  else {
                      ii = indexOf.call(this._minWeekdaysParse, llc);
                      return ii !== -1 ? ii : null;
                  }
              }
              else {
                  if (format === 'dddd') {
                      ii = indexOf.call(this._weekdaysParse, llc);
                      if (ii !== -1) {
                          return ii;
                      }
                      ii = indexOf.call(this._shortWeekdaysParse, llc);
                      if (ii !== -1) {
                          return ii;
                      }
                      ii = indexOf.call(this._minWeekdaysParse, llc);
                      return ii !== -1 ? ii : null;
                  }
                  else if (format === 'ddd') {
                      ii = indexOf.call(this._shortWeekdaysParse, llc);
                      if (ii !== -1) {
                          return ii;
                      }
                      ii = indexOf.call(this._weekdaysParse, llc);
                      if (ii !== -1) {
                          return ii;
                      }
                      ii = indexOf.call(this._minWeekdaysParse, llc);
                      return ii !== -1 ? ii : null;
                  }
                  else {
                      ii = indexOf.call(this._minWeekdaysParse, llc);
                      if (ii !== -1) {
                          return ii;
                      }
                      ii = indexOf.call(this._weekdaysParse, llc);
                      if (ii !== -1) {
                          return ii;
                      }
                      ii = indexOf.call(this._shortWeekdaysParse, llc);
                      return ii !== -1 ? ii : null;
                  }
              }
          }
          function localeWeekdaysParse(weekdayName, format, strict) {
              var i, mom, regex;
              if (this._weekdaysParseExact) {
                  return handleStrictParse$1.call(this, weekdayName, format, strict);
              }
              if (!this._weekdaysParse) {
                  this._weekdaysParse = [];
                  this._minWeekdaysParse = [];
                  this._shortWeekdaysParse = [];
                  this._fullWeekdaysParse = [];
              }
              for (i = 0; i < 7; i++) {
                  // make the regex if we don't have it already
                  mom = createUTC([2000, 1]).day(i);
                  if (strict && !this._fullWeekdaysParse[i]) {
                      this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                      this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                      this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
                  }
                  if (!this._weekdaysParse[i]) {
                      regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                      this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                  }
                  // test the regex
                  if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                      return i;
                  }
                  else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                      return i;
                  }
                  else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                      return i;
                  }
                  else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                      return i;
                  }
              }
          }
          // MOMENTS
          function getSetDayOfWeek(input) {
              if (!this.isValid()) {
                  return input != null ? this : NaN;
              }
              var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
              if (input != null) {
                  input = parseWeekday(input, this.localeData());
                  return this.add(input - day, 'd');
              }
              else {
                  return day;
              }
          }
          function getSetLocaleDayOfWeek(input) {
              if (!this.isValid()) {
                  return input != null ? this : NaN;
              }
              var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
              return input == null ? weekday : this.add(input - weekday, 'd');
          }
          function getSetISODayOfWeek(input) {
              if (!this.isValid()) {
                  return input != null ? this : NaN;
              }
              // behaves the same as moment#day except
              // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
              // as a setter, sunday should belong to the previous week.
              if (input != null) {
                  var weekday = parseIsoWeekday(input, this.localeData());
                  return this.day(this.day() % 7 ? weekday : weekday - 7);
              }
              else {
                  return this.day() || 7;
              }
          }
          var defaultWeekdaysRegex = matchWord;
          function weekdaysRegex(isStrict) {
              if (this._weekdaysParseExact) {
                  if (!hasOwnProp(this, '_weekdaysRegex')) {
                      computeWeekdaysParse.call(this);
                  }
                  if (isStrict) {
                      return this._weekdaysStrictRegex;
                  }
                  else {
                      return this._weekdaysRegex;
                  }
              }
              else {
                  if (!hasOwnProp(this, '_weekdaysRegex')) {
                      this._weekdaysRegex = defaultWeekdaysRegex;
                  }
                  return this._weekdaysStrictRegex && isStrict ?
                      this._weekdaysStrictRegex : this._weekdaysRegex;
              }
          }
          var defaultWeekdaysShortRegex = matchWord;
          function weekdaysShortRegex(isStrict) {
              if (this._weekdaysParseExact) {
                  if (!hasOwnProp(this, '_weekdaysRegex')) {
                      computeWeekdaysParse.call(this);
                  }
                  if (isStrict) {
                      return this._weekdaysShortStrictRegex;
                  }
                  else {
                      return this._weekdaysShortRegex;
                  }
              }
              else {
                  if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
                  }
                  return this._weekdaysShortStrictRegex && isStrict ?
                      this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
              }
          }
          var defaultWeekdaysMinRegex = matchWord;
          function weekdaysMinRegex(isStrict) {
              if (this._weekdaysParseExact) {
                  if (!hasOwnProp(this, '_weekdaysRegex')) {
                      computeWeekdaysParse.call(this);
                  }
                  if (isStrict) {
                      return this._weekdaysMinStrictRegex;
                  }
                  else {
                      return this._weekdaysMinRegex;
                  }
              }
              else {
                  if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
                  }
                  return this._weekdaysMinStrictRegex && isStrict ?
                      this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
              }
          }
          function computeWeekdaysParse() {
              function cmpLenRev(a, b) {
                  return b.length - a.length;
              }
              var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
              for (i = 0; i < 7; i++) {
                  // make the regex if we don't have it already
                  mom = createUTC([2000, 1]).day(i);
                  minp = this.weekdaysMin(mom, '');
                  shortp = this.weekdaysShort(mom, '');
                  longp = this.weekdays(mom, '');
                  minPieces.push(minp);
                  shortPieces.push(shortp);
                  longPieces.push(longp);
                  mixedPieces.push(minp);
                  mixedPieces.push(shortp);
                  mixedPieces.push(longp);
              }
              // Sorting makes sure if one weekday (or abbr) is a prefix of another it
              // will match the longer piece.
              minPieces.sort(cmpLenRev);
              shortPieces.sort(cmpLenRev);
              longPieces.sort(cmpLenRev);
              mixedPieces.sort(cmpLenRev);
              for (i = 0; i < 7; i++) {
                  shortPieces[i] = regexEscape(shortPieces[i]);
                  longPieces[i] = regexEscape(longPieces[i]);
                  mixedPieces[i] = regexEscape(mixedPieces[i]);
              }
              this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
              this._weekdaysShortRegex = this._weekdaysRegex;
              this._weekdaysMinRegex = this._weekdaysRegex;
              this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
              this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
              this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
          }
          // FORMATTING
          function hFormat() {
              return this.hours() % 12 || 12;
          }
          function kFormat() {
              return this.hours() || 24;
          }
          addFormatToken('H', ['HH', 2], 0, 'hour');
          addFormatToken('h', ['hh', 2], 0, hFormat);
          addFormatToken('k', ['kk', 2], 0, kFormat);
          addFormatToken('hmm', 0, 0, function () {
              return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
          });
          addFormatToken('hmmss', 0, 0, function () {
              return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
                  zeroFill(this.seconds(), 2);
          });
          addFormatToken('Hmm', 0, 0, function () {
              return '' + this.hours() + zeroFill(this.minutes(), 2);
          });
          addFormatToken('Hmmss', 0, 0, function () {
              return '' + this.hours() + zeroFill(this.minutes(), 2) +
                  zeroFill(this.seconds(), 2);
          });
          function meridiem(token, lowercase) {
              addFormatToken(token, 0, 0, function () {
                  return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
              });
          }
          meridiem('a', true);
          meridiem('A', false);
          // ALIASES
          addUnitAlias('hour', 'h');
          // PRIORITY
          addUnitPriority('hour', 13);
          // PARSING
          function matchMeridiem(isStrict, locale) {
              return locale._meridiemParse;
          }
          addRegexToken('a', matchMeridiem);
          addRegexToken('A', matchMeridiem);
          addRegexToken('H', match1to2);
          addRegexToken('h', match1to2);
          addRegexToken('k', match1to2);
          addRegexToken('HH', match1to2, match2);
          addRegexToken('hh', match1to2, match2);
          addRegexToken('kk', match1to2, match2);
          addRegexToken('hmm', match3to4);
          addRegexToken('hmmss', match5to6);
          addRegexToken('Hmm', match3to4);
          addRegexToken('Hmmss', match5to6);
          addParseToken(['H', 'HH'], HOUR);
          addParseToken(['k', 'kk'], function (input, array, config) {
              var kInput = toInt(input);
              array[HOUR] = kInput === 24 ? 0 : kInput;
          });
          addParseToken(['a', 'A'], function (input, array, config) {
              config._isPm = config._locale.isPM(input);
              config._meridiem = input;
          });
          addParseToken(['h', 'hh'], function (input, array, config) {
              array[HOUR] = toInt(input);
              getParsingFlags(config).bigHour = true;
          });
          addParseToken('hmm', function (input, array, config) {
              var pos = input.length - 2;
              array[HOUR] = toInt(input.substr(0, pos));
              array[MINUTE] = toInt(input.substr(pos));
              getParsingFlags(config).bigHour = true;
          });
          addParseToken('hmmss', function (input, array, config) {
              var pos1 = input.length - 4;
              var pos2 = input.length - 2;
              array[HOUR] = toInt(input.substr(0, pos1));
              array[MINUTE] = toInt(input.substr(pos1, 2));
              array[SECOND] = toInt(input.substr(pos2));
              getParsingFlags(config).bigHour = true;
          });
          addParseToken('Hmm', function (input, array, config) {
              var pos = input.length - 2;
              array[HOUR] = toInt(input.substr(0, pos));
              array[MINUTE] = toInt(input.substr(pos));
          });
          addParseToken('Hmmss', function (input, array, config) {
              var pos1 = input.length - 4;
              var pos2 = input.length - 2;
              array[HOUR] = toInt(input.substr(0, pos1));
              array[MINUTE] = toInt(input.substr(pos1, 2));
              array[SECOND] = toInt(input.substr(pos2));
          });
          // LOCALES
          function localeIsPM(input) {
              // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
              // Using charAt should be more compatible.
              return ((input + '').toLowerCase().charAt(0) === 'p');
          }
          var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
          function localeMeridiem(hours, minutes, isLower) {
              if (hours > 11) {
                  return isLower ? 'pm' : 'PM';
              }
              else {
                  return isLower ? 'am' : 'AM';
              }
          }
          // MOMENTS
          // Setting the hour should keep the time, because the user explicitly
          // specified which hour they want. So trying to maintain the same hour (in
          // a new timezone) makes sense. Adding/subtracting hours does not follow
          // this rule.
          var getSetHour = makeGetSet('Hours', true);
          var baseConfig = {
              calendar: defaultCalendar,
              longDateFormat: defaultLongDateFormat,
              invalidDate: defaultInvalidDate,
              ordinal: defaultOrdinal,
              dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
              relativeTime: defaultRelativeTime,
              months: defaultLocaleMonths,
              monthsShort: defaultLocaleMonthsShort,
              week: defaultLocaleWeek,
              weekdays: defaultLocaleWeekdays,
              weekdaysMin: defaultLocaleWeekdaysMin,
              weekdaysShort: defaultLocaleWeekdaysShort,
              meridiemParse: defaultLocaleMeridiemParse
          };
          // internal storage for locale config files
          var locales = {};
          var localeFamilies = {};
          var globalLocale;
          function normalizeLocale(key) {
              return key ? key.toLowerCase().replace('_', '-') : key;
          }
          // pick the locale from the array
          // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
          // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
          function chooseLocale(names) {
              var i = 0, j, next, locale, split;
              while (i < names.length) {
                  split = normalizeLocale(names[i]).split('-');
                  j = split.length;
                  next = normalizeLocale(names[i + 1]);
                  next = next ? next.split('-') : null;
                  while (j > 0) {
                      locale = loadLocale(split.slice(0, j).join('-'));
                      if (locale) {
                          return locale;
                      }
                      if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                          //the next array item is better than a shallower substring of this one
                          break;
                      }
                      j--;
                  }
                  i++;
              }
              return globalLocale;
          }
          function loadLocale(name) {
              var oldLocale = null;
              // TODO: Find a better way to register and load all the locales in Node
              if (!locales[name] && ('object' !== 'undefined') &&
                  module && module.exports) {
                  try {
                      oldLocale = globalLocale._abbr;
                      var aliasedRequire = commonjsRequire;
                      aliasedRequire('./locale/' + name);
                      getSetGlobalLocale(oldLocale);
                  }
                  catch (e) { }
              }
              return locales[name];
          }
          // This function will load locale and then set the global locale.  If
          // no arguments are passed in, it will simply return the current global
          // locale key.
          function getSetGlobalLocale(key, values) {
              var data;
              if (key) {
                  if (isUndefined(values)) {
                      data = getLocale(key);
                  }
                  else {
                      data = defineLocale(key, values);
                  }
                  if (data) {
                      // moment.duration._locale = moment._locale = data;
                      globalLocale = data;
                  }
                  else {
                      if ((typeof console !== 'undefined') && console.warn) {
                          //warn user if arguments are passed but the locale could not be set
                          console.warn('Locale ' + key + ' not found. Did you forget to load it?');
                      }
                  }
              }
              return globalLocale._abbr;
          }
          function defineLocale(name, config) {
              if (config !== null) {
                  var locale, parentConfig = baseConfig;
                  config.abbr = name;
                  if (locales[name] != null) {
                      deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' +
                          'an existing locale. moment.defineLocale(localeName, ' +
                          'config) should only be used for creating a new locale ' +
                          'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                      parentConfig = locales[name]._config;
                  }
                  else if (config.parentLocale != null) {
                      if (locales[config.parentLocale] != null) {
                          parentConfig = locales[config.parentLocale]._config;
                      }
                      else {
                          locale = loadLocale(config.parentLocale);
                          if (locale != null) {
                              parentConfig = locale._config;
                          }
                          else {
                              if (!localeFamilies[config.parentLocale]) {
                                  localeFamilies[config.parentLocale] = [];
                              }
                              localeFamilies[config.parentLocale].push({
                                  name: name,
                                  config: config
                              });
                              return null;
                          }
                      }
                  }
                  locales[name] = new Locale(mergeConfigs(parentConfig, config));
                  if (localeFamilies[name]) {
                      localeFamilies[name].forEach(function (x) {
                          defineLocale(x.name, x.config);
                      });
                  }
                  // backwards compat for now: also set the locale
                  // make sure we set the locale AFTER all child locales have been
                  // created, so we won't end up with the child locale set.
                  getSetGlobalLocale(name);
                  return locales[name];
              }
              else {
                  // useful for testing
                  delete locales[name];
                  return null;
              }
          }
          function updateLocale(name, config) {
              if (config != null) {
                  var locale, tmpLocale, parentConfig = baseConfig;
                  // MERGE
                  tmpLocale = loadLocale(name);
                  if (tmpLocale != null) {
                      parentConfig = tmpLocale._config;
                  }
                  config = mergeConfigs(parentConfig, config);
                  locale = new Locale(config);
                  locale.parentLocale = locales[name];
                  locales[name] = locale;
                  // backwards compat for now: also set the locale
                  getSetGlobalLocale(name);
              }
              else {
                  // pass null for config to unupdate, useful for tests
                  if (locales[name] != null) {
                      if (locales[name].parentLocale != null) {
                          locales[name] = locales[name].parentLocale;
                      }
                      else if (locales[name] != null) {
                          delete locales[name];
                      }
                  }
              }
              return locales[name];
          }
          // returns locale data
          function getLocale(key) {
              var locale;
              if (key && key._locale && key._locale._abbr) {
                  key = key._locale._abbr;
              }
              if (!key) {
                  return globalLocale;
              }
              if (!isArray(key)) {
                  //short-circuit everything else
                  locale = loadLocale(key);
                  if (locale) {
                      return locale;
                  }
                  key = [key];
              }
              return chooseLocale(key);
          }
          function listLocales() {
              return keys(locales);
          }
          function checkOverflow(m) {
              var overflow;
              var a = m._a;
              if (a && getParsingFlags(m).overflow === -2) {
                  overflow =
                      a[MONTH] < 0 || a[MONTH] > 11 ? MONTH :
                          a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                              a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                                  a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE :
                                      a[SECOND] < 0 || a[SECOND] > 59 ? SECOND :
                                          a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                                              -1;
                  if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                      overflow = DATE;
                  }
                  if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                      overflow = WEEK;
                  }
                  if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                      overflow = WEEKDAY;
                  }
                  getParsingFlags(m).overflow = overflow;
              }
              return m;
          }
          // Pick the first defined of two or three arguments.
          function defaults(a, b, c) {
              if (a != null) {
                  return a;
              }
              if (b != null) {
                  return b;
              }
              return c;
          }
          function currentDateArray(config) {
              // hooks is actually the exported moment object
              var nowValue = new Date(hooks.now());
              if (config._useUTC) {
                  return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
              }
              return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
          }
          // convert an array to a date.
          // the array should mirror the parameters below
          // note: all values past the year are optional and will default to the lowest possible value.
          // [year, month, day , hour, minute, second, millisecond]
          function configFromArray(config) {
              var i, date, input = [], currentDate, expectedWeekday, yearToUse;
              if (config._d) {
                  return;
              }
              currentDate = currentDateArray(config);
              //compute day of the year from weeks and weekdays
              if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                  dayOfYearFromWeekInfo(config);
              }
              //if the day of the year is set, figure out what it is
              if (config._dayOfYear != null) {
                  yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
                  if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                      getParsingFlags(config)._overflowDayOfYear = true;
                  }
                  date = createUTCDate(yearToUse, 0, config._dayOfYear);
                  config._a[MONTH] = date.getUTCMonth();
                  config._a[DATE] = date.getUTCDate();
              }
              // Default to current date.
              // * if no year, month, day of month are given, default to today
              // * if day of month is given, default month and year
              // * if month is given, default only year
              // * if year is given, don't default anything
              for (i = 0; i < 3 && config._a[i] == null; ++i) {
                  config._a[i] = input[i] = currentDate[i];
              }
              // Zero out whatever was not defaulted, including time
              for (; i < 7; i++) {
                  config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
              }
              // Check for 24:00:00.000
              if (config._a[HOUR] === 24 &&
                  config._a[MINUTE] === 0 &&
                  config._a[SECOND] === 0 &&
                  config._a[MILLISECOND] === 0) {
                  config._nextDay = true;
                  config._a[HOUR] = 0;
              }
              config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
              expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
              // Apply timezone offset from input. The actual utcOffset can be changed
              // with parseZone.
              if (config._tzm != null) {
                  config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
              }
              if (config._nextDay) {
                  config._a[HOUR] = 24;
              }
              // check for mismatching day of week
              if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
                  getParsingFlags(config).weekdayMismatch = true;
              }
          }
          function dayOfYearFromWeekInfo(config) {
              var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
              w = config._w;
              if (w.GG != null || w.W != null || w.E != null) {
                  dow = 1;
                  doy = 4;
                  // TODO: We need to take the current isoWeekYear, but that depends on
                  // how we interpret now (local, utc, fixed offset). So create
                  // a now version of current config (take local/utc/offset flags, and
                  // create now).
                  weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
                  week = defaults(w.W, 1);
                  weekday = defaults(w.E, 1);
                  if (weekday < 1 || weekday > 7) {
                      weekdayOverflow = true;
                  }
              }
              else {
                  dow = config._locale._week.dow;
                  doy = config._locale._week.doy;
                  var curWeek = weekOfYear(createLocal(), dow, doy);
                  weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
                  // Default to current week.
                  week = defaults(w.w, curWeek.week);
                  if (w.d != null) {
                      // weekday -- low day numbers are considered next week
                      weekday = w.d;
                      if (weekday < 0 || weekday > 6) {
                          weekdayOverflow = true;
                      }
                  }
                  else if (w.e != null) {
                      // local weekday -- counting starts from beginning of week
                      weekday = w.e + dow;
                      if (w.e < 0 || w.e > 6) {
                          weekdayOverflow = true;
                      }
                  }
                  else {
                      // default to beginning of week
                      weekday = dow;
                  }
              }
              if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
                  getParsingFlags(config)._overflowWeeks = true;
              }
              else if (weekdayOverflow != null) {
                  getParsingFlags(config)._overflowWeekday = true;
              }
              else {
                  temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
                  config._a[YEAR] = temp.year;
                  config._dayOfYear = temp.dayOfYear;
              }
          }
          // iso 8601 regex
          // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
          var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
          var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
          var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
          var isoDates = [
              ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
              ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
              ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
              ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
              ['YYYY-DDD', /\d{4}-\d{3}/],
              ['YYYY-MM', /\d{4}-\d\d/, false],
              ['YYYYYYMMDD', /[+-]\d{10}/],
              ['YYYYMMDD', /\d{8}/],
              // YYYYMM is NOT allowed by the standard
              ['GGGG[W]WWE', /\d{4}W\d{3}/],
              ['GGGG[W]WW', /\d{4}W\d{2}/, false],
              ['YYYYDDD', /\d{7}/]
          ];
          // iso time formats and regexes
          var isoTimes = [
              ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
              ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
              ['HH:mm:ss', /\d\d:\d\d:\d\d/],
              ['HH:mm', /\d\d:\d\d/],
              ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
              ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
              ['HHmmss', /\d\d\d\d\d\d/],
              ['HHmm', /\d\d\d\d/],
              ['HH', /\d\d/]
          ];
          var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
          // date from iso format
          function configFromISO(config) {
              var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat;
              if (match) {
                  getParsingFlags(config).iso = true;
                  for (i = 0, l = isoDates.length; i < l; i++) {
                      if (isoDates[i][1].exec(match[1])) {
                          dateFormat = isoDates[i][0];
                          allowTime = isoDates[i][2] !== false;
                          break;
                      }
                  }
                  if (dateFormat == null) {
                      config._isValid = false;
                      return;
                  }
                  if (match[3]) {
                      for (i = 0, l = isoTimes.length; i < l; i++) {
                          if (isoTimes[i][1].exec(match[3])) {
                              // match[2] should be 'T' or space
                              timeFormat = (match[2] || ' ') + isoTimes[i][0];
                              break;
                          }
                      }
                      if (timeFormat == null) {
                          config._isValid = false;
                          return;
                      }
                  }
                  if (!allowTime && timeFormat != null) {
                      config._isValid = false;
                      return;
                  }
                  if (match[4]) {
                      if (tzRegex.exec(match[4])) {
                          tzFormat = 'Z';
                      }
                      else {
                          config._isValid = false;
                          return;
                      }
                  }
                  config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
                  configFromStringAndFormat(config);
              }
              else {
                  config._isValid = false;
              }
          }
          // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
          var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
          function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
              var result = [
                  untruncateYear(yearStr),
                  defaultLocaleMonthsShort.indexOf(monthStr),
                  parseInt(dayStr, 10),
                  parseInt(hourStr, 10),
                  parseInt(minuteStr, 10)
              ];
              if (secondStr) {
                  result.push(parseInt(secondStr, 10));
              }
              return result;
          }
          function untruncateYear(yearStr) {
              var year = parseInt(yearStr, 10);
              if (year <= 49) {
                  return 2000 + year;
              }
              else if (year <= 999) {
                  return 1900 + year;
              }
              return year;
          }
          function preprocessRFC2822(s) {
              // Remove comments and folding whitespace and replace multiple-spaces with a single space
              return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
          }
          function checkWeekday(weekdayStr, parsedInput, config) {
              if (weekdayStr) {
                  // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
                  var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
                  if (weekdayProvided !== weekdayActual) {
                      getParsingFlags(config).weekdayMismatch = true;
                      config._isValid = false;
                      return false;
                  }
              }
              return true;
          }
          var obsOffsets = {
              UT: 0,
              GMT: 0,
              EDT: -4 * 60,
              EST: -5 * 60,
              CDT: -5 * 60,
              CST: -6 * 60,
              MDT: -6 * 60,
              MST: -7 * 60,
              PDT: -7 * 60,
              PST: -8 * 60
          };
          function calculateOffset(obsOffset, militaryOffset, numOffset) {
              if (obsOffset) {
                  return obsOffsets[obsOffset];
              }
              else if (militaryOffset) {
                  // the only allowed military tz is Z
                  return 0;
              }
              else {
                  var hm = parseInt(numOffset, 10);
                  var m = hm % 100, h = (hm - m) / 100;
                  return h * 60 + m;
              }
          }
          // date and time from ref 2822 format
          function configFromRFC2822(config) {
              var match = rfc2822.exec(preprocessRFC2822(config._i));
              if (match) {
                  var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
                  if (!checkWeekday(match[1], parsedArray, config)) {
                      return;
                  }
                  config._a = parsedArray;
                  config._tzm = calculateOffset(match[8], match[9], match[10]);
                  config._d = createUTCDate.apply(null, config._a);
                  config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
                  getParsingFlags(config).rfc2822 = true;
              }
              else {
                  config._isValid = false;
              }
          }
          // date from iso format or fallback
          function configFromString(config) {
              var matched = aspNetJsonRegex.exec(config._i);
              if (matched !== null) {
                  config._d = new Date(+matched[1]);
                  return;
              }
              configFromISO(config);
              if (config._isValid === false) {
                  delete config._isValid;
              }
              else {
                  return;
              }
              configFromRFC2822(config);
              if (config._isValid === false) {
                  delete config._isValid;
              }
              else {
                  return;
              }
              // Final attempt, use Input Fallback
              hooks.createFromInputFallback(config);
          }
          hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
              'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
              'discouraged and will be removed in an upcoming major release. Please refer to ' +
              'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
              config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
          });
          // constant that refers to the ISO standard
          hooks.ISO_8601 = function () { };
          // constant that refers to the RFC 2822 form
          hooks.RFC_2822 = function () { };
          // date from string and format string
          function configFromStringAndFormat(config) {
              // TODO: Move this to another part of the creation flow to prevent circular deps
              if (config._f === hooks.ISO_8601) {
                  configFromISO(config);
                  return;
              }
              if (config._f === hooks.RFC_2822) {
                  configFromRFC2822(config);
                  return;
              }
              config._a = [];
              getParsingFlags(config).empty = true;
              // This array is used to make a Date, either with `new Date` or `Date.UTC`
              var string = '' + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0;
              tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
              for (i = 0; i < tokens.length; i++) {
                  token = tokens[i];
                  parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
                  // console.log('token', token, 'parsedInput', parsedInput,
                  //         'regex', getParseRegexForToken(token, config));
                  if (parsedInput) {
                      skipped = string.substr(0, string.indexOf(parsedInput));
                      if (skipped.length > 0) {
                          getParsingFlags(config).unusedInput.push(skipped);
                      }
                      string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                      totalParsedInputLength += parsedInput.length;
                  }
                  // don't parse if it's not a known token
                  if (formatTokenFunctions[token]) {
                      if (parsedInput) {
                          getParsingFlags(config).empty = false;
                      }
                      else {
                          getParsingFlags(config).unusedTokens.push(token);
                      }
                      addTimeToArrayFromToken(token, parsedInput, config);
                  }
                  else if (config._strict && !parsedInput) {
                      getParsingFlags(config).unusedTokens.push(token);
                  }
              }
              // add remaining unparsed input length to the string
              getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
              if (string.length > 0) {
                  getParsingFlags(config).unusedInput.push(string);
              }
              // clear _12h flag if hour is <= 12
              if (config._a[HOUR] <= 12 &&
                  getParsingFlags(config).bigHour === true &&
                  config._a[HOUR] > 0) {
                  getParsingFlags(config).bigHour = undefined;
              }
              getParsingFlags(config).parsedDateParts = config._a.slice(0);
              getParsingFlags(config).meridiem = config._meridiem;
              // handle meridiem
              config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
              configFromArray(config);
              checkOverflow(config);
          }
          function meridiemFixWrap(locale, hour, meridiem) {
              var isPm;
              if (meridiem == null) {
                  // nothing to do
                  return hour;
              }
              if (locale.meridiemHour != null) {
                  return locale.meridiemHour(hour, meridiem);
              }
              else if (locale.isPM != null) {
                  // Fallback
                  isPm = locale.isPM(meridiem);
                  if (isPm && hour < 12) {
                      hour += 12;
                  }
                  if (!isPm && hour === 12) {
                      hour = 0;
                  }
                  return hour;
              }
              else {
                  // this is not supposed to happen
                  return hour;
              }
          }
          // date from string and array of format strings
          function configFromStringAndArray(config) {
              var tempConfig, bestMoment, scoreToBeat, i, currentScore;
              if (config._f.length === 0) {
                  getParsingFlags(config).invalidFormat = true;
                  config._d = new Date(NaN);
                  return;
              }
              for (i = 0; i < config._f.length; i++) {
                  currentScore = 0;
                  tempConfig = copyConfig({}, config);
                  if (config._useUTC != null) {
                      tempConfig._useUTC = config._useUTC;
                  }
                  tempConfig._f = config._f[i];
                  configFromStringAndFormat(tempConfig);
                  if (!isValid(tempConfig)) {
                      continue;
                  }
                  // if there is any input that was not parsed add a penalty for that format
                  currentScore += getParsingFlags(tempConfig).charsLeftOver;
                  //or tokens
                  currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
                  getParsingFlags(tempConfig).score = currentScore;
                  if (scoreToBeat == null || currentScore < scoreToBeat) {
                      scoreToBeat = currentScore;
                      bestMoment = tempConfig;
                  }
              }
              extend(config, bestMoment || tempConfig);
          }
          function configFromObject(config) {
              if (config._d) {
                  return;
              }
              var i = normalizeObjectUnits(config._i);
              config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
                  return obj && parseInt(obj, 10);
              });
              configFromArray(config);
          }
          function createFromConfig(config) {
              var res = new Moment(checkOverflow(prepareConfig(config)));
              if (res._nextDay) {
                  // Adding is smart enough around DST
                  res.add(1, 'd');
                  res._nextDay = undefined;
              }
              return res;
          }
          function prepareConfig(config) {
              var input = config._i, format = config._f;
              config._locale = config._locale || getLocale(config._l);
              if (input === null || (format === undefined && input === '')) {
                  return createInvalid({ nullInput: true });
              }
              if (typeof input === 'string') {
                  config._i = input = config._locale.preparse(input);
              }
              if (isMoment(input)) {
                  return new Moment(checkOverflow(input));
              }
              else if (isDate(input)) {
                  config._d = input;
              }
              else if (isArray(format)) {
                  configFromStringAndArray(config);
              }
              else if (format) {
                  configFromStringAndFormat(config);
              }
              else {
                  configFromInput(config);
              }
              if (!isValid(config)) {
                  config._d = null;
              }
              return config;
          }
          function configFromInput(config) {
              var input = config._i;
              if (isUndefined(input)) {
                  config._d = new Date(hooks.now());
              }
              else if (isDate(input)) {
                  config._d = new Date(input.valueOf());
              }
              else if (typeof input === 'string') {
                  configFromString(config);
              }
              else if (isArray(input)) {
                  config._a = map(input.slice(0), function (obj) {
                      return parseInt(obj, 10);
                  });
                  configFromArray(config);
              }
              else if (isObject(input)) {
                  configFromObject(config);
              }
              else if (isNumber(input)) {
                  // from milliseconds
                  config._d = new Date(input);
              }
              else {
                  hooks.createFromInputFallback(config);
              }
          }
          function createLocalOrUTC(input, format, locale, strict, isUTC) {
              var c = {};
              if (locale === true || locale === false) {
                  strict = locale;
                  locale = undefined;
              }
              if ((isObject(input) && isObjectEmpty(input)) ||
                  (isArray(input) && input.length === 0)) {
                  input = undefined;
              }
              // object construction must be done this way.
              // https://github.com/moment/moment/issues/1423
              c._isAMomentObject = true;
              c._useUTC = c._isUTC = isUTC;
              c._l = locale;
              c._i = input;
              c._f = format;
              c._strict = strict;
              return createFromConfig(c);
          }
          function createLocal(input, format, locale, strict) {
              return createLocalOrUTC(input, format, locale, strict, false);
          }
          var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
              var other = createLocal.apply(null, arguments);
              if (this.isValid() && other.isValid()) {
                  return other < this ? this : other;
              }
              else {
                  return createInvalid();
              }
          });
          var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
              var other = createLocal.apply(null, arguments);
              if (this.isValid() && other.isValid()) {
                  return other > this ? this : other;
              }
              else {
                  return createInvalid();
              }
          });
          // Pick a moment m from moments so that m[fn](other) is true for all
          // other. This relies on the function fn to be transitive.
          //
          // moments should either be an array of moment objects or an array, whose
          // first element is an array of moment objects.
          function pickBy(fn, moments) {
              var res, i;
              if (moments.length === 1 && isArray(moments[0])) {
                  moments = moments[0];
              }
              if (!moments.length) {
                  return createLocal();
              }
              res = moments[0];
              for (i = 1; i < moments.length; ++i) {
                  if (!moments[i].isValid() || moments[i][fn](res)) {
                      res = moments[i];
                  }
              }
              return res;
          }
          // TODO: Use [].sort instead?
          function min() {
              var args = [].slice.call(arguments, 0);
              return pickBy('isBefore', args);
          }
          function max() {
              var args = [].slice.call(arguments, 0);
              return pickBy('isAfter', args);
          }
          var now = function () {
              return Date.now ? Date.now() : +(new Date());
          };
          var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];
          function isDurationValid(m) {
              for (var key in m) {
                  if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                      return false;
                  }
              }
              var unitHasDecimal = false;
              for (var i = 0; i < ordering.length; ++i) {
                  if (m[ordering[i]]) {
                      if (unitHasDecimal) {
                          return false; // only allow non-integers for smallest unit
                      }
                      if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                          unitHasDecimal = true;
                      }
                  }
              }
              return true;
          }
          function isValid$1() {
              return this._isValid;
          }
          function createInvalid$1() {
              return createDuration(NaN);
          }
          function Duration(duration) {
              var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || normalizedInput.isoWeek || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
              this._isValid = isDurationValid(normalizedInput);
              // representation for dateAddRemove
              this._milliseconds = +milliseconds +
                  seconds * 1e3 + // 1000
                  minutes * 6e4 + // 1000 * 60
                  hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
              // Because of dateAddRemove treats 24 hours as different from a
              // day when working around DST, we need to store them separately
              this._days = +days +
                  weeks * 7;
              // It is impossible to translate months into days without knowing
              // which months you are are talking about, so we have to store
              // it separately.
              this._months = +months +
                  quarters * 3 +
                  years * 12;
              this._data = {};
              this._locale = getLocale();
              this._bubble();
          }
          function isDuration(obj) {
              return obj instanceof Duration;
          }
          function absRound(number) {
              if (number < 0) {
                  return Math.round(-1 * number) * -1;
              }
              else {
                  return Math.round(number);
              }
          }
          // FORMATTING
          function offset(token, separator) {
              addFormatToken(token, 0, 0, function () {
                  var offset = this.utcOffset();
                  var sign = '+';
                  if (offset < 0) {
                      offset = -offset;
                      sign = '-';
                  }
                  return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
              });
          }
          offset('Z', ':');
          offset('ZZ', '');
          // PARSING
          addRegexToken('Z', matchShortOffset);
          addRegexToken('ZZ', matchShortOffset);
          addParseToken(['Z', 'ZZ'], function (input, array, config) {
              config._useUTC = true;
              config._tzm = offsetFromString(matchShortOffset, input);
          });
          // HELPERS
          // timezone chunker
          // '+10:00' > ['10',  '00']
          // '-1530'  > ['-15', '30']
          var chunkOffset = /([\+\-]|\d\d)/gi;
          function offsetFromString(matcher, string) {
              var matches = (string || '').match(matcher);
              if (matches === null) {
                  return null;
              }
              var chunk = matches[matches.length - 1] || [];
              var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
              var minutes = +(parts[1] * 60) + toInt(parts[2]);
              return minutes === 0 ?
                  0 :
                  parts[0] === '+' ? minutes : -minutes;
          }
          // Return a moment from input, that is local/utc/zone equivalent to model.
          function cloneWithOffset(input, model) {
              var res, diff;
              if (model._isUTC) {
                  res = model.clone();
                  diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
                  // Use low-level api, because this fn is low-level api.
                  res._d.setTime(res._d.valueOf() + diff);
                  hooks.updateOffset(res, false);
                  return res;
              }
              else {
                  return createLocal(input).local();
              }
          }
          function getDateOffset(m) {
              // On Firefox.24 Date#getTimezoneOffset returns a floating point.
              // https://github.com/moment/moment/pull/1871
              return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
          }
          // HOOKS
          // This function will be called whenever a moment is mutated.
          // It is intended to keep the offset in sync with the timezone.
          hooks.updateOffset = function () { };
          // MOMENTS
          // keepLocalTime = true means only change the timezone, without
          // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
          // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
          // +0200, so we adjust the time as needed, to be valid.
          //
          // Keeping the time actually adds/subtracts (one hour)
          // from the actual represented time. That is why we call updateOffset
          // a second time. In case it wants us to change the offset again
          // _changeInProgress == true case, then we have to adjust, because
          // there is no such time in the given timezone.
          function getSetOffset(input, keepLocalTime, keepMinutes) {
              var offset = this._offset || 0, localAdjust;
              if (!this.isValid()) {
                  return input != null ? this : NaN;
              }
              if (input != null) {
                  if (typeof input === 'string') {
                      input = offsetFromString(matchShortOffset, input);
                      if (input === null) {
                          return this;
                      }
                  }
                  else if (Math.abs(input) < 16 && !keepMinutes) {
                      input = input * 60;
                  }
                  if (!this._isUTC && keepLocalTime) {
                      localAdjust = getDateOffset(this);
                  }
                  this._offset = input;
                  this._isUTC = true;
                  if (localAdjust != null) {
                      this.add(localAdjust, 'm');
                  }
                  if (offset !== input) {
                      if (!keepLocalTime || this._changeInProgress) {
                          addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                      }
                      else if (!this._changeInProgress) {
                          this._changeInProgress = true;
                          hooks.updateOffset(this, true);
                          this._changeInProgress = null;
                      }
                  }
                  return this;
              }
              else {
                  return this._isUTC ? offset : getDateOffset(this);
              }
          }
          function getSetZone(input, keepLocalTime) {
              if (input != null) {
                  if (typeof input !== 'string') {
                      input = -input;
                  }
                  this.utcOffset(input, keepLocalTime);
                  return this;
              }
              else {
                  return -this.utcOffset();
              }
          }
          function setOffsetToUTC(keepLocalTime) {
              return this.utcOffset(0, keepLocalTime);
          }
          function setOffsetToLocal(keepLocalTime) {
              if (this._isUTC) {
                  this.utcOffset(0, keepLocalTime);
                  this._isUTC = false;
                  if (keepLocalTime) {
                      this.subtract(getDateOffset(this), 'm');
                  }
              }
              return this;
          }
          function setOffsetToParsedOffset() {
              if (this._tzm != null) {
                  this.utcOffset(this._tzm, false, true);
              }
              else if (typeof this._i === 'string') {
                  var tZone = offsetFromString(matchOffset, this._i);
                  if (tZone != null) {
                      this.utcOffset(tZone);
                  }
                  else {
                      this.utcOffset(0, true);
                  }
              }
              return this;
          }
          function hasAlignedHourOffset(input) {
              if (!this.isValid()) {
                  return false;
              }
              input = input ? createLocal(input).utcOffset() : 0;
              return (this.utcOffset() - input) % 60 === 0;
          }
          function isDaylightSavingTime() {
              return (this.utcOffset() > this.clone().month(0).utcOffset() ||
                  this.utcOffset() > this.clone().month(5).utcOffset());
          }
          function isDaylightSavingTimeShifted() {
              if (!isUndefined(this._isDSTShifted)) {
                  return this._isDSTShifted;
              }
              var c = {};
              copyConfig(c, this);
              c = prepareConfig(c);
              if (c._a) {
                  var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
                  this._isDSTShifted = this.isValid() &&
                      compareArrays(c._a, other.toArray()) > 0;
              }
              else {
                  this._isDSTShifted = false;
              }
              return this._isDSTShifted;
          }
          function isLocal() {
              return this.isValid() ? !this._isUTC : false;
          }
          function isUtcOffset() {
              return this.isValid() ? this._isUTC : false;
          }
          function isUtc() {
              return this.isValid() ? this._isUTC && this._offset === 0 : false;
          }
          // ASP.NET json date format regex
          var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;
          // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
          // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
          // and further modified to allow for strings containing both week and day
          var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
          function createDuration(input, key) {
              var duration = input, 
              // matching against regexp is expensive, do it on demand
              match = null, sign, ret, diffRes;
              if (isDuration(input)) {
                  duration = {
                      ms: input._milliseconds,
                      d: input._days,
                      M: input._months
                  };
              }
              else if (isNumber(input)) {
                  duration = {};
                  if (key) {
                      duration[key] = input;
                  }
                  else {
                      duration.milliseconds = input;
                  }
              }
              else if (!!(match = aspNetRegex.exec(input))) {
                  sign = (match[1] === '-') ? -1 : 1;
                  duration = {
                      y: 0,
                      d: toInt(match[DATE]) * sign,
                      h: toInt(match[HOUR]) * sign,
                      m: toInt(match[MINUTE]) * sign,
                      s: toInt(match[SECOND]) * sign,
                      ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
                  };
              }
              else if (!!(match = isoRegex.exec(input))) {
                  sign = (match[1] === '-') ? -1 : 1;
                  duration = {
                      y: parseIso(match[2], sign),
                      M: parseIso(match[3], sign),
                      w: parseIso(match[4], sign),
                      d: parseIso(match[5], sign),
                      h: parseIso(match[6], sign),
                      m: parseIso(match[7], sign),
                      s: parseIso(match[8], sign)
                  };
              }
              else if (duration == null) { // checks for null or undefined
                  duration = {};
              }
              else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
                  diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
                  duration = {};
                  duration.ms = diffRes.milliseconds;
                  duration.M = diffRes.months;
              }
              ret = new Duration(duration);
              if (isDuration(input) && hasOwnProp(input, '_locale')) {
                  ret._locale = input._locale;
              }
              return ret;
          }
          createDuration.fn = Duration.prototype;
          createDuration.invalid = createInvalid$1;
          function parseIso(inp, sign) {
              // We'd normally use ~~inp for this, but unfortunately it also
              // converts floats to ints.
              // inp may be undefined, so careful calling replace on it.
              var res = inp && parseFloat(inp.replace(',', '.'));
              // apply sign while we're at it
              return (isNaN(res) ? 0 : res) * sign;
          }
          function positiveMomentsDifference(base, other) {
              var res = {};
              res.months = other.month() - base.month() +
                  (other.year() - base.year()) * 12;
              if (base.clone().add(res.months, 'M').isAfter(other)) {
                  --res.months;
              }
              res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
              return res;
          }
          function momentsDifference(base, other) {
              var res;
              if (!(base.isValid() && other.isValid())) {
                  return { milliseconds: 0, months: 0 };
              }
              other = cloneWithOffset(other, base);
              if (base.isBefore(other)) {
                  res = positiveMomentsDifference(base, other);
              }
              else {
                  res = positiveMomentsDifference(other, base);
                  res.milliseconds = -res.milliseconds;
                  res.months = -res.months;
              }
              return res;
          }
          // TODO: remove 'name' arg after deprecation is removed
          function createAdder(direction, name) {
              return function (val, period) {
                  var dur, tmp;
                  //invert the arguments, but complain about it
                  if (period !== null && !isNaN(+period)) {
                      deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                          'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                      tmp = val;
                      val = period;
                      period = tmp;
                  }
                  val = typeof val === 'string' ? +val : val;
                  dur = createDuration(val, period);
                  addSubtract(this, dur, direction);
                  return this;
              };
          }
          function addSubtract(mom, duration, isAdding, updateOffset) {
              var milliseconds = duration._milliseconds, days = absRound(duration._days), months = absRound(duration._months);
              if (!mom.isValid()) {
                  // No op
                  return;
              }
              updateOffset = updateOffset == null ? true : updateOffset;
              if (months) {
                  setMonth(mom, get(mom, 'Month') + months * isAdding);
              }
              if (days) {
                  set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
              }
              if (milliseconds) {
                  mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
              }
              if (updateOffset) {
                  hooks.updateOffset(mom, days || months);
              }
          }
          var add = createAdder(1, 'add');
          var subtract = createAdder(-1, 'subtract');
          function getCalendarFormat(myMoment, now) {
              var diff = myMoment.diff(now, 'days', true);
              return diff < -6 ? 'sameElse' :
                  diff < -1 ? 'lastWeek' :
                      diff < 0 ? 'lastDay' :
                          diff < 1 ? 'sameDay' :
                              diff < 2 ? 'nextDay' :
                                  diff < 7 ? 'nextWeek' : 'sameElse';
          }
          function calendar$1(time, formats) {
              // We want to compare the start of today, vs this.
              // Getting start-of-today depends on whether we're local/utc/offset or not.
              var now = time || createLocal(), sod = cloneWithOffset(now, this).startOf('day'), format = hooks.calendarFormat(this, sod) || 'sameElse';
              var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
              return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
          }
          function clone() {
              return new Moment(this);
          }
          function isAfter(input, units) {
              var localInput = isMoment(input) ? input : createLocal(input);
              if (!(this.isValid() && localInput.isValid())) {
                  return false;
              }
              units = normalizeUnits(units) || 'millisecond';
              if (units === 'millisecond') {
                  return this.valueOf() > localInput.valueOf();
              }
              else {
                  return localInput.valueOf() < this.clone().startOf(units).valueOf();
              }
          }
          function isBefore(input, units) {
              var localInput = isMoment(input) ? input : createLocal(input);
              if (!(this.isValid() && localInput.isValid())) {
                  return false;
              }
              units = normalizeUnits(units) || 'millisecond';
              if (units === 'millisecond') {
                  return this.valueOf() < localInput.valueOf();
              }
              else {
                  return this.clone().endOf(units).valueOf() < localInput.valueOf();
              }
          }
          function isBetween(from, to, units, inclusivity) {
              var localFrom = isMoment(from) ? from : createLocal(from), localTo = isMoment(to) ? to : createLocal(to);
              if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
                  return false;
              }
              inclusivity = inclusivity || '()';
              return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
                  (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
          }
          function isSame(input, units) {
              var localInput = isMoment(input) ? input : createLocal(input), inputMs;
              if (!(this.isValid() && localInput.isValid())) {
                  return false;
              }
              units = normalizeUnits(units) || 'millisecond';
              if (units === 'millisecond') {
                  return this.valueOf() === localInput.valueOf();
              }
              else {
                  inputMs = localInput.valueOf();
                  return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
              }
          }
          function isSameOrAfter(input, units) {
              return this.isSame(input, units) || this.isAfter(input, units);
          }
          function isSameOrBefore(input, units) {
              return this.isSame(input, units) || this.isBefore(input, units);
          }
          function diff(input, units, asFloat) {
              var that, zoneDelta, output;
              if (!this.isValid()) {
                  return NaN;
              }
              that = cloneWithOffset(input, this);
              if (!that.isValid()) {
                  return NaN;
              }
              zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
              units = normalizeUnits(units);
              switch (units) {
                  case 'year':
                      output = monthDiff(this, that) / 12;
                      break;
                  case 'month':
                      output = monthDiff(this, that);
                      break;
                  case 'quarter':
                      output = monthDiff(this, that) / 3;
                      break;
                  case 'second':
                      output = (this - that) / 1e3;
                      break; // 1000
                  case 'minute':
                      output = (this - that) / 6e4;
                      break; // 1000 * 60
                  case 'hour':
                      output = (this - that) / 36e5;
                      break; // 1000 * 60 * 60
                  case 'day':
                      output = (this - that - zoneDelta) / 864e5;
                      break; // 1000 * 60 * 60 * 24, negate dst
                  case 'week':
                      output = (this - that - zoneDelta) / 6048e5;
                      break; // 1000 * 60 * 60 * 24 * 7, negate dst
                  default: output = this - that;
              }
              return asFloat ? output : absFloor(output);
          }
          function monthDiff(a, b) {
              // difference in months
              var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()), 
              // b is in (anchor - 1 month, anchor + 1 month)
              anchor = a.clone().add(wholeMonthDiff, 'months'), anchor2, adjust;
              if (b - anchor < 0) {
                  anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
                  // linear across the month
                  adjust = (b - anchor) / (anchor - anchor2);
              }
              else {
                  anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
                  // linear across the month
                  adjust = (b - anchor) / (anchor2 - anchor);
              }
              //check for negative zero, return zero if negative zero
              return -(wholeMonthDiff + adjust) || 0;
          }
          hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
          hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
          function toString() {
              return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
          }
          function toISOString(keepOffset) {
              if (!this.isValid()) {
                  return null;
              }
              var utc = keepOffset !== true;
              var m = utc ? this.clone().utc() : this;
              if (m.year() < 0 || m.year() > 9999) {
                  return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
              }
              if (isFunction(Date.prototype.toISOString)) {
                  // native implementation is ~50x faster, use it when we can
                  if (utc) {
                      return this.toDate().toISOString();
                  }
                  else {
                      return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
                  }
              }
              return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
          }
          /**
           * Return a human readable representation of a moment that can
           * also be evaluated to get a new moment which is the same
           *
           * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
           */
          function inspect() {
              if (!this.isValid()) {
                  return 'moment.invalid(/* ' + this._i + ' */)';
              }
              var func = 'moment';
              var zone = '';
              if (!this.isLocal()) {
                  func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
                  zone = 'Z';
              }
              var prefix = '[' + func + '("]';
              var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
              var datetime = '-MM-DD[T]HH:mm:ss.SSS';
              var suffix = zone + '[")]';
              return this.format(prefix + year + datetime + suffix);
          }
          function format(inputString) {
              if (!inputString) {
                  inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
              }
              var output = formatMoment(this, inputString);
              return this.localeData().postformat(output);
          }
          function from(time, withoutSuffix) {
              if (this.isValid() &&
                  ((isMoment(time) && time.isValid()) ||
                      createLocal(time).isValid())) {
                  return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
              }
              else {
                  return this.localeData().invalidDate();
              }
          }
          function fromNow(withoutSuffix) {
              return this.from(createLocal(), withoutSuffix);
          }
          function to(time, withoutSuffix) {
              if (this.isValid() &&
                  ((isMoment(time) && time.isValid()) ||
                      createLocal(time).isValid())) {
                  return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
              }
              else {
                  return this.localeData().invalidDate();
              }
          }
          function toNow(withoutSuffix) {
              return this.to(createLocal(), withoutSuffix);
          }
          // If passed a locale key, it will set the locale for this
          // instance.  Otherwise, it will return the locale configuration
          // variables for this instance.
          function locale(key) {
              var newLocaleData;
              if (key === undefined) {
                  return this._locale._abbr;
              }
              else {
                  newLocaleData = getLocale(key);
                  if (newLocaleData != null) {
                      this._locale = newLocaleData;
                  }
                  return this;
              }
          }
          var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
              if (key === undefined) {
                  return this.localeData();
              }
              else {
                  return this.locale(key);
              }
          });
          function localeData() {
              return this._locale;
          }
          var MS_PER_SECOND = 1000;
          var MS_PER_MINUTE = 60 * MS_PER_SECOND;
          var MS_PER_HOUR = 60 * MS_PER_MINUTE;
          var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
          // actual modulo - handles negative numbers (for dates before 1970):
          function mod$1(dividend, divisor) {
              return (dividend % divisor + divisor) % divisor;
          }
          function localStartOfDate(y, m, d) {
              // the date constructor remaps years 0-99 to 1900-1999
              if (y < 100 && y >= 0) {
                  // preserve leap years using a full 400 year cycle, then reset
                  return new Date(y + 400, m, d) - MS_PER_400_YEARS;
              }
              else {
                  return new Date(y, m, d).valueOf();
              }
          }
          function utcStartOfDate(y, m, d) {
              // Date.UTC remaps years 0-99 to 1900-1999
              if (y < 100 && y >= 0) {
                  // preserve leap years using a full 400 year cycle, then reset
                  return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
              }
              else {
                  return Date.UTC(y, m, d);
              }
          }
          function startOf(units) {
              var time;
              units = normalizeUnits(units);
              if (units === undefined || units === 'millisecond' || !this.isValid()) {
                  return this;
              }
              var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
              switch (units) {
                  case 'year':
                      time = startOfDate(this.year(), 0, 1);
                      break;
                  case 'quarter':
                      time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
                      break;
                  case 'month':
                      time = startOfDate(this.year(), this.month(), 1);
                      break;
                  case 'week':
                      time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                      break;
                  case 'isoWeek':
                      time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                      break;
                  case 'day':
                  case 'date':
                      time = startOfDate(this.year(), this.month(), this.date());
                      break;
                  case 'hour':
                      time = this._d.valueOf();
                      time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                      break;
                  case 'minute':
                      time = this._d.valueOf();
                      time -= mod$1(time, MS_PER_MINUTE);
                      break;
                  case 'second':
                      time = this._d.valueOf();
                      time -= mod$1(time, MS_PER_SECOND);
                      break;
              }
              this._d.setTime(time);
              hooks.updateOffset(this, true);
              return this;
          }
          function endOf(units) {
              var time;
              units = normalizeUnits(units);
              if (units === undefined || units === 'millisecond' || !this.isValid()) {
                  return this;
              }
              var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
              switch (units) {
                  case 'year':
                      time = startOfDate(this.year() + 1, 0, 1) - 1;
                      break;
                  case 'quarter':
                      time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                      break;
                  case 'month':
                      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                      break;
                  case 'week':
                      time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                      break;
                  case 'isoWeek':
                      time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                      break;
                  case 'day':
                  case 'date':
                      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                      break;
                  case 'hour':
                      time = this._d.valueOf();
                      time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                      break;
                  case 'minute':
                      time = this._d.valueOf();
                      time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                      break;
                  case 'second':
                      time = this._d.valueOf();
                      time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                      break;
              }
              this._d.setTime(time);
              hooks.updateOffset(this, true);
              return this;
          }
          function valueOf() {
              return this._d.valueOf() - ((this._offset || 0) * 60000);
          }
          function unix() {
              return Math.floor(this.valueOf() / 1000);
          }
          function toDate() {
              return new Date(this.valueOf());
          }
          function toArray() {
              var m = this;
              return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
          }
          function toObject() {
              var m = this;
              return {
                  years: m.year(),
                  months: m.month(),
                  date: m.date(),
                  hours: m.hours(),
                  minutes: m.minutes(),
                  seconds: m.seconds(),
                  milliseconds: m.milliseconds()
              };
          }
          function toJSON() {
              // new Date(NaN).toJSON() === null
              return this.isValid() ? this.toISOString() : null;
          }
          function isValid$2() {
              return isValid(this);
          }
          function parsingFlags() {
              return extend({}, getParsingFlags(this));
          }
          function invalidAt() {
              return getParsingFlags(this).overflow;
          }
          function creationData() {
              return {
                  input: this._i,
                  format: this._f,
                  locale: this._locale,
                  isUTC: this._isUTC,
                  strict: this._strict
              };
          }
          // FORMATTING
          addFormatToken(0, ['gg', 2], 0, function () {
              return this.weekYear() % 100;
          });
          addFormatToken(0, ['GG', 2], 0, function () {
              return this.isoWeekYear() % 100;
          });
          function addWeekYearFormatToken(token, getter) {
              addFormatToken(0, [token, token.length], 0, getter);
          }
          addWeekYearFormatToken('gggg', 'weekYear');
          addWeekYearFormatToken('ggggg', 'weekYear');
          addWeekYearFormatToken('GGGG', 'isoWeekYear');
          addWeekYearFormatToken('GGGGG', 'isoWeekYear');
          // ALIASES
          addUnitAlias('weekYear', 'gg');
          addUnitAlias('isoWeekYear', 'GG');
          // PRIORITY
          addUnitPriority('weekYear', 1);
          addUnitPriority('isoWeekYear', 1);
          // PARSING
          addRegexToken('G', matchSigned);
          addRegexToken('g', matchSigned);
          addRegexToken('GG', match1to2, match2);
          addRegexToken('gg', match1to2, match2);
          addRegexToken('GGGG', match1to4, match4);
          addRegexToken('gggg', match1to4, match4);
          addRegexToken('GGGGG', match1to6, match6);
          addRegexToken('ggggg', match1to6, match6);
          addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
              week[token.substr(0, 2)] = toInt(input);
          });
          addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
              week[token] = hooks.parseTwoDigitYear(input);
          });
          // MOMENTS
          function getSetWeekYear(input) {
              return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
          }
          function getSetISOWeekYear(input) {
              return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
          }
          function getISOWeeksInYear() {
              return weeksInYear(this.year(), 1, 4);
          }
          function getWeeksInYear() {
              var weekInfo = this.localeData()._week;
              return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
          }
          function getSetWeekYearHelper(input, week, weekday, dow, doy) {
              var weeksTarget;
              if (input == null) {
                  return weekOfYear(this, dow, doy).year;
              }
              else {
                  weeksTarget = weeksInYear(input, dow, doy);
                  if (week > weeksTarget) {
                      week = weeksTarget;
                  }
                  return setWeekAll.call(this, input, week, weekday, dow, doy);
              }
          }
          function setWeekAll(weekYear, week, weekday, dow, doy) {
              var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
              this.year(date.getUTCFullYear());
              this.month(date.getUTCMonth());
              this.date(date.getUTCDate());
              return this;
          }
          // FORMATTING
          addFormatToken('Q', 0, 'Qo', 'quarter');
          // ALIASES
          addUnitAlias('quarter', 'Q');
          // PRIORITY
          addUnitPriority('quarter', 7);
          // PARSING
          addRegexToken('Q', match1);
          addParseToken('Q', function (input, array) {
              array[MONTH] = (toInt(input) - 1) * 3;
          });
          // MOMENTS
          function getSetQuarter(input) {
              return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
          }
          // FORMATTING
          addFormatToken('D', ['DD', 2], 'Do', 'date');
          // ALIASES
          addUnitAlias('date', 'D');
          // PRIORITY
          addUnitPriority('date', 9);
          // PARSING
          addRegexToken('D', match1to2);
          addRegexToken('DD', match1to2, match2);
          addRegexToken('Do', function (isStrict, locale) {
              // TODO: Remove "ordinalParse" fallback in next major release.
              return isStrict ?
                  (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
                  locale._dayOfMonthOrdinalParseLenient;
          });
          addParseToken(['D', 'DD'], DATE);
          addParseToken('Do', function (input, array) {
              array[DATE] = toInt(input.match(match1to2)[0]);
          });
          // MOMENTS
          var getSetDayOfMonth = makeGetSet('Date', true);
          // FORMATTING
          addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
          // ALIASES
          addUnitAlias('dayOfYear', 'DDD');
          // PRIORITY
          addUnitPriority('dayOfYear', 4);
          // PARSING
          addRegexToken('DDD', match1to3);
          addRegexToken('DDDD', match3);
          addParseToken(['DDD', 'DDDD'], function (input, array, config) {
              config._dayOfYear = toInt(input);
          });
          // HELPERS
          // MOMENTS
          function getSetDayOfYear(input) {
              var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
              return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
          }
          // FORMATTING
          addFormatToken('m', ['mm', 2], 0, 'minute');
          // ALIASES
          addUnitAlias('minute', 'm');
          // PRIORITY
          addUnitPriority('minute', 14);
          // PARSING
          addRegexToken('m', match1to2);
          addRegexToken('mm', match1to2, match2);
          addParseToken(['m', 'mm'], MINUTE);
          // MOMENTS
          var getSetMinute = makeGetSet('Minutes', false);
          // FORMATTING
          addFormatToken('s', ['ss', 2], 0, 'second');
          // ALIASES
          addUnitAlias('second', 's');
          // PRIORITY
          addUnitPriority('second', 15);
          // PARSING
          addRegexToken('s', match1to2);
          addRegexToken('ss', match1to2, match2);
          addParseToken(['s', 'ss'], SECOND);
          // MOMENTS
          var getSetSecond = makeGetSet('Seconds', false);
          // FORMATTING
          addFormatToken('S', 0, 0, function () {
              return ~~(this.millisecond() / 100);
          });
          addFormatToken(0, ['SS', 2], 0, function () {
              return ~~(this.millisecond() / 10);
          });
          addFormatToken(0, ['SSS', 3], 0, 'millisecond');
          addFormatToken(0, ['SSSS', 4], 0, function () {
              return this.millisecond() * 10;
          });
          addFormatToken(0, ['SSSSS', 5], 0, function () {
              return this.millisecond() * 100;
          });
          addFormatToken(0, ['SSSSSS', 6], 0, function () {
              return this.millisecond() * 1000;
          });
          addFormatToken(0, ['SSSSSSS', 7], 0, function () {
              return this.millisecond() * 10000;
          });
          addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
              return this.millisecond() * 100000;
          });
          addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
              return this.millisecond() * 1000000;
          });
          // ALIASES
          addUnitAlias('millisecond', 'ms');
          // PRIORITY
          addUnitPriority('millisecond', 16);
          // PARSING
          addRegexToken('S', match1to3, match1);
          addRegexToken('SS', match1to3, match2);
          addRegexToken('SSS', match1to3, match3);
          var token;
          for (token = 'SSSS'; token.length <= 9; token += 'S') {
              addRegexToken(token, matchUnsigned);
          }
          function parseMs(input, array) {
              array[MILLISECOND] = toInt(('0.' + input) * 1000);
          }
          for (token = 'S'; token.length <= 9; token += 'S') {
              addParseToken(token, parseMs);
          }
          // MOMENTS
          var getSetMillisecond = makeGetSet('Milliseconds', false);
          // FORMATTING
          addFormatToken('z', 0, 0, 'zoneAbbr');
          addFormatToken('zz', 0, 0, 'zoneName');
          // MOMENTS
          function getZoneAbbr() {
              return this._isUTC ? 'UTC' : '';
          }
          function getZoneName() {
              return this._isUTC ? 'Coordinated Universal Time' : '';
          }
          var proto = Moment.prototype;
          proto.add = add;
          proto.calendar = calendar$1;
          proto.clone = clone;
          proto.diff = diff;
          proto.endOf = endOf;
          proto.format = format;
          proto.from = from;
          proto.fromNow = fromNow;
          proto.to = to;
          proto.toNow = toNow;
          proto.get = stringGet;
          proto.invalidAt = invalidAt;
          proto.isAfter = isAfter;
          proto.isBefore = isBefore;
          proto.isBetween = isBetween;
          proto.isSame = isSame;
          proto.isSameOrAfter = isSameOrAfter;
          proto.isSameOrBefore = isSameOrBefore;
          proto.isValid = isValid$2;
          proto.lang = lang;
          proto.locale = locale;
          proto.localeData = localeData;
          proto.max = prototypeMax;
          proto.min = prototypeMin;
          proto.parsingFlags = parsingFlags;
          proto.set = stringSet;
          proto.startOf = startOf;
          proto.subtract = subtract;
          proto.toArray = toArray;
          proto.toObject = toObject;
          proto.toDate = toDate;
          proto.toISOString = toISOString;
          proto.inspect = inspect;
          proto.toJSON = toJSON;
          proto.toString = toString;
          proto.unix = unix;
          proto.valueOf = valueOf;
          proto.creationData = creationData;
          proto.year = getSetYear;
          proto.isLeapYear = getIsLeapYear;
          proto.weekYear = getSetWeekYear;
          proto.isoWeekYear = getSetISOWeekYear;
          proto.quarter = proto.quarters = getSetQuarter;
          proto.month = getSetMonth;
          proto.daysInMonth = getDaysInMonth;
          proto.week = proto.weeks = getSetWeek;
          proto.isoWeek = proto.isoWeeks = getSetISOWeek;
          proto.weeksInYear = getWeeksInYear;
          proto.isoWeeksInYear = getISOWeeksInYear;
          proto.date = getSetDayOfMonth;
          proto.day = proto.days = getSetDayOfWeek;
          proto.weekday = getSetLocaleDayOfWeek;
          proto.isoWeekday = getSetISODayOfWeek;
          proto.dayOfYear = getSetDayOfYear;
          proto.hour = proto.hours = getSetHour;
          proto.minute = proto.minutes = getSetMinute;
          proto.second = proto.seconds = getSetSecond;
          proto.millisecond = proto.milliseconds = getSetMillisecond;
          proto.utcOffset = getSetOffset;
          proto.utc = setOffsetToUTC;
          proto.local = setOffsetToLocal;
          proto.parseZone = setOffsetToParsedOffset;
          proto.hasAlignedHourOffset = hasAlignedHourOffset;
          proto.isDST = isDaylightSavingTime;
          proto.isLocal = isLocal;
          proto.isUtcOffset = isUtcOffset;
          proto.isUtc = isUtc;
          proto.isUTC = isUtc;
          proto.zoneAbbr = getZoneAbbr;
          proto.zoneName = getZoneName;
          proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
          proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
          proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
          proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
          proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);
          function createUnix(input) {
              return createLocal(input * 1000);
          }
          function createInZone() {
              return createLocal.apply(null, arguments).parseZone();
          }
          function preParsePostFormat(string) {
              return string;
          }
          var proto$1 = Locale.prototype;
          proto$1.calendar = calendar;
          proto$1.longDateFormat = longDateFormat;
          proto$1.invalidDate = invalidDate;
          proto$1.ordinal = ordinal;
          proto$1.preparse = preParsePostFormat;
          proto$1.postformat = preParsePostFormat;
          proto$1.relativeTime = relativeTime;
          proto$1.pastFuture = pastFuture;
          proto$1.set = set;
          proto$1.months = localeMonths;
          proto$1.monthsShort = localeMonthsShort;
          proto$1.monthsParse = localeMonthsParse;
          proto$1.monthsRegex = monthsRegex;
          proto$1.monthsShortRegex = monthsShortRegex;
          proto$1.week = localeWeek;
          proto$1.firstDayOfYear = localeFirstDayOfYear;
          proto$1.firstDayOfWeek = localeFirstDayOfWeek;
          proto$1.weekdays = localeWeekdays;
          proto$1.weekdaysMin = localeWeekdaysMin;
          proto$1.weekdaysShort = localeWeekdaysShort;
          proto$1.weekdaysParse = localeWeekdaysParse;
          proto$1.weekdaysRegex = weekdaysRegex;
          proto$1.weekdaysShortRegex = weekdaysShortRegex;
          proto$1.weekdaysMinRegex = weekdaysMinRegex;
          proto$1.isPM = localeIsPM;
          proto$1.meridiem = localeMeridiem;
          function get$1(format, index, field, setter) {
              var locale = getLocale();
              var utc = createUTC().set(setter, index);
              return locale[field](utc, format);
          }
          function listMonthsImpl(format, index, field) {
              if (isNumber(format)) {
                  index = format;
                  format = undefined;
              }
              format = format || '';
              if (index != null) {
                  return get$1(format, index, field, 'month');
              }
              var i;
              var out = [];
              for (i = 0; i < 12; i++) {
                  out[i] = get$1(format, i, field, 'month');
              }
              return out;
          }
          // ()
          // (5)
          // (fmt, 5)
          // (fmt)
          // (true)
          // (true, 5)
          // (true, fmt, 5)
          // (true, fmt)
          function listWeekdaysImpl(localeSorted, format, index, field) {
              if (typeof localeSorted === 'boolean') {
                  if (isNumber(format)) {
                      index = format;
                      format = undefined;
                  }
                  format = format || '';
              }
              else {
                  format = localeSorted;
                  index = format;
                  localeSorted = false;
                  if (isNumber(format)) {
                      index = format;
                      format = undefined;
                  }
                  format = format || '';
              }
              var locale = getLocale(), shift = localeSorted ? locale._week.dow : 0;
              if (index != null) {
                  return get$1(format, (index + shift) % 7, field, 'day');
              }
              var i;
              var out = [];
              for (i = 0; i < 7; i++) {
                  out[i] = get$1(format, (i + shift) % 7, field, 'day');
              }
              return out;
          }
          function listMonths(format, index) {
              return listMonthsImpl(format, index, 'months');
          }
          function listMonthsShort(format, index) {
              return listMonthsImpl(format, index, 'monthsShort');
          }
          function listWeekdays(localeSorted, format, index) {
              return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
          }
          function listWeekdaysShort(localeSorted, format, index) {
              return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
          }
          function listWeekdaysMin(localeSorted, format, index) {
              return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
          }
          getSetGlobalLocale('en', {
              dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
              ordinal: function (number) {
                  var b = number % 10, output = (toInt(number % 100 / 10) === 1) ? 'th' :
                      (b === 1) ? 'st' :
                          (b === 2) ? 'nd' :
                              (b === 3) ? 'rd' : 'th';
                  return number + output;
              }
          });
          // Side effect imports
          hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
          hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
          var mathAbs = Math.abs;
          function abs() {
              var data = this._data;
              this._milliseconds = mathAbs(this._milliseconds);
              this._days = mathAbs(this._days);
              this._months = mathAbs(this._months);
              data.milliseconds = mathAbs(data.milliseconds);
              data.seconds = mathAbs(data.seconds);
              data.minutes = mathAbs(data.minutes);
              data.hours = mathAbs(data.hours);
              data.months = mathAbs(data.months);
              data.years = mathAbs(data.years);
              return this;
          }
          function addSubtract$1(duration, input, value, direction) {
              var other = createDuration(input, value);
              duration._milliseconds += direction * other._milliseconds;
              duration._days += direction * other._days;
              duration._months += direction * other._months;
              return duration._bubble();
          }
          // supports only 2.0-style add(1, 's') or add(duration)
          function add$1(input, value) {
              return addSubtract$1(this, input, value, 1);
          }
          // supports only 2.0-style subtract(1, 's') or subtract(duration)
          function subtract$1(input, value) {
              return addSubtract$1(this, input, value, -1);
          }
          function absCeil(number) {
              if (number < 0) {
                  return Math.floor(number);
              }
              else {
                  return Math.ceil(number);
              }
          }
          function bubble() {
              var milliseconds = this._milliseconds;
              var days = this._days;
              var months = this._months;
              var data = this._data;
              var seconds, minutes, hours, years, monthsFromDays;
              // if we have a mix of positive and negative values, bubble down first
              // check: https://github.com/moment/moment/issues/2166
              if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                  (milliseconds <= 0 && days <= 0 && months <= 0))) {
                  milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
                  days = 0;
                  months = 0;
              }
              // The following code bubbles up values, see the tests for
              // examples of what that means.
              data.milliseconds = milliseconds % 1000;
              seconds = absFloor(milliseconds / 1000);
              data.seconds = seconds % 60;
              minutes = absFloor(seconds / 60);
              data.minutes = minutes % 60;
              hours = absFloor(minutes / 60);
              data.hours = hours % 24;
              days += absFloor(hours / 24);
              // convert days to months
              monthsFromDays = absFloor(daysToMonths(days));
              months += monthsFromDays;
              days -= absCeil(monthsToDays(monthsFromDays));
              // 12 months -> 1 year
              years = absFloor(months / 12);
              months %= 12;
              data.days = days;
              data.months = months;
              data.years = years;
              return this;
          }
          function daysToMonths(days) {
              // 400 years have 146097 days (taking into account leap year rules)
              // 400 years have 12 months === 4800
              return days * 4800 / 146097;
          }
          function monthsToDays(months) {
              // the reverse of daysToMonths
              return months * 146097 / 4800;
          }
          function as(units) {
              if (!this.isValid()) {
                  return NaN;
              }
              var days;
              var months;
              var milliseconds = this._milliseconds;
              units = normalizeUnits(units);
              if (units === 'month' || units === 'quarter' || units === 'year') {
                  days = this._days + milliseconds / 864e5;
                  months = this._months + daysToMonths(days);
                  switch (units) {
                      case 'month': return months;
                      case 'quarter': return months / 3;
                      case 'year': return months / 12;
                  }
              }
              else {
                  // handle milliseconds separately because of floating point math errors (issue #1867)
                  days = this._days + Math.round(monthsToDays(this._months));
                  switch (units) {
                      case 'week': return days / 7 + milliseconds / 6048e5;
                      case 'day': return days + milliseconds / 864e5;
                      case 'hour': return days * 24 + milliseconds / 36e5;
                      case 'minute': return days * 1440 + milliseconds / 6e4;
                      case 'second': return days * 86400 + milliseconds / 1000;
                      // Math.floor prevents floating point math errors here
                      case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                      default: throw new Error('Unknown unit ' + units);
                  }
              }
          }
          // TODO: Use this.as('ms')?
          function valueOf$1() {
              if (!this.isValid()) {
                  return NaN;
              }
              return (this._milliseconds +
                  this._days * 864e5 +
                  (this._months % 12) * 2592e6 +
                  toInt(this._months / 12) * 31536e6);
          }
          function makeAs(alias) {
              return function () {
                  return this.as(alias);
              };
          }
          var asMilliseconds = makeAs('ms');
          var asSeconds = makeAs('s');
          var asMinutes = makeAs('m');
          var asHours = makeAs('h');
          var asDays = makeAs('d');
          var asWeeks = makeAs('w');
          var asMonths = makeAs('M');
          var asQuarters = makeAs('Q');
          var asYears = makeAs('y');
          function clone$1() {
              return createDuration(this);
          }
          function get$2(units) {
              units = normalizeUnits(units);
              return this.isValid() ? this[units + 's']() : NaN;
          }
          function makeGetter(name) {
              return function () {
                  return this.isValid() ? this._data[name] : NaN;
              };
          }
          var milliseconds = makeGetter('milliseconds');
          var seconds = makeGetter('seconds');
          var minutes = makeGetter('minutes');
          var hours = makeGetter('hours');
          var days = makeGetter('days');
          var months = makeGetter('months');
          var years = makeGetter('years');
          function weeks() {
              return absFloor(this.days() / 7);
          }
          var round = Math.round;
          var thresholds = {
              ss: 44,
              s: 45,
              m: 45,
              h: 22,
              d: 26,
              M: 11 // months to year
          };
          // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
          function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
              return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
          }
          function relativeTime$1(posNegDuration, withoutSuffix, locale) {
              var duration = createDuration(posNegDuration).abs();
              var seconds = round(duration.as('s'));
              var minutes = round(duration.as('m'));
              var hours = round(duration.as('h'));
              var days = round(duration.as('d'));
              var months = round(duration.as('M'));
              var years = round(duration.as('y'));
              var a = seconds <= thresholds.ss && ['s', seconds] ||
                  seconds < thresholds.s && ['ss', seconds] ||
                  minutes <= 1 && ['m'] ||
                  minutes < thresholds.m && ['mm', minutes] ||
                  hours <= 1 && ['h'] ||
                  hours < thresholds.h && ['hh', hours] ||
                  days <= 1 && ['d'] ||
                  days < thresholds.d && ['dd', days] ||
                  months <= 1 && ['M'] ||
                  months < thresholds.M && ['MM', months] ||
                  years <= 1 && ['y'] || ['yy', years];
              a[2] = withoutSuffix;
              a[3] = +posNegDuration > 0;
              a[4] = locale;
              return substituteTimeAgo.apply(null, a);
          }
          // This function allows you to set the rounding function for relative time strings
          function getSetRelativeTimeRounding(roundingFunction) {
              if (roundingFunction === undefined) {
                  return round;
              }
              if (typeof (roundingFunction) === 'function') {
                  round = roundingFunction;
                  return true;
              }
              return false;
          }
          // This function allows you to set a threshold for relative time strings
          function getSetRelativeTimeThreshold(threshold, limit) {
              if (thresholds[threshold] === undefined) {
                  return false;
              }
              if (limit === undefined) {
                  return thresholds[threshold];
              }
              thresholds[threshold] = limit;
              if (threshold === 's') {
                  thresholds.ss = limit - 1;
              }
              return true;
          }
          function humanize(withSuffix) {
              if (!this.isValid()) {
                  return this.localeData().invalidDate();
              }
              var locale = this.localeData();
              var output = relativeTime$1(this, !withSuffix, locale);
              if (withSuffix) {
                  output = locale.pastFuture(+this, output);
              }
              return locale.postformat(output);
          }
          var abs$1 = Math.abs;
          function sign(x) {
              return ((x > 0) - (x < 0)) || +x;
          }
          function toISOString$1() {
              // for ISO strings we do not use the normal bubbling rules:
              //  * milliseconds bubble up until they become hours
              //  * days do not bubble at all
              //  * months bubble up until they become years
              // This is because there is no context-free conversion between hours and days
              // (think of clock changes)
              // and also not between days and months (28-31 days per month)
              if (!this.isValid()) {
                  return this.localeData().invalidDate();
              }
              var seconds = abs$1(this._milliseconds) / 1000;
              var days = abs$1(this._days);
              var months = abs$1(this._months);
              var minutes, hours, years;
              // 3600 seconds -> 60 minutes -> 1 hour
              minutes = absFloor(seconds / 60);
              hours = absFloor(minutes / 60);
              seconds %= 60;
              minutes %= 60;
              // 12 months -> 1 year
              years = absFloor(months / 12);
              months %= 12;
              // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
              var Y = years;
              var M = months;
              var D = days;
              var h = hours;
              var m = minutes;
              var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
              var total = this.asSeconds();
              if (!total) {
                  // this is the same as C#'s (Noda) and python (isodate)...
                  // but not other JS (goog.date)
                  return 'P0D';
              }
              var totalSign = total < 0 ? '-' : '';
              var ymSign = sign(this._months) !== sign(total) ? '-' : '';
              var daysSign = sign(this._days) !== sign(total) ? '-' : '';
              var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
              return totalSign + 'P' +
                  (Y ? ymSign + Y + 'Y' : '') +
                  (M ? ymSign + M + 'M' : '') +
                  (D ? daysSign + D + 'D' : '') +
                  ((h || m || s) ? 'T' : '') +
                  (h ? hmsSign + h + 'H' : '') +
                  (m ? hmsSign + m + 'M' : '') +
                  (s ? hmsSign + s + 'S' : '');
          }
          var proto$2 = Duration.prototype;
          proto$2.isValid = isValid$1;
          proto$2.abs = abs;
          proto$2.add = add$1;
          proto$2.subtract = subtract$1;
          proto$2.as = as;
          proto$2.asMilliseconds = asMilliseconds;
          proto$2.asSeconds = asSeconds;
          proto$2.asMinutes = asMinutes;
          proto$2.asHours = asHours;
          proto$2.asDays = asDays;
          proto$2.asWeeks = asWeeks;
          proto$2.asMonths = asMonths;
          proto$2.asQuarters = asQuarters;
          proto$2.asYears = asYears;
          proto$2.valueOf = valueOf$1;
          proto$2._bubble = bubble;
          proto$2.clone = clone$1;
          proto$2.get = get$2;
          proto$2.milliseconds = milliseconds;
          proto$2.seconds = seconds;
          proto$2.minutes = minutes;
          proto$2.hours = hours;
          proto$2.days = days;
          proto$2.weeks = weeks;
          proto$2.months = months;
          proto$2.years = years;
          proto$2.humanize = humanize;
          proto$2.toISOString = toISOString$1;
          proto$2.toString = toISOString$1;
          proto$2.toJSON = toISOString$1;
          proto$2.locale = locale;
          proto$2.localeData = localeData;
          proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
          proto$2.lang = lang;
          // Side effect imports
          // FORMATTING
          addFormatToken('X', 0, 0, 'unix');
          addFormatToken('x', 0, 0, 'valueOf');
          // PARSING
          addRegexToken('x', matchSigned);
          addRegexToken('X', matchTimestamp);
          addParseToken('X', function (input, array, config) {
              config._d = new Date(parseFloat(input, 10) * 1000);
          });
          addParseToken('x', function (input, array, config) {
              config._d = new Date(toInt(input));
          });
          // Side effect imports
          hooks.version = '2.24.0';
          setHookCallback(createLocal);
          hooks.fn = proto;
          hooks.min = min;
          hooks.max = max;
          hooks.now = now;
          hooks.utc = createUTC;
          hooks.unix = createUnix;
          hooks.months = listMonths;
          hooks.isDate = isDate;
          hooks.locale = getSetGlobalLocale;
          hooks.invalid = createInvalid;
          hooks.duration = createDuration;
          hooks.isMoment = isMoment;
          hooks.weekdays = listWeekdays;
          hooks.parseZone = createInZone;
          hooks.localeData = getLocale;
          hooks.isDuration = isDuration;
          hooks.monthsShort = listMonthsShort;
          hooks.weekdaysMin = listWeekdaysMin;
          hooks.defineLocale = defineLocale;
          hooks.updateLocale = updateLocale;
          hooks.locales = listLocales;
          hooks.weekdaysShort = listWeekdaysShort;
          hooks.normalizeUnits = normalizeUnits;
          hooks.relativeTimeRounding = getSetRelativeTimeRounding;
          hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
          hooks.calendarFormat = getCalendarFormat;
          hooks.prototype = proto;
          // currently HTML5 input type only supports 24-hour formats
          hooks.HTML5_FMT = {
              DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
              DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
              DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
              DATE: 'YYYY-MM-DD',
              TIME: 'HH:mm',
              TIME_SECONDS: 'HH:mm:ss',
              TIME_MS: 'HH:mm:ss.SSS',
              WEEK: 'GGGG-[W]WW',
              MONTH: 'YYYY-MM' // <input type="month" />
          };
          return hooks;
      })));
  });

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var moment$1 = moment;
  var AppVersionComponent = /** @class */ (function () {
      function AppVersionComponent(versionService) {
          this.versionService = versionService;
      }
      /**
       * @return {?}
       */
      AppVersionComponent.prototype.getMoment = /**
       * @return {?}
       */
          function () {
              return moment$1().format('MMMM Do YYYY');
          };
      AppVersionComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'app-version',
                      template: "<mat-card>\n  Version {{ versionService.getVersion() }} of shared library, Today: {{ getMoment() }}\n</mat-card>\n",
                      styles: [".mat-badge-content{font-weight:600;font-size:12px;font-family:Roboto,\"Helvetica Neue\",sans-serif}.mat-badge-small .mat-badge-content{font-size:6px}.mat-badge-large .mat-badge-content{font-size:24px}.mat-h1,.mat-headline,.mat-typography h1{font:400 24px/32px Roboto,\"Helvetica Neue\",sans-serif;margin:0 0 16px}.mat-h2,.mat-title,.mat-typography h2{font:500 20px/32px Roboto,\"Helvetica Neue\",sans-serif;margin:0 0 16px}.mat-h3,.mat-subheading-2,.mat-typography h3{font:400 16px/28px Roboto,\"Helvetica Neue\",sans-serif;margin:0 0 16px}.mat-h4,.mat-subheading-1,.mat-typography h4{font:400 15px/24px Roboto,\"Helvetica Neue\",sans-serif;margin:0 0 16px}.mat-h5,.mat-typography h5{font:400 11.62px/20px Roboto,\"Helvetica Neue\",sans-serif;margin:0 0 12px}.mat-h6,.mat-typography h6{font:400 9.38px/20px Roboto,\"Helvetica Neue\",sans-serif;margin:0 0 12px}.mat-body-2,.mat-body-strong{font:500 14px/24px Roboto,\"Helvetica Neue\",sans-serif}.mat-body,.mat-body-1,.mat-typography{font:400 14px/20px Roboto,\"Helvetica Neue\",sans-serif}.mat-body p,.mat-body-1 p,.mat-typography p{margin:0 0 12px}.mat-caption,.mat-small{font:400 12px/20px Roboto,\"Helvetica Neue\",sans-serif}.mat-display-4,.mat-typography .mat-display-4{font:300 112px/112px Roboto,\"Helvetica Neue\",sans-serif;margin:0 0 56px;letter-spacing:-.05em}.mat-display-3,.mat-typography .mat-display-3{font:400 56px/56px Roboto,\"Helvetica Neue\",sans-serif;margin:0 0 64px;letter-spacing:-.02em}.mat-display-2,.mat-typography .mat-display-2{font:400 45px/48px Roboto,\"Helvetica Neue\",sans-serif;margin:0 0 64px;letter-spacing:-.005em}.mat-display-1,.mat-typography .mat-display-1{font:400 34px/40px Roboto,\"Helvetica Neue\",sans-serif;margin:0 0 64px}.mat-bottom-sheet-container{font:400 14px/20px Roboto,\"Helvetica Neue\",sans-serif}.mat-button,.mat-fab,.mat-flat-button,.mat-icon-button,.mat-mini-fab,.mat-raised-button,.mat-stroked-button{font-family:Roboto,\"Helvetica Neue\",sans-serif;font-size:14px;font-weight:500}.mat-button-toggle,.mat-card{font-family:Roboto,\"Helvetica Neue\",sans-serif}.mat-card-title{font-size:24px;font-weight:500}.mat-card-header .mat-card-title{font-size:20px}.mat-card-content,.mat-card-subtitle{font-size:14px}.mat-checkbox{font-family:Roboto,\"Helvetica Neue\",sans-serif}.mat-checkbox-layout .mat-checkbox-label{line-height:24px}.mat-chip{font-size:14px;font-weight:500}.mat-chip .mat-chip-remove.mat-icon,.mat-chip .mat-chip-trailing-icon.mat-icon{font-size:18px}.mat-table{font-family:Roboto,\"Helvetica Neue\",sans-serif}.mat-header-cell{font-size:12px;font-weight:500}.mat-cell,.mat-footer-cell{font-size:14px}.mat-calendar{font-family:Roboto,\"Helvetica Neue\",sans-serif}.mat-calendar-body{font-size:13px}.mat-calendar-body-label,.mat-calendar-period-button{font-size:14px;font-weight:500}.mat-calendar-table-header th{font-size:11px;font-weight:400}.mat-dialog-title{font:500 20px/32px Roboto,\"Helvetica Neue\",sans-serif}.mat-expansion-panel-header{font-family:Roboto,\"Helvetica Neue\",sans-serif;font-size:15px;font-weight:400}.mat-expansion-panel-content{font:400 14px/20px Roboto,\"Helvetica Neue\",sans-serif}.mat-form-field{font-size:inherit;font-weight:400;line-height:1.125;font-family:Roboto,\"Helvetica Neue\",sans-serif}.mat-form-field-wrapper{padding-bottom:1.34375em}.mat-form-field-prefix .mat-icon,.mat-form-field-suffix .mat-icon{font-size:150%;line-height:1.125}.mat-form-field-prefix .mat-icon-button,.mat-form-field-suffix .mat-icon-button{height:1.5em;width:1.5em}.mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-suffix .mat-icon-button .mat-icon{height:1.125em;line-height:1.125}.mat-form-field-infix{padding:.5em 0;border-top:.84375em solid transparent}.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{-webkit-transform:translateY(-1.34375em) scale(.75);transform:translateY(-1.34375em) scale(.75);width:133.33333%}.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{-webkit-transform:translateY(-1.34374em) scale(.75);transform:translateY(-1.34374em) scale(.75);width:133.33334%}.mat-form-field-label-wrapper{top:-.84375em;padding-top:.84375em}.mat-form-field-label{top:1.34375em}.mat-form-field-underline{bottom:1.34375em}.mat-form-field-subscript-wrapper{font-size:75%;margin-top:.66667em;top:calc(100% - 1.79167em)}.mat-form-field-appearance-legacy .mat-form-field-wrapper{padding-bottom:1.25em}.mat-form-field-appearance-legacy .mat-form-field-infix{padding:.4375em 0}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-appearance-legacy.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{-webkit-transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.001px);transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.001px);-ms-transform:translateY(-1.28125em) scale(.75);width:133.33333%}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{-webkit-transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.00101px);transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.00101px);-ms-transform:translateY(-1.28124em) scale(.75);width:133.33334%}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{-webkit-transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.00102px);transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.00102px);-ms-transform:translateY(-1.28123em) scale(.75);width:133.33335%}.mat-form-field-appearance-legacy .mat-form-field-label{top:1.28125em}.mat-form-field-appearance-legacy .mat-form-field-subscript-wrapper{margin-top:.54167em;top:calc(100% - 1.66667em)}@media print{.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-appearance-legacy.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{-webkit-transform:translateY(-1.28122em) scale(.75);transform:translateY(-1.28122em) scale(.75)}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{-webkit-transform:translateY(-1.28121em) scale(.75);transform:translateY(-1.28121em) scale(.75)}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{-webkit-transform:translateY(-1.2812em) scale(.75);transform:translateY(-1.2812em) scale(.75)}}.mat-form-field-appearance-fill .mat-form-field-infix{padding:.25em 0 .75em}.mat-form-field-appearance-fill .mat-form-field-label{top:1.09375em;margin-top:-.5em}.mat-form-field-appearance-fill.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-appearance-fill.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{-webkit-transform:translateY(-.59375em) scale(.75);transform:translateY(-.59375em) scale(.75);width:133.33333%}.mat-form-field-appearance-fill.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{-webkit-transform:translateY(-.59374em) scale(.75);transform:translateY(-.59374em) scale(.75);width:133.33334%}.mat-form-field-appearance-outline .mat-form-field-infix{padding:1em 0}.mat-form-field-appearance-outline .mat-form-field-label{top:1.84375em;margin-top:-.25em}.mat-form-field-appearance-outline.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{-webkit-transform:translateY(-1.59375em) scale(.75);transform:translateY(-1.59375em) scale(.75);width:133.33333%}.mat-form-field-appearance-outline.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{-webkit-transform:translateY(-1.59374em) scale(.75);transform:translateY(-1.59374em) scale(.75);width:133.33334%}.mat-grid-tile-footer,.mat-grid-tile-header{font-size:14px}.mat-grid-tile-footer .mat-line,.mat-grid-tile-header .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-grid-tile-footer .mat-line:nth-child(n+2),.mat-grid-tile-header .mat-line:nth-child(n+2){font-size:12px}input.mat-input-element{margin-top:-.0625em}.mat-menu-item{font-family:Roboto,\"Helvetica Neue\",sans-serif;font-size:14px;font-weight:400}.mat-paginator,.mat-paginator-page-size .mat-select-trigger{font-family:Roboto,\"Helvetica Neue\",sans-serif;font-size:12px}.mat-radio-button,.mat-select{font-family:Roboto,\"Helvetica Neue\",sans-serif}.mat-select-trigger{height:1.125em}.mat-slide-toggle-content{font-family:Roboto,\"Helvetica Neue\",sans-serif}.mat-slider-thumb-label-text{font-family:Roboto,\"Helvetica Neue\",sans-serif;font-size:12px;font-weight:500}.mat-stepper-horizontal,.mat-stepper-vertical{font-family:Roboto,\"Helvetica Neue\",sans-serif}.mat-step-label{font-size:14px;font-weight:400}.mat-step-sub-label-error{font-weight:400}.mat-step-label-error{font-size:14px}.mat-step-label-selected{font-size:14px;font-weight:500}.mat-tab-group{font-family:Roboto,\"Helvetica Neue\",sans-serif}.mat-tab-label,.mat-tab-link{font-family:Roboto,\"Helvetica Neue\",sans-serif;font-size:14px;font-weight:500}.mat-toolbar,.mat-toolbar h1,.mat-toolbar h2,.mat-toolbar h3,.mat-toolbar h4,.mat-toolbar h5,.mat-toolbar h6{font:500 20px/32px Roboto,\"Helvetica Neue\",sans-serif;margin:0}.mat-tooltip{font-family:Roboto,\"Helvetica Neue\",sans-serif;font-size:10px;padding-top:6px;padding-bottom:6px}.mat-tooltip-handset{font-size:14px;padding-top:8px;padding-bottom:8px}.mat-list-item,.mat-list-option{font-family:Roboto,\"Helvetica Neue\",sans-serif}.mat-list-base .mat-list-item{font-size:16px}.mat-list-base .mat-list-item .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base .mat-list-item .mat-line:nth-child(n+2){font-size:14px}.mat-list-base .mat-list-option{font-size:16px}.mat-list-base .mat-list-option .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base .mat-list-option .mat-line:nth-child(n+2){font-size:14px}.mat-list-base[dense] .mat-list-item{font-size:12px}.mat-list-base[dense] .mat-list-item .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base[dense] .mat-list-item .mat-line:nth-child(n+2),.mat-list-base[dense] .mat-list-option{font-size:12px}.mat-list-base[dense] .mat-list-option .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base[dense] .mat-list-option .mat-line:nth-child(n+2){font-size:12px}.mat-list-base[dense] .mat-subheader{font-family:Roboto,\"Helvetica Neue\",sans-serif;font-size:12px;font-weight:500}.mat-option{font-family:Roboto,\"Helvetica Neue\",sans-serif;font-size:16px;color:rgba(0,0,0,.87)}.mat-optgroup-label{font:500 14px/24px Roboto,\"Helvetica Neue\",sans-serif;color:rgba(0,0,0,.54)}.mat-simple-snackbar{font-family:Roboto,\"Helvetica Neue\",sans-serif;font-size:14px}.mat-simple-snackbar-action{line-height:1;font-family:inherit;font-size:inherit;font-weight:500}.mat-ripple{overflow:hidden;position:relative}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform cubic-bezier(0,0,.2,1),-webkit-transform cubic-bezier(0,0,.2,1);-webkit-transform:scale(0);transform:scale(0)}@media (-ms-high-contrast:active){.mat-ripple-element{display:none}}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;outline:0;-webkit-appearance:none;-moz-appearance:none}.cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;z-index:1000;display:flex;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}@media screen and (-ms-high-contrast:active){.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}}.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}@-webkit-keyframes cdk-text-field-autofill-start{/*!*/}@keyframes cdk-text-field-autofill-start{/*!*/}@-webkit-keyframes cdk-text-field-autofill-end{/*!*/}@keyframes cdk-text-field-autofill-end{/*!*/}.cdk-text-field-autofill-monitored:-webkit-autofill{-webkit-animation-name:cdk-text-field-autofill-start;animation-name:cdk-text-field-autofill-start}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){-webkit-animation-name:cdk-text-field-autofill-end;animation-name:cdk-text-field-autofill-end}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{height:auto!important;overflow:hidden!important;padding:2px 0!important;box-sizing:content-box!important}.mat-ripple-element{background-color:rgba(0,0,0,.1)}.mat-option.mat-selected:not(.mat-option-multiple):not(.mat-option-disabled),.mat-option:focus:not(.mat-option-disabled),.mat-option:hover:not(.mat-option-disabled){background:rgba(0,0,0,.04)}.mat-option.mat-active{background:rgba(0,0,0,.04);color:rgba(0,0,0,.87)}.mat-option.mat-option-disabled{color:rgba(0,0,0,.38)}.mat-primary .mat-option.mat-selected:not(.mat-option-disabled){color:#3f51b5}.mat-accent .mat-option.mat-selected:not(.mat-option-disabled){color:#ff4081}.mat-warn .mat-option.mat-selected:not(.mat-option-disabled){color:#f44336}.mat-optgroup-disabled .mat-optgroup-label{color:rgba(0,0,0,.38)}.mat-pseudo-checkbox{color:rgba(0,0,0,.54)}.mat-pseudo-checkbox::after{color:#fafafa}.mat-accent .mat-pseudo-checkbox-checked,.mat-accent .mat-pseudo-checkbox-indeterminate,.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox-indeterminate{background:#ff4081}.mat-primary .mat-pseudo-checkbox-checked,.mat-primary .mat-pseudo-checkbox-indeterminate{background:#3f51b5}.mat-warn .mat-pseudo-checkbox-checked,.mat-warn .mat-pseudo-checkbox-indeterminate{background:#f44336}.mat-pseudo-checkbox-checked.mat-pseudo-checkbox-disabled,.mat-pseudo-checkbox-indeterminate.mat-pseudo-checkbox-disabled{background:#b0b0b0}.mat-elevation-z0{box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12)}.mat-elevation-z1{box-shadow:0 2px 1px -1px rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 1px 3px 0 rgba(0,0,0,.12)}.mat-elevation-z2{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12)}.mat-elevation-z3{box-shadow:0 3px 3px -2px rgba(0,0,0,.2),0 3px 4px 0 rgba(0,0,0,.14),0 1px 8px 0 rgba(0,0,0,.12)}.mat-elevation-z4{box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)}.mat-elevation-z5{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 5px 8px 0 rgba(0,0,0,.14),0 1px 14px 0 rgba(0,0,0,.12)}.mat-elevation-z6{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12)}.mat-elevation-z7{box-shadow:0 4px 5px -2px rgba(0,0,0,.2),0 7px 10px 1px rgba(0,0,0,.14),0 2px 16px 1px rgba(0,0,0,.12)}.mat-elevation-z8{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}.mat-elevation-z9{box-shadow:0 5px 6px -3px rgba(0,0,0,.2),0 9px 12px 1px rgba(0,0,0,.14),0 3px 16px 2px rgba(0,0,0,.12)}.mat-elevation-z10{box-shadow:0 6px 6px -3px rgba(0,0,0,.2),0 10px 14px 1px rgba(0,0,0,.14),0 4px 18px 3px rgba(0,0,0,.12)}.mat-elevation-z11{box-shadow:0 6px 7px -4px rgba(0,0,0,.2),0 11px 15px 1px rgba(0,0,0,.14),0 4px 20px 3px rgba(0,0,0,.12)}.mat-elevation-z12{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.mat-elevation-z13{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 13px 19px 2px rgba(0,0,0,.14),0 5px 24px 4px rgba(0,0,0,.12)}.mat-elevation-z14{box-shadow:0 7px 9px -4px rgba(0,0,0,.2),0 14px 21px 2px rgba(0,0,0,.14),0 5px 26px 4px rgba(0,0,0,.12)}.mat-elevation-z15{box-shadow:0 8px 9px -5px rgba(0,0,0,.2),0 15px 22px 2px rgba(0,0,0,.14),0 6px 28px 5px rgba(0,0,0,.12)}.mat-elevation-z16{box-shadow:0 8px 10px -5px rgba(0,0,0,.2),0 16px 24px 2px rgba(0,0,0,.14),0 6px 30px 5px rgba(0,0,0,.12)}.mat-elevation-z17{box-shadow:0 8px 11px -5px rgba(0,0,0,.2),0 17px 26px 2px rgba(0,0,0,.14),0 6px 32px 5px rgba(0,0,0,.12)}.mat-elevation-z18{box-shadow:0 9px 11px -5px rgba(0,0,0,.2),0 18px 28px 2px rgba(0,0,0,.14),0 7px 34px 6px rgba(0,0,0,.12)}.mat-elevation-z19{box-shadow:0 9px 12px -6px rgba(0,0,0,.2),0 19px 29px 2px rgba(0,0,0,.14),0 7px 36px 6px rgba(0,0,0,.12)}.mat-elevation-z20{box-shadow:0 10px 13px -6px rgba(0,0,0,.2),0 20px 31px 3px rgba(0,0,0,.14),0 8px 38px 7px rgba(0,0,0,.12)}.mat-elevation-z21{box-shadow:0 10px 13px -6px rgba(0,0,0,.2),0 21px 33px 3px rgba(0,0,0,.14),0 8px 40px 7px rgba(0,0,0,.12)}.mat-elevation-z22{box-shadow:0 10px 14px -6px rgba(0,0,0,.2),0 22px 35px 3px rgba(0,0,0,.14),0 8px 42px 7px rgba(0,0,0,.12)}.mat-elevation-z23{box-shadow:0 11px 14px -7px rgba(0,0,0,.2),0 23px 36px 3px rgba(0,0,0,.14),0 9px 44px 8px rgba(0,0,0,.12)}.mat-elevation-z24{box-shadow:0 11px 15px -7px rgba(0,0,0,.2),0 24px 38px 3px rgba(0,0,0,.14),0 9px 46px 8px rgba(0,0,0,.12)}.mat-app-background{background-color:#fafafa;color:rgba(0,0,0,.87)}.mat-theme-loaded-marker{display:none}.mat-autocomplete-panel{background:#fff;color:rgba(0,0,0,.87)}.mat-autocomplete-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)}.mat-autocomplete-panel .mat-option.mat-selected:not(.mat-active):not(:hover){background:#fff}.mat-autocomplete-panel .mat-option.mat-selected:not(.mat-active):not(:hover):not(.mat-option-disabled){color:rgba(0,0,0,.87)}@media (-ms-high-contrast:active){.mat-badge-content{outline:solid 1px;border-radius:0}.mat-checkbox-disabled{opacity:.5}}.mat-badge-accent .mat-badge-content{background:#ff4081;color:#fff}.mat-badge-warn .mat-badge-content{color:#fff;background:#f44336}.mat-badge{position:relative}.mat-badge-hidden .mat-badge-content{display:none}.mat-badge-disabled .mat-badge-content{background:#b9b9b9;color:rgba(0,0,0,.38)}.mat-badge-content{color:#fff;background:#3f51b5;position:absolute;text-align:center;display:inline-block;border-radius:50%;transition:transform .2s ease-in-out,-webkit-transform .2s ease-in-out;-webkit-transform:scale(.6);transform:scale(.6);overflow:hidden;white-space:nowrap;text-overflow:ellipsis;pointer-events:none}.mat-badge-content.mat-badge-active{-webkit-transform:none;transform:none}.mat-badge-small .mat-badge-content{width:16px;height:16px;line-height:16px}.mat-badge-small.mat-badge-above .mat-badge-content{top:-8px}.mat-badge-small.mat-badge-below .mat-badge-content{bottom:-8px}.mat-badge-small.mat-badge-before .mat-badge-content{left:-16px}[dir=rtl] .mat-badge-small.mat-badge-before .mat-badge-content{left:auto;right:-16px}.mat-badge-small.mat-badge-after .mat-badge-content{right:-16px}[dir=rtl] .mat-badge-small.mat-badge-after .mat-badge-content{right:auto;left:-16px}.mat-badge-small.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-8px}[dir=rtl] .mat-badge-small.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-8px}.mat-badge-small.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-8px}[dir=rtl] .mat-badge-small.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-8px}.mat-badge-medium .mat-badge-content{width:22px;height:22px;line-height:22px}.mat-badge-medium.mat-badge-above .mat-badge-content{top:-11px}.mat-badge-medium.mat-badge-below .mat-badge-content{bottom:-11px}.mat-badge-medium.mat-badge-before .mat-badge-content{left:-22px}[dir=rtl] .mat-badge-medium.mat-badge-before .mat-badge-content{left:auto;right:-22px}.mat-badge-medium.mat-badge-after .mat-badge-content{right:-22px}[dir=rtl] .mat-badge-medium.mat-badge-after .mat-badge-content{right:auto;left:-22px}.mat-badge-medium.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-11px}[dir=rtl] .mat-badge-medium.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-11px}.mat-badge-medium.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-11px}[dir=rtl] .mat-badge-medium.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-11px}.mat-badge-large .mat-badge-content{width:28px;height:28px;line-height:28px}.mat-badge-large.mat-badge-above .mat-badge-content{top:-14px}.mat-badge-large.mat-badge-below .mat-badge-content{bottom:-14px}.mat-badge-large.mat-badge-before .mat-badge-content{left:-28px}[dir=rtl] .mat-badge-large.mat-badge-before .mat-badge-content{left:auto;right:-28px}.mat-badge-large.mat-badge-after .mat-badge-content{right:-28px}[dir=rtl] .mat-badge-large.mat-badge-after .mat-badge-content{right:auto;left:-28px}.mat-badge-large.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-14px}[dir=rtl] .mat-badge-large.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-14px}.mat-badge-large.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-14px}[dir=rtl] .mat-badge-large.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-14px}.mat-bottom-sheet-container{box-shadow:0 8px 10px -5px rgba(0,0,0,.2),0 16px 24px 2px rgba(0,0,0,.14),0 6px 30px 5px rgba(0,0,0,.12);background:#fff;color:rgba(0,0,0,.87)}.mat-button,.mat-icon-button,.mat-stroked-button{color:inherit;background:0 0}.mat-button.mat-primary,.mat-icon-button.mat-primary,.mat-stroked-button.mat-primary{color:#3f51b5}.mat-button.mat-accent,.mat-icon-button.mat-accent,.mat-stroked-button.mat-accent{color:#ff4081}.mat-button.mat-warn,.mat-icon-button.mat-warn,.mat-stroked-button.mat-warn{color:#f44336}.mat-button.mat-accent[disabled],.mat-button.mat-primary[disabled],.mat-button.mat-warn[disabled],.mat-button[disabled][disabled],.mat-icon-button.mat-accent[disabled],.mat-icon-button.mat-primary[disabled],.mat-icon-button.mat-warn[disabled],.mat-icon-button[disabled][disabled],.mat-stroked-button.mat-accent[disabled],.mat-stroked-button.mat-primary[disabled],.mat-stroked-button.mat-warn[disabled],.mat-stroked-button[disabled][disabled]{color:rgba(0,0,0,.26)}.mat-button.mat-primary .mat-button-focus-overlay,.mat-icon-button.mat-primary .mat-button-focus-overlay,.mat-stroked-button.mat-primary .mat-button-focus-overlay{background-color:#3f51b5}.mat-button.mat-accent .mat-button-focus-overlay,.mat-icon-button.mat-accent .mat-button-focus-overlay,.mat-stroked-button.mat-accent .mat-button-focus-overlay{background-color:#ff4081}.mat-button.mat-warn .mat-button-focus-overlay,.mat-icon-button.mat-warn .mat-button-focus-overlay,.mat-stroked-button.mat-warn .mat-button-focus-overlay{background-color:#f44336}.mat-button[disabled] .mat-button-focus-overlay,.mat-icon-button[disabled] .mat-button-focus-overlay,.mat-stroked-button[disabled] .mat-button-focus-overlay{background-color:transparent}.mat-button .mat-ripple-element,.mat-icon-button .mat-ripple-element,.mat-stroked-button .mat-ripple-element{opacity:.1;background-color:currentColor}.mat-button-focus-overlay{background:#000}.mat-stroked-button:not([disabled]){border-color:rgba(0,0,0,.12)}.mat-fab,.mat-flat-button,.mat-mini-fab,.mat-raised-button{color:rgba(0,0,0,.87);background-color:#fff}.mat-fab.mat-accent,.mat-fab.mat-primary,.mat-fab.mat-warn,.mat-flat-button.mat-accent,.mat-flat-button.mat-primary,.mat-flat-button.mat-warn,.mat-mini-fab.mat-accent,.mat-mini-fab.mat-primary,.mat-mini-fab.mat-warn,.mat-raised-button.mat-accent,.mat-raised-button.mat-primary,.mat-raised-button.mat-warn{color:#fff}.mat-fab.mat-accent[disabled],.mat-fab.mat-primary[disabled],.mat-fab.mat-warn[disabled],.mat-fab[disabled][disabled],.mat-flat-button.mat-accent[disabled],.mat-flat-button.mat-primary[disabled],.mat-flat-button.mat-warn[disabled],.mat-flat-button[disabled][disabled],.mat-mini-fab.mat-accent[disabled],.mat-mini-fab.mat-primary[disabled],.mat-mini-fab.mat-warn[disabled],.mat-mini-fab[disabled][disabled],.mat-raised-button.mat-accent[disabled],.mat-raised-button.mat-primary[disabled],.mat-raised-button.mat-warn[disabled],.mat-raised-button[disabled][disabled]{color:rgba(0,0,0,.26);background-color:rgba(0,0,0,.12)}.mat-fab.mat-primary,.mat-flat-button.mat-primary,.mat-mini-fab.mat-primary,.mat-raised-button.mat-primary{background-color:#3f51b5}.mat-fab.mat-accent,.mat-flat-button.mat-accent,.mat-mini-fab.mat-accent,.mat-raised-button.mat-accent{background-color:#ff4081}.mat-fab.mat-warn,.mat-flat-button.mat-warn,.mat-mini-fab.mat-warn,.mat-raised-button.mat-warn{background-color:#f44336}.mat-fab.mat-accent .mat-ripple-element,.mat-fab.mat-primary .mat-ripple-element,.mat-fab.mat-warn .mat-ripple-element,.mat-flat-button.mat-accent .mat-ripple-element,.mat-flat-button.mat-primary .mat-ripple-element,.mat-flat-button.mat-warn .mat-ripple-element,.mat-mini-fab.mat-accent .mat-ripple-element,.mat-mini-fab.mat-primary .mat-ripple-element,.mat-mini-fab.mat-warn .mat-ripple-element,.mat-raised-button.mat-accent .mat-ripple-element,.mat-raised-button.mat-primary .mat-ripple-element,.mat-raised-button.mat-warn .mat-ripple-element{background-color:rgba(255,255,255,.1)}.mat-flat-button:not([class*=mat-elevation-z]),.mat-stroked-button:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12)}.mat-raised-button:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12)}.mat-raised-button:not([disabled]):active:not([class*=mat-elevation-z]){box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}.mat-raised-button[disabled]:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12)}.mat-fab:not([class*=mat-elevation-z]),.mat-mini-fab:not([class*=mat-elevation-z]){box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12)}.mat-fab:not([disabled]):active:not([class*=mat-elevation-z]),.mat-mini-fab:not([disabled]):active:not([class*=mat-elevation-z]){box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.mat-fab[disabled]:not([class*=mat-elevation-z]),.mat-mini-fab[disabled]:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12)}.mat-button-toggle-group,.mat-button-toggle-standalone{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12)}.mat-button-toggle-group-appearance-standard,.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{box-shadow:none;border:1px solid rgba(0,0,0,.12)}.mat-button-toggle{color:rgba(0,0,0,.38)}.mat-button-toggle .mat-button-toggle-focus-overlay{background-color:rgba(0,0,0,.12)}.mat-button-toggle-appearance-standard{color:rgba(0,0,0,.87);background:#fff}.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{background-color:#000}.mat-button-toggle-group-appearance-standard .mat-button-toggle+.mat-button-toggle{border-left:1px solid rgba(0,0,0,.12)}[dir=rtl] .mat-button-toggle-group-appearance-standard .mat-button-toggle+.mat-button-toggle{border-left:none;border-right:1px solid rgba(0,0,0,.12)}.mat-button-toggle-group-appearance-standard.mat-button-toggle-vertical .mat-button-toggle+.mat-button-toggle{border-left:none;border-right:none;border-top:1px solid rgba(0,0,0,.12)}.mat-button-toggle-checked{background-color:#e0e0e0;color:rgba(0,0,0,.54)}.mat-button-toggle-checked.mat-button-toggle-appearance-standard{color:rgba(0,0,0,.87)}.mat-button-toggle-disabled{color:rgba(0,0,0,.26);background-color:#eee}.mat-button-toggle-disabled.mat-button-toggle-appearance-standard{background:#fff}.mat-button-toggle-disabled.mat-button-toggle-checked{background-color:#bdbdbd}.mat-card{background:#fff;color:rgba(0,0,0,.87)}.mat-card:not([class*=mat-elevation-z]){box-shadow:0 2px 1px -1px rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 1px 3px 0 rgba(0,0,0,.12)}.mat-card.mat-card-flat:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12)}.mat-card-subtitle{color:rgba(0,0,0,.54)}.mat-checkbox-frame{border-color:rgba(0,0,0,.54)}.mat-checkbox-checkmark{fill:#fafafa}.mat-checkbox-checkmark-path{stroke:#fafafa!important}@media (-ms-high-contrast:black-on-white){.mat-checkbox-checkmark-path{stroke:#000!important}}.mat-checkbox-mixedmark{background-color:#fafafa}.mat-checkbox-checked.mat-primary .mat-checkbox-background,.mat-checkbox-indeterminate.mat-primary .mat-checkbox-background{background-color:#3f51b5}.mat-checkbox-checked.mat-accent .mat-checkbox-background,.mat-checkbox-indeterminate.mat-accent .mat-checkbox-background{background-color:#ff4081}.mat-checkbox-checked.mat-warn .mat-checkbox-background,.mat-checkbox-indeterminate.mat-warn .mat-checkbox-background{background-color:#f44336}.mat-checkbox-disabled.mat-checkbox-checked .mat-checkbox-background,.mat-checkbox-disabled.mat-checkbox-indeterminate .mat-checkbox-background{background-color:#b0b0b0}.mat-checkbox-disabled:not(.mat-checkbox-checked) .mat-checkbox-frame{border-color:#b0b0b0}.mat-checkbox-disabled .mat-checkbox-label{color:rgba(0,0,0,.54)}@media (-ms-high-contrast:active){.mat-checkbox-background{background:0 0}}.mat-checkbox:not(.mat-checkbox-disabled).mat-primary .mat-checkbox-ripple .mat-ripple-element{background-color:#3f51b5}.mat-checkbox:not(.mat-checkbox-disabled).mat-accent .mat-checkbox-ripple .mat-ripple-element{background-color:#ff4081}.mat-checkbox:not(.mat-checkbox-disabled).mat-warn .mat-checkbox-ripple .mat-ripple-element{background-color:#f44336}.mat-chip.mat-standard-chip{background-color:#e0e0e0;color:rgba(0,0,0,.87)}.mat-chip.mat-standard-chip .mat-chip-remove{color:rgba(0,0,0,.87);opacity:.4}.mat-chip.mat-standard-chip:not(.mat-chip-disabled):active{box-shadow:0 3px 3px -2px rgba(0,0,0,.2),0 3px 4px 0 rgba(0,0,0,.14),0 1px 8px 0 rgba(0,0,0,.12)}.mat-chip.mat-standard-chip:not(.mat-chip-disabled) .mat-chip-remove:hover{opacity:.54}.mat-chip.mat-standard-chip.mat-chip-disabled{opacity:.4}.mat-chip.mat-standard-chip::after{background:#000}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary{background-color:#3f51b5;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary .mat-ripple-element{background:rgba(255,255,255,.1)}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn{background-color:#f44336;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn .mat-ripple-element{background:rgba(255,255,255,.1)}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent{background-color:#ff4081;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent .mat-ripple-element{background:rgba(255,255,255,.1)}.mat-table{background:#fff}.mat-table tbody,.mat-table tfoot,.mat-table thead,.mat-table-sticky,[mat-footer-row],[mat-header-row],[mat-row],mat-footer-row,mat-header-row,mat-row{background:inherit}mat-footer-row,mat-header-row,mat-row,td.mat-cell,td.mat-footer-cell,th.mat-header-cell{border-bottom-color:rgba(0,0,0,.12)}.mat-header-cell{color:rgba(0,0,0,.54)}.mat-cell,.mat-footer-cell{color:rgba(0,0,0,.87)}.mat-calendar-arrow{border-top-color:rgba(0,0,0,.54)}.mat-datepicker-content .mat-calendar-next-button,.mat-datepicker-content .mat-calendar-previous-button,.mat-datepicker-toggle{color:rgba(0,0,0,.54)}.mat-calendar-table-header{color:rgba(0,0,0,.38)}.mat-calendar-table-header-divider::after{background:rgba(0,0,0,.12)}.mat-calendar-body-label{color:rgba(0,0,0,.54)}.mat-calendar-body-cell-content{color:rgba(0,0,0,.87);border-color:transparent}.mat-calendar-body-disabled>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected){color:rgba(0,0,0,.38)}.cdk-keyboard-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected),.cdk-program-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected),.mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected){background-color:rgba(0,0,0,.04)}.mat-calendar-body-today:not(.mat-calendar-body-selected){border-color:rgba(0,0,0,.38)}.mat-calendar-body-disabled>.mat-calendar-body-today:not(.mat-calendar-body-selected){border-color:rgba(0,0,0,.18)}.mat-calendar-body-selected{background-color:#3f51b5;color:#fff}.mat-calendar-body-disabled>.mat-calendar-body-selected{background-color:rgba(63,81,181,.4)}.mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.mat-datepicker-content{box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12);background-color:#fff;color:rgba(0,0,0,.87)}.mat-datepicker-content.mat-accent .mat-calendar-body-selected{background-color:#ff4081;color:#fff}.mat-datepicker-content.mat-accent .mat-calendar-body-disabled>.mat-calendar-body-selected{background-color:rgba(255,64,129,.4)}.mat-datepicker-content.mat-accent .mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.mat-datepicker-content.mat-warn .mat-calendar-body-selected{background-color:#f44336;color:#fff}.mat-datepicker-content.mat-warn .mat-calendar-body-disabled>.mat-calendar-body-selected{background-color:rgba(244,67,54,.4)}.mat-datepicker-content.mat-warn .mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.mat-datepicker-content-touch{box-shadow:0 0 0 0 rgba(0,0,0,.2),0 0 0 0 rgba(0,0,0,.14),0 0 0 0 rgba(0,0,0,.12)}.mat-datepicker-toggle-active{color:#3f51b5}.mat-datepicker-toggle-active.mat-accent{color:#ff4081}.mat-datepicker-toggle-active.mat-warn{color:#f44336}.mat-dialog-container{box-shadow:0 11px 15px -7px rgba(0,0,0,.2),0 24px 38px 3px rgba(0,0,0,.14),0 9px 46px 8px rgba(0,0,0,.12);background:#fff;color:rgba(0,0,0,.87)}.mat-divider{border-top-color:rgba(0,0,0,.12)}.mat-divider-vertical{border-right-color:rgba(0,0,0,.12)}.mat-expansion-panel{background:#fff;color:rgba(0,0,0,.87)}.mat-expansion-panel:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12)}.mat-action-row{border-top-color:rgba(0,0,0,.12)}.mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:not([aria-disabled=true]).cdk-keyboard-focused,.mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:not([aria-disabled=true]).cdk-program-focused,.mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:not([aria-disabled=true]):hover{background:rgba(0,0,0,.04)}@media (hover:none){.mat-expansion-panel:not(.mat-expanded):not([aria-disabled=true]) .mat-expansion-panel-header:hover{background:#fff}}.mat-expansion-panel-header-title{color:rgba(0,0,0,.87)}.mat-expansion-indicator::after,.mat-expansion-panel-header-description{color:rgba(0,0,0,.54)}.mat-expansion-panel-header[aria-disabled=true]{color:rgba(0,0,0,.26)}.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-description,.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-title{color:inherit}.mat-form-field-label,.mat-hint{color:rgba(0,0,0,.6)}.mat-form-field.mat-focused .mat-form-field-label{color:#3f51b5}.mat-form-field.mat-focused .mat-form-field-label.mat-accent{color:#ff4081}.mat-form-field.mat-focused .mat-form-field-label.mat-warn{color:#f44336}.mat-focused .mat-form-field-required-marker{color:#ff4081}.mat-form-field-ripple{background-color:rgba(0,0,0,.87)}.mat-form-field.mat-focused .mat-form-field-ripple{background-color:#3f51b5}.mat-form-field.mat-focused .mat-form-field-ripple.mat-accent{background-color:#ff4081}.mat-form-field.mat-focused .mat-form-field-ripple.mat-warn{background-color:#f44336}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid) .mat-form-field-infix::after{color:#3f51b5}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid).mat-accent .mat-form-field-infix::after{color:#ff4081}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid).mat-warn .mat-form-field-infix::after,.mat-form-field.mat-form-field-invalid .mat-form-field-label,.mat-form-field.mat-form-field-invalid .mat-form-field-label .mat-form-field-required-marker,.mat-form-field.mat-form-field-invalid .mat-form-field-label.mat-accent{color:#f44336}.mat-form-field.mat-form-field-invalid .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple.mat-accent{background-color:#f44336}.mat-error{color:#f44336}.mat-form-field-appearance-legacy .mat-form-field-label,.mat-form-field-appearance-legacy .mat-hint{color:rgba(0,0,0,.54)}.mat-form-field-appearance-legacy .mat-form-field-underline{bottom:1.25em;background-color:rgba(0,0,0,.42)}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-image:linear-gradient(to right,rgba(0,0,0,.42) 0,rgba(0,0,0,.42) 33%,transparent 0);background-size:4px 100%;background-repeat:repeat-x}.mat-form-field-appearance-standard .mat-form-field-underline{background-color:rgba(0,0,0,.42)}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-image:linear-gradient(to right,rgba(0,0,0,.42) 0,rgba(0,0,0,.42) 33%,transparent 0);background-size:4px 100%;background-repeat:repeat-x}.mat-form-field-appearance-fill .mat-form-field-flex{background-color:rgba(0,0,0,.04)}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-flex{background-color:rgba(0,0,0,.02)}.mat-form-field-appearance-fill .mat-form-field-underline::before{background-color:rgba(0,0,0,.42)}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-label{color:rgba(0,0,0,.38)}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-underline::before{background-color:transparent}.mat-form-field-appearance-outline .mat-form-field-outline{color:rgba(0,0,0,.12)}.mat-form-field-appearance-outline .mat-form-field-outline-thick{color:rgba(0,0,0,.87)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick{color:#3f51b5}.mat-form-field-appearance-outline.mat-focused.mat-accent .mat-form-field-outline-thick{color:#ff4081}.mat-form-field-appearance-outline.mat-focused.mat-warn .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid.mat-form-field-invalid .mat-form-field-outline-thick{color:#f44336}.mat-form-field-appearance-outline.mat-form-field-disabled .mat-form-field-label{color:rgba(0,0,0,.38)}.mat-form-field-appearance-outline.mat-form-field-disabled .mat-form-field-outline{color:rgba(0,0,0,.06)}.mat-icon.mat-primary{color:#3f51b5}.mat-icon.mat-accent{color:#ff4081}.mat-icon.mat-warn{color:#f44336}.mat-form-field-type-mat-native-select .mat-form-field-infix::after{color:rgba(0,0,0,.54)}.mat-form-field-type-mat-native-select.mat-form-field-disabled .mat-form-field-infix::after,.mat-input-element:disabled{color:rgba(0,0,0,.38)}.mat-input-element{caret-color:#3f51b5}.mat-input-element::-ms-input-placeholder{color:rgba(0,0,0,.42)}.mat-input-element::placeholder{color:rgba(0,0,0,.42)}.mat-input-element::-moz-placeholder{color:rgba(0,0,0,.42)}.mat-input-element::-webkit-input-placeholder{color:rgba(0,0,0,.42)}.mat-input-element:-ms-input-placeholder{color:rgba(0,0,0,.42)}.mat-accent .mat-input-element{caret-color:#ff4081}.mat-form-field-invalid .mat-input-element,.mat-warn .mat-input-element{caret-color:#f44336}.mat-form-field-type-mat-native-select.mat-form-field-invalid .mat-form-field-infix::after{color:#f44336}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{color:rgba(0,0,0,.87)}.mat-list-base .mat-subheader{font-family:Roboto,\"Helvetica Neue\",sans-serif;font-size:14px;font-weight:500;color:rgba(0,0,0,.54)}.mat-list-item-disabled{background-color:#eee}.mat-list-option:focus,.mat-list-option:hover,.mat-nav-list .mat-list-item:focus,.mat-nav-list .mat-list-item:hover{background:rgba(0,0,0,.04)}.mat-menu-panel{background:#fff}.mat-menu-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)}.mat-menu-item{background:0 0;color:rgba(0,0,0,.87)}.mat-menu-item[disabled],.mat-menu-item[disabled]::after{color:rgba(0,0,0,.38)}.mat-menu-item .mat-icon-no-color,.mat-menu-item-submenu-trigger::after{color:rgba(0,0,0,.54)}.mat-menu-item-highlighted:not([disabled]),.mat-menu-item.cdk-keyboard-focused:not([disabled]),.mat-menu-item.cdk-program-focused:not([disabled]),.mat-menu-item:hover:not([disabled]){background:rgba(0,0,0,.04)}.mat-paginator{background:#fff}.mat-paginator,.mat-paginator-page-size .mat-select-trigger{color:rgba(0,0,0,.54)}.mat-paginator-decrement,.mat-paginator-increment{border-top:2px solid rgba(0,0,0,.54);border-right:2px solid rgba(0,0,0,.54)}.mat-paginator-first,.mat-paginator-last{border-top:2px solid rgba(0,0,0,.54)}.mat-icon-button[disabled] .mat-paginator-decrement,.mat-icon-button[disabled] .mat-paginator-first,.mat-icon-button[disabled] .mat-paginator-increment,.mat-icon-button[disabled] .mat-paginator-last{border-color:rgba(0,0,0,.38)}.mat-progress-bar-background{fill:#c5cae9}.mat-progress-bar-buffer{background-color:#c5cae9}.mat-progress-bar-fill::after{background-color:#3f51b5}.mat-progress-bar.mat-accent .mat-progress-bar-background{fill:#ff80ab}.mat-progress-bar.mat-accent .mat-progress-bar-buffer{background-color:#ff80ab}.mat-progress-bar.mat-accent .mat-progress-bar-fill::after{background-color:#ff4081}.mat-progress-bar.mat-warn .mat-progress-bar-background{fill:#ffcdd2}.mat-progress-bar.mat-warn .mat-progress-bar-buffer{background-color:#ffcdd2}.mat-progress-bar.mat-warn .mat-progress-bar-fill::after{background-color:#f44336}.mat-progress-spinner circle,.mat-spinner circle{stroke:#3f51b5}.mat-progress-spinner.mat-accent circle,.mat-spinner.mat-accent circle{stroke:#ff4081}.mat-progress-spinner.mat-warn circle,.mat-spinner.mat-warn circle{stroke:#f44336}.mat-radio-outer-circle{border-color:rgba(0,0,0,.54)}.mat-radio-button.mat-primary.mat-radio-checked .mat-radio-outer-circle{border-color:#3f51b5}.mat-radio-button.mat-primary .mat-radio-inner-circle,.mat-radio-button.mat-primary .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-primary.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-primary:active .mat-radio-persistent-ripple{background-color:#3f51b5}.mat-radio-button.mat-accent.mat-radio-checked .mat-radio-outer-circle{border-color:#ff4081}.mat-radio-button.mat-accent .mat-radio-inner-circle,.mat-radio-button.mat-accent .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-accent.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-accent:active .mat-radio-persistent-ripple{background-color:#ff4081}.mat-radio-button.mat-warn.mat-radio-checked .mat-radio-outer-circle{border-color:#f44336}.mat-radio-button.mat-warn .mat-radio-inner-circle,.mat-radio-button.mat-warn .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-warn.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-warn:active .mat-radio-persistent-ripple{background-color:#f44336}.mat-radio-button.mat-radio-disabled .mat-radio-outer-circle,.mat-radio-button.mat-radio-disabled.mat-radio-checked .mat-radio-outer-circle{border-color:rgba(0,0,0,.38)}.mat-radio-button.mat-radio-disabled .mat-radio-inner-circle,.mat-radio-button.mat-radio-disabled .mat-radio-ripple .mat-ripple-element{background-color:rgba(0,0,0,.38)}.mat-radio-button.mat-radio-disabled .mat-radio-label-content{color:rgba(0,0,0,.38)}.mat-radio-button .mat-ripple-element{background-color:#000}.mat-select-value{color:rgba(0,0,0,.87)}.mat-select-placeholder{color:rgba(0,0,0,.42)}.mat-select-disabled .mat-select-value{color:rgba(0,0,0,.38)}.mat-select-arrow{color:rgba(0,0,0,.54)}.mat-select-panel{background:#fff}.mat-select-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)}.mat-select-panel .mat-option.mat-selected:not(.mat-option-multiple){background:rgba(0,0,0,.12)}.mat-form-field.mat-focused.mat-primary .mat-select-arrow{color:#3f51b5}.mat-form-field.mat-focused.mat-accent .mat-select-arrow{color:#ff4081}.mat-form-field .mat-select.mat-select-invalid .mat-select-arrow,.mat-form-field.mat-focused.mat-warn .mat-select-arrow{color:#f44336}.mat-form-field .mat-select.mat-select-disabled .mat-select-arrow{color:rgba(0,0,0,.38)}.mat-drawer-container{background-color:#fafafa;color:rgba(0,0,0,.87)}.mat-drawer{background-color:#fff;color:rgba(0,0,0,.87)}.mat-drawer.mat-drawer-push{background-color:#fff}.mat-drawer:not(.mat-drawer-side){box-shadow:0 8px 10px -5px rgba(0,0,0,.2),0 16px 24px 2px rgba(0,0,0,.14),0 6px 30px 5px rgba(0,0,0,.12)}.mat-drawer-side{border-right:1px solid rgba(0,0,0,.12)}.mat-drawer-side.mat-drawer-end,[dir=rtl] .mat-drawer-side{border-left:1px solid rgba(0,0,0,.12);border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-left:none;border-right:1px solid rgba(0,0,0,.12)}.mat-drawer-backdrop.mat-drawer-shown{background-color:rgba(0,0,0,.6)}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb{background-color:#ff4081}.mat-slide-toggle.mat-checked .mat-slide-toggle-bar{background-color:rgba(255,64,129,.54)}.mat-slide-toggle.mat-checked .mat-ripple-element{background-color:#ff4081}.mat-slide-toggle.mat-primary.mat-checked .mat-slide-toggle-thumb{background-color:#3f51b5}.mat-slide-toggle.mat-primary.mat-checked .mat-slide-toggle-bar{background-color:rgba(63,81,181,.54)}.mat-slide-toggle.mat-primary.mat-checked .mat-ripple-element{background-color:#3f51b5}.mat-slide-toggle.mat-warn.mat-checked .mat-slide-toggle-thumb{background-color:#f44336}.mat-slide-toggle.mat-warn.mat-checked .mat-slide-toggle-bar{background-color:rgba(244,67,54,.54)}.mat-slide-toggle.mat-warn.mat-checked .mat-ripple-element{background-color:#f44336}.mat-slide-toggle:not(.mat-checked) .mat-ripple-element{background-color:#000}.mat-slide-toggle-thumb{box-shadow:0 2px 1px -1px rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 1px 3px 0 rgba(0,0,0,.12);background-color:#fafafa}.mat-slide-toggle-bar{background-color:rgba(0,0,0,.38)}.mat-slider-track-background{background-color:rgba(0,0,0,.26)}.mat-primary .mat-slider-thumb,.mat-primary .mat-slider-thumb-label,.mat-primary .mat-slider-track-fill{background-color:#3f51b5}.mat-primary .mat-slider-thumb-label-text{color:#fff}.mat-accent .mat-slider-thumb,.mat-accent .mat-slider-thumb-label,.mat-accent .mat-slider-track-fill{background-color:#ff4081}.mat-accent .mat-slider-thumb-label-text{color:#fff}.mat-warn .mat-slider-thumb,.mat-warn .mat-slider-thumb-label,.mat-warn .mat-slider-track-fill{background-color:#f44336}.mat-warn .mat-slider-thumb-label-text{color:#fff}.mat-slider-focus-ring{background-color:rgba(255,64,129,.2)}.cdk-focused .mat-slider-track-background,.mat-slider:hover .mat-slider-track-background{background-color:rgba(0,0,0,.38)}.mat-slider-disabled .mat-slider-thumb,.mat-slider-disabled .mat-slider-track-background,.mat-slider-disabled .mat-slider-track-fill,.mat-slider-disabled:hover .mat-slider-track-background{background-color:rgba(0,0,0,.26)}.mat-slider-min-value .mat-slider-focus-ring{background-color:rgba(0,0,0,.12)}.mat-slider-min-value.mat-slider-thumb-label-showing .mat-slider-thumb,.mat-slider-min-value.mat-slider-thumb-label-showing .mat-slider-thumb-label{background-color:rgba(0,0,0,.87)}.mat-slider-min-value.mat-slider-thumb-label-showing.cdk-focused .mat-slider-thumb,.mat-slider-min-value.mat-slider-thumb-label-showing.cdk-focused .mat-slider-thumb-label{background-color:rgba(0,0,0,.26)}.mat-slider-min-value:not(.mat-slider-thumb-label-showing) .mat-slider-thumb{border-color:rgba(0,0,0,.26);background-color:transparent}.mat-slider-min-value:not(.mat-slider-thumb-label-showing).cdk-focused .mat-slider-thumb,.mat-slider-min-value:not(.mat-slider-thumb-label-showing):hover .mat-slider-thumb{border-color:rgba(0,0,0,.38)}.mat-slider-min-value:not(.mat-slider-thumb-label-showing).cdk-focused.mat-slider-disabled .mat-slider-thumb,.mat-slider-min-value:not(.mat-slider-thumb-label-showing):hover.mat-slider-disabled .mat-slider-thumb{border-color:rgba(0,0,0,.26)}.mat-slider-has-ticks .mat-slider-wrapper::after{border-color:rgba(0,0,0,.7)}.mat-slider-horizontal .mat-slider-ticks{background-image:repeating-linear-gradient(to right,rgba(0,0,0,.7),rgba(0,0,0,.7) 2px,transparent 0,transparent);background-image:-moz-repeating-linear-gradient(.0001deg,rgba(0,0,0,.7),rgba(0,0,0,.7) 2px,transparent 0,transparent)}.mat-slider-vertical .mat-slider-ticks{background-image:repeating-linear-gradient(to bottom,rgba(0,0,0,.7),rgba(0,0,0,.7) 2px,transparent 0,transparent)}.mat-step-header.cdk-keyboard-focused,.mat-step-header.cdk-program-focused,.mat-step-header:hover{background-color:rgba(0,0,0,.04)}@media (hover:none){.mat-step-header:hover{background:0 0}}.mat-step-header .mat-step-label,.mat-step-header .mat-step-optional{color:rgba(0,0,0,.54)}.mat-step-header .mat-step-icon{background-color:rgba(0,0,0,.54);color:#fff}.mat-step-header .mat-step-icon-selected,.mat-step-header .mat-step-icon-state-done,.mat-step-header .mat-step-icon-state-edit{background-color:#3f51b5;color:#fff}.mat-step-header .mat-step-icon-state-error{background-color:transparent;color:#f44336}.mat-step-header .mat-step-label.mat-step-label-active{color:rgba(0,0,0,.87)}.mat-step-header .mat-step-label.mat-step-label-error{color:#f44336}.mat-stepper-horizontal,.mat-stepper-vertical{background-color:#fff}.mat-stepper-vertical-line::before{border-left-color:rgba(0,0,0,.12)}.mat-horizontal-stepper-header::after,.mat-horizontal-stepper-header::before,.mat-stepper-horizontal-line{border-top-color:rgba(0,0,0,.12)}.mat-sort-header-arrow{color:#757575}.mat-tab-header,.mat-tab-nav-bar{border-bottom:1px solid rgba(0,0,0,.12)}.mat-tab-group-inverted-header .mat-tab-header,.mat-tab-group-inverted-header .mat-tab-nav-bar{border-top:1px solid rgba(0,0,0,.12);border-bottom:none}.mat-tab-label,.mat-tab-link{color:rgba(0,0,0,.87)}.mat-tab-label.mat-tab-disabled,.mat-tab-link.mat-tab-disabled{color:rgba(0,0,0,.38)}.mat-tab-header-pagination-chevron{border-color:rgba(0,0,0,.87)}.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:rgba(0,0,0,.38)}.mat-tab-group[class*=mat-background-] .mat-tab-header,.mat-tab-nav-bar[class*=mat-background-]{border-bottom:none;border-top:none}.mat-tab-group.mat-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:rgba(197,202,233,.3)}.mat-tab-group.mat-primary .mat-ink-bar,.mat-tab-nav-bar.mat-primary .mat-ink-bar{background-color:#3f51b5}.mat-tab-group.mat-primary.mat-background-primary .mat-ink-bar,.mat-tab-nav-bar.mat-primary.mat-background-primary .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:rgba(255,128,171,.3)}.mat-tab-group.mat-accent .mat-ink-bar,.mat-tab-nav-bar.mat-accent .mat-ink-bar{background-color:#ff4081}.mat-tab-group.mat-accent.mat-background-accent .mat-ink-bar,.mat-tab-nav-bar.mat-accent.mat-background-accent .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:rgba(255,205,210,.3)}.mat-tab-group.mat-warn .mat-ink-bar,.mat-tab-nav-bar.mat-warn .mat-ink-bar{background-color:#f44336}.mat-tab-group.mat-warn.mat-background-warn .mat-ink-bar,.mat-tab-nav-bar.mat-warn.mat-background-warn .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-background-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:rgba(197,202,233,.3)}.mat-tab-group.mat-background-primary .mat-tab-header,.mat-tab-group.mat-background-primary .mat-tab-links,.mat-tab-nav-bar.mat-background-primary .mat-tab-header,.mat-tab-nav-bar.mat-background-primary .mat-tab-links{background-color:#3f51b5}.mat-tab-group.mat-background-primary .mat-tab-label,.mat-tab-group.mat-background-primary .mat-tab-link,.mat-tab-nav-bar.mat-background-primary .mat-tab-label,.mat-tab-nav-bar.mat-background-primary .mat-tab-link{color:#fff}.mat-tab-group.mat-background-primary .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-primary .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-primary .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-primary .mat-tab-link.mat-tab-disabled{color:rgba(255,255,255,.4)}.mat-tab-group.mat-background-primary .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary .mat-tab-header-pagination-chevron{border-color:#fff}.mat-tab-group.mat-background-primary .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:rgba(255,255,255,.4)}.mat-tab-group.mat-background-primary .mat-ripple-element,.mat-tab-nav-bar.mat-background-primary .mat-ripple-element{background-color:rgba(255,255,255,.12)}.mat-tab-group.mat-background-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:rgba(255,128,171,.3)}.mat-tab-group.mat-background-accent .mat-tab-header,.mat-tab-group.mat-background-accent .mat-tab-links,.mat-tab-nav-bar.mat-background-accent .mat-tab-header,.mat-tab-nav-bar.mat-background-accent .mat-tab-links{background-color:#ff4081}.mat-tab-group.mat-background-accent .mat-tab-label,.mat-tab-group.mat-background-accent .mat-tab-link,.mat-tab-nav-bar.mat-background-accent .mat-tab-label,.mat-tab-nav-bar.mat-background-accent .mat-tab-link{color:#fff}.mat-tab-group.mat-background-accent .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-accent .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-accent .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-accent .mat-tab-link.mat-tab-disabled{color:rgba(255,255,255,.4)}.mat-tab-group.mat-background-accent .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent .mat-tab-header-pagination-chevron{border-color:#fff}.mat-tab-group.mat-background-accent .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:rgba(255,255,255,.4)}.mat-tab-group.mat-background-accent .mat-ripple-element,.mat-tab-nav-bar.mat-background-accent .mat-ripple-element{background-color:rgba(255,255,255,.12)}.mat-tab-group.mat-background-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:rgba(255,205,210,.3)}.mat-tab-group.mat-background-warn .mat-tab-header,.mat-tab-group.mat-background-warn .mat-tab-links,.mat-tab-nav-bar.mat-background-warn .mat-tab-header,.mat-tab-nav-bar.mat-background-warn .mat-tab-links{background-color:#f44336}.mat-tab-group.mat-background-warn .mat-tab-label,.mat-tab-group.mat-background-warn .mat-tab-link,.mat-tab-nav-bar.mat-background-warn .mat-tab-label,.mat-tab-nav-bar.mat-background-warn .mat-tab-link{color:#fff}.mat-tab-group.mat-background-warn .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-warn .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-warn .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-warn .mat-tab-link.mat-tab-disabled{color:rgba(255,255,255,.4)}.mat-tab-group.mat-background-warn .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn .mat-tab-header-pagination-chevron{border-color:#fff}.mat-tab-group.mat-background-warn .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:rgba(255,255,255,.4)}.mat-tab-group.mat-background-warn .mat-ripple-element,.mat-tab-nav-bar.mat-background-warn .mat-ripple-element{background-color:rgba(255,255,255,.12)}.mat-toolbar{background:#f5f5f5;color:rgba(0,0,0,.87)}.mat-toolbar.mat-primary{background:#3f51b5;color:#fff}.mat-toolbar.mat-accent{background:#ff4081;color:#fff}.mat-toolbar.mat-warn{background:#f44336;color:#fff}.mat-toolbar .mat-focused .mat-form-field-ripple,.mat-toolbar .mat-form-field-ripple,.mat-toolbar .mat-form-field-underline{background-color:currentColor}.mat-toolbar .mat-focused .mat-form-field-label,.mat-toolbar .mat-form-field-label,.mat-toolbar .mat-form-field.mat-focused .mat-select-arrow,.mat-toolbar .mat-select-arrow,.mat-toolbar .mat-select-value{color:inherit}.mat-toolbar .mat-input-element{caret-color:currentColor}.mat-tooltip{background:rgba(97,97,97,.9)}.mat-tree{font-family:Roboto,\"Helvetica Neue\",sans-serif;background:#fff}.mat-nested-tree-node,.mat-tree-node{font-weight:400;font-size:14px;color:rgba(0,0,0,.87)}.mat-snack-bar-container{color:rgba(255,255,255,.7);background:#323232;box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12)}.mat-simple-snackbar-action{color:#ff4081}"]
                  }] }
      ];
      /** @nocollapse */
      AppVersionComponent.ctorParameters = function () {
          return [
              { type: VersionService }
          ];
      };
      return AppVersionComponent;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Note:
  // Ace Editor libs must be included in build
  // ---
  var AppEditorComponent = /** @class */ (function () {
      function AppEditorComponent() {
          this.text = 'Ace example text';
      }
      /**
       * @return {?}
       */
      AppEditorComponent.prototype.ngAfterViewInit = /**
       * @return {?}
       */
          function () {
              this.aceEditor.getEditor().commands.addCommand({
                  name: 'showOtherCompletions',
                  bindKey: 'Ctrl-.',
                  exec: function (editor) {
                      console.log(editor);
                  }
              });
          };
      AppEditorComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'app-editor',
                      template: "<div class=\"container\">\n    <ace-editor [(text)]=\"text\" #aceEditor style=\"height:150px;\"></ace-editor>\n</div>\n",
                      styles: [".container{margin-top:20px}"]
                  }] }
      ];
      AppEditorComponent.propDecorators = {
          aceEditor: [{ type: core.ViewChild, args: ['aceEditor',] }]
      };
      return AppEditorComponent;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var AppTextEditorComponent = /** @class */ (function () {
      function AppTextEditorComponent() {
          this.text = 'Froala editor example text';
      }
      AppTextEditorComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'app-text-editor',
                      template: "<div class=\"container\">\n    <div [froalaEditor]>Hello, Froala!</div>\n</div>\n    ",
                      styles: [".container{margin-top:20px}"]
                  }] }
      ];
      return AppTextEditorComponent;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var AppDynamicComponent = /** @class */ (function () {
      function AppDynamicComponent(_globalComponentService) {
          this._globalComponentService = _globalComponentService;
      }
      /**
       * @return {?}
       */
      AppDynamicComponent.prototype.ngAfterContentInit = /**
       * @return {?}
       */
          function () {
              /** @type {?} */
              var factory = this._globalComponentService.getComponent(this.name);
              this.dynamicContainer.createComponent(factory);
          };
      AppDynamicComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'app-dynamic',
                      template: '<ng-container #dynamicContainer></ng-container>'
                  }] }
      ];
      /** @nocollapse */
      AppDynamicComponent.ctorParameters = function () {
          return [
              { type: GlobalComponentService }
          ];
      };
      AppDynamicComponent.propDecorators = {
          name: [{ type: core.Input }],
          dynamicContainer: [{ type: core.ViewChild, args: ['dynamicContainer', { read: core.ViewContainerRef },] }]
      };
      return AppDynamicComponent;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var AgGridModule = require('ag-grid-angular').AgGridModule;
  /** @type {?} */
  var components = [
      AppDynamicComponent,
      AppLabelComponent,
      AppInputComponent,
      AppFieldComponent,
      AppVersionComponent,
      AppActionsComponent,
      AppTableComponent,
      AppEditorComponent,
      AppTextEditorComponent,
  ];
  /** @type {?} */
  var services = [
      AlertService,
      VersionService,
      GlobalComponentService,
  ];
  var ComponentsModule = /** @class */ (function () {
      function ComponentsModule() {
      }
      ComponentsModule.decorators = [
          { type: core.NgModule, args: [{
                      declarations: tslib_1.__spread(components),
                      providers: tslib_1.__spread(services),
                      imports: [
                          common.CommonModule,
                          store.StoreModule.forFeature('counter', counterReducer),
                          AceEditorModule,
                          FroalaEditorModule.forRoot(),
                          FroalaViewModule.forRoot(),
                          AgGridModule.withComponents([]),
                          MatCardModule,
                      ],
                      exports: tslib_1.__spread(components),
                      schemas: [core.CUSTOM_ELEMENTS_SCHEMA]
                  },] }
      ];
      return ComponentsModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  var Beta2ExampleComponent = /** @class */ (function () {
      function Beta2ExampleComponent() {
      }
      Beta2ExampleComponent.decorators = [
          { type: core.Component, args: [{
                      selector: 'app-beta2-example',
                      template: "<div class=\"container\">\n  <span>Beta2Component</span>\n  <h1>This component is from Beta2</h1>\n  <app-label text=\"This is label from shared\"></app-label>\n</div>\n",
                      styles: ["h1{color:red}.container{padding:12px;background:#efefef}"]
                  }] }
      ];
      return Beta2ExampleComponent;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  var globalComponents = [
      Beta2ExampleComponent,
  ];
  var GlobalModule = /** @class */ (function () {
      function GlobalModule() {
      }
      GlobalModule.decorators = [
          { type: core.NgModule, args: [{
                      declarations: tslib_1.__spread(globalComponents),
                      imports: [
                          common.CommonModule,
                          ComponentsModule,
                      ],
                      schemas: [
                          core.CUSTOM_ELEMENTS_SCHEMA,
                      ],
                      exports: tslib_1.__spread(globalComponents)
                  },] }
      ];
      return GlobalModule;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */

  exports.GlobalModule = GlobalModule;
  exports.ɵa = Beta2ExampleComponent;
  exports.ɵb = ComponentsModule;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=global.bundle.umd.js.map